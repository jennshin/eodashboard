/**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.12.0-rc.26
 * @license MIT
 * @copyright (c) 2017-2021, Vladimir Vershinin <ghettovoice@gmail.com>
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('ol'), require('ol/source'), require('ol/control'), require('ol/extent'), require('ol/format'), require('ol/geom'), require('ol/sphere'), require('ol/geom/Polygon'), require('ol/proj'), require('ol/style'), require('ol/interaction'), require('ol/layer/Base'), require('vue'), require('ol/util'), require('ol/loadingstrategy'), require('ol/tilegrid'), require('ol/events/condition'), require('ol/layer/Graticule'), require('ol/layer'), require('ol/size'), require('ol/tilegrid/WMTS')) :
  typeof define === 'function' && define.amd ? define('vuelayers', ['ol', 'ol/source', 'ol/control', 'ol/extent', 'ol/format', 'ol/geom', 'ol/sphere', 'ol/geom/Polygon', 'ol/proj', 'ol/style', 'ol/interaction', 'ol/layer/Base', 'vue', 'ol/util', 'ol/loadingstrategy', 'ol/tilegrid', 'ol/events/condition', 'ol/layer/Graticule', 'ol/layer', 'ol/size', 'ol/tilegrid/WMTS'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.VueLayers = factory(global.ol, global.ol.source, global.ol.control, global.ol.extent, global.ol.format, global.ol.geom, global.ol.sphere, global.ol.geom.Polygon, global.ol.proj, global.ol.style, global.ol.interaction, global.ol.layer.Base, global.Vue, global.ol.util, global.ol.loadingstrategy, global.ol.tilegrid, global.ol.events.condition, global.ol.layer.Graticule, global.ol.layer, global.ol.size, global.ol.tilegrid.WMTS));
}(this, (function (ol, source$1, control, extent, format, geom, sphere, Polygon, proj, style$1, interaction$1, BaseLayer, Vue, util, loadingstrategy, tilegrid, condition, GraticuleLayer$1, layer$1, size, WMTSTileGrid) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var BaseLayer__default = /*#__PURE__*/_interopDefaultLegacy(BaseLayer);
  var Vue__default = /*#__PURE__*/_interopDefaultLegacy(Vue);
  var GraticuleLayer__default = /*#__PURE__*/_interopDefaultLegacy(GraticuleLayer$1);
  var WMTSTileGrid__default = /*#__PURE__*/_interopDefaultLegacy(WMTSTileGrid);

  function _defineProperty$1(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _classCallCheck$1(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function _inherits$1(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function getDefaultExportFromCjs (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function createCommonjsModule(fn, basedir, module) {
  	return module = {
  		path: basedir,
  		exports: {},
  		require: function (path, base) {
  			return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
  		}
  	}, fn(module, module.exports), module.exports;
  }

  function commonjsRequire () {
  	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
  }

  var _typeof_1 = createCommonjsModule(function (module) {
  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      module.exports = _typeof = function _typeof(obj) {
        return typeof obj;
      };

      module.exports["default"] = module.exports, module.exports.__esModule = true;
    } else {
      module.exports = _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };

      module.exports["default"] = module.exports, module.exports.__esModule = true;
    }

    return _typeof(obj);
  }

  module.exports = _typeof;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  });

  var _typeof$1 = /*@__PURE__*/getDefaultExportFromCjs(_typeof_1);

  function _possibleConstructorReturn$1(self, call) {
    if (call && (_typeof$1(call) === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _getPrototypeOf$1(o) {
    _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$1(o);
  }

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  function _isNativeReflectConstruct$5() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct$5()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf$1(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  function _typeof(obj) {
    "@babel/helpers - typeof";

    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof(obj) {
        return typeof obj;
      };
    } else {
      _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  var runtime_1 = createCommonjsModule(function (module) {
  /**
   * Copyright (c) 2014-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var runtime = (function (exports) {

    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined$1; // More compressible than void 0.
    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

    function define(obj, key, value) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
      return obj[key];
    }
    try {
      // IE 8 has a broken Object.defineProperty that only works on DOM objects.
      define({}, "");
    } catch (err) {
      define = function(obj, key, value) {
        return obj[key] = value;
      };
    }

    function wrap(innerFn, outerFn, self, tryLocsList) {
      // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []);

      // The ._invoke method unifies the implementations of the .next,
      // .throw, and .return methods.
      generator._invoke = makeInvokeMethod(innerFn, self, context);

      return generator;
    }
    exports.wrap = wrap;

    // Try/catch helper to minimize deoptimizations. Returns a completion
    // record like context.tryEntries[i].completion. This interface could
    // have been (and was previously) designed to take a closure to be
    // invoked without arguments, but in all the cases we care about we
    // already have an existing method we want to call, so there's no need
    // to create a new function object. We can even get away with assuming
    // the method takes exactly one argument, since that happens to be true
    // in every case, so we don't have to touch the arguments object. The
    // only additional allocation required is the completion record, which
    // has a stable shape and so hopefully should be cheap to allocate.
    function tryCatch(fn, obj, arg) {
      try {
        return { type: "normal", arg: fn.call(obj, arg) };
      } catch (err) {
        return { type: "throw", arg: err };
      }
    }

    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed";

    // Returning this object from the innerFn has the same effect as
    // breaking out of the dispatch switch statement.
    var ContinueSentinel = {};

    // Dummy constructor functions that we use as the .constructor and
    // .constructor.prototype properties for functions that return Generator
    // objects. For full spec compliance, you may wish to configure your
    // minifier not to mangle the names of these two functions.
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}

    // This is a polyfill for %IteratorPrototype% for environments that
    // don't natively support it.
    var IteratorPrototype = {};
    IteratorPrototype[iteratorSymbol] = function () {
      return this;
    };

    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    if (NativeIteratorPrototype &&
        NativeIteratorPrototype !== Op &&
        hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      // This environment has a native %IteratorPrototype%; use it instead
      // of the polyfill.
      IteratorPrototype = NativeIteratorPrototype;
    }

    var Gp = GeneratorFunctionPrototype.prototype =
      Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
    GeneratorFunctionPrototype.constructor = GeneratorFunction;
    GeneratorFunction.displayName = define(
      GeneratorFunctionPrototype,
      toStringTagSymbol,
      "GeneratorFunction"
    );

    // Helper for defining the .next, .throw, and .return methods of the
    // Iterator interface in terms of a single ._invoke method.
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function(method) {
        define(prototype, method, function(arg) {
          return this._invoke(method, arg);
        });
      });
    }

    exports.isGeneratorFunction = function(genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor
        ? ctor === GeneratorFunction ||
          // For the native GeneratorFunction constructor, the best we can
          // do is to check its .name property.
          (ctor.displayName || ctor.name) === "GeneratorFunction"
        : false;
    };

    exports.mark = function(genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;
        define(genFun, toStringTagSymbol, "GeneratorFunction");
      }
      genFun.prototype = Object.create(Gp);
      return genFun;
    };

    // Within the body of any async function, `await x` is transformed to
    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
    // `hasOwn.call(value, "__await")` to determine if the yielded value is
    // meant to be awaited.
    exports.awrap = function(arg) {
      return { __await: arg };
    };

    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);
        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;
          if (value &&
              typeof value === "object" &&
              hasOwn.call(value, "__await")) {
            return PromiseImpl.resolve(value.__await).then(function(value) {
              invoke("next", value, resolve, reject);
            }, function(err) {
              invoke("throw", err, resolve, reject);
            });
          }

          return PromiseImpl.resolve(value).then(function(unwrapped) {
            // When a yielded Promise is resolved, its final value becomes
            // the .value of the Promise<{value,done}> result for the
            // current iteration.
            result.value = unwrapped;
            resolve(result);
          }, function(error) {
            // If a rejected Promise was yielded, throw the rejection back
            // into the async generator function so it can be handled there.
            return invoke("throw", error, resolve, reject);
          });
        }
      }

      var previousPromise;

      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }

        return previousPromise =
          // If enqueue has been called before, then we want to wait until
          // all previous Promises have been resolved before calling invoke,
          // so that results are always delivered in the correct order. If
          // enqueue has not been called before, then it is important to
          // call invoke immediately, without waiting on a callback to fire,
          // so that the async generator function has the opportunity to do
          // any necessary setup in a predictable way. This predictability
          // is why the Promise constructor synchronously invokes its
          // executor callback, and why async functions synchronously
          // execute code before the first await. Since we implement simple
          // async functions in terms of async generators, it is especially
          // important to get this right, even though it requires care.
          previousPromise ? previousPromise.then(
            callInvokeWithMethodAndArg,
            // Avoid propagating failures to Promises returned by later
            // invocations of the iterator.
            callInvokeWithMethodAndArg
          ) : callInvokeWithMethodAndArg();
      }

      // Define the unified helper method that is used to implement .next,
      // .throw, and .return (see defineIteratorMethods).
      this._invoke = enqueue;
    }

    defineIteratorMethods(AsyncIterator.prototype);
    AsyncIterator.prototype[asyncIteratorSymbol] = function () {
      return this;
    };
    exports.AsyncIterator = AsyncIterator;

    // Note that simple async functions are implemented on top of
    // AsyncIterator objects; they just return a Promise for the value of
    // the final result produced by the iterator.
    exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      if (PromiseImpl === void 0) PromiseImpl = Promise;

      var iter = new AsyncIterator(
        wrap(innerFn, outerFn, self, tryLocsList),
        PromiseImpl
      );

      return exports.isGeneratorFunction(outerFn)
        ? iter // If outerFn is a generator, return the full iterator.
        : iter.next().then(function(result) {
            return result.done ? result.value : iter.next();
          });
    };

    function makeInvokeMethod(innerFn, self, context) {
      var state = GenStateSuspendedStart;

      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }

        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          }

          // Be forgiving, per 25.3.3.3.3 of the spec:
          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
          return doneResult();
        }

        context.method = method;
        context.arg = arg;

        while (true) {
          var delegate = context.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if (context.method === "next") {
            // Setting context._sent for legacy support of Babel's
            // function.sent implementation.
            context.sent = context._sent = context.arg;

          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }

            context.dispatchException(context.arg);

          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }

          state = GenStateExecuting;

          var record = tryCatch(innerFn, self, context);
          if (record.type === "normal") {
            // If an exception is thrown from innerFn, we leave state ===
            // GenStateExecuting and loop back for another invocation.
            state = context.done
              ? GenStateCompleted
              : GenStateSuspendedYield;

            if (record.arg === ContinueSentinel) {
              continue;
            }

            return {
              value: record.arg,
              done: context.done
            };

          } else if (record.type === "throw") {
            state = GenStateCompleted;
            // Dispatch the exception by looping back around to the
            // context.dispatchException(context.arg) call above.
            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    }

    // Call delegate.iterator[context.method](context.arg) and handle the
    // result, either by returning a { value, done } result from the
    // delegate iterator, or by modifying context.method and context.arg,
    // setting context.delegate to null, and returning the ContinueSentinel.
    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];
      if (method === undefined$1) {
        // A .throw or .return when the delegate iterator has no .throw
        // method always terminates the yield* loop.
        context.delegate = null;

        if (context.method === "throw") {
          // Note: ["return"] must be used for ES3 parsing compatibility.
          if (delegate.iterator["return"]) {
            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            context.method = "return";
            context.arg = undefined$1;
            maybeInvokeDelegate(delegate, context);

            if (context.method === "throw") {
              // If maybeInvokeDelegate(context) changed context.method from
              // "return" to "throw", let that override the TypeError below.
              return ContinueSentinel;
            }
          }

          context.method = "throw";
          context.arg = new TypeError(
            "The iterator does not provide a 'throw' method");
        }

        return ContinueSentinel;
      }

      var record = tryCatch(method, delegate.iterator, context.arg);

      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }

      var info = record.arg;

      if (! info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }

      if (info.done) {
        // Assign the result of the finished delegate to the temporary
        // variable specified by delegate.resultName (see delegateYield).
        context[delegate.resultName] = info.value;

        // Resume execution at the desired location (see delegateYield).
        context.next = delegate.nextLoc;

        // If context.method was "throw" but the delegate handled the
        // exception, let the outer generator proceed normally. If
        // context.method was "next", forget context.arg since it has been
        // "consumed" by the delegate iterator. If context.method was
        // "return", allow the original .return call to continue in the
        // outer generator.
        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined$1;
        }

      } else {
        // Re-yield the result returned by the delegate method.
        return info;
      }

      // The delegate iterator is finished, so forget it and continue with
      // the outer generator.
      context.delegate = null;
      return ContinueSentinel;
    }

    // Define Generator.prototype.{next,throw,return} in terms of the
    // unified ._invoke helper method.
    defineIteratorMethods(Gp);

    define(Gp, toStringTagSymbol, "Generator");

    // A Generator should always return itself as the iterator object when the
    // @@iterator function is called on it. Some browsers' implementations of the
    // iterator prototype chain incorrectly implement this, causing the Generator
    // object to not be returned from this call. This ensures that doesn't happen.
    // See https://github.com/facebook/regenerator/issues/274 for more details.
    Gp[iteratorSymbol] = function() {
      return this;
    };

    Gp.toString = function() {
      return "[object Generator]";
    };

    function pushTryEntry(locs) {
      var entry = { tryLoc: locs[0] };

      if (1 in locs) {
        entry.catchLoc = locs[1];
      }

      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }

      this.tryEntries.push(entry);
    }

    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }

    function Context(tryLocsList) {
      // The root entry object (effectively a try statement without a catch
      // or a finally block) gives us a place to store values thrown from
      // locations where there is no enclosing try statement.
      this.tryEntries = [{ tryLoc: "root" }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }

    exports.keys = function(object) {
      var keys = [];
      for (var key in object) {
        keys.push(key);
      }
      keys.reverse();

      // Rather than returning an object with a next method, we keep
      // things simple and return the next function itself.
      return function next() {
        while (keys.length) {
          var key = keys.pop();
          if (key in object) {
            next.value = key;
            next.done = false;
            return next;
          }
        }

        // To avoid creating an additional object, we just hang the .value
        // and .done properties off the next function object itself. This
        // also ensures that the minifier will not anonymize the function.
        next.done = true;
        return next;
      };
    };

    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }

        if (typeof iterable.next === "function") {
          return iterable;
        }

        if (!isNaN(iterable.length)) {
          var i = -1, next = function next() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next.value = iterable[i];
                next.done = false;
                return next;
              }
            }

            next.value = undefined$1;
            next.done = true;

            return next;
          };

          return next.next = next;
        }
      }

      // Return an iterator with no values.
      return { next: doneResult };
    }
    exports.values = values;

    function doneResult() {
      return { value: undefined$1, done: true };
    }

    Context.prototype = {
      constructor: Context,

      reset: function(skipTempReset) {
        this.prev = 0;
        this.next = 0;
        // Resetting context._sent for legacy support of Babel's
        // function.sent implementation.
        this.sent = this._sent = undefined$1;
        this.done = false;
        this.delegate = null;

        this.method = "next";
        this.arg = undefined$1;

        this.tryEntries.forEach(resetTryEntry);

        if (!skipTempReset) {
          for (var name in this) {
            // Not sure about the optimal order of these conditions:
            if (name.charAt(0) === "t" &&
                hasOwn.call(this, name) &&
                !isNaN(+name.slice(1))) {
              this[name] = undefined$1;
            }
          }
        }
      },

      stop: function() {
        this.done = true;

        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;
        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }

        return this.rval;
      },

      dispatchException: function(exception) {
        if (this.done) {
          throw exception;
        }

        var context = this;
        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;

          if (caught) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            context.method = "next";
            context.arg = undefined$1;
          }

          return !! caught;
        }

        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;

          if (entry.tryLoc === "root") {
            // Exception thrown outside of any try block that could handle
            // it, so set the completion value of the entire function to
            // throw the exception.
            return handle("end");
          }

          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");

            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }

            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }

            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }

            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },

      abrupt: function(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev &&
              hasOwn.call(entry, "finallyLoc") &&
              this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }

        if (finallyEntry &&
            (type === "break" ||
             type === "continue") &&
            finallyEntry.tryLoc <= arg &&
            arg <= finallyEntry.finallyLoc) {
          // Ignore the finally entry if control is not jumping to a
          // location outside the try/catch block.
          finallyEntry = null;
        }

        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;

        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }

        return this.complete(record);
      },

      complete: function(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }

        if (record.type === "break" ||
            record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }

        return ContinueSentinel;
      },

      finish: function(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },

      "catch": function(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }

        // The context.catch method must only be called with a location
        // argument that corresponds to a known catch block.
        throw new Error("illegal catch attempt");
      },

      delegateYield: function(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        };

        if (this.method === "next") {
          // Deliberately forget the last sent value so that we don't
          // accidentally pass it on to the delegate.
          this.arg = undefined$1;
        }

        return ContinueSentinel;
      }
    };

    // Regardless of whether this script is executing as a CommonJS module
    // or not, return the runtime object so that we can declare the variable
    // regeneratorRuntime in the outer scope, which allows this module to be
    // injected easily by `bin/regenerator --include-runtime script.js`.
    return exports;

  }(
    // If this script is executing as a CommonJS module, use module.exports
    // as the regeneratorRuntime namespace. Otherwise create a new empty
    // object. Either way, the resulting object will be used to initialize
    // the regeneratorRuntime variable at the top of this file.
    module.exports 
  ));

  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    // This module should not be running in strict mode, so the above
    // assignment should always work unless something is misconfigured. Just
    // in case runtime.js accidentally runs in strict mode, we can escape
    // strict mode using a global Function call. This could conceivably fail
    // if a Content Security Policy forbids using Function, but in that case
    // the proper solution is to fix the accidental strict mode problem. If
    // you've misconfigured your bundler to force strict mode and applied a
    // CSP to forbid Function, and you're not willing to fix either of those
    // problems, please detail your unique predicament in a GitHub issue.
    Function("r", "regeneratorRuntime = r")(runtime);
  }
  });

  var regenerator = runtime_1;

  var _context;

  var _marked = /*#__PURE__*/regenerator.mark(rangeIterator);
  /**
   * Mini Lodash.
   */

  var glob = typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : {};
  var globIsFinite = glob.isFinite || noop$1;
  var objectProto = Object.prototype;
  var funcProto = Object.prototype;
  var objectToString = objectProto.toString;
  var objectHasOwnProp = objectProto.hasOwnProperty;
  var funcToString = funcProto.toString;
  var objectTag = /*#__PURE__*/(_context = {}, objectToString).call(_context);
  var numberTag = /*#__PURE__*/(_context = 0, objectToString).call(_context);
  var stringTag = /*#__PURE__*/(_context = '', objectToString).call(_context);
  var booleanTag = /*#__PURE__*/(_context = true, objectToString).call(_context);
  var objectCtorString = /*#__PURE__*/funcToString.call(Object);
  function noop$1() {// do nothing
  }
  function constant(value) {
    return function () {
      return value;
    };
  }
  function stubArray() {
    return [];
  }
  function stubObject() {
    return Object.create(null);
  }
  function stubCollection() {
    return new ol.Collection();
  }
  function stubTrue() {
    return true;
  }
  function stubFalse() {
    return false;
  }
  function identity$2(value) {
    return value;
  }
  function negate(func) {
    return function () {
      return !func.apply(void 0, arguments);
    };
  }
  function or() {
    for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
      funcs[_key] = arguments[_key];
    }

    return function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return reduce(funcs, function (result, fn) {
        return result || fn.apply(void 0, args);
      }, false);
    };
  }
  function and() {
    for (var _len3 = arguments.length, funcs = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      funcs[_key3] = arguments[_key3];
    }

    return function () {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      return reduce(funcs, function (result, fn) {
        return result && fn.apply(void 0, args);
      }, true);
    };
  }
  function toArray(value) {
    return Array.from(value);
  }
  function isBoolean(value) {
    return objectToString.call(value) === booleanTag;
  }
  function isNumber$1(value) {
    return objectToString.call(value) === numberTag;
  }
  function isString(value) {
    return objectToString.call(value) === stringTag;
  }
  function isArray$2(value) {
    return Array.isArray(value);
  }
  function isArrayLike$1(value) {
    return isObjectLike(value) && objectHasOwnProp.call(value, 'length');
  }
  function isCollection(value) {
    return value instanceof ol.Collection;
  }
  function isFinite$1(value) {
    return typeof value === 'number' && globIsFinite(value);
  }
  function isFunction$1(value) {
    return typeof value === 'function';
  }
  /**
   * @param {*} value
   * @return {boolean} True if value is number or numeric string.
   */

  function isNumeric$1(value) {
    return !isNaN(parseFloat(value)) && globIsFinite(value);
  }
  function isObjectLike(value) {
    return value != null && _typeof(value) === 'object';
  }
  function isPlainObject(value) {
    if (!isObjectLike(value) || objectToString.call(value) !== objectTag) {
      return false;
    }

    var proto = Object.getPrototypeOf(value);

    if (proto == null) {
      return true;
    }

    var Ctor = proto.constructor;
    return typeof Ctor === 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) === objectCtorString;
  }
  function round(number) {
    var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    if (!globIsFinite(number)) return number;
    if (precision < 0) return Number(number);
    return Number(Number(number).toFixed(precision));
  }
  /**
   * @param {...*} [args]
   *
   * @return {*}
   */

  function coalesce() {
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }

    return args.find(function (val) {
      return val != null;
    });
  }
  /**
   * @param {Object} object
   * @return {Object} Returns object only with plain properties.
   */

  function plainProps(object) {
    var newObject = {};

    var isPlain = function isPlain(x) {
      return isNumeric$1(x) || isString(x) || isArray$2(x) || isBoolean(x) || isPlainObject(x);
    };

    Object.keys(object).forEach(function (key) {
      if (isPlain(object[key])) {
        newObject[key] = object[key];
      }
    });
    return newObject;
  }
  /**
   * Replaces `tokens` in the `string` by values from the `replaces`.
   *
   * @param {string} string
   * @param {Object} replaces
   *
   * @returns {string}
   */

  function replaceTokens(string, replaces) {
    var regExp = new RegExp(Object.keys(replaces).map(function (field) {
      return '(\\{' + field + '\\})';
    }).join('|'), 'ig');
    return string.replace(regExp, function (match) {
      return replaces[match.substr(1, match.length - 2)] || '';
    });
  }
  function isEqual(value, other) {
    if (value === other) {
      return true;
    }

    if (value == null || other == null || !(isObjectLike(value) && isObjectLike(other))) {
      // eslint-disable-next-line no-self-compare
      return value !== value && other !== other;
    }

    var valueProps = Object.keys(value);
    var otherProps = Object.keys(other);

    if (valueProps.length !== otherProps.length) {
      return false;
    } // if (serialize(value) === serialize(other)) return


    var checked = [];

    var traverse = function traverse(valueProps, otherProps) {
      for (var i = 0, l = valueProps.length; i < l; i++) {
        var valueProp = valueProps[i];

        if (checked.includes(valueProp)) {
          continue;
        }

        if (objectHasOwnProp.call(other, valueProp) === false) {
          return false;
        }

        var otherProp = otherProps[i];

        if (!isEqual(value[valueProp], other[otherProp])) {
          return false;
        }

        checked.push(otherProp);
      }

      return true;
    };

    if (traverse(valueProps, otherProps) === false) {
      return false;
    }

    return traverse(otherProps, valueProps);
  }
  function getLength(value) {
    if (isCollection(value)) {
      value = value.getArray();
    }

    if (isArrayLike$1(value)) {
      return value.length;
    }

    return 0;
  }
  function isEmpty$2(value) {
    if (isCollection(value)) {
      value = value.getArray();
    }

    if (isObjectLike(value)) {
      value = Object.values(value).filter(negate(isEmpty$2));
    }

    return !value || isArrayLike$1(value) && getLength(value) === 0;
  }
  function keys(object) {
    return Object.keys(object);
  }
  function values(object) {
    return Object.values(object);
  }
  function seal(object) {
    return Object.seal(object);
  }
  function freeze(object) {
    return Object.freeze(object);
  }
  function sealFactory(factory) {
    var fn = factory;

    if (!fn.sealed) {
      fn = function fn() {
        return seal(factory.apply(void 0, arguments));
      };

      fn.sealed = true;
    }

    return fn;
  }
  function freezeFactory(factory) {
    var fn = factory;

    if (!fn.freezed) {
      fn = function fn() {
        return freeze(factory.apply(void 0, arguments));
      };

      fn.freezed = true;
    }

    return fn;
  }
  function forEach(collection, iteratee) {
    if (isCollection(collection)) {
      collection = collection.getArray();
    }

    var keys = Object.keys(collection);

    for (var i = 0, l = keys.length; i < l; i++) {
      var key = keys[i];
      var value = collection[key];

      if (iteratee(value, key) === false) {
        return;
      }
    }
  }
  function reduce(collection, iteratee, initial) {
    var result = initial;
    forEach(collection, function (value, key) {
      result = iteratee(result, value, key);
    });
    return result;
  }
  function filter$1(collection) {
    var iteratee = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : negate(isEmpty$2);
    return reduce(collection, function (newCollection, value, key) {
      if (iteratee(value, key)) {
        if (isArray$2(newCollection)) {
          newCollection.push(value);
        } else {
          newCollection[key] = value;
        }
      }

      return newCollection;
    }, isArrayLike$1(collection) || isCollection(collection) ? [] : {});
  }
  function find(collection) {
    var iteratee = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity$2;
    var res = filter$1(collection, iteratee);
    if (isArray$2(res)) return res[0];
    return res[keys(res)[0]];
  }
  function map$1(collection) {
    var iteratee = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity$2;
    return reduce(collection, function (newCollection, value, key) {
      newCollection[key] = iteratee(value, key);
      return newCollection;
    }, isArrayLike$1(collection) || isCollection(collection) ? [] : {});
  }
  function mapValues(object) {
    var iteratee = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity$2;
    return map$1(object, iteratee);
  }
  function mapKeys(object) {
    var iteratee = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity$2;
    return reduce(object, function (newObject, value, key) {
      newObject[iteratee(value, key)] = value;
      return newObject;
    }, isArrayLike$1(object) || isCollection(object) ? [] : {});
  }
  function every(collection) {
    var iteratee = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity$2;
    return reduce(collection, function (result, value, key) {
      return result && iteratee(value, key);
    }, true);
  }
  function some(collection) {
    var iteratee = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity$2;
    return reduce(collection, function (result, value, key) {
      return result || iteratee(value, key);
    }, false);
  }
  function firstEl(object) {
    if (isCollection(object)) {
      object = object.getArray();
    }

    if (!isArrayLike$1(object)) return;
    return object[0];
  }
  function lastEl(object) {
    if (isCollection(object)) {
      object = object.getArray();
    }

    if (!isArrayLike$1(object)) return;
    return object[object.length - 1];
  }
  function pick(object, key) {
    for (var _len6 = arguments.length, keys = new Array(_len6 > 2 ? _len6 - 2 : 0), _key6 = 2; _key6 < _len6; _key6++) {
      keys[_key6 - 2] = arguments[_key6];
    }

    if (Array.isArray(key)) {
      keys = key;
    } else {
      keys = [key].concat(keys);
    }

    return reduce(keys, function (picked, key) {
      picked[key] = object[key];
      return picked;
    }, {});
  }
  function omit(object, key) {
    for (var _len7 = arguments.length, keys = new Array(_len7 > 2 ? _len7 - 2 : 0), _key7 = 2; _key7 < _len7; _key7++) {
      keys[_key7 - 2] = arguments[_key7];
    }

    if (Array.isArray(key)) {
      keys = key;
    } else {
      keys = [key].concat(keys);
    }

    return filter$1(object, function (value, key) {
      return !keys.includes(key);
    });
  }
  function upperFirst(string) {
    string = String(string);

    if (string.length === 0) {
      return '';
    }

    return string[0].toUpperCase() + string.slice(1);
  }
  function lowerFirst(string) {
    string = String(string);

    if (string.length === 0) {
      return '';
    }

    return string[0].toLowerCase() + string.slice(1);
  }
  function rangeIterator(start, end) {
    var step,
        i,
        _args = arguments;
    return regenerator.wrap(function rangeIterator$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            step = _args.length > 2 && _args[2] !== undefined ? _args[2] : 1;
            i = start;

          case 2:
            if (!(i < end)) {
              _context2.next = 8;
              break;
            }

            _context2.next = 5;
            return i;

          case 5:
            i += step;
            _context2.next = 2;
            break;

          case 8:
          case "end":
            return _context2.stop();
        }
      }
    }, _marked);
  }
  function range(start, end) {
    var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    return Array.from(rangeIterator(start, end, step));
  }
  /**
   * https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_get
   *
   * @param obj
   * @param path
   * @param defaultValue
   * @return {*}
   */

  function get$1(obj, path, defaultValue) {
    var travel = function travel(regexp) {
      return String.prototype.split.call(path, regexp).filter(Boolean).reduce(function (res, key) {
        return res !== null && res !== undefined ? res[key] : res;
      }, obj);
    };

    var result = travel(/[,[\]]+?/) || travel(/[,[\].]+?/);
    return result === undefined || result === obj ? defaultValue : result;
  }
  function hasOwnProp(object, prop) {
    return isObjectLike(object) && objectHasOwnProp.call(object, prop);
  }
  function hasProp(object, prop) {
    return isObjectLike(object) && prop in object;
  }
  function includes$1(array, value) {
    var comparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : isEqual;
    var elems = filter$1(array, function (elem) {
      return comparator(elem, value);
    });
    return elems.shift();
  }
  function difference(array1, array2) {
    var comparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : isEqual;
    return filter$1(array1, function (value) {
      return !includes$1(array2, value, comparator);
    });
  }
  /**
   * @param {string} str
   * @return {string}
   */

  function camelCase(str) {
    var regExp = /([-_]\w)/g;
    return str.replace(regExp, function (matches) {
      return matches[1].toUpperCase();
    });
  }
  /**
   * @param {string} str
   * @returns {string}
   */

  function kebabCase(str) {
    return str.match(/[A-Z]{2,}(?=[A-Z][a-z0-9]*|\b)|[A-Z]?[a-z0-9]*|[A-Z]|[0-9]+/g).filter(Boolean).map(function (x) {
      return x.toLowerCase();
    }).join('-');
  }
  function serialize$1(value) {
    return JSON.stringify(value);
  }
  function unserialize(value) {
    if (!isString(value)) return;
    return JSON.parse(value);
  }
  function clonePlainObject(obj) {
    return unserialize(serialize$1(obj));
  }
  function addPrefix(prefix) {
    return function (str) {
      return prefix + (prefix ? upperFirst(str) : str);
    };
  }

  function _createSuper$4(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$4(); return function _createSuperInternal() { var Super = _getPrototypeOf$1(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$1(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$1(this, result); }; }

  function _isNativeReflectConstruct$4() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var AssertionError = /*#__PURE__*/function (_Error) {
    _inherits$1(AssertionError, _Error);

    var _super = _createSuper$4(AssertionError);

    function AssertionError(message) {
      var _this;

      _classCallCheck$1(this, AssertionError);

      _this = _super.call(this, message);
      _this.name = _this.constructor.name;

      if (typeof Error.captureStackTrace === 'function') {
        Error.captureStackTrace(_assertThisInitialized(_this), _this.constructor);
      } else {
        _this.stack = new Error(message).stack;
      }

      return _this;
    }

    return AssertionError;
  }( /*#__PURE__*/_wrapNativeSuper(Error));
  /**
   * @param {*} value
   * @param {string} message
   * @throws AssertionError
   */

  function assert$1(value, message) {
    if (!value) {
      throw new AssertionError(message || 'Assertion failed');
    }
  }
  /**
   * @param {*} value
   * @param {string|undefined} [msg]
   * @throws {AssertionError}
   */

  function numeric(value, msg) {
    assert$1(isNumeric$1(value), msg || 'value is a number');
  }
  /**
   * @param {*} value
   * @param {Function} Ctor
   * @param {string|undefined} [msg]
   * @throws {AssertionError}
   */

  function instanceOf(value, Ctor, msg) {
    assert$1(value instanceof Ctor, msg || "value is an instance of ".concat(Ctor.name));
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass$1(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  /**
   * Simple Identity map with refs count
   */
  var IdentityMap = /*#__PURE__*/function () {
    function IdentityMap() {
      _classCallCheck$1(this, IdentityMap);

      _defineProperty$1(this, "_pools", Object.create(null));
    }

    _createClass$1(IdentityMap, [{
      key: "_preparePool",
      value:
      /**
       * @param {string} pool
       * @private
       */
      function _preparePool(pool) {
        this._pools[pool] || (this._pools[pool] = Object.create(null));
      }
      /**
       * @param {string} id
       * @param {*} value
       * @param {string} pool
       */

    }, {
      key: "set",
      value: function set(id, value) {
        var pool = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'default';
        if (value == null) return;

        this._preparePool(pool);

        this._pools[pool][id] = {
          value: value,
          refs: 1
        };
      }
      /**
       * @param {string} id
       * @param {string} pool
       */

    }, {
      key: "get",
      value: function get(id) {
        var pool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';

        this._preparePool(pool);

        var rec = this._pools[pool][id];
        if (!rec || rec.value == null) return;
        rec.refs++;
        this._pools[pool][id] = rec;
        return rec.value;
      }
      /**
       * @param {string} id
       * @param {string} pool
       */

    }, {
      key: "unset",
      value: function unset(id) {
        var pool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';

        this._preparePool(pool);

        var rec = this._pools[pool][id];
        if (!rec || rec.value == null) return;
        rec.refs--;

        if (rec.refs === 0) {
          delete this._pools[pool][id];
        }
      }
      /**
       * @param {string} id
       * @param {string} pool
       * @return {boolean}
       */

    }, {
      key: "has",
      value: function has(id) {
        var pool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';

        this._preparePool(pool);

        return !!this._pools[pool][id];
      }
      /**
       * @param {string} fromId
       * @param {string} toId
       * @param {string} [pool]
       * @returns {boolean}
       */

    }, {
      key: "move",
      value: function move(fromId, toId) {
        var pool = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'default';
        if (!this.has(fromId, pool) || !toId) return false;
        this._pools[pool][toId] = this._pools[pool][fromId];
        delete this._pools[pool][fromId];
        return true;
      }
      /**
       * @param {string} pool
       * @return {string[]}
       */

    }, {
      key: "ids",
      value: function ids() {
        var pool = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'default';

        this._preparePool(pool);

        return Object.keys(this._pools[pool]);
      }
      /**
       * @param {string} id
       * @param {string} pool
       * @return {*}
       */

    }, {
      key: "refs",
      value: function refs(id) {
        var pool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';

        this._preparePool(pool);

        return this.has(id, pool) ? this._pools[pool][id].refs : undefined;
      }
    }]);

    return IdentityMap;
  }();

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;

    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray(arr);
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
  }

  /* eslint-disable no-console */

  var log = makeLog('[VueLayers]');
  var warn = makeWarn('[VueLayers] WARN');
  var error = makeError('[VueLayers] ERR');
  /* eslint-enable no-console */

  function encode(val) {
    return JSON.stringify(val);
  }
  function newLogger() {
    var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    return {
      log: makeLog("[VueLayers] ".concat(prefix)),
      warn: makeWarn("[VueLayers] WARN ".concat(prefix)),
      error: makeError("[VueLayers] ERR ".concat(prefix))
    };
  }
  function makeLog() {
    var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    return function () {
      var _console;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (prefix) {
        if (isString(args[0])) {
          args[0] = prefix.trim() + ' ' + args[0];
        } else {
          args = [prefix.trim()].concat(_toConsumableArray(args));
        }
      }

      (_console = console).log.apply(_console, _toConsumableArray(args));
    };
  }
  function makeWarn() {
    var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    return function () {
      var _console2;

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      if (prefix) {
        if (isString(args[0])) {
          args[0] = prefix.trim() + ' ' + args[0];
        } else {
          args = [prefix.trim()].concat(_toConsumableArray(args));
        }
      }

      (_console2 = console).warn.apply(_console2, _toConsumableArray(args));
    };
  }
  function makeError() {
    var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    return function () {
      var _console3;

      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      if (prefix) {
        if (isString(args[0])) {
          args[0] = prefix.trim() + ' ' + args[0];
        } else {
          args = [prefix.trim()].concat(_toConsumableArray(args));
        }
      }

      (_console3 = console).error.apply(_console3, _toConsumableArray(args));
    };
  }

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  function sequential (fn) {
    return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
      var res,
          _args = arguments;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!fn._execPromise) {
                _context.next = 3;
                break;
              }

              _context.next = 3;
              return fn._execPromise;

            case 3:
              fn._execPromise = Promise.resolve(fn.call.apply(fn, [this].concat(Array.prototype.slice.call(_args))));
              _context.next = 6;
              return fn._execPromise;

            case 6:
              res = _context.sent;
              delete fn._execPromise;
              return _context.abrupt("return", res);

            case 9:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));
  }

  /*!
   * merge-descriptors
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   */

  /**
   * Module exports.
   * @public
   */

  var mergeDescriptors$1 = merge$1;

  /**
   * Module variables.
   * @private
   */

  var hasOwnProperty = Object.prototype.hasOwnProperty;

  /**
   * Merge the property descriptors of `src` into `dest`
   *
   * @param {object} dest Object to add descriptors to
   * @param {object} src Object to clone descriptors from
   * @param {boolean} [redefine=true] Redefine `dest` properties with `src` properties
   * @returns {object} Reference to dest
   * @public
   */

  function merge$1(dest, src, redefine) {
    if (!dest) {
      throw new TypeError('argument dest is required')
    }

    if (!src) {
      throw new TypeError('argument src is required')
    }

    if (redefine === undefined) {
      // Default to true
      redefine = true;
    }

    Object.getOwnPropertyNames(src).forEach(function forEachOwnPropertyName(name) {
      if (!redefine && hasOwnProperty.call(dest, name)) {
        // Skip desriptor
        return
      }

      // Copy descriptor
      var descriptor = Object.getOwnPropertyDescriptor(src, name);
      Object.defineProperty(dest, name, descriptor);
    });

    return dest
  }

  /**
   * @param {...Object} args
   * @returns {Object}
   */

  function mergeDescriptors() {
    var redefine;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (_typeof(args[args.length - 1]) !== 'object') {
      redefine = args.pop();
    }

    return args.slice(1).reduce(function (dest, src, i) {
      return mergeDescriptors$1(dest, src, redefine);
    }, args[0]);
  }

  /**
   * Constructs watch hash for multiple properties.
   * @param {string[]} props
   * @param {function|Object} watcherFactory
   */
  function makeWatchers(props, watcherFactory) {
    return props.reduce(function (hash, prop) {
      hash[prop] = watcherFactory(prop);
      return hash;
    }, {});
  }
  function extractChildren(slots) {
    var slotNames = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    return Object.keys(slots).reduce(function (all, name) {
      if (!slotNames.length || slotNames.includes(name)) {
        all = all.concat(slots[name]);
      }

      return all;
    }, []);
  }

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */
  /* global Reflect, Promise */

  var extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf ||
          ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
          function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
      return extendStatics(d, b);
  };

  function __extends(d, b) {
      extendStatics(d, b);
      function __() { this.constructor = d; }
      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  function isFunction(x) {
      return typeof x === 'function';
  }

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  var _enable_super_gross_mode_that_will_cause_bad_things = false;
  var config = {
      Promise: undefined,
      set useDeprecatedSynchronousErrorHandling(value) {
          if (value) {
              var error = /*@__PURE__*/ new Error();
              /*@__PURE__*/ console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
          }
          _enable_super_gross_mode_that_will_cause_bad_things = value;
      },
      get useDeprecatedSynchronousErrorHandling() {
          return _enable_super_gross_mode_that_will_cause_bad_things;
      },
  };

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  function hostReportError(err) {
      setTimeout(function () { throw err; }, 0);
  }

  /** PURE_IMPORTS_START _config,_util_hostReportError PURE_IMPORTS_END */
  var empty$1 = {
      closed: true,
      next: function (value) { },
      error: function (err) {
          if (config.useDeprecatedSynchronousErrorHandling) {
              throw err;
          }
          else {
              hostReportError(err);
          }
      },
      complete: function () { }
  };

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  var isArray$1 = /*@__PURE__*/ (function () { return Array.isArray || (function (x) { return x && typeof x.length === 'number'; }); })();

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  function isObject$1(x) {
      return x !== null && typeof x === 'object';
  }

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  var UnsubscriptionErrorImpl = /*@__PURE__*/ (function () {
      function UnsubscriptionErrorImpl(errors) {
          Error.call(this);
          this.message = errors ?
              errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ') : '';
          this.name = 'UnsubscriptionError';
          this.errors = errors;
          return this;
      }
      UnsubscriptionErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
      return UnsubscriptionErrorImpl;
  })();
  var UnsubscriptionError = UnsubscriptionErrorImpl;

  /** PURE_IMPORTS_START _util_isArray,_util_isObject,_util_isFunction,_util_UnsubscriptionError PURE_IMPORTS_END */
  var Subscription = /*@__PURE__*/ (function () {
      function Subscription(unsubscribe) {
          this.closed = false;
          this._parentOrParents = null;
          this._subscriptions = null;
          if (unsubscribe) {
              this._ctorUnsubscribe = true;
              this._unsubscribe = unsubscribe;
          }
      }
      Subscription.prototype.unsubscribe = function () {
          var errors;
          if (this.closed) {
              return;
          }
          var _a = this, _parentOrParents = _a._parentOrParents, _ctorUnsubscribe = _a._ctorUnsubscribe, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
          this.closed = true;
          this._parentOrParents = null;
          this._subscriptions = null;
          if (_parentOrParents instanceof Subscription) {
              _parentOrParents.remove(this);
          }
          else if (_parentOrParents !== null) {
              for (var index = 0; index < _parentOrParents.length; ++index) {
                  var parent_1 = _parentOrParents[index];
                  parent_1.remove(this);
              }
          }
          if (isFunction(_unsubscribe)) {
              if (_ctorUnsubscribe) {
                  this._unsubscribe = undefined;
              }
              try {
                  _unsubscribe.call(this);
              }
              catch (e) {
                  errors = e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];
              }
          }
          if (isArray$1(_subscriptions)) {
              var index = -1;
              var len = _subscriptions.length;
              while (++index < len) {
                  var sub = _subscriptions[index];
                  if (isObject$1(sub)) {
                      try {
                          sub.unsubscribe();
                      }
                      catch (e) {
                          errors = errors || [];
                          if (e instanceof UnsubscriptionError) {
                              errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
                          }
                          else {
                              errors.push(e);
                          }
                      }
                  }
              }
          }
          if (errors) {
              throw new UnsubscriptionError(errors);
          }
      };
      Subscription.prototype.add = function (teardown) {
          var subscription = teardown;
          if (!teardown) {
              return Subscription.EMPTY;
          }
          switch (typeof teardown) {
              case 'function':
                  subscription = new Subscription(teardown);
              case 'object':
                  if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') {
                      return subscription;
                  }
                  else if (this.closed) {
                      subscription.unsubscribe();
                      return subscription;
                  }
                  else if (!(subscription instanceof Subscription)) {
                      var tmp = subscription;
                      subscription = new Subscription();
                      subscription._subscriptions = [tmp];
                  }
                  break;
              default: {
                  throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
              }
          }
          var _parentOrParents = subscription._parentOrParents;
          if (_parentOrParents === null) {
              subscription._parentOrParents = this;
          }
          else if (_parentOrParents instanceof Subscription) {
              if (_parentOrParents === this) {
                  return subscription;
              }
              subscription._parentOrParents = [_parentOrParents, this];
          }
          else if (_parentOrParents.indexOf(this) === -1) {
              _parentOrParents.push(this);
          }
          else {
              return subscription;
          }
          var subscriptions = this._subscriptions;
          if (subscriptions === null) {
              this._subscriptions = [subscription];
          }
          else {
              subscriptions.push(subscription);
          }
          return subscription;
      };
      Subscription.prototype.remove = function (subscription) {
          var subscriptions = this._subscriptions;
          if (subscriptions) {
              var subscriptionIndex = subscriptions.indexOf(subscription);
              if (subscriptionIndex !== -1) {
                  subscriptions.splice(subscriptionIndex, 1);
              }
          }
      };
      Subscription.EMPTY = (function (empty) {
          empty.closed = true;
          return empty;
      }(new Subscription()));
      return Subscription;
  }());
  function flattenUnsubscriptionErrors(errors) {
      return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError) ? err.errors : err); }, []);
  }

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  var rxSubscriber = /*@__PURE__*/ (function () {
      return typeof Symbol === 'function'
          ? /*@__PURE__*/ Symbol('rxSubscriber')
          : '@@rxSubscriber_' + /*@__PURE__*/ Math.random();
  })();

  /** PURE_IMPORTS_START tslib,_util_isFunction,_Observer,_Subscription,_internal_symbol_rxSubscriber,_config,_util_hostReportError PURE_IMPORTS_END */
  var Subscriber = /*@__PURE__*/ (function (_super) {
      __extends(Subscriber, _super);
      function Subscriber(destinationOrNext, error, complete) {
          var _this = _super.call(this) || this;
          _this.syncErrorValue = null;
          _this.syncErrorThrown = false;
          _this.syncErrorThrowable = false;
          _this.isStopped = false;
          switch (arguments.length) {
              case 0:
                  _this.destination = empty$1;
                  break;
              case 1:
                  if (!destinationOrNext) {
                      _this.destination = empty$1;
                      break;
                  }
                  if (typeof destinationOrNext === 'object') {
                      if (destinationOrNext instanceof Subscriber) {
                          _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
                          _this.destination = destinationOrNext;
                          destinationOrNext.add(_this);
                      }
                      else {
                          _this.syncErrorThrowable = true;
                          _this.destination = new SafeSubscriber(_this, destinationOrNext);
                      }
                      break;
                  }
              default:
                  _this.syncErrorThrowable = true;
                  _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
                  break;
          }
          return _this;
      }
      Subscriber.prototype[rxSubscriber] = function () { return this; };
      Subscriber.create = function (next, error, complete) {
          var subscriber = new Subscriber(next, error, complete);
          subscriber.syncErrorThrowable = false;
          return subscriber;
      };
      Subscriber.prototype.next = function (value) {
          if (!this.isStopped) {
              this._next(value);
          }
      };
      Subscriber.prototype.error = function (err) {
          if (!this.isStopped) {
              this.isStopped = true;
              this._error(err);
          }
      };
      Subscriber.prototype.complete = function () {
          if (!this.isStopped) {
              this.isStopped = true;
              this._complete();
          }
      };
      Subscriber.prototype.unsubscribe = function () {
          if (this.closed) {
              return;
          }
          this.isStopped = true;
          _super.prototype.unsubscribe.call(this);
      };
      Subscriber.prototype._next = function (value) {
          this.destination.next(value);
      };
      Subscriber.prototype._error = function (err) {
          this.destination.error(err);
          this.unsubscribe();
      };
      Subscriber.prototype._complete = function () {
          this.destination.complete();
          this.unsubscribe();
      };
      Subscriber.prototype._unsubscribeAndRecycle = function () {
          var _parentOrParents = this._parentOrParents;
          this._parentOrParents = null;
          this.unsubscribe();
          this.closed = false;
          this.isStopped = false;
          this._parentOrParents = _parentOrParents;
          return this;
      };
      return Subscriber;
  }(Subscription));
  var SafeSubscriber = /*@__PURE__*/ (function (_super) {
      __extends(SafeSubscriber, _super);
      function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
          var _this = _super.call(this) || this;
          _this._parentSubscriber = _parentSubscriber;
          var next;
          var context = _this;
          if (isFunction(observerOrNext)) {
              next = observerOrNext;
          }
          else if (observerOrNext) {
              next = observerOrNext.next;
              error = observerOrNext.error;
              complete = observerOrNext.complete;
              if (observerOrNext !== empty$1) {
                  context = Object.create(observerOrNext);
                  if (isFunction(context.unsubscribe)) {
                      _this.add(context.unsubscribe.bind(context));
                  }
                  context.unsubscribe = _this.unsubscribe.bind(_this);
              }
          }
          _this._context = context;
          _this._next = next;
          _this._error = error;
          _this._complete = complete;
          return _this;
      }
      SafeSubscriber.prototype.next = function (value) {
          if (!this.isStopped && this._next) {
              var _parentSubscriber = this._parentSubscriber;
              if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                  this.__tryOrUnsub(this._next, value);
              }
              else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                  this.unsubscribe();
              }
          }
      };
      SafeSubscriber.prototype.error = function (err) {
          if (!this.isStopped) {
              var _parentSubscriber = this._parentSubscriber;
              var useDeprecatedSynchronousErrorHandling = config.useDeprecatedSynchronousErrorHandling;
              if (this._error) {
                  if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                      this.__tryOrUnsub(this._error, err);
                      this.unsubscribe();
                  }
                  else {
                      this.__tryOrSetError(_parentSubscriber, this._error, err);
                      this.unsubscribe();
                  }
              }
              else if (!_parentSubscriber.syncErrorThrowable) {
                  this.unsubscribe();
                  if (useDeprecatedSynchronousErrorHandling) {
                      throw err;
                  }
                  hostReportError(err);
              }
              else {
                  if (useDeprecatedSynchronousErrorHandling) {
                      _parentSubscriber.syncErrorValue = err;
                      _parentSubscriber.syncErrorThrown = true;
                  }
                  else {
                      hostReportError(err);
                  }
                  this.unsubscribe();
              }
          }
      };
      SafeSubscriber.prototype.complete = function () {
          var _this = this;
          if (!this.isStopped) {
              var _parentSubscriber = this._parentSubscriber;
              if (this._complete) {
                  var wrappedComplete = function () { return _this._complete.call(_this._context); };
                  if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                      this.__tryOrUnsub(wrappedComplete);
                      this.unsubscribe();
                  }
                  else {
                      this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                      this.unsubscribe();
                  }
              }
              else {
                  this.unsubscribe();
              }
          }
      };
      SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
          try {
              fn.call(this._context, value);
          }
          catch (err) {
              this.unsubscribe();
              if (config.useDeprecatedSynchronousErrorHandling) {
                  throw err;
              }
              else {
                  hostReportError(err);
              }
          }
      };
      SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
          if (!config.useDeprecatedSynchronousErrorHandling) {
              throw new Error('bad call');
          }
          try {
              fn.call(this._context, value);
          }
          catch (err) {
              if (config.useDeprecatedSynchronousErrorHandling) {
                  parent.syncErrorValue = err;
                  parent.syncErrorThrown = true;
                  return true;
              }
              else {
                  hostReportError(err);
                  return true;
              }
          }
          return false;
      };
      SafeSubscriber.prototype._unsubscribe = function () {
          var _parentSubscriber = this._parentSubscriber;
          this._context = null;
          this._parentSubscriber = null;
          _parentSubscriber.unsubscribe();
      };
      return SafeSubscriber;
  }(Subscriber));

  /** PURE_IMPORTS_START _Subscriber PURE_IMPORTS_END */
  function canReportError(observer) {
      while (observer) {
          var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;
          if (closed_1 || isStopped) {
              return false;
          }
          else if (destination && destination instanceof Subscriber) {
              observer = destination;
          }
          else {
              observer = null;
          }
      }
      return true;
  }

  /** PURE_IMPORTS_START _Subscriber,_symbol_rxSubscriber,_Observer PURE_IMPORTS_END */
  function toSubscriber(nextOrObserver, error, complete) {
      if (nextOrObserver) {
          if (nextOrObserver instanceof Subscriber) {
              return nextOrObserver;
          }
          if (nextOrObserver[rxSubscriber]) {
              return nextOrObserver[rxSubscriber]();
          }
      }
      if (!nextOrObserver && !error && !complete) {
          return new Subscriber(empty$1);
      }
      return new Subscriber(nextOrObserver, error, complete);
  }

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  var observable = /*@__PURE__*/ (function () { return typeof Symbol === 'function' && Symbol.observable || '@@observable'; })();

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  function identity$1(x) {
      return x;
  }

  /** PURE_IMPORTS_START _identity PURE_IMPORTS_END */
  function pipeFromArray(fns) {
      if (fns.length === 0) {
          return identity$1;
      }
      if (fns.length === 1) {
          return fns[0];
      }
      return function piped(input) {
          return fns.reduce(function (prev, fn) { return fn(prev); }, input);
      };
  }

  /** PURE_IMPORTS_START _util_canReportError,_util_toSubscriber,_symbol_observable,_util_pipe,_config PURE_IMPORTS_END */
  var Observable = /*@__PURE__*/ (function () {
      function Observable(subscribe) {
          this._isScalar = false;
          if (subscribe) {
              this._subscribe = subscribe;
          }
      }
      Observable.prototype.lift = function (operator) {
          var observable = new Observable();
          observable.source = this;
          observable.operator = operator;
          return observable;
      };
      Observable.prototype.subscribe = function (observerOrNext, error, complete) {
          var operator = this.operator;
          var sink = toSubscriber(observerOrNext, error, complete);
          if (operator) {
              sink.add(operator.call(sink, this.source));
          }
          else {
              sink.add(this.source || (config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ?
                  this._subscribe(sink) :
                  this._trySubscribe(sink));
          }
          if (config.useDeprecatedSynchronousErrorHandling) {
              if (sink.syncErrorThrowable) {
                  sink.syncErrorThrowable = false;
                  if (sink.syncErrorThrown) {
                      throw sink.syncErrorValue;
                  }
              }
          }
          return sink;
      };
      Observable.prototype._trySubscribe = function (sink) {
          try {
              return this._subscribe(sink);
          }
          catch (err) {
              if (config.useDeprecatedSynchronousErrorHandling) {
                  sink.syncErrorThrown = true;
                  sink.syncErrorValue = err;
              }
              if (canReportError(sink)) {
                  sink.error(err);
              }
              else {
                  console.warn(err);
              }
          }
      };
      Observable.prototype.forEach = function (next, promiseCtor) {
          var _this = this;
          promiseCtor = getPromiseCtor(promiseCtor);
          return new promiseCtor(function (resolve, reject) {
              var subscription;
              subscription = _this.subscribe(function (value) {
                  try {
                      next(value);
                  }
                  catch (err) {
                      reject(err);
                      if (subscription) {
                          subscription.unsubscribe();
                      }
                  }
              }, reject, resolve);
          });
      };
      Observable.prototype._subscribe = function (subscriber) {
          var source = this.source;
          return source && source.subscribe(subscriber);
      };
      Observable.prototype[observable] = function () {
          return this;
      };
      Observable.prototype.pipe = function () {
          var operations = [];
          for (var _i = 0; _i < arguments.length; _i++) {
              operations[_i] = arguments[_i];
          }
          if (operations.length === 0) {
              return this;
          }
          return pipeFromArray(operations)(this);
      };
      Observable.prototype.toPromise = function (promiseCtor) {
          var _this = this;
          promiseCtor = getPromiseCtor(promiseCtor);
          return new promiseCtor(function (resolve, reject) {
              var value;
              _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
          });
      };
      Observable.create = function (subscribe) {
          return new Observable(subscribe);
      };
      return Observable;
  }());
  function getPromiseCtor(promiseCtor) {
      if (!promiseCtor) {
          promiseCtor = Promise;
      }
      if (!promiseCtor) {
          throw new Error('no Promise impl found');
      }
      return promiseCtor;
  }

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  var ObjectUnsubscribedErrorImpl = /*@__PURE__*/ (function () {
      function ObjectUnsubscribedErrorImpl() {
          Error.call(this);
          this.message = 'object unsubscribed';
          this.name = 'ObjectUnsubscribedError';
          return this;
      }
      ObjectUnsubscribedErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
      return ObjectUnsubscribedErrorImpl;
  })();
  var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;

  /** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */
  var SubjectSubscription = /*@__PURE__*/ (function (_super) {
      __extends(SubjectSubscription, _super);
      function SubjectSubscription(subject, subscriber) {
          var _this = _super.call(this) || this;
          _this.subject = subject;
          _this.subscriber = subscriber;
          _this.closed = false;
          return _this;
      }
      SubjectSubscription.prototype.unsubscribe = function () {
          if (this.closed) {
              return;
          }
          this.closed = true;
          var subject = this.subject;
          var observers = subject.observers;
          this.subject = null;
          if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
              return;
          }
          var subscriberIndex = observers.indexOf(this.subscriber);
          if (subscriberIndex !== -1) {
              observers.splice(subscriberIndex, 1);
          }
      };
      return SubjectSubscription;
  }(Subscription));

  /** PURE_IMPORTS_START tslib,_Observable,_Subscriber,_Subscription,_util_ObjectUnsubscribedError,_SubjectSubscription,_internal_symbol_rxSubscriber PURE_IMPORTS_END */
  var SubjectSubscriber = /*@__PURE__*/ (function (_super) {
      __extends(SubjectSubscriber, _super);
      function SubjectSubscriber(destination) {
          var _this = _super.call(this, destination) || this;
          _this.destination = destination;
          return _this;
      }
      return SubjectSubscriber;
  }(Subscriber));
  var Subject = /*@__PURE__*/ (function (_super) {
      __extends(Subject, _super);
      function Subject() {
          var _this = _super.call(this) || this;
          _this.observers = [];
          _this.closed = false;
          _this.isStopped = false;
          _this.hasError = false;
          _this.thrownError = null;
          return _this;
      }
      Subject.prototype[rxSubscriber] = function () {
          return new SubjectSubscriber(this);
      };
      Subject.prototype.lift = function (operator) {
          var subject = new AnonymousSubject(this, this);
          subject.operator = operator;
          return subject;
      };
      Subject.prototype.next = function (value) {
          if (this.closed) {
              throw new ObjectUnsubscribedError();
          }
          if (!this.isStopped) {
              var observers = this.observers;
              var len = observers.length;
              var copy = observers.slice();
              for (var i = 0; i < len; i++) {
                  copy[i].next(value);
              }
          }
      };
      Subject.prototype.error = function (err) {
          if (this.closed) {
              throw new ObjectUnsubscribedError();
          }
          this.hasError = true;
          this.thrownError = err;
          this.isStopped = true;
          var observers = this.observers;
          var len = observers.length;
          var copy = observers.slice();
          for (var i = 0; i < len; i++) {
              copy[i].error(err);
          }
          this.observers.length = 0;
      };
      Subject.prototype.complete = function () {
          if (this.closed) {
              throw new ObjectUnsubscribedError();
          }
          this.isStopped = true;
          var observers = this.observers;
          var len = observers.length;
          var copy = observers.slice();
          for (var i = 0; i < len; i++) {
              copy[i].complete();
          }
          this.observers.length = 0;
      };
      Subject.prototype.unsubscribe = function () {
          this.isStopped = true;
          this.closed = true;
          this.observers = null;
      };
      Subject.prototype._trySubscribe = function (subscriber) {
          if (this.closed) {
              throw new ObjectUnsubscribedError();
          }
          else {
              return _super.prototype._trySubscribe.call(this, subscriber);
          }
      };
      Subject.prototype._subscribe = function (subscriber) {
          if (this.closed) {
              throw new ObjectUnsubscribedError();
          }
          else if (this.hasError) {
              subscriber.error(this.thrownError);
              return Subscription.EMPTY;
          }
          else if (this.isStopped) {
              subscriber.complete();
              return Subscription.EMPTY;
          }
          else {
              this.observers.push(subscriber);
              return new SubjectSubscription(this, subscriber);
          }
      };
      Subject.prototype.asObservable = function () {
          var observable = new Observable();
          observable.source = this;
          return observable;
      };
      Subject.create = function (destination, source) {
          return new AnonymousSubject(destination, source);
      };
      return Subject;
  }(Observable));
  var AnonymousSubject = /*@__PURE__*/ (function (_super) {
      __extends(AnonymousSubject, _super);
      function AnonymousSubject(destination, source) {
          var _this = _super.call(this) || this;
          _this.destination = destination;
          _this.source = source;
          return _this;
      }
      AnonymousSubject.prototype.next = function (value) {
          var destination = this.destination;
          if (destination && destination.next) {
              destination.next(value);
          }
      };
      AnonymousSubject.prototype.error = function (err) {
          var destination = this.destination;
          if (destination && destination.error) {
              this.destination.error(err);
          }
      };
      AnonymousSubject.prototype.complete = function () {
          var destination = this.destination;
          if (destination && destination.complete) {
              this.destination.complete();
          }
      };
      AnonymousSubject.prototype._subscribe = function (subscriber) {
          var source = this.source;
          if (source) {
              return this.source.subscribe(subscriber);
          }
          else {
              return Subscription.EMPTY;
          }
      };
      return AnonymousSubject;
  }(Subject));

  /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
  function refCount() {
      return function refCountOperatorFunction(source) {
          return source.lift(new RefCountOperator(source));
      };
  }
  var RefCountOperator = /*@__PURE__*/ (function () {
      function RefCountOperator(connectable) {
          this.connectable = connectable;
      }
      RefCountOperator.prototype.call = function (subscriber, source) {
          var connectable = this.connectable;
          connectable._refCount++;
          var refCounter = new RefCountSubscriber(subscriber, connectable);
          var subscription = source.subscribe(refCounter);
          if (!refCounter.closed) {
              refCounter.connection = connectable.connect();
          }
          return subscription;
      };
      return RefCountOperator;
  }());
  var RefCountSubscriber = /*@__PURE__*/ (function (_super) {
      __extends(RefCountSubscriber, _super);
      function RefCountSubscriber(destination, connectable) {
          var _this = _super.call(this, destination) || this;
          _this.connectable = connectable;
          return _this;
      }
      RefCountSubscriber.prototype._unsubscribe = function () {
          var connectable = this.connectable;
          if (!connectable) {
              this.connection = null;
              return;
          }
          this.connectable = null;
          var refCount = connectable._refCount;
          if (refCount <= 0) {
              this.connection = null;
              return;
          }
          connectable._refCount = refCount - 1;
          if (refCount > 1) {
              this.connection = null;
              return;
          }
          var connection = this.connection;
          var sharedConnection = connectable._connection;
          this.connection = null;
          if (sharedConnection && (!connection || sharedConnection === connection)) {
              sharedConnection.unsubscribe();
          }
      };
      return RefCountSubscriber;
  }(Subscriber));

  /** PURE_IMPORTS_START tslib,_Subject,_Observable,_Subscriber,_Subscription,_operators_refCount PURE_IMPORTS_END */
  var ConnectableObservable = /*@__PURE__*/ (function (_super) {
      __extends(ConnectableObservable, _super);
      function ConnectableObservable(source, subjectFactory) {
          var _this = _super.call(this) || this;
          _this.source = source;
          _this.subjectFactory = subjectFactory;
          _this._refCount = 0;
          _this._isComplete = false;
          return _this;
      }
      ConnectableObservable.prototype._subscribe = function (subscriber) {
          return this.getSubject().subscribe(subscriber);
      };
      ConnectableObservable.prototype.getSubject = function () {
          var subject = this._subject;
          if (!subject || subject.isStopped) {
              this._subject = this.subjectFactory();
          }
          return this._subject;
      };
      ConnectableObservable.prototype.connect = function () {
          var connection = this._connection;
          if (!connection) {
              this._isComplete = false;
              connection = this._connection = new Subscription();
              connection.add(this.source
                  .subscribe(new ConnectableSubscriber(this.getSubject(), this)));
              if (connection.closed) {
                  this._connection = null;
                  connection = Subscription.EMPTY;
              }
          }
          return connection;
      };
      ConnectableObservable.prototype.refCount = function () {
          return refCount()(this);
      };
      return ConnectableObservable;
  }(Observable));
  var connectableObservableDescriptor = /*@__PURE__*/ (function () {
      var connectableProto = ConnectableObservable.prototype;
      return {
          operator: { value: null },
          _refCount: { value: 0, writable: true },
          _subject: { value: null, writable: true },
          _connection: { value: null, writable: true },
          _subscribe: { value: connectableProto._subscribe },
          _isComplete: { value: connectableProto._isComplete, writable: true },
          getSubject: { value: connectableProto.getSubject },
          connect: { value: connectableProto.connect },
          refCount: { value: connectableProto.refCount }
      };
  })();
  var ConnectableSubscriber = /*@__PURE__*/ (function (_super) {
      __extends(ConnectableSubscriber, _super);
      function ConnectableSubscriber(destination, connectable) {
          var _this = _super.call(this, destination) || this;
          _this.connectable = connectable;
          return _this;
      }
      ConnectableSubscriber.prototype._error = function (err) {
          this._unsubscribe();
          _super.prototype._error.call(this, err);
      };
      ConnectableSubscriber.prototype._complete = function () {
          this.connectable._isComplete = true;
          this._unsubscribe();
          _super.prototype._complete.call(this);
      };
      ConnectableSubscriber.prototype._unsubscribe = function () {
          var connectable = this.connectable;
          if (connectable) {
              this.connectable = null;
              var connection = connectable._connection;
              connectable._refCount = 0;
              connectable._subject = null;
              connectable._connection = null;
              if (connection) {
                  connection.unsubscribe();
              }
          }
      };
      return ConnectableSubscriber;
  }(SubjectSubscriber));

  /** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */
  var Action = /*@__PURE__*/ (function (_super) {
      __extends(Action, _super);
      function Action(scheduler, work) {
          return _super.call(this) || this;
      }
      Action.prototype.schedule = function (state, delay) {
          return this;
      };
      return Action;
  }(Subscription));

  /** PURE_IMPORTS_START tslib,_Action PURE_IMPORTS_END */
  var AsyncAction = /*@__PURE__*/ (function (_super) {
      __extends(AsyncAction, _super);
      function AsyncAction(scheduler, work) {
          var _this = _super.call(this, scheduler, work) || this;
          _this.scheduler = scheduler;
          _this.work = work;
          _this.pending = false;
          return _this;
      }
      AsyncAction.prototype.schedule = function (state, delay) {
          if (delay === void 0) {
              delay = 0;
          }
          if (this.closed) {
              return this;
          }
          this.state = state;
          var id = this.id;
          var scheduler = this.scheduler;
          if (id != null) {
              this.id = this.recycleAsyncId(scheduler, id, delay);
          }
          this.pending = true;
          this.delay = delay;
          this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
          return this;
      };
      AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
          if (delay === void 0) {
              delay = 0;
          }
          return setInterval(scheduler.flush.bind(scheduler, this), delay);
      };
      AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
          if (delay === void 0) {
              delay = 0;
          }
          if (delay !== null && this.delay === delay && this.pending === false) {
              return id;
          }
          clearInterval(id);
          return undefined;
      };
      AsyncAction.prototype.execute = function (state, delay) {
          if (this.closed) {
              return new Error('executing a cancelled action');
          }
          this.pending = false;
          var error = this._execute(state, delay);
          if (error) {
              return error;
          }
          else if (this.pending === false && this.id != null) {
              this.id = this.recycleAsyncId(this.scheduler, this.id, null);
          }
      };
      AsyncAction.prototype._execute = function (state, delay) {
          var errored = false;
          var errorValue = undefined;
          try {
              this.work(state);
          }
          catch (e) {
              errored = true;
              errorValue = !!e && e || new Error(e);
          }
          if (errored) {
              this.unsubscribe();
              return errorValue;
          }
      };
      AsyncAction.prototype._unsubscribe = function () {
          var id = this.id;
          var scheduler = this.scheduler;
          var actions = scheduler.actions;
          var index = actions.indexOf(this);
          this.work = null;
          this.state = null;
          this.pending = false;
          this.scheduler = null;
          if (index !== -1) {
              actions.splice(index, 1);
          }
          if (id != null) {
              this.id = this.recycleAsyncId(scheduler, id, null);
          }
          this.delay = null;
      };
      return AsyncAction;
  }(Action));

  /** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */
  var QueueAction = /*@__PURE__*/ (function (_super) {
      __extends(QueueAction, _super);
      function QueueAction(scheduler, work) {
          var _this = _super.call(this, scheduler, work) || this;
          _this.scheduler = scheduler;
          _this.work = work;
          return _this;
      }
      QueueAction.prototype.schedule = function (state, delay) {
          if (delay === void 0) {
              delay = 0;
          }
          if (delay > 0) {
              return _super.prototype.schedule.call(this, state, delay);
          }
          this.delay = delay;
          this.state = state;
          this.scheduler.flush(this);
          return this;
      };
      QueueAction.prototype.execute = function (state, delay) {
          return (delay > 0 || this.closed) ?
              _super.prototype.execute.call(this, state, delay) :
              this._execute(state, delay);
      };
      QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
          if (delay === void 0) {
              delay = 0;
          }
          if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
              return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
          }
          return scheduler.flush(this);
      };
      return QueueAction;
  }(AsyncAction));

  var Scheduler = /*@__PURE__*/ (function () {
      function Scheduler(SchedulerAction, now) {
          if (now === void 0) {
              now = Scheduler.now;
          }
          this.SchedulerAction = SchedulerAction;
          this.now = now;
      }
      Scheduler.prototype.schedule = function (work, delay, state) {
          if (delay === void 0) {
              delay = 0;
          }
          return new this.SchedulerAction(this, work).schedule(state, delay);
      };
      Scheduler.now = function () { return Date.now(); };
      return Scheduler;
  }());

  /** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */
  var AsyncScheduler = /*@__PURE__*/ (function (_super) {
      __extends(AsyncScheduler, _super);
      function AsyncScheduler(SchedulerAction, now) {
          if (now === void 0) {
              now = Scheduler.now;
          }
          var _this = _super.call(this, SchedulerAction, function () {
              if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {
                  return AsyncScheduler.delegate.now();
              }
              else {
                  return now();
              }
          }) || this;
          _this.actions = [];
          _this.active = false;
          _this.scheduled = undefined;
          return _this;
      }
      AsyncScheduler.prototype.schedule = function (work, delay, state) {
          if (delay === void 0) {
              delay = 0;
          }
          if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
              return AsyncScheduler.delegate.schedule(work, delay, state);
          }
          else {
              return _super.prototype.schedule.call(this, work, delay, state);
          }
      };
      AsyncScheduler.prototype.flush = function (action) {
          var actions = this.actions;
          if (this.active) {
              actions.push(action);
              return;
          }
          var error;
          this.active = true;
          do {
              if (error = action.execute(action.state, action.delay)) {
                  break;
              }
          } while (action = actions.shift());
          this.active = false;
          if (error) {
              while (action = actions.shift()) {
                  action.unsubscribe();
              }
              throw error;
          }
      };
      return AsyncScheduler;
  }(Scheduler));

  /** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */
  var QueueScheduler = /*@__PURE__*/ (function (_super) {
      __extends(QueueScheduler, _super);
      function QueueScheduler() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      return QueueScheduler;
  }(AsyncScheduler));

  /** PURE_IMPORTS_START _QueueAction,_QueueScheduler PURE_IMPORTS_END */
  var queueScheduler = /*@__PURE__*/ new QueueScheduler(QueueAction);
  var queue = queueScheduler;

  /** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
  var EMPTY = /*@__PURE__*/ new Observable(function (subscriber) { return subscriber.complete(); });
  function empty(scheduler) {
      return scheduler ? emptyScheduled(scheduler) : EMPTY;
  }
  function emptyScheduled(scheduler) {
      return new Observable(function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });
  }

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  function isScheduler(value) {
      return value && typeof value.schedule === 'function';
  }

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  var subscribeToArray = function (array) {
      return function (subscriber) {
          for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {
              subscriber.next(array[i]);
          }
          subscriber.complete();
      };
  };

  /** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */
  function scheduleArray(input, scheduler) {
      return new Observable(function (subscriber) {
          var sub = new Subscription();
          var i = 0;
          sub.add(scheduler.schedule(function () {
              if (i === input.length) {
                  subscriber.complete();
                  return;
              }
              subscriber.next(input[i++]);
              if (!subscriber.closed) {
                  sub.add(this.schedule());
              }
          }));
          return sub;
      });
  }

  /** PURE_IMPORTS_START _Observable,_util_subscribeToArray,_scheduled_scheduleArray PURE_IMPORTS_END */
  function fromArray(input, scheduler) {
      if (!scheduler) {
          return new Observable(subscribeToArray(input));
      }
      else {
          return scheduleArray(input, scheduler);
      }
  }

  /** PURE_IMPORTS_START _util_isScheduler,_fromArray,_scheduled_scheduleArray PURE_IMPORTS_END */
  function of() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
      }
      var scheduler = args[args.length - 1];
      if (isScheduler(scheduler)) {
          args.pop();
          return scheduleArray(args, scheduler);
      }
      else {
          return fromArray(args);
      }
  }

  /** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
  function throwError(error, scheduler) {
      if (!scheduler) {
          return new Observable(function (subscriber) { return subscriber.error(error); });
      }
      else {
          return new Observable(function (subscriber) { return scheduler.schedule(dispatch$1, 0, { error: error, subscriber: subscriber }); });
      }
  }
  function dispatch$1(_a) {
      var error = _a.error, subscriber = _a.subscriber;
      subscriber.error(error);
  }

  /** PURE_IMPORTS_START _observable_empty,_observable_of,_observable_throwError PURE_IMPORTS_END */
  var Notification = /*@__PURE__*/ (function () {
      function Notification(kind, value, error) {
          this.kind = kind;
          this.value = value;
          this.error = error;
          this.hasValue = kind === 'N';
      }
      Notification.prototype.observe = function (observer) {
          switch (this.kind) {
              case 'N':
                  return observer.next && observer.next(this.value);
              case 'E':
                  return observer.error && observer.error(this.error);
              case 'C':
                  return observer.complete && observer.complete();
          }
      };
      Notification.prototype.do = function (next, error, complete) {
          var kind = this.kind;
          switch (kind) {
              case 'N':
                  return next && next(this.value);
              case 'E':
                  return error && error(this.error);
              case 'C':
                  return complete && complete();
          }
      };
      Notification.prototype.accept = function (nextOrObserver, error, complete) {
          if (nextOrObserver && typeof nextOrObserver.next === 'function') {
              return this.observe(nextOrObserver);
          }
          else {
              return this.do(nextOrObserver, error, complete);
          }
      };
      Notification.prototype.toObservable = function () {
          var kind = this.kind;
          switch (kind) {
              case 'N':
                  return of(this.value);
              case 'E':
                  return throwError(this.error);
              case 'C':
                  return empty();
          }
          throw new Error('unexpected notification kind value');
      };
      Notification.createNext = function (value) {
          if (typeof value !== 'undefined') {
              return new Notification('N', value);
          }
          return Notification.undefinedValueNotification;
      };
      Notification.createError = function (err) {
          return new Notification('E', undefined, err);
      };
      Notification.createComplete = function () {
          return Notification.completeNotification;
      };
      Notification.completeNotification = new Notification('C');
      Notification.undefinedValueNotification = new Notification('N', undefined);
      return Notification;
  }());

  /** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */
  var ObserveOnSubscriber = /*@__PURE__*/ (function (_super) {
      __extends(ObserveOnSubscriber, _super);
      function ObserveOnSubscriber(destination, scheduler, delay) {
          if (delay === void 0) {
              delay = 0;
          }
          var _this = _super.call(this, destination) || this;
          _this.scheduler = scheduler;
          _this.delay = delay;
          return _this;
      }
      ObserveOnSubscriber.dispatch = function (arg) {
          var notification = arg.notification, destination = arg.destination;
          notification.observe(destination);
          this.unsubscribe();
      };
      ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
          var destination = this.destination;
          destination.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
      };
      ObserveOnSubscriber.prototype._next = function (value) {
          this.scheduleMessage(Notification.createNext(value));
      };
      ObserveOnSubscriber.prototype._error = function (err) {
          this.scheduleMessage(Notification.createError(err));
          this.unsubscribe();
      };
      ObserveOnSubscriber.prototype._complete = function () {
          this.scheduleMessage(Notification.createComplete());
          this.unsubscribe();
      };
      return ObserveOnSubscriber;
  }(Subscriber));
  var ObserveOnMessage = /*@__PURE__*/ (function () {
      function ObserveOnMessage(notification, destination) {
          this.notification = notification;
          this.destination = destination;
      }
      return ObserveOnMessage;
  }());

  /** PURE_IMPORTS_START tslib,_Subject,_scheduler_queue,_Subscription,_operators_observeOn,_util_ObjectUnsubscribedError,_SubjectSubscription PURE_IMPORTS_END */
  var ReplaySubject = /*@__PURE__*/ (function (_super) {
      __extends(ReplaySubject, _super);
      function ReplaySubject(bufferSize, windowTime, scheduler) {
          if (bufferSize === void 0) {
              bufferSize = Number.POSITIVE_INFINITY;
          }
          if (windowTime === void 0) {
              windowTime = Number.POSITIVE_INFINITY;
          }
          var _this = _super.call(this) || this;
          _this.scheduler = scheduler;
          _this._events = [];
          _this._infiniteTimeWindow = false;
          _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
          _this._windowTime = windowTime < 1 ? 1 : windowTime;
          if (windowTime === Number.POSITIVE_INFINITY) {
              _this._infiniteTimeWindow = true;
              _this.next = _this.nextInfiniteTimeWindow;
          }
          else {
              _this.next = _this.nextTimeWindow;
          }
          return _this;
      }
      ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) {
          if (!this.isStopped) {
              var _events = this._events;
              _events.push(value);
              if (_events.length > this._bufferSize) {
                  _events.shift();
              }
          }
          _super.prototype.next.call(this, value);
      };
      ReplaySubject.prototype.nextTimeWindow = function (value) {
          if (!this.isStopped) {
              this._events.push(new ReplayEvent(this._getNow(), value));
              this._trimBufferThenGetEvents();
          }
          _super.prototype.next.call(this, value);
      };
      ReplaySubject.prototype._subscribe = function (subscriber) {
          var _infiniteTimeWindow = this._infiniteTimeWindow;
          var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
          var scheduler = this.scheduler;
          var len = _events.length;
          var subscription;
          if (this.closed) {
              throw new ObjectUnsubscribedError();
          }
          else if (this.isStopped || this.hasError) {
              subscription = Subscription.EMPTY;
          }
          else {
              this.observers.push(subscriber);
              subscription = new SubjectSubscription(this, subscriber);
          }
          if (scheduler) {
              subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));
          }
          if (_infiniteTimeWindow) {
              for (var i = 0; i < len && !subscriber.closed; i++) {
                  subscriber.next(_events[i]);
              }
          }
          else {
              for (var i = 0; i < len && !subscriber.closed; i++) {
                  subscriber.next(_events[i].value);
              }
          }
          if (this.hasError) {
              subscriber.error(this.thrownError);
          }
          else if (this.isStopped) {
              subscriber.complete();
          }
          return subscription;
      };
      ReplaySubject.prototype._getNow = function () {
          return (this.scheduler || queue).now();
      };
      ReplaySubject.prototype._trimBufferThenGetEvents = function () {
          var now = this._getNow();
          var _bufferSize = this._bufferSize;
          var _windowTime = this._windowTime;
          var _events = this._events;
          var eventsCount = _events.length;
          var spliceCount = 0;
          while (spliceCount < eventsCount) {
              if ((now - _events[spliceCount].time) < _windowTime) {
                  break;
              }
              spliceCount++;
          }
          if (eventsCount > _bufferSize) {
              spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
          }
          if (spliceCount > 0) {
              _events.splice(0, spliceCount);
          }
          return _events;
      };
      return ReplaySubject;
  }(Subject));
  var ReplayEvent = /*@__PURE__*/ (function () {
      function ReplayEvent(time, value) {
          this.time = time;
          this.value = value;
      }
      return ReplayEvent;
  }());

  /** PURE_IMPORTS_START _AsyncAction,_AsyncScheduler PURE_IMPORTS_END */
  var asyncScheduler = /*@__PURE__*/ new AsyncScheduler(AsyncAction);
  var async = asyncScheduler;

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  function noop() { }

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  var ArgumentOutOfRangeErrorImpl = /*@__PURE__*/ (function () {
      function ArgumentOutOfRangeErrorImpl() {
          Error.call(this);
          this.message = 'argument out of range';
          this.name = 'ArgumentOutOfRangeError';
          return this;
      }
      ArgumentOutOfRangeErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
      return ArgumentOutOfRangeErrorImpl;
  })();
  var ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  var EmptyErrorImpl = /*@__PURE__*/ (function () {
      function EmptyErrorImpl() {
          Error.call(this);
          this.message = 'no elements in sequence';
          this.name = 'EmptyError';
          return this;
      }
      EmptyErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
      return EmptyErrorImpl;
  })();
  var EmptyError = EmptyErrorImpl;

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  var TimeoutErrorImpl = /*@__PURE__*/ (function () {
      function TimeoutErrorImpl() {
          Error.call(this);
          this.message = 'Timeout has occurred';
          this.name = 'TimeoutError';
          return this;
      }
      TimeoutErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
      return TimeoutErrorImpl;
  })();
  var TimeoutError = TimeoutErrorImpl;

  /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
  function map(project, thisArg) {
      return function mapOperation(source) {
          if (typeof project !== 'function') {
              throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
          }
          return source.lift(new MapOperator(project, thisArg));
      };
  }
  var MapOperator = /*@__PURE__*/ (function () {
      function MapOperator(project, thisArg) {
          this.project = project;
          this.thisArg = thisArg;
      }
      MapOperator.prototype.call = function (subscriber, source) {
          return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
      };
      return MapOperator;
  }());
  var MapSubscriber = /*@__PURE__*/ (function (_super) {
      __extends(MapSubscriber, _super);
      function MapSubscriber(destination, project, thisArg) {
          var _this = _super.call(this, destination) || this;
          _this.project = project;
          _this.count = 0;
          _this.thisArg = thisArg || _this;
          return _this;
      }
      MapSubscriber.prototype._next = function (value) {
          var result;
          try {
              result = this.project.call(this.thisArg, value, this.count++);
          }
          catch (err) {
              this.destination.error(err);
              return;
          }
          this.destination.next(result);
      };
      return MapSubscriber;
  }(Subscriber));

  /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
  var OuterSubscriber = /*@__PURE__*/ (function (_super) {
      __extends(OuterSubscriber, _super);
      function OuterSubscriber() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
          this.destination.next(innerValue);
      };
      OuterSubscriber.prototype.notifyError = function (error, innerSub) {
          this.destination.error(error);
      };
      OuterSubscriber.prototype.notifyComplete = function (innerSub) {
          this.destination.complete();
      };
      return OuterSubscriber;
  }(Subscriber));

  /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
  var InnerSubscriber = /*@__PURE__*/ (function (_super) {
      __extends(InnerSubscriber, _super);
      function InnerSubscriber(parent, outerValue, outerIndex) {
          var _this = _super.call(this) || this;
          _this.parent = parent;
          _this.outerValue = outerValue;
          _this.outerIndex = outerIndex;
          _this.index = 0;
          return _this;
      }
      InnerSubscriber.prototype._next = function (value) {
          this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
      };
      InnerSubscriber.prototype._error = function (error) {
          this.parent.notifyError(error, this);
          this.unsubscribe();
      };
      InnerSubscriber.prototype._complete = function () {
          this.parent.notifyComplete(this);
          this.unsubscribe();
      };
      return InnerSubscriber;
  }(Subscriber));

  /** PURE_IMPORTS_START _hostReportError PURE_IMPORTS_END */
  var subscribeToPromise = function (promise) {
      return function (subscriber) {
          promise.then(function (value) {
              if (!subscriber.closed) {
                  subscriber.next(value);
                  subscriber.complete();
              }
          }, function (err) { return subscriber.error(err); })
              .then(null, hostReportError);
          return subscriber;
      };
  };

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  function getSymbolIterator() {
      if (typeof Symbol !== 'function' || !Symbol.iterator) {
          return '@@iterator';
      }
      return Symbol.iterator;
  }
  var iterator = /*@__PURE__*/ getSymbolIterator();

  /** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */
  var subscribeToIterable = function (iterable) {
      return function (subscriber) {
          var iterator$1 = iterable[iterator]();
          do {
              var item = void 0;
              try {
                  item = iterator$1.next();
              }
              catch (err) {
                  subscriber.error(err);
                  return subscriber;
              }
              if (item.done) {
                  subscriber.complete();
                  break;
              }
              subscriber.next(item.value);
              if (subscriber.closed) {
                  break;
              }
          } while (true);
          if (typeof iterator$1.return === 'function') {
              subscriber.add(function () {
                  if (iterator$1.return) {
                      iterator$1.return();
                  }
              });
          }
          return subscriber;
      };
  };

  /** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */
  var subscribeToObservable = function (obj) {
      return function (subscriber) {
          var obs = obj[observable]();
          if (typeof obs.subscribe !== 'function') {
              throw new TypeError('Provided object does not correctly implement Symbol.observable');
          }
          else {
              return obs.subscribe(subscriber);
          }
      };
  };

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  var isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  function isPromise(value) {
      return !!value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
  }

  /** PURE_IMPORTS_START _subscribeToArray,_subscribeToPromise,_subscribeToIterable,_subscribeToObservable,_isArrayLike,_isPromise,_isObject,_symbol_iterator,_symbol_observable PURE_IMPORTS_END */
  var subscribeTo = function (result) {
      if (!!result && typeof result[observable] === 'function') {
          return subscribeToObservable(result);
      }
      else if (isArrayLike(result)) {
          return subscribeToArray(result);
      }
      else if (isPromise(result)) {
          return subscribeToPromise(result);
      }
      else if (!!result && typeof result[iterator] === 'function') {
          return subscribeToIterable(result);
      }
      else {
          var value = isObject$1(result) ? 'an invalid object' : "'" + result + "'";
          var msg = "You provided " + value + " where a stream was expected."
              + ' You can provide an Observable, Promise, Array, or Iterable.';
          throw new TypeError(msg);
      }
  };

  /** PURE_IMPORTS_START _InnerSubscriber,_subscribeTo,_Observable PURE_IMPORTS_END */
  function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, innerSubscriber) {
      if (innerSubscriber === void 0) {
          innerSubscriber = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);
      }
      if (innerSubscriber.closed) {
          return undefined;
      }
      if (result instanceof Observable) {
          return result.subscribe(innerSubscriber);
      }
      return subscribeTo(result)(innerSubscriber);
  }

  /** PURE_IMPORTS_START _Observable,_Subscription,_symbol_observable PURE_IMPORTS_END */
  function scheduleObservable(input, scheduler) {
      return new Observable(function (subscriber) {
          var sub = new Subscription();
          sub.add(scheduler.schedule(function () {
              var observable$1 = input[observable]();
              sub.add(observable$1.subscribe({
                  next: function (value) { sub.add(scheduler.schedule(function () { return subscriber.next(value); })); },
                  error: function (err) { sub.add(scheduler.schedule(function () { return subscriber.error(err); })); },
                  complete: function () { sub.add(scheduler.schedule(function () { return subscriber.complete(); })); },
              }));
          }));
          return sub;
      });
  }

  /** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */
  function schedulePromise(input, scheduler) {
      return new Observable(function (subscriber) {
          var sub = new Subscription();
          sub.add(scheduler.schedule(function () {
              return input.then(function (value) {
                  sub.add(scheduler.schedule(function () {
                      subscriber.next(value);
                      sub.add(scheduler.schedule(function () { return subscriber.complete(); }));
                  }));
              }, function (err) {
                  sub.add(scheduler.schedule(function () { return subscriber.error(err); }));
              });
          }));
          return sub;
      });
  }

  /** PURE_IMPORTS_START _Observable,_Subscription,_symbol_iterator PURE_IMPORTS_END */
  function scheduleIterable(input, scheduler) {
      if (!input) {
          throw new Error('Iterable cannot be null');
      }
      return new Observable(function (subscriber) {
          var sub = new Subscription();
          var iterator$1;
          sub.add(function () {
              if (iterator$1 && typeof iterator$1.return === 'function') {
                  iterator$1.return();
              }
          });
          sub.add(scheduler.schedule(function () {
              iterator$1 = input[iterator]();
              sub.add(scheduler.schedule(function () {
                  if (subscriber.closed) {
                      return;
                  }
                  var value;
                  var done;
                  try {
                      var result = iterator$1.next();
                      value = result.value;
                      done = result.done;
                  }
                  catch (err) {
                      subscriber.error(err);
                      return;
                  }
                  if (done) {
                      subscriber.complete();
                  }
                  else {
                      subscriber.next(value);
                      this.schedule();
                  }
              }));
          }));
          return sub;
      });
  }

  /** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */
  function isInteropObservable(input) {
      return input && typeof input[observable] === 'function';
  }

  /** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */
  function isIterable(input) {
      return input && typeof input[iterator] === 'function';
  }

  /** PURE_IMPORTS_START _scheduleObservable,_schedulePromise,_scheduleArray,_scheduleIterable,_util_isInteropObservable,_util_isPromise,_util_isArrayLike,_util_isIterable PURE_IMPORTS_END */
  function scheduled(input, scheduler) {
      if (input != null) {
          if (isInteropObservable(input)) {
              return scheduleObservable(input, scheduler);
          }
          else if (isPromise(input)) {
              return schedulePromise(input, scheduler);
          }
          else if (isArrayLike(input)) {
              return scheduleArray(input, scheduler);
          }
          else if (isIterable(input) || typeof input === 'string') {
              return scheduleIterable(input, scheduler);
          }
      }
      throw new TypeError((input !== null && typeof input || input) + ' is not observable');
  }

  /** PURE_IMPORTS_START _Observable,_util_subscribeTo,_scheduled_scheduled PURE_IMPORTS_END */
  function from$1(input, scheduler) {
      if (!scheduler) {
          if (input instanceof Observable) {
              return input;
          }
          return new Observable(subscribeTo(input));
      }
      else {
          return scheduled(input, scheduler);
      }
  }

  /** PURE_IMPORTS_START tslib,_Subscriber,_Observable,_util_subscribeTo PURE_IMPORTS_END */
  var SimpleInnerSubscriber = /*@__PURE__*/ (function (_super) {
      __extends(SimpleInnerSubscriber, _super);
      function SimpleInnerSubscriber(parent) {
          var _this = _super.call(this) || this;
          _this.parent = parent;
          return _this;
      }
      SimpleInnerSubscriber.prototype._next = function (value) {
          this.parent.notifyNext(value);
      };
      SimpleInnerSubscriber.prototype._error = function (error) {
          this.parent.notifyError(error);
          this.unsubscribe();
      };
      SimpleInnerSubscriber.prototype._complete = function () {
          this.parent.notifyComplete();
          this.unsubscribe();
      };
      return SimpleInnerSubscriber;
  }(Subscriber));
  var SimpleOuterSubscriber = /*@__PURE__*/ (function (_super) {
      __extends(SimpleOuterSubscriber, _super);
      function SimpleOuterSubscriber() {
          return _super !== null && _super.apply(this, arguments) || this;
      }
      SimpleOuterSubscriber.prototype.notifyNext = function (innerValue) {
          this.destination.next(innerValue);
      };
      SimpleOuterSubscriber.prototype.notifyError = function (err) {
          this.destination.error(err);
      };
      SimpleOuterSubscriber.prototype.notifyComplete = function () {
          this.destination.complete();
      };
      return SimpleOuterSubscriber;
  }(Subscriber));
  function innerSubscribe(result, innerSubscriber) {
      if (innerSubscriber.closed) {
          return undefined;
      }
      if (result instanceof Observable) {
          return result.subscribe(innerSubscriber);
      }
      var subscription;
      try {
          subscription = subscribeTo(result)(innerSubscriber);
      }
      catch (error) {
          innerSubscriber.error(error);
      }
      return subscription;
  }

  /** PURE_IMPORTS_START tslib,_map,_observable_from,_innerSubscribe PURE_IMPORTS_END */
  function mergeMap(project, resultSelector, concurrent) {
      if (concurrent === void 0) {
          concurrent = Number.POSITIVE_INFINITY;
      }
      if (typeof resultSelector === 'function') {
          return function (source) { return source.pipe(mergeMap(function (a, i) { return from$1(project(a, i)).pipe(map(function (b, ii) { return resultSelector(a, b, i, ii); })); }, concurrent)); };
      }
      else if (typeof resultSelector === 'number') {
          concurrent = resultSelector;
      }
      return function (source) { return source.lift(new MergeMapOperator(project, concurrent)); };
  }
  var MergeMapOperator = /*@__PURE__*/ (function () {
      function MergeMapOperator(project, concurrent) {
          if (concurrent === void 0) {
              concurrent = Number.POSITIVE_INFINITY;
          }
          this.project = project;
          this.concurrent = concurrent;
      }
      MergeMapOperator.prototype.call = function (observer, source) {
          return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
      };
      return MergeMapOperator;
  }());
  var MergeMapSubscriber = /*@__PURE__*/ (function (_super) {
      __extends(MergeMapSubscriber, _super);
      function MergeMapSubscriber(destination, project, concurrent) {
          if (concurrent === void 0) {
              concurrent = Number.POSITIVE_INFINITY;
          }
          var _this = _super.call(this, destination) || this;
          _this.project = project;
          _this.concurrent = concurrent;
          _this.hasCompleted = false;
          _this.buffer = [];
          _this.active = 0;
          _this.index = 0;
          return _this;
      }
      MergeMapSubscriber.prototype._next = function (value) {
          if (this.active < this.concurrent) {
              this._tryNext(value);
          }
          else {
              this.buffer.push(value);
          }
      };
      MergeMapSubscriber.prototype._tryNext = function (value) {
          var result;
          var index = this.index++;
          try {
              result = this.project(value, index);
          }
          catch (err) {
              this.destination.error(err);
              return;
          }
          this.active++;
          this._innerSub(result);
      };
      MergeMapSubscriber.prototype._innerSub = function (ish) {
          var innerSubscriber = new SimpleInnerSubscriber(this);
          var destination = this.destination;
          destination.add(innerSubscriber);
          var innerSubscription = innerSubscribe(ish, innerSubscriber);
          if (innerSubscription !== innerSubscriber) {
              destination.add(innerSubscription);
          }
      };
      MergeMapSubscriber.prototype._complete = function () {
          this.hasCompleted = true;
          if (this.active === 0 && this.buffer.length === 0) {
              this.destination.complete();
          }
          this.unsubscribe();
      };
      MergeMapSubscriber.prototype.notifyNext = function (innerValue) {
          this.destination.next(innerValue);
      };
      MergeMapSubscriber.prototype.notifyComplete = function () {
          var buffer = this.buffer;
          this.active--;
          if (buffer.length > 0) {
              this._next(buffer.shift());
          }
          else if (this.active === 0 && this.hasCompleted) {
              this.destination.complete();
          }
      };
      return MergeMapSubscriber;
  }(SimpleOuterSubscriber));

  /** PURE_IMPORTS_START _mergeMap,_util_identity PURE_IMPORTS_END */
  function mergeAll(concurrent) {
      if (concurrent === void 0) {
          concurrent = Number.POSITIVE_INFINITY;
      }
      return mergeMap(identity$1, concurrent);
  }

  /** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */
  function fromEventPattern(addHandler, removeHandler, resultSelector) {
      if (resultSelector) {
          return fromEventPattern(addHandler, removeHandler).pipe(map(function (args) { return isArray$1(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
      }
      return new Observable(function (subscriber) {
          var handler = function () {
              var e = [];
              for (var _i = 0; _i < arguments.length; _i++) {
                  e[_i] = arguments[_i];
              }
              return subscriber.next(e.length === 1 ? e[0] : e);
          };
          var retValue;
          try {
              retValue = addHandler(handler);
          }
          catch (err) {
              subscriber.error(err);
              return undefined;
          }
          if (!isFunction(removeHandler)) {
              return undefined;
          }
          return function () { return removeHandler(handler, retValue); };
      });
  }

  /** PURE_IMPORTS_START _isArray PURE_IMPORTS_END */
  function isNumeric(val) {
      return !isArray$1(val) && (val - parseFloat(val) + 1) >= 0;
  }

  /** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric PURE_IMPORTS_END */
  function interval(period, scheduler) {
      if (period === void 0) {
          period = 0;
      }
      if (scheduler === void 0) {
          scheduler = async;
      }
      if (!isNumeric(period) || period < 0) {
          period = 0;
      }
      if (!scheduler || typeof scheduler.schedule !== 'function') {
          scheduler = async;
      }
      return new Observable(function (subscriber) {
          subscriber.add(scheduler.schedule(dispatch, period, { subscriber: subscriber, counter: 0, period: period }));
          return subscriber;
      });
  }
  function dispatch(state) {
      var subscriber = state.subscriber, counter = state.counter, period = state.period;
      subscriber.next(counter);
      this.schedule({ subscriber: subscriber, counter: counter + 1, period: period }, period);
  }

  /** PURE_IMPORTS_START _Observable,_util_isScheduler,_operators_mergeAll,_fromArray PURE_IMPORTS_END */
  function merge() {
      var observables = [];
      for (var _i = 0; _i < arguments.length; _i++) {
          observables[_i] = arguments[_i];
      }
      var concurrent = Number.POSITIVE_INFINITY;
      var scheduler = null;
      var last = observables[observables.length - 1];
      if (isScheduler(last)) {
          scheduler = observables.pop();
          if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
              concurrent = observables.pop();
          }
      }
      else if (typeof last === 'number') {
          concurrent = observables.pop();
      }
      if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable) {
          return observables[0];
      }
      return mergeAll(concurrent)(fromArray(observables, scheduler));
  }

  /** PURE_IMPORTS_START _Observable,_util_noop PURE_IMPORTS_END */
  var NEVER = /*@__PURE__*/ new Observable(noop);

  /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
  function filter(predicate, thisArg) {
      return function filterOperatorFunction(source) {
          return source.lift(new FilterOperator(predicate, thisArg));
      };
  }
  var FilterOperator = /*@__PURE__*/ (function () {
      function FilterOperator(predicate, thisArg) {
          this.predicate = predicate;
          this.thisArg = thisArg;
      }
      FilterOperator.prototype.call = function (subscriber, source) {
          return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
      };
      return FilterOperator;
  }());
  var FilterSubscriber = /*@__PURE__*/ (function (_super) {
      __extends(FilterSubscriber, _super);
      function FilterSubscriber(destination, predicate, thisArg) {
          var _this = _super.call(this, destination) || this;
          _this.predicate = predicate;
          _this.thisArg = thisArg;
          _this.count = 0;
          return _this;
      }
      FilterSubscriber.prototype._next = function (value) {
          var result;
          try {
              result = this.predicate.call(this.thisArg, value, this.count++);
          }
          catch (err) {
              this.destination.error(err);
              return;
          }
          if (result) {
              this.destination.next(value);
          }
      };
      return FilterSubscriber;
  }(Subscriber));

  /** PURE_IMPORTS_START tslib,_util_isArray,_fromArray,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
  function race() {
      var observables = [];
      for (var _i = 0; _i < arguments.length; _i++) {
          observables[_i] = arguments[_i];
      }
      if (observables.length === 1) {
          if (isArray$1(observables[0])) {
              observables = observables[0];
          }
          else {
              return observables[0];
          }
      }
      return fromArray(observables, undefined).lift(new RaceOperator());
  }
  var RaceOperator = /*@__PURE__*/ (function () {
      function RaceOperator() {
      }
      RaceOperator.prototype.call = function (subscriber, source) {
          return source.subscribe(new RaceSubscriber(subscriber));
      };
      return RaceOperator;
  }());
  var RaceSubscriber = /*@__PURE__*/ (function (_super) {
      __extends(RaceSubscriber, _super);
      function RaceSubscriber(destination) {
          var _this = _super.call(this, destination) || this;
          _this.hasFirst = false;
          _this.observables = [];
          _this.subscriptions = [];
          return _this;
      }
      RaceSubscriber.prototype._next = function (observable) {
          this.observables.push(observable);
      };
      RaceSubscriber.prototype._complete = function () {
          var observables = this.observables;
          var len = observables.length;
          if (len === 0) {
              this.destination.complete();
          }
          else {
              for (var i = 0; i < len && !this.hasFirst; i++) {
                  var observable = observables[i];
                  var subscription = subscribeToResult(this, observable, undefined, i);
                  if (this.subscriptions) {
                      this.subscriptions.push(subscription);
                  }
                  this.add(subscription);
              }
              this.observables = null;
          }
      };
      RaceSubscriber.prototype.notifyNext = function (_outerValue, innerValue, outerIndex) {
          if (!this.hasFirst) {
              this.hasFirst = true;
              for (var i = 0; i < this.subscriptions.length; i++) {
                  if (i !== outerIndex) {
                      var subscription = this.subscriptions[i];
                      subscription.unsubscribe();
                      this.remove(subscription);
                  }
              }
              this.subscriptions = null;
          }
          this.destination.next(innerValue);
      };
      return RaceSubscriber;
  }(OuterSubscriber));

  /** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */
  function catchError(selector) {
      return function catchErrorOperatorFunction(source) {
          var operator = new CatchOperator(selector);
          var caught = source.lift(operator);
          return (operator.caught = caught);
      };
  }
  var CatchOperator = /*@__PURE__*/ (function () {
      function CatchOperator(selector) {
          this.selector = selector;
      }
      CatchOperator.prototype.call = function (subscriber, source) {
          return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
      };
      return CatchOperator;
  }());
  var CatchSubscriber = /*@__PURE__*/ (function (_super) {
      __extends(CatchSubscriber, _super);
      function CatchSubscriber(destination, selector, caught) {
          var _this = _super.call(this, destination) || this;
          _this.selector = selector;
          _this.caught = caught;
          return _this;
      }
      CatchSubscriber.prototype.error = function (err) {
          if (!this.isStopped) {
              var result = void 0;
              try {
                  result = this.selector(err, this.caught);
              }
              catch (err2) {
                  _super.prototype.error.call(this, err2);
                  return;
              }
              this._unsubscribeAndRecycle();
              var innerSubscriber = new SimpleInnerSubscriber(this);
              this.add(innerSubscriber);
              var innerSubscription = innerSubscribe(result, innerSubscriber);
              if (innerSubscription !== innerSubscriber) {
                  this.add(innerSubscription);
              }
          }
      };
      return CatchSubscriber;
  }(SimpleOuterSubscriber));

  /** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */
  function debounceTime(dueTime, scheduler) {
      if (scheduler === void 0) {
          scheduler = async;
      }
      return function (source) { return source.lift(new DebounceTimeOperator(dueTime, scheduler)); };
  }
  var DebounceTimeOperator = /*@__PURE__*/ (function () {
      function DebounceTimeOperator(dueTime, scheduler) {
          this.dueTime = dueTime;
          this.scheduler = scheduler;
      }
      DebounceTimeOperator.prototype.call = function (subscriber, source) {
          return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
      };
      return DebounceTimeOperator;
  }());
  var DebounceTimeSubscriber = /*@__PURE__*/ (function (_super) {
      __extends(DebounceTimeSubscriber, _super);
      function DebounceTimeSubscriber(destination, dueTime, scheduler) {
          var _this = _super.call(this, destination) || this;
          _this.dueTime = dueTime;
          _this.scheduler = scheduler;
          _this.debouncedSubscription = null;
          _this.lastValue = null;
          _this.hasValue = false;
          return _this;
      }
      DebounceTimeSubscriber.prototype._next = function (value) {
          this.clearDebounce();
          this.lastValue = value;
          this.hasValue = true;
          this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));
      };
      DebounceTimeSubscriber.prototype._complete = function () {
          this.debouncedNext();
          this.destination.complete();
      };
      DebounceTimeSubscriber.prototype.debouncedNext = function () {
          this.clearDebounce();
          if (this.hasValue) {
              var lastValue = this.lastValue;
              this.lastValue = null;
              this.hasValue = false;
              this.destination.next(lastValue);
          }
      };
      DebounceTimeSubscriber.prototype.clearDebounce = function () {
          var debouncedSubscription = this.debouncedSubscription;
          if (debouncedSubscription !== null) {
              this.remove(debouncedSubscription);
              debouncedSubscription.unsubscribe();
              this.debouncedSubscription = null;
          }
      };
      return DebounceTimeSubscriber;
  }(Subscriber));
  function dispatchNext(subscriber) {
      subscriber.debouncedNext();
  }

  /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
  function defaultIfEmpty(defaultValue) {
      if (defaultValue === void 0) {
          defaultValue = null;
      }
      return function (source) { return source.lift(new DefaultIfEmptyOperator(defaultValue)); };
  }
  var DefaultIfEmptyOperator = /*@__PURE__*/ (function () {
      function DefaultIfEmptyOperator(defaultValue) {
          this.defaultValue = defaultValue;
      }
      DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {
          return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
      };
      return DefaultIfEmptyOperator;
  }());
  var DefaultIfEmptySubscriber = /*@__PURE__*/ (function (_super) {
      __extends(DefaultIfEmptySubscriber, _super);
      function DefaultIfEmptySubscriber(destination, defaultValue) {
          var _this = _super.call(this, destination) || this;
          _this.defaultValue = defaultValue;
          _this.isEmpty = true;
          return _this;
      }
      DefaultIfEmptySubscriber.prototype._next = function (value) {
          this.isEmpty = false;
          this.destination.next(value);
      };
      DefaultIfEmptySubscriber.prototype._complete = function () {
          if (this.isEmpty) {
              this.destination.next(this.defaultValue);
          }
          this.destination.complete();
      };
      return DefaultIfEmptySubscriber;
  }(Subscriber));

  /** PURE_IMPORTS_START  PURE_IMPORTS_END */
  function isDate(value) {
      return value instanceof Date && !isNaN(+value);
  }

  /** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_Subscriber,_Notification PURE_IMPORTS_END */
  function delay(delay, scheduler) {
      if (scheduler === void 0) {
          scheduler = async;
      }
      var absoluteDelay = isDate(delay);
      var delayFor = absoluteDelay ? (+delay - scheduler.now()) : Math.abs(delay);
      return function (source) { return source.lift(new DelayOperator(delayFor, scheduler)); };
  }
  var DelayOperator = /*@__PURE__*/ (function () {
      function DelayOperator(delay, scheduler) {
          this.delay = delay;
          this.scheduler = scheduler;
      }
      DelayOperator.prototype.call = function (subscriber, source) {
          return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
      };
      return DelayOperator;
  }());
  var DelaySubscriber = /*@__PURE__*/ (function (_super) {
      __extends(DelaySubscriber, _super);
      function DelaySubscriber(destination, delay, scheduler) {
          var _this = _super.call(this, destination) || this;
          _this.delay = delay;
          _this.scheduler = scheduler;
          _this.queue = [];
          _this.active = false;
          _this.errored = false;
          return _this;
      }
      DelaySubscriber.dispatch = function (state) {
          var source = state.source;
          var queue = source.queue;
          var scheduler = state.scheduler;
          var destination = state.destination;
          while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {
              queue.shift().notification.observe(destination);
          }
          if (queue.length > 0) {
              var delay_1 = Math.max(0, queue[0].time - scheduler.now());
              this.schedule(state, delay_1);
          }
          else {
              this.unsubscribe();
              source.active = false;
          }
      };
      DelaySubscriber.prototype._schedule = function (scheduler) {
          this.active = true;
          var destination = this.destination;
          destination.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
              source: this, destination: this.destination, scheduler: scheduler
          }));
      };
      DelaySubscriber.prototype.scheduleNotification = function (notification) {
          if (this.errored === true) {
              return;
          }
          var scheduler = this.scheduler;
          var message = new DelayMessage(scheduler.now() + this.delay, notification);
          this.queue.push(message);
          if (this.active === false) {
              this._schedule(scheduler);
          }
      };
      DelaySubscriber.prototype._next = function (value) {
          this.scheduleNotification(Notification.createNext(value));
      };
      DelaySubscriber.prototype._error = function (err) {
          this.errored = true;
          this.queue = [];
          this.destination.error(err);
          this.unsubscribe();
      };
      DelaySubscriber.prototype._complete = function () {
          this.scheduleNotification(Notification.createComplete());
          this.unsubscribe();
      };
      return DelaySubscriber;
  }(Subscriber));
  var DelayMessage = /*@__PURE__*/ (function () {
      function DelayMessage(time, notification) {
          this.time = time;
          this.notification = notification;
      }
      return DelayMessage;
  }());

  /** PURE_IMPORTS_START tslib,_Subscriber,_Observable,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
  function delayWhen(delayDurationSelector, subscriptionDelay) {
      if (subscriptionDelay) {
          return function (source) {
              return new SubscriptionDelayObservable(source, subscriptionDelay)
                  .lift(new DelayWhenOperator(delayDurationSelector));
          };
      }
      return function (source) { return source.lift(new DelayWhenOperator(delayDurationSelector)); };
  }
  var DelayWhenOperator = /*@__PURE__*/ (function () {
      function DelayWhenOperator(delayDurationSelector) {
          this.delayDurationSelector = delayDurationSelector;
      }
      DelayWhenOperator.prototype.call = function (subscriber, source) {
          return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));
      };
      return DelayWhenOperator;
  }());
  var DelayWhenSubscriber = /*@__PURE__*/ (function (_super) {
      __extends(DelayWhenSubscriber, _super);
      function DelayWhenSubscriber(destination, delayDurationSelector) {
          var _this = _super.call(this, destination) || this;
          _this.delayDurationSelector = delayDurationSelector;
          _this.completed = false;
          _this.delayNotifierSubscriptions = [];
          _this.index = 0;
          return _this;
      }
      DelayWhenSubscriber.prototype.notifyNext = function (outerValue, _innerValue, _outerIndex, _innerIndex, innerSub) {
          this.destination.next(outerValue);
          this.removeSubscription(innerSub);
          this.tryComplete();
      };
      DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {
          this._error(error);
      };
      DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {
          var value = this.removeSubscription(innerSub);
          if (value) {
              this.destination.next(value);
          }
          this.tryComplete();
      };
      DelayWhenSubscriber.prototype._next = function (value) {
          var index = this.index++;
          try {
              var delayNotifier = this.delayDurationSelector(value, index);
              if (delayNotifier) {
                  this.tryDelay(delayNotifier, value);
              }
          }
          catch (err) {
              this.destination.error(err);
          }
      };
      DelayWhenSubscriber.prototype._complete = function () {
          this.completed = true;
          this.tryComplete();
          this.unsubscribe();
      };
      DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {
          subscription.unsubscribe();
          var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
          if (subscriptionIdx !== -1) {
              this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
          }
          return subscription.outerValue;
      };
      DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {
          var notifierSubscription = subscribeToResult(this, delayNotifier, value);
          if (notifierSubscription && !notifierSubscription.closed) {
              var destination = this.destination;
              destination.add(notifierSubscription);
              this.delayNotifierSubscriptions.push(notifierSubscription);
          }
      };
      DelayWhenSubscriber.prototype.tryComplete = function () {
          if (this.completed && this.delayNotifierSubscriptions.length === 0) {
              this.destination.complete();
          }
      };
      return DelayWhenSubscriber;
  }(OuterSubscriber));
  var SubscriptionDelayObservable = /*@__PURE__*/ (function (_super) {
      __extends(SubscriptionDelayObservable, _super);
      function SubscriptionDelayObservable(source, subscriptionDelay) {
          var _this = _super.call(this) || this;
          _this.source = source;
          _this.subscriptionDelay = subscriptionDelay;
          return _this;
      }
      SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {
          this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
      };
      return SubscriptionDelayObservable;
  }(Observable));
  var SubscriptionDelaySubscriber = /*@__PURE__*/ (function (_super) {
      __extends(SubscriptionDelaySubscriber, _super);
      function SubscriptionDelaySubscriber(parent, source) {
          var _this = _super.call(this) || this;
          _this.parent = parent;
          _this.source = source;
          _this.sourceSubscribed = false;
          return _this;
      }
      SubscriptionDelaySubscriber.prototype._next = function (unused) {
          this.subscribeToSource();
      };
      SubscriptionDelaySubscriber.prototype._error = function (err) {
          this.unsubscribe();
          this.parent.error(err);
      };
      SubscriptionDelaySubscriber.prototype._complete = function () {
          this.unsubscribe();
          this.subscribeToSource();
      };
      SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {
          if (!this.sourceSubscribed) {
              this.sourceSubscribed = true;
              this.unsubscribe();
              this.source.subscribe(this.parent);
          }
      };
      return SubscriptionDelaySubscriber;
  }(Subscriber));

  /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
  function distinctUntilChanged(compare, keySelector) {
      return function (source) { return source.lift(new DistinctUntilChangedOperator(compare, keySelector)); };
  }
  var DistinctUntilChangedOperator = /*@__PURE__*/ (function () {
      function DistinctUntilChangedOperator(compare, keySelector) {
          this.compare = compare;
          this.keySelector = keySelector;
      }
      DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
          return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
      };
      return DistinctUntilChangedOperator;
  }());
  var DistinctUntilChangedSubscriber = /*@__PURE__*/ (function (_super) {
      __extends(DistinctUntilChangedSubscriber, _super);
      function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
          var _this = _super.call(this, destination) || this;
          _this.keySelector = keySelector;
          _this.hasKey = false;
          if (typeof compare === 'function') {
              _this.compare = compare;
          }
          return _this;
      }
      DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
          return x === y;
      };
      DistinctUntilChangedSubscriber.prototype._next = function (value) {
          var key;
          try {
              var keySelector = this.keySelector;
              key = keySelector ? keySelector(value) : value;
          }
          catch (err) {
              return this.destination.error(err);
          }
          var result = false;
          if (this.hasKey) {
              try {
                  var compare = this.compare;
                  result = compare(this.key, key);
              }
              catch (err) {
                  return this.destination.error(err);
              }
          }
          else {
              this.hasKey = true;
          }
          if (!result) {
              this.key = key;
              this.destination.next(value);
          }
      };
      return DistinctUntilChangedSubscriber;
  }(Subscriber));

  /** PURE_IMPORTS_START _distinctUntilChanged PURE_IMPORTS_END */
  function distinctUntilKeyChanged(key, compare) {
      return distinctUntilChanged(function (x, y) { return compare ? compare(x[key], y[key]) : x[key] === y[key]; });
  }

  /** PURE_IMPORTS_START tslib,_util_EmptyError,_Subscriber PURE_IMPORTS_END */
  function throwIfEmpty(errorFactory) {
      if (errorFactory === void 0) {
          errorFactory = defaultErrorFactory;
      }
      return function (source) {
          return source.lift(new ThrowIfEmptyOperator(errorFactory));
      };
  }
  var ThrowIfEmptyOperator = /*@__PURE__*/ (function () {
      function ThrowIfEmptyOperator(errorFactory) {
          this.errorFactory = errorFactory;
      }
      ThrowIfEmptyOperator.prototype.call = function (subscriber, source) {
          return source.subscribe(new ThrowIfEmptySubscriber(subscriber, this.errorFactory));
      };
      return ThrowIfEmptyOperator;
  }());
  var ThrowIfEmptySubscriber = /*@__PURE__*/ (function (_super) {
      __extends(ThrowIfEmptySubscriber, _super);
      function ThrowIfEmptySubscriber(destination, errorFactory) {
          var _this = _super.call(this, destination) || this;
          _this.errorFactory = errorFactory;
          _this.hasValue = false;
          return _this;
      }
      ThrowIfEmptySubscriber.prototype._next = function (value) {
          this.hasValue = true;
          this.destination.next(value);
      };
      ThrowIfEmptySubscriber.prototype._complete = function () {
          if (!this.hasValue) {
              var err = void 0;
              try {
                  err = this.errorFactory();
              }
              catch (e) {
                  err = e;
              }
              this.destination.error(err);
          }
          else {
              return this.destination.complete();
          }
      };
      return ThrowIfEmptySubscriber;
  }(Subscriber));
  function defaultErrorFactory() {
      return new EmptyError();
  }

  /** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */
  function take(count) {
      return function (source) {
          if (count === 0) {
              return empty();
          }
          else {
              return source.lift(new TakeOperator(count));
          }
      };
  }
  var TakeOperator = /*@__PURE__*/ (function () {
      function TakeOperator(total) {
          this.total = total;
          if (this.total < 0) {
              throw new ArgumentOutOfRangeError;
          }
      }
      TakeOperator.prototype.call = function (subscriber, source) {
          return source.subscribe(new TakeSubscriber(subscriber, this.total));
      };
      return TakeOperator;
  }());
  var TakeSubscriber = /*@__PURE__*/ (function (_super) {
      __extends(TakeSubscriber, _super);
      function TakeSubscriber(destination, total) {
          var _this = _super.call(this, destination) || this;
          _this.total = total;
          _this.count = 0;
          return _this;
      }
      TakeSubscriber.prototype._next = function (value) {
          var total = this.total;
          var count = ++this.count;
          if (count <= total) {
              this.destination.next(value);
              if (count === total) {
                  this.destination.complete();
                  this.unsubscribe();
              }
          }
      };
      return TakeSubscriber;
  }(Subscriber));

  /** PURE_IMPORTS_START _util_EmptyError,_filter,_take,_defaultIfEmpty,_throwIfEmpty,_util_identity PURE_IMPORTS_END */
  function first(predicate, defaultValue) {
      var hasDefaultValue = arguments.length >= 2;
      return function (source) { return source.pipe(predicate ? filter(function (v, i) { return predicate(v, i, source); }) : identity$1, take(1), hasDefaultValue ? defaultIfEmpty(defaultValue) : throwIfEmpty(function () { return new EmptyError(); })); };
  }

  /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
  function mapTo(value) {
      return function (source) { return source.lift(new MapToOperator(value)); };
  }
  var MapToOperator = /*@__PURE__*/ (function () {
      function MapToOperator(value) {
          this.value = value;
      }
      MapToOperator.prototype.call = function (subscriber, source) {
          return source.subscribe(new MapToSubscriber(subscriber, this.value));
      };
      return MapToOperator;
  }());
  var MapToSubscriber = /*@__PURE__*/ (function (_super) {
      __extends(MapToSubscriber, _super);
      function MapToSubscriber(destination, value) {
          var _this = _super.call(this, destination) || this;
          _this.value = value;
          return _this;
      }
      MapToSubscriber.prototype._next = function (x) {
          this.destination.next(this.value);
      };
      return MapToSubscriber;
  }(Subscriber));

  /** PURE_IMPORTS_START _observable_ConnectableObservable PURE_IMPORTS_END */
  function multicast(subjectOrSubjectFactory, selector) {
      return function multicastOperatorFunction(source) {
          var subjectFactory;
          if (typeof subjectOrSubjectFactory === 'function') {
              subjectFactory = subjectOrSubjectFactory;
          }
          else {
              subjectFactory = function subjectFactory() {
                  return subjectOrSubjectFactory;
              };
          }
          if (typeof selector === 'function') {
              return source.lift(new MulticastOperator(subjectFactory, selector));
          }
          var connectable = Object.create(source, connectableObservableDescriptor);
          connectable.source = source;
          connectable.subjectFactory = subjectFactory;
          return connectable;
      };
  }
  var MulticastOperator = /*@__PURE__*/ (function () {
      function MulticastOperator(subjectFactory, selector) {
          this.subjectFactory = subjectFactory;
          this.selector = selector;
      }
      MulticastOperator.prototype.call = function (subscriber, source) {
          var selector = this.selector;
          var subject = this.subjectFactory();
          var subscription = selector(subject).subscribe(subscriber);
          subscription.add(source.subscribe(subject));
          return subscription;
      };
      return MulticastOperator;
  }());

  /** PURE_IMPORTS_START _ReplaySubject,_multicast PURE_IMPORTS_END */
  function publishReplay(bufferSize, windowTime, selectorOrScheduler, scheduler) {
      if (selectorOrScheduler && typeof selectorOrScheduler !== 'function') {
          scheduler = selectorOrScheduler;
      }
      var selector = typeof selectorOrScheduler === 'function' ? selectorOrScheduler : undefined;
      var subject = new ReplaySubject(bufferSize, windowTime, scheduler);
      return function (source) { return multicast(function () { return subject; }, selector)(source); };
  }

  /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
  function retry(count) {
      if (count === void 0) {
          count = -1;
      }
      return function (source) { return source.lift(new RetryOperator(count, source)); };
  }
  var RetryOperator = /*@__PURE__*/ (function () {
      function RetryOperator(count, source) {
          this.count = count;
          this.source = source;
      }
      RetryOperator.prototype.call = function (subscriber, source) {
          return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
      };
      return RetryOperator;
  }());
  var RetrySubscriber = /*@__PURE__*/ (function (_super) {
      __extends(RetrySubscriber, _super);
      function RetrySubscriber(destination, count, source) {
          var _this = _super.call(this, destination) || this;
          _this.count = count;
          _this.source = source;
          return _this;
      }
      RetrySubscriber.prototype.error = function (err) {
          if (!this.isStopped) {
              var _a = this, source = _a.source, count = _a.count;
              if (count === 0) {
                  return _super.prototype.error.call(this, err);
              }
              else if (count > -1) {
                  this.count = count - 1;
              }
              source.subscribe(this._unsubscribeAndRecycle());
          }
      };
      return RetrySubscriber;
  }(Subscriber));

  /** PURE_IMPORTS_START tslib,_innerSubscribe PURE_IMPORTS_END */
  function skipUntil(notifier) {
      return function (source) { return source.lift(new SkipUntilOperator(notifier)); };
  }
  var SkipUntilOperator = /*@__PURE__*/ (function () {
      function SkipUntilOperator(notifier) {
          this.notifier = notifier;
      }
      SkipUntilOperator.prototype.call = function (destination, source) {
          return source.subscribe(new SkipUntilSubscriber(destination, this.notifier));
      };
      return SkipUntilOperator;
  }());
  var SkipUntilSubscriber = /*@__PURE__*/ (function (_super) {
      __extends(SkipUntilSubscriber, _super);
      function SkipUntilSubscriber(destination, notifier) {
          var _this = _super.call(this, destination) || this;
          _this.hasValue = false;
          var innerSubscriber = new SimpleInnerSubscriber(_this);
          _this.add(innerSubscriber);
          _this.innerSubscription = innerSubscriber;
          var innerSubscription = innerSubscribe(notifier, innerSubscriber);
          if (innerSubscription !== innerSubscriber) {
              _this.add(innerSubscription);
              _this.innerSubscription = innerSubscription;
          }
          return _this;
      }
      SkipUntilSubscriber.prototype._next = function (value) {
          if (this.hasValue) {
              _super.prototype._next.call(this, value);
          }
      };
      SkipUntilSubscriber.prototype.notifyNext = function () {
          this.hasValue = true;
          if (this.innerSubscription) {
              this.innerSubscription.unsubscribe();
          }
      };
      SkipUntilSubscriber.prototype.notifyComplete = function () {
      };
      return SkipUntilSubscriber;
  }(SimpleOuterSubscriber));

  /** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
  function skipWhile(predicate) {
      return function (source) { return source.lift(new SkipWhileOperator(predicate)); };
  }
  var SkipWhileOperator = /*@__PURE__*/ (function () {
      function SkipWhileOperator(predicate) {
          this.predicate = predicate;
      }
      SkipWhileOperator.prototype.call = function (subscriber, source) {
          return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
      };
      return SkipWhileOperator;
  }());
  var SkipWhileSubscriber = /*@__PURE__*/ (function (_super) {
      __extends(SkipWhileSubscriber, _super);
      function SkipWhileSubscriber(destination, predicate) {
          var _this = _super.call(this, destination) || this;
          _this.predicate = predicate;
          _this.skipping = true;
          _this.index = 0;
          return _this;
      }
      SkipWhileSubscriber.prototype._next = function (value) {
          var destination = this.destination;
          if (this.skipping) {
              this.tryCallPredicate(value);
          }
          if (!this.skipping) {
              destination.next(value);
          }
      };
      SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {
          try {
              var result = this.predicate(value, this.index++);
              this.skipping = Boolean(result);
          }
          catch (err) {
              this.destination.error(err);
          }
      };
      return SkipWhileSubscriber;
  }(Subscriber));

  /** PURE_IMPORTS_START tslib,_map,_observable_from,_innerSubscribe PURE_IMPORTS_END */
  function switchMap(project, resultSelector) {
      if (typeof resultSelector === 'function') {
          return function (source) { return source.pipe(switchMap(function (a, i) { return from$1(project(a, i)).pipe(map(function (b, ii) { return resultSelector(a, b, i, ii); })); })); };
      }
      return function (source) { return source.lift(new SwitchMapOperator(project)); };
  }
  var SwitchMapOperator = /*@__PURE__*/ (function () {
      function SwitchMapOperator(project) {
          this.project = project;
      }
      SwitchMapOperator.prototype.call = function (subscriber, source) {
          return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
      };
      return SwitchMapOperator;
  }());
  var SwitchMapSubscriber = /*@__PURE__*/ (function (_super) {
      __extends(SwitchMapSubscriber, _super);
      function SwitchMapSubscriber(destination, project) {
          var _this = _super.call(this, destination) || this;
          _this.project = project;
          _this.index = 0;
          return _this;
      }
      SwitchMapSubscriber.prototype._next = function (value) {
          var result;
          var index = this.index++;
          try {
              result = this.project(value, index);
          }
          catch (error) {
              this.destination.error(error);
              return;
          }
          this._innerSub(result);
      };
      SwitchMapSubscriber.prototype._innerSub = function (result) {
          var innerSubscription = this.innerSubscription;
          if (innerSubscription) {
              innerSubscription.unsubscribe();
          }
          var innerSubscriber = new SimpleInnerSubscriber(this);
          var destination = this.destination;
          destination.add(innerSubscriber);
          this.innerSubscription = innerSubscribe(result, innerSubscriber);
          if (this.innerSubscription !== innerSubscriber) {
              destination.add(this.innerSubscription);
          }
      };
      SwitchMapSubscriber.prototype._complete = function () {
          var innerSubscription = this.innerSubscription;
          if (!innerSubscription || innerSubscription.closed) {
              _super.prototype._complete.call(this);
          }
          this.unsubscribe();
      };
      SwitchMapSubscriber.prototype._unsubscribe = function () {
          this.innerSubscription = undefined;
      };
      SwitchMapSubscriber.prototype.notifyComplete = function () {
          this.innerSubscription = undefined;
          if (this.isStopped) {
              _super.prototype._complete.call(this);
          }
      };
      SwitchMapSubscriber.prototype.notifyNext = function (innerValue) {
          this.destination.next(innerValue);
      };
      return SwitchMapSubscriber;
  }(SimpleOuterSubscriber));

  /** PURE_IMPORTS_START tslib,_Subscriber,_util_noop,_util_isFunction PURE_IMPORTS_END */
  function tap(nextOrObserver, error, complete) {
      return function tapOperatorFunction(source) {
          return source.lift(new DoOperator(nextOrObserver, error, complete));
      };
  }
  var DoOperator = /*@__PURE__*/ (function () {
      function DoOperator(nextOrObserver, error, complete) {
          this.nextOrObserver = nextOrObserver;
          this.error = error;
          this.complete = complete;
      }
      DoOperator.prototype.call = function (subscriber, source) {
          return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
      };
      return DoOperator;
  }());
  var TapSubscriber = /*@__PURE__*/ (function (_super) {
      __extends(TapSubscriber, _super);
      function TapSubscriber(destination, observerOrNext, error, complete) {
          var _this = _super.call(this, destination) || this;
          _this._tapNext = noop;
          _this._tapError = noop;
          _this._tapComplete = noop;
          _this._tapError = error || noop;
          _this._tapComplete = complete || noop;
          if (isFunction(observerOrNext)) {
              _this._context = _this;
              _this._tapNext = observerOrNext;
          }
          else if (observerOrNext) {
              _this._context = observerOrNext;
              _this._tapNext = observerOrNext.next || noop;
              _this._tapError = observerOrNext.error || noop;
              _this._tapComplete = observerOrNext.complete || noop;
          }
          return _this;
      }
      TapSubscriber.prototype._next = function (value) {
          try {
              this._tapNext.call(this._context, value);
          }
          catch (err) {
              this.destination.error(err);
              return;
          }
          this.destination.next(value);
      };
      TapSubscriber.prototype._error = function (err) {
          try {
              this._tapError.call(this._context, err);
          }
          catch (err) {
              this.destination.error(err);
              return;
          }
          this.destination.error(err);
      };
      TapSubscriber.prototype._complete = function () {
          try {
              this._tapComplete.call(this._context);
          }
          catch (err) {
              this.destination.error(err);
              return;
          }
          return this.destination.complete();
      };
      return TapSubscriber;
  }(Subscriber));

  /** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_innerSubscribe PURE_IMPORTS_END */
  function timeoutWith(due, withObservable, scheduler) {
      if (scheduler === void 0) {
          scheduler = async;
      }
      return function (source) {
          var absoluteTimeout = isDate(due);
          var waitFor = absoluteTimeout ? (+due - scheduler.now()) : Math.abs(due);
          return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
      };
  }
  var TimeoutWithOperator = /*@__PURE__*/ (function () {
      function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {
          this.waitFor = waitFor;
          this.absoluteTimeout = absoluteTimeout;
          this.withObservable = withObservable;
          this.scheduler = scheduler;
      }
      TimeoutWithOperator.prototype.call = function (subscriber, source) {
          return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
      };
      return TimeoutWithOperator;
  }());
  var TimeoutWithSubscriber = /*@__PURE__*/ (function (_super) {
      __extends(TimeoutWithSubscriber, _super);
      function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
          var _this = _super.call(this, destination) || this;
          _this.absoluteTimeout = absoluteTimeout;
          _this.waitFor = waitFor;
          _this.withObservable = withObservable;
          _this.scheduler = scheduler;
          _this.scheduleTimeout();
          return _this;
      }
      TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {
          var withObservable = subscriber.withObservable;
          subscriber._unsubscribeAndRecycle();
          subscriber.add(innerSubscribe(withObservable, new SimpleInnerSubscriber(subscriber)));
      };
      TimeoutWithSubscriber.prototype.scheduleTimeout = function () {
          var action = this.action;
          if (action) {
              this.action = action.schedule(this, this.waitFor);
          }
          else {
              this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));
          }
      };
      TimeoutWithSubscriber.prototype._next = function (value) {
          if (!this.absoluteTimeout) {
              this.scheduleTimeout();
          }
          _super.prototype._next.call(this, value);
      };
      TimeoutWithSubscriber.prototype._unsubscribe = function () {
          this.action = undefined;
          this.scheduler = null;
          this.withObservable = null;
      };
      return TimeoutWithSubscriber;
  }(SimpleOuterSubscriber));

  /** PURE_IMPORTS_START _scheduler_async,_util_TimeoutError,_timeoutWith,_observable_throwError PURE_IMPORTS_END */
  function timeout(due, scheduler) {
      if (scheduler === void 0) {
          scheduler = async;
      }
      return timeoutWith(due, throwError(new TimeoutError()), scheduler);
  }

  function _createSuper$3(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$3(); return function _createSuperInternal() { var Super = _getPrototypeOf$1(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$1(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$1(this, result); }; }

  function _isNativeReflectConstruct$3() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  var WaitCancelError = /*#__PURE__*/function (_Error) {
    _inherits$1(WaitCancelError, _Error);

    var _super = _createSuper$3(WaitCancelError);

    function WaitCancelError(message) {
      var _this;

      _classCallCheck$1(this, WaitCancelError);

      _this = _super.call(this, message);

      _defineProperty$1(_assertThisInitialized(_this), "name", 'WaitCancelError');

      if (isFunction$1(Error.captureStackTrace)) {
        Error.captureStackTrace(_assertThisInitialized(_this), _this.constructor);
      } else {
        _this.stack = new Error(message).stack;
      }

      return _this;
    }

    return WaitCancelError;
  }( /*#__PURE__*/_wrapNativeSuper(Error));
  var WaitTimeoutError = /*#__PURE__*/function (_Error2) {
    _inherits$1(WaitTimeoutError, _Error2);

    var _super2 = _createSuper$3(WaitTimeoutError);

    function WaitTimeoutError(message) {
      var _this2;

      _classCallCheck$1(this, WaitTimeoutError);

      _this2 = _super2.call(this, message);

      _defineProperty$1(_assertThisInitialized(_this2), "name", 'WaitTimeoutError');

      if (isFunction$1(Error.captureStackTrace)) {
        Error.captureStackTrace(_assertThisInitialized(_this2), _this2.constructor);
      } else {
        _this2.stack = new Error(message).stack;
      }

      return _this2;
    }

    return WaitTimeoutError;
  }( /*#__PURE__*/_wrapNativeSuper(Error));
  /**
   * @param {function|Observable} condition
   * @param {function|Observable} [breakOn]
   * @param {number} [timeout]
   * @returns {Promise<boolean>}
   */

  function waitFor(condition, breakOn, timeout$1) {
    var defCond = function defCond(x) {
      return !x;
    };

    var success = interval(1000 / 60).pipe(isFunction$1(condition) ? skipWhile(negate(condition)) : skipUntil(condition.pipe(skipWhile(defCond))), first());
    var failed = NEVER;

    if (breakOn) {
      failed = interval(1000 / 60).pipe(isFunction$1(breakOn) ? skipWhile(negate(breakOn)) : skipUntil(breakOn.pipe(skipWhile(defCond))), first(), switchMap(function () {
        return throwError(new WaitCancelError('wait canceled'));
      }));
    }

    var obs = race(success, failed);

    if (timeout$1 > 0) {
      obs = obs.pipe(timeout(timeout$1));
    }

    return obs.pipe(catchError(function (err) {
      if (err.name === 'TimeoutError') {
        err = new WaitTimeoutError('wait timed out');
      }

      throw err;
    })).toPromise();
  }

  var utils = /*#__PURE__*/Object.freeze({
    __proto__: null,
    IdentityMap: IdentityMap,
    sequential: sequential,
    mergeDescriptors: mergeDescriptors,
    waitFor: waitFor,
    WaitCancelError: WaitCancelError,
    WaitTimeoutError: WaitTimeoutError,
    AssertionError: AssertionError,
    assert: assert$1,
    numeric: numeric,
    instanceOf: instanceOf,
    log: log,
    warn: warn,
    error: error,
    encode: encode,
    newLogger: newLogger,
    makeLog: makeLog,
    makeWarn: makeWarn,
    makeError: makeError,
    noop: noop$1,
    constant: constant,
    stubArray: stubArray,
    stubObject: stubObject,
    stubCollection: stubCollection,
    stubTrue: stubTrue,
    stubFalse: stubFalse,
    identity: identity$2,
    negate: negate,
    or: or,
    and: and,
    toArray: toArray,
    isBoolean: isBoolean,
    isNumber: isNumber$1,
    isString: isString,
    isArray: isArray$2,
    isArrayLike: isArrayLike$1,
    isCollection: isCollection,
    isFinite: isFinite$1,
    isFunction: isFunction$1,
    isNumeric: isNumeric$1,
    isObjectLike: isObjectLike,
    isPlainObject: isPlainObject,
    round: round,
    coalesce: coalesce,
    plainProps: plainProps,
    replaceTokens: replaceTokens,
    isEqual: isEqual,
    getLength: getLength,
    isEmpty: isEmpty$2,
    keys: keys,
    values: values,
    seal: seal,
    freeze: freeze,
    sealFactory: sealFactory,
    freezeFactory: freezeFactory,
    forEach: forEach,
    reduce: reduce,
    filter: filter$1,
    find: find,
    map: map$1,
    mapValues: mapValues,
    mapKeys: mapKeys,
    every: every,
    some: some,
    firstEl: firstEl,
    lastEl: lastEl,
    pick: pick,
    omit: omit,
    upperFirst: upperFirst,
    lowerFirst: lowerFirst,
    rangeIterator: rangeIterator,
    range: range,
    get: get$1,
    hasOwnProp: hasOwnProp,
    hasProp: hasProp,
    includes: includes$1,
    difference: difference,
    camelCase: camelCase,
    kebabCase: kebabCase,
    serialize: serialize$1,
    unserialize: unserialize,
    clonePlainObject: clonePlainObject,
    addPrefix: addPrefix,
    makeWatchers: makeWatchers,
    extractChildren: extractChildren
  });

  // Unique ID creation requires a high quality random # generator. In the browser we therefore
  // require the crypto API and do not support built-in fallback to lower quality random number
  // generators (like Math.random()).
  var getRandomValues;
  var rnds8 = new Uint8Array(16);
  function rng() {
    // lazy load so that environments that need to polyfill have a chance to do so
    if (!getRandomValues) {
      // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
      // find the complete implementation of crypto (msCrypto) on IE11.
      getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

      if (!getRandomValues) {
        throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
      }
    }

    return getRandomValues(rnds8);
  }

  var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

  function validate(uuid) {
    return typeof uuid === 'string' && REGEX.test(uuid);
  }

  /**
   * Convert array of 16 byte values to UUID string format of the form:
   * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
   */

  var byteToHex = [];

  for (var i = 0; i < 256; ++i) {
    byteToHex.push((i + 0x100).toString(16).substr(1));
  }

  function stringify(arr) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    // Note: Be careful editing this code!  It's been tuned for performance
    // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
    var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
    // of the following:
    // - One or more input array values don't map to a hex octet (leading to
    // "undefined" in the uuid)
    // - Invalid input values for the RFC `version` or `variant` fields

    if (!validate(uuid)) {
      throw TypeError('Stringified UUID is invalid');
    }

    return uuid;
  }

  function v4(options, buf, offset) {
    options = options || {};
    var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

    rnds[6] = rnds[6] & 0x0f | 0x40;
    rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

    if (buf) {
      offset = offset || 0;

      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = rnds[i];
      }

      return buf;
    }

    return stringify(rnds);
  }

  function getControlId(control$1) {
    if (control$1 instanceof control.Control) {
      return control$1.get('id');
    }

    throw new Error('Illegal control argument');
  }
  function setControlId(control$1, controlId) {
    if (control$1 instanceof control.Control) {
      control$1.set('id', controlId);
      return control$1;
    }

    throw new Error('Illegal control argument');
  }
  function initializeControl(control, defaultControlId) {
    if (getControlId(control) == null) {
      setControlId(control, defaultControlId || v4());
    }

    return control;
  }

  /**
   * @module ol/geom/GeometryType
   */
  /**
   * The geometry type. One of `'Point'`, `'LineString'`, `'LinearRing'`,
   * `'Polygon'`, `'MultiPoint'`, `'MultiLineString'`, `'MultiPolygon'`,
   * `'GeometryCollection'`, `'Circle'`.
   * @enum {string}
   */
  var GeometryType = {
      POINT: 'Point',
      LINE_STRING: 'LineString',
      LINEAR_RING: 'LinearRing',
      POLYGON: 'Polygon',
      MULTI_POINT: 'MultiPoint',
      MULTI_LINE_STRING: 'MultiLineString',
      MULTI_POLYGON: 'MultiPolygon',
      GEOMETRY_COLLECTION: 'GeometryCollection',
      CIRCLE: 'Circle',
  };

  var COORD_PRECISION = -1;
  function roundExtent(extent) {
    var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
    if (!extent) return;
    return extent.map(function (x) {
      return round(x, precision);
    });
  }
  function roundPointCoords(coordinates) {
    var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
    if (!coordinates) return;
    return coordinates.map(function (x) {
      return round(x, precision);
    });
  }
  function roundLineCoords(coordinates) {
    var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
    if (!coordinates) return;
    return coordinates.map(function (point) {
      return roundPointCoords(point, precision);
    });
  }
  function roundPolygonCoords(coordinates) {
    var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
    if (!coordinates) return;
    return coordinates.map(function (line) {
      return roundLineCoords(line, precision);
    });
  }
  function roundMultiPointCoords(coordinates) {
    var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
    return roundLineCoords(coordinates, precision);
  }
  function roundMultiLineCoords(coordinates) {
    var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
    return roundPolygonCoords(coordinates, precision);
  }
  function roundMultiPolygonCoords(coordinates) {
    var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
    if (!coordinates) return;
    return coordinates.map(function (polygon) {
      return roundPolygonCoords(polygon, precision);
    });
  }
  function roundCoords(geomType, coordinates) {
    var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;

    switch (geomType) {
      case GeometryType.POINT:
      case GeometryType.CIRCLE:
        return roundPointCoords(coordinates, precision);

      case GeometryType.LINE_STRING:
      case GeometryType.MULTI_POINT:
        return roundLineCoords(coordinates, precision);

      case GeometryType.POLYGON:
      case GeometryType.MULTI_LINE_STRING:
        return roundPolygonCoords(coordinates, precision);

      case GeometryType.MULTI_POLYGON:
        return roundMultiPolygonCoords(coordinates, precision);
    }
  }
  function flatCoords(geomType, coordinates) {
    var polygonReducer = function polygonReducer(coords, lineString) {
      return coords.concat(lineString);
    };

    switch (geomType) {
      case GeometryType.POINT:
        return [coordinates];

      case GeometryType.LINE_STRING:
      case GeometryType.MULTI_POINT:
        return coordinates;

      case GeometryType.POLYGON:
      case GeometryType.MULTI_LINE_STRING:
        return coordinates.reduce(polygonReducer, []);

      case GeometryType.MULTI_POLYGON:
        return coordinates.reduce(function (coords, polygon) {
          return coords.concat(polygon.reduce(polygonReducer, []));
        }, []);

      default:
        // todo maybe return null?
        return [];
    }
  }
  /**
   * @param {{coordinates: number[], extent: number[]}} a
   * @param {{coordinates: number[], extent: number[]}} b
   * @returns {boolean}
   */

  function isEqualCoord(a, b) {
    return isEqual(a.extent, b.extent) ? isEqual(a.coordinates, b.coordinates) : false;
  }
  function calcDistance(point1, point2) {
    var dx = point2[0] - point1[0];
    var dy = point2[1] - point1[1];
    var squared = dx * dx + dy * dy;
    return round(Math.sqrt(squared), COORD_PRECISION);
  }
  var isPointCoords = /*#__PURE__*/and(isArray$2, function (point) {
    return point.length >= 2;
  }, function (point) {
    return every(point, isNumber$1);
  });
  var isLineCoords = /*#__PURE__*/and(isArray$2, function (line) {
    return line.length >= 0;
  }, function (line) {
    return every(line, isPointCoords);
  });
  var isPolygonCoords = /*#__PURE__*/and(isArray$2, function (polygon) {
    return polygon.length >= 0;
  }, function (polygon) {
    return every(polygon, isLineCoords);
  });
  var isMultiPointCoords = isLineCoords;
  var isMultiLineCoords = isPolygonCoords;
  var isMultiPolygonCoords = /*#__PURE__*/and(isArray$2, function (multiPolygon) {
    return multiPolygon.length >= 0;
  }, function (multiPolygon) {
    return every(multiPolygon, isPolygonCoords);
  });

  /**
   * @module ol/extent/Corner
   */
  /**
   * Extent corner.
   * @enum {string}
   */
  var ExtentCorner = {
      BOTTOM_LEFT: 'bottom-left',
      BOTTOM_RIGHT: 'bottom-right',
      TOP_LEFT: 'top-left',
      TOP_RIGHT: 'top-right',
  };

  // copy-paste from ol/extent
  function createOrUpdate(minX, minY, maxX, maxY, extent) {
    if (extent) {
      extent[0] = minX;
      extent[1] = minY;
      extent[2] = maxX;
      extent[3] = maxY;
      return extent;
    }

    return [minX, minY, maxX, maxY];
  }
  function getCorner(extent$1, corner) {
    var coordinate;

    if (corner === ExtentCorner.BOTTOM_LEFT) {
      coordinate = extent.getBottomLeft(extent$1);
    } else if (corner === ExtentCorner.BOTTOM_RIGHT) {
      coordinate = extent.getBottomRight(extent$1);
    } else if (corner === ExtentCorner.TOP_LEFT) {
      coordinate = extent.getTopLeft(extent$1);
    } else if (corner === ExtentCorner.TOP_RIGHT) {
      coordinate = extent.getTopRight(extent$1);
    } else {
      assert$1(false, 'Invalid extent corner');
    }

    return coordinate;
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf$1(object);
      if (object === null) break;
    }

    return object;
  }

  function _get$1(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get$1 = Reflect.get;
    } else {
      _get$1 = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);
        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get$1(target, property, receiver || target);
  }

  /**
   * @module ol/obj
   */
  /**
   * Determine if an object has any properties.
   * @param {Object} object The object to check.
   * @return {boolean} The object is empty.
   */
  function isEmpty$1(object) {
      var property;
      for (property in object) {
          return false;
      }
      return !property;
  }

  /**
   * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.
   */
  var earthRadius = 6371008.8;

  /**
   * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.
   */
  var factors = {
      meters: earthRadius,
      metres: earthRadius,
      millimeters: earthRadius * 1000,
      millimetres: earthRadius * 1000,
      centimeters: earthRadius * 100,
      centimetres: earthRadius * 100,
      kilometers: earthRadius / 1000,
      kilometres: earthRadius / 1000,
      miles: earthRadius / 1609.344,
      nauticalmiles: earthRadius / 1852,
      inches: earthRadius * 39.370,
      yards: earthRadius / 1.0936,
      feet: earthRadius * 3.28084,
      radians: 1,
      degrees: earthRadius / 111325,
  };

  /**
   * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.
   *
   * @name feature
   * @param {Geometry} geometry input geometry
   * @param {Object} [properties={}] an Object of key-value pairs to add as properties
   * @param {Object} [options={}] Optional Parameters
   * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
   * @param {string|number} [options.id] Identifier associated with the Feature
   * @returns {Feature} a GeoJSON Feature
   * @example
   * var geometry = {
   *   "type": "Point",
   *   "coordinates": [110, 50]
   * };
   *
   * var feature = turf.feature(geometry);
   *
   * //=feature
   */
  function feature$1(geometry, properties, options) {
      // Optional Parameters
      options = options || {};
      if (!isObject(options)) throw new Error('options is invalid');
      var bbox = options.bbox;
      var id = options.id;

      // Validation
      if (geometry === undefined) throw new Error('geometry is required');
      if (properties && properties.constructor !== Object) throw new Error('properties must be an Object');
      if (bbox) validateBBox(bbox);
      if (id) validateId(id);

      // Main
      var feat = {type: 'Feature'};
      if (id) feat.id = id;
      if (bbox) feat.bbox = bbox;
      feat.properties = properties || {};
      feat.geometry = geometry;
      return feat;
  }

  /**
   * Creates a {@link Point} {@link Feature} from a Position.
   *
   * @name point
   * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)
   * @param {Object} [properties={}] an Object of key-value pairs to add as properties
   * @param {Object} [options={}] Optional Parameters
   * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
   * @param {string|number} [options.id] Identifier associated with the Feature
   * @returns {Feature<Point>} a Point feature
   * @example
   * var point = turf.point([-75.343, 39.984]);
   *
   * //=point
   */
  function point(coordinates, properties, options) {
      if (!coordinates) throw new Error('coordinates is required');
      if (!Array.isArray(coordinates)) throw new Error('coordinates must be an Array');
      if (coordinates.length < 2) throw new Error('coordinates must be at least 2 numbers long');
      if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) throw new Error('coordinates must contain numbers');

      return feature$1({
          type: 'Point',
          coordinates: coordinates
      }, properties, options);
  }

  /**
   * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.
   *
   * @name featureCollection
   * @param {Feature[]} features input features
   * @param {Object} [options={}] Optional Parameters
   * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
   * @param {string|number} [options.id] Identifier associated with the Feature
   * @returns {FeatureCollection} FeatureCollection of Features
   * @example
   * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});
   * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});
   * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});
   *
   * var collection = turf.featureCollection([
   *   locationA,
   *   locationB,
   *   locationC
   * ]);
   *
   * //=collection
   */
  function featureCollection(features, options) {
      // Optional Parameters
      options = options || {};
      if (!isObject(options)) throw new Error('options is invalid');
      var bbox = options.bbox;
      var id = options.id;

      // Validation
      if (!features) throw new Error('No features passed');
      if (!Array.isArray(features)) throw new Error('features must be an Array');
      if (bbox) validateBBox(bbox);
      if (id) validateId(id);

      // Main
      var fc = {type: 'FeatureCollection'};
      if (id) fc.id = id;
      if (bbox) fc.bbox = bbox;
      fc.features = features;
      return fc;
  }

  /**
   * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.
   * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
   *
   * @name radiansToLength
   * @param {number} radians in radians across the sphere
   * @param {string} [units='kilometers'] can be degrees, radians, miles, or kilometers inches, yards, metres, meters, kilometres, kilometers.
   * @returns {number} distance
   */
  function radiansToLength(radians, units) {
      if (radians === undefined || radians === null) throw new Error('radians is required');

      if (units && typeof units !== 'string') throw new Error('units must be a string');
      var factor = factors[units || 'kilometers'];
      if (!factor) throw new Error(units + ' units is invalid');
      return radians * factor;
  }

  /**
   * Converts an angle in degrees to radians
   *
   * @name degreesToRadians
   * @param {number} degrees angle between 0 and 360 degrees
   * @returns {number} angle in radians
   */
  function degreesToRadians(degrees) {
      if (degrees === null || degrees === undefined) throw new Error('degrees is required');

      var radians = degrees % 360;
      return radians * Math.PI / 180;
  }

  /**
   * isNumber
   *
   * @param {*} num Number to validate
   * @returns {boolean} true/false
   * @example
   * turf.isNumber(123)
   * //=true
   * turf.isNumber('foo')
   * //=false
   */
  function isNumber(num) {
      return !isNaN(num) && num !== null && !Array.isArray(num);
  }

  /**
   * isObject
   *
   * @param {*} input variable to validate
   * @returns {boolean} true/false
   * @example
   * turf.isObject({elevation: 10})
   * //=true
   * turf.isObject('foo')
   * //=false
   */
  function isObject(input) {
      return (!!input) && (input.constructor === Object);
  }

  /**
   * Validate BBox
   *
   * @private
   * @param {Array<number>} bbox BBox to validate
   * @returns {void}
   * @throws Error if BBox is not valid
   * @example
   * validateBBox([-180, -40, 110, 50])
   * //=OK
   * validateBBox([-180, -40])
   * //=Error
   * validateBBox('Foo')
   * //=Error
   * validateBBox(5)
   * //=Error
   * validateBBox(null)
   * //=Error
   * validateBBox(undefined)
   * //=Error
   */
  function validateBBox(bbox) {
      if (!bbox) throw new Error('bbox is required');
      if (!Array.isArray(bbox)) throw new Error('bbox must be an Array');
      if (bbox.length !== 4 && bbox.length !== 6) throw new Error('bbox must be an Array of 4 or 6 numbers');
      bbox.forEach(function (num) {
          if (!isNumber(num)) throw new Error('bbox must only contain numbers');
      });
  }

  /**
   * Validate Id
   *
   * @private
   * @param {string|number} id Id to validate
   * @returns {void}
   * @throws Error if Id is not valid
   * @example
   * validateId([-180, -40, 110, 50])
   * //=Error
   * validateId([-180, -40])
   * //=Error
   * validateId('Foo')
   * //=OK
   * validateId(5)
   * //=OK
   * validateId(null)
   * //=Error
   * validateId(undefined)
   * //=Error
   */
  function validateId(id) {
      if (!id) throw new Error('id is required');
      if (['string', 'number'].indexOf(typeof id) === -1) throw new Error('id must be a number or a string');
  }

  /**
   * Callback for coordEach
   *
   * @callback coordEachCallback
   * @param {Array<number>} currentCoord The current coordinate being processed.
   * @param {number} coordIndex The current index of the coordinate being processed.
   * @param {number} featureIndex The current index of the Feature being processed.
   * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
   * @param {number} geometryIndex The current index of the Geometry being processed.
   */

  /**
   * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()
   *
   * @name coordEach
   * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
   * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)
   * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
   * @returns {void}
   * @example
   * var features = turf.featureCollection([
   *   turf.point([26, 37], {"foo": "bar"}),
   *   turf.point([36, 53], {"hello": "world"})
   * ]);
   *
   * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
   *   //=currentCoord
   *   //=coordIndex
   *   //=featureIndex
   *   //=multiFeatureIndex
   *   //=geometryIndex
   * });
   */
  function coordEach(geojson, callback, excludeWrapCoord) {
      // Handles null Geometry -- Skips this GeoJSON
      if (geojson === null) return;
      var j, k, l, geometry, stopG, coords,
          geometryMaybeCollection,
          wrapShrink = 0,
          coordIndex = 0,
          isGeometryCollection,
          type = geojson.type,
          isFeatureCollection = type === 'FeatureCollection',
          isFeature = type === 'Feature',
          stop = isFeatureCollection ? geojson.features.length : 1;

      // This logic may look a little weird. The reason why it is that way
      // is because it's trying to be fast. GeoJSON supports multiple kinds
      // of objects at its root: FeatureCollection, Features, Geometries.
      // This function has the responsibility of handling all of them, and that
      // means that some of the `for` loops you see below actually just don't apply
      // to certain inputs. For instance, if you give this just a
      // Point geometry, then both loops are short-circuited and all we do
      // is gradually rename the input until it's called 'geometry'.
      //
      // This also aims to allocate as few resources as possible: just a
      // few numbers and booleans, rather than any temporary arrays as would
      // be required with the normalization approach.
      for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
          geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :
              (isFeature ? geojson.geometry : geojson));
          isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;
          stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

          for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
              var multiFeatureIndex = 0;
              var geometryIndex = 0;
              geometry = isGeometryCollection ?
                  geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;

              // Handles null Geometry -- Skips this geometry
              if (geometry === null) continue;
              coords = geometry.coordinates;
              var geomType = geometry.type;

              wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;

              switch (geomType) {
              case null:
                  break;
              case 'Point':
                  if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
                  coordIndex++;
                  multiFeatureIndex++;
                  break;
              case 'LineString':
              case 'MultiPoint':
                  for (j = 0; j < coords.length; j++) {
                      if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
                      coordIndex++;
                      if (geomType === 'MultiPoint') multiFeatureIndex++;
                  }
                  if (geomType === 'LineString') multiFeatureIndex++;
                  break;
              case 'Polygon':
              case 'MultiLineString':
                  for (j = 0; j < coords.length; j++) {
                      for (k = 0; k < coords[j].length - wrapShrink; k++) {
                          if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
                          coordIndex++;
                      }
                      if (geomType === 'MultiLineString') multiFeatureIndex++;
                      if (geomType === 'Polygon') geometryIndex++;
                  }
                  if (geomType === 'Polygon') multiFeatureIndex++;
                  break;
              case 'MultiPolygon':
                  for (j = 0; j < coords.length; j++) {
                      if (geomType === 'MultiPolygon') geometryIndex = 0;
                      for (k = 0; k < coords[j].length; k++) {
                          for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                              if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
                              coordIndex++;
                          }
                          geometryIndex++;
                      }
                      multiFeatureIndex++;
                  }
                  break;
              case 'GeometryCollection':
                  for (j = 0; j < geometry.geometries.length; j++)
                      if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;
                  break;
              default:
                  throw new Error('Unknown Geometry Type');
              }
          }
      }
  }

  /**
   * Callback for featureEach
   *
   * @callback featureEachCallback
   * @param {Feature<any>} currentFeature The current Feature being processed.
   * @param {number} featureIndex The current index of the Feature being processed.
   */

  /**
   * Iterate over features in any GeoJSON object, similar to
   * Array.forEach.
   *
   * @name featureEach
   * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
   * @param {Function} callback a method that takes (currentFeature, featureIndex)
   * @returns {void}
   * @example
   * var features = turf.featureCollection([
   *   turf.point([26, 37], {foo: 'bar'}),
   *   turf.point([36, 53], {hello: 'world'})
   * ]);
   *
   * turf.featureEach(features, function (currentFeature, featureIndex) {
   *   //=currentFeature
   *   //=featureIndex
   * });
   */
  function featureEach(geojson, callback) {
      if (geojson.type === 'Feature') {
          callback(geojson, 0);
      } else if (geojson.type === 'FeatureCollection') {
          for (var i = 0; i < geojson.features.length; i++) {
              if (callback(geojson.features[i], i) === false) break;
          }
      }
  }

  /**
   * Takes a feature or set of features and returns all positions as {@link Point|points}.
   *
   * @name explode
   * @param {GeoJSON} geojson input features
   * @returns {FeatureCollection<point>} points representing the exploded input features
   * @throws {Error} if it encounters an unknown geometry type
   * @example
   * var polygon = turf.polygon([[[-81, 41], [-88, 36], [-84, 31], [-80, 33], [-77, 39], [-81, 41]]]);
   *
   * var explode = turf.explode(polygon);
   *
   * //addToMap
   * var addToMap = [polygon, explode]
   */
  function explode(geojson) {
      var points = [];
      if (geojson.type === 'FeatureCollection') {
          featureEach(geojson, function (feature) {
              coordEach(feature, function (coord) {
                  points.push(point(coord, feature.properties));
              });
          });
      } else {
          coordEach(geojson, function (coord) {
              points.push(point(coord, geojson.properties));
          });
      }
      return featureCollection(points);
  }

  /**
   * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.
   *
   * @name bbox
   * @param {GeoJSON} geojson any GeoJSON object
   * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order
   * @example
   * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);
   * var bbox = turf.bbox(line);
   * var bboxPolygon = turf.bboxPolygon(bbox);
   *
   * //addToMap
   * var addToMap = [line, bboxPolygon]
   */
  function bbox(geojson) {
      var BBox = [Infinity, Infinity, -Infinity, -Infinity];
      coordEach(geojson, function (coord) {
          if (BBox[0] > coord[0]) BBox[0] = coord[0];
          if (BBox[1] > coord[1]) BBox[1] = coord[1];
          if (BBox[2] < coord[0]) BBox[2] = coord[0];
          if (BBox[3] < coord[1]) BBox[3] = coord[1];
      });
      return BBox;
  }

  /**
   * Takes a {@link Feature} or {@link FeatureCollection} and returns the absolute center point of all features.
   *
   * @name center
   * @param {GeoJSON} geojson GeoJSON to be centered
   * @param {Object} [options={}] Optional parameters
   * @param {Object} [options.properties={}] an Object that is used as the {@link Feature}'s properties
   * @returns {Feature<Point>} a Point feature at the absolute center point of all input features
   * @example
   * var features = turf.featureCollection([
   *   turf.point( [-97.522259, 35.4691]),
   *   turf.point( [-97.502754, 35.463455]),
   *   turf.point( [-97.508269, 35.463245])
   * ]);
   *
   * var center = turf.center(features);
   *
   * //addToMap
   * var addToMap = [features, center]
   * center.properties['marker-size'] = 'large';
   * center.properties['marker-color'] = '#000';
   */
  function center(geojson, options) {
      // Optional parameters
      options = options || {};
      if (!isObject(options)) throw new Error('options is invalid');
      var properties = options.properties;

      // Input validation
      if (!geojson) throw new Error('geojson is required');

      var ext = bbox(geojson);
      var x = (ext[0] + ext[2]) / 2;
      var y = (ext[1] + ext[3]) / 2;
      return point([x, y], properties);
  }

  /**
   * Returns a cloned copy of the passed GeoJSON Object, including possible 'Foreign Members'.
   * ~3-5x faster than the common JSON.parse + JSON.stringify combo method.
   *
   * @name clone
   * @param {GeoJSON} geojson GeoJSON Object
   * @returns {GeoJSON} cloned GeoJSON Object
   * @example
   * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]], {color: 'red'});
   *
   * var lineCloned = turf.clone(line);
   */
  function clone(geojson) {
      if (!geojson) throw new Error('geojson is required');

      switch (geojson.type) {
      case 'Feature':
          return cloneFeature(geojson);
      case 'FeatureCollection':
          return cloneFeatureCollection(geojson);
      case 'Point':
      case 'LineString':
      case 'Polygon':
      case 'MultiPoint':
      case 'MultiLineString':
      case 'MultiPolygon':
      case 'GeometryCollection':
          return cloneGeometry(geojson);
      default:
          throw new Error('unknown GeoJSON type');
      }
  }

  /**
   * Clone Feature
   *
   * @private
   * @param {Feature<any>} geojson GeoJSON Feature
   * @returns {Feature<any>} cloned Feature
   */
  function cloneFeature(geojson) {
      var cloned = {type: 'Feature'};
      // Preserve Foreign Members
      Object.keys(geojson).forEach(function (key) {
          switch (key) {
          case 'type':
          case 'properties':
          case 'geometry':
              return;
          default:
              cloned[key] = geojson[key];
          }
      });
      // Add properties & geometry last
      cloned.properties = cloneProperties(geojson.properties);
      cloned.geometry = cloneGeometry(geojson.geometry);
      return cloned;
  }

  /**
   * Clone Properties
   *
   * @private
   * @param {Object} properties GeoJSON Properties
   * @returns {Object} cloned Properties
   */
  function cloneProperties(properties) {
      var cloned = {};
      if (!properties) return cloned;
      Object.keys(properties).forEach(function (key) {
          var value = properties[key];
          if (typeof value === 'object') {
              if (value === null) {
                  // handle null
                  cloned[key] = null;
              } else if (value.length) {
                  // handle Array
                  cloned[key] = value.map(function (item) {
                      return item;
                  });
              } else {
                  // handle generic Object
                  cloned[key] = cloneProperties(value);
              }
          } else cloned[key] = value;
      });
      return cloned;
  }

  /**
   * Clone Feature Collection
   *
   * @private
   * @param {FeatureCollection<any>} geojson GeoJSON Feature Collection
   * @returns {FeatureCollection<any>} cloned Feature Collection
   */
  function cloneFeatureCollection(geojson) {
      var cloned = {type: 'FeatureCollection'};

      // Preserve Foreign Members
      Object.keys(geojson).forEach(function (key) {
          switch (key) {
          case 'type':
          case 'features':
              return;
          default:
              cloned[key] = geojson[key];
          }
      });
      // Add features
      cloned.features = geojson.features.map(function (feature) {
          return cloneFeature(feature);
      });
      return cloned;
  }

  /**
   * Clone Geometry
   *
   * @private
   * @param {Geometry<any>} geometry GeoJSON Geometry
   * @returns {Geometry<any>} cloned Geometry
   */
  function cloneGeometry(geometry) {
      var geom = {type: geometry.type};
      if (geometry.bbox) geom.bbox = geometry.bbox;

      if (geometry.type === 'GeometryCollection') {
          geom.geometries = geometry.geometries.map(function (geom) {
              return cloneGeometry(geom);
          });
          return geom;
      }
      geom.coordinates = deepSlice(geometry.coordinates);
      return geom;
  }

  /**
   * Deep Slice coordinates
   *
   * @private
   * @param {Coordinates} coords Coordinates
   * @returns {Coordinates} all coordinates sliced
   */
  function deepSlice(coords) {
      if (typeof coords[0] !== 'object') { return coords.slice(); }
      return coords.map(function (coord) {
          return deepSlice(coord);
      });
  }

  /**
   * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.
   *
   * @name getCoord
   * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers
   * @returns {Array<number>} coordinates
   * @example
   * var pt = turf.point([10, 10]);
   *
   * var coord = turf.getCoord(pt);
   * //= [10, 10]
   */
  function getCoord(coord) {
      if (!coord) throw new Error('coord is required');
      if (coord.type === 'Feature' && coord.geometry !== null && coord.geometry.type === 'Point') return coord.geometry.coordinates;
      if (coord.type === 'Point') return coord.coordinates;
      if (Array.isArray(coord) && coord.length >= 2 && coord[0].length === undefined && coord[1].length === undefined) return coord;

      throw new Error('coord must be GeoJSON Point or an Array of numbers');
  }

  /**
   * Unwrap coordinates from a Feature, Geometry Object or an Array
   *
   * @name getCoords
   * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array
   * @returns {Array<any>} coordinates
   * @example
   * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);
   *
   * var coords = turf.getCoords(poly);
   * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]
   */
  function getCoords(coords) {
      if (!coords) throw new Error('coords is required');

      // Feature
      if (coords.type === 'Feature' && coords.geometry !== null) return coords.geometry.coordinates;

      // Geometry
      if (coords.coordinates) return coords.coordinates;

      // Array of numbers
      if (Array.isArray(coords)) return coords;

      throw new Error('coords must be GeoJSON Feature, Geometry Object or an Array');
  }

  //http://en.wikipedia.org/wiki/Haversine_formula
  //http://www.movable-type.co.uk/scripts/latlong.html

  /**
   * Calculates the distance between two {@link Point|points} in degrees, radians,
   * miles, or kilometers. This uses the
   * [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula)
   * to account for global curvature.
   *
   * @name distance
   * @param {Coord} from origin point
   * @param {Coord} to destination point
   * @param {Object} [options={}] Optional parameters
   * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers
   * @returns {number} distance between the two points
   * @example
   * var from = turf.point([-75.343, 39.984]);
   * var to = turf.point([-75.534, 39.123]);
   * var options = {units: 'miles'};
   *
   * var distance = turf.distance(from, to, options);
   *
   * //addToMap
   * var addToMap = [from, to];
   * from.properties.distance = distance;
   * to.properties.distance = distance;
   */
  function distance(from, to, options) {
      // Optional parameters
      options = options || {};
      if (!isObject(options)) throw new Error('options is invalid');
      var units = options.units;

      var coordinates1 = getCoord(from);
      var coordinates2 = getCoord(to);
      var dLat = degreesToRadians((coordinates2[1] - coordinates1[1]));
      var dLon = degreesToRadians((coordinates2[0] - coordinates1[0]));
      var lat1 = degreesToRadians(coordinates1[1]);
      var lat2 = degreesToRadians(coordinates2[1]);

      var a = Math.pow(Math.sin(dLat / 2), 2) +
            Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);

      return radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), units);
  }

  /**
   * Takes a reference {@link Point|point} and a FeatureCollection of Features
   * with Point geometries and returns the
   * point from the FeatureCollection closest to the reference. This calculation
   * is geodesic.
   *
   * @name nearestPoint
   * @param {Coord} targetPoint the reference point
   * @param {FeatureCollection<Point>} points against input point set
   * @returns {Feature<Point>} the closest point in the set to the reference point
   * @example
   * var targetPoint = turf.point([28.965797, 41.010086], {"marker-color": "#0F0"});
   * var points = turf.featureCollection([
   *     turf.point([28.973865, 41.011122]),
   *     turf.point([28.948459, 41.024204]),
   *     turf.point([28.938674, 41.013324])
   * ]);
   *
   * var nearest = turf.nearestPoint(targetPoint, points);
   *
   * //addToMap
   * var addToMap = [targetPoint, points, nearest];
   * nearest.properties['marker-color'] = '#F00';
   */
  function nearestPoint(targetPoint, points) {
      // Input validation
      if (!targetPoint) throw new Error('targetPoint is required');
      if (!points) throw new Error('points is required');

      var nearest;
      var minDist = Infinity;
      featureEach(points, function (pt, featureIndex) {
          var distanceToPoint = distance(targetPoint, pt);
          if (distanceToPoint < minDist) {
              nearest = clone(pt);
              nearest.properties.featureIndex = featureIndex;
              nearest.properties.distanceToPoint = distanceToPoint;
              minDist = distanceToPoint;
          }

      });
      return nearest;
  }

  // http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule
  // modified from: https://github.com/substack/point-in-polygon/blob/master/index.js
  // which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html

  /**
   * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point resides inside the polygon. The polygon can
   * be convex or concave. The function accounts for holes.
   *
   * @name booleanPointInPolygon
   * @param {Coord} point input point
   * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon
   * @param {Object} [options={}] Optional parameters
   * @param {boolean} [options.ignoreBoundary=false] True if polygon boundary should be ignored when determining if the point is inside the polygon otherwise false.
   * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon
   * @example
   * var pt = turf.point([-77, 44]);
   * var poly = turf.polygon([[
   *   [-81, 41],
   *   [-81, 47],
   *   [-72, 47],
   *   [-72, 41],
   *   [-81, 41]
   * ]]);
   *
   * turf.booleanPointInPolygon(pt, poly);
   * //= true
   */
  function booleanPointInPolygon(point, polygon, options) {
      // Optional parameters
      options = options || {};
      if (typeof options !== 'object') throw new Error('options is invalid');
      var ignoreBoundary = options.ignoreBoundary;

      // validation
      if (!point) throw new Error('point is required');
      if (!polygon) throw new Error('polygon is required');

      var pt = getCoord(point);
      var polys = getCoords(polygon);
      var type = (polygon.geometry) ? polygon.geometry.type : polygon.type;
      var bbox = polygon.bbox;

      // Quick elimination if point is not inside bbox
      if (bbox && inBBox(pt, bbox) === false) return false;

      // normalize to multipolygon
      if (type === 'Polygon') polys = [polys];

      for (var i = 0, insidePoly = false; i < polys.length && !insidePoly; i++) {
          // check if it is in the outer ring first
          if (inRing(pt, polys[i][0], ignoreBoundary)) {
              var inHole = false;
              var k = 1;
              // check for the point in any of the holes
              while (k < polys[i].length && !inHole) {
                  if (inRing(pt, polys[i][k], !ignoreBoundary)) {
                      inHole = true;
                  }
                  k++;
              }
              if (!inHole) insidePoly = true;
          }
      }
      return insidePoly;
  }

  /**
   * inRing
   *
   * @private
   * @param {Array<number>} pt [x,y]
   * @param {Array<Array<number>>} ring [[x,y], [x,y],..]
   * @param {boolean} ignoreBoundary ignoreBoundary
   * @returns {boolean} inRing
   */
  function inRing(pt, ring, ignoreBoundary) {
      var isInside = false;
      if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) ring = ring.slice(0, ring.length - 1);

      for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
          var xi = ring[i][0], yi = ring[i][1];
          var xj = ring[j][0], yj = ring[j][1];
          var onBoundary = (pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0) &&
              ((xi - pt[0]) * (xj - pt[0]) <= 0) && ((yi - pt[1]) * (yj - pt[1]) <= 0);
          if (onBoundary) return !ignoreBoundary;
          var intersect = ((yi > pt[1]) !== (yj > pt[1])) &&
          (pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi);
          if (intersect) isInside = !isInside;
      }
      return isInside;
  }

  /**
   * inBBox
   *
   * @private
   * @param {Position} pt point [x,y]
   * @param {BBox} bbox BBox [west, south, east, north]
   * @returns {boolean} true/false if point is inside BBox
   */
  function inBBox(pt, bbox) {
      return bbox[0] <= pt[0] &&
             bbox[1] <= pt[1] &&
             bbox[2] >= pt[0] &&
             bbox[3] >= pt[1];
  }

  /**
   * Takes a Feature or FeatureCollection and returns a {@link Point} guaranteed to be on the surface of the feature.
   *
   * * Given a {@link Polygon}, the point will be in the area of the polygon
   * * Given a {@link LineString}, the point will be along the string
   * * Given a {@link Point}, the point will the same as the input
   *
   * @name pointOnFeature
   * @param {GeoJSON} geojson any Feature or FeatureCollection
   * @returns {Feature<Point>} a point on the surface of `input`
   * @example
   * var polygon = turf.polygon([[
   *   [116, -36],
   *   [131, -32],
   *   [146, -43],
   *   [155, -25],
   *   [133, -9],
   *   [111, -22],
   *   [116, -36]
   * ]]);
   *
   * var pointOnPolygon = turf.pointOnFeature(polygon);
   *
   * //addToMap
   * var addToMap = [polygon, pointOnPolygon];
   */
  function pointOnFeature(geojson) {
      // normalize
      var fc = normalize(geojson);

      // get centroid
      var cent = center(fc);

      // check to see if centroid is on surface
      var onSurface = false;
      var i = 0;
      while (!onSurface && i < fc.features.length) {
          var geom = fc.features[i].geometry;
          var x, y, x1, y1, x2, y2, k;
          var onLine = false;
          if (geom.type === 'Point') {
              if (cent.geometry.coordinates[0] === geom.coordinates[0] &&
                  cent.geometry.coordinates[1] === geom.coordinates[1]) {
                  onSurface = true;
              }
          } else if (geom.type === 'MultiPoint') {
              var onMultiPoint = false;
              k = 0;
              while (!onMultiPoint && k < geom.coordinates.length) {
                  if (cent.geometry.coordinates[0] === geom.coordinates[k][0] &&
            cent.geometry.coordinates[1] === geom.coordinates[k][1]) {
                      onSurface = true;
                      onMultiPoint = true;
                  }
                  k++;
              }
          } else if (geom.type === 'LineString') {
              k = 0;
              while (!onLine && k < geom.coordinates.length - 1) {
                  x = cent.geometry.coordinates[0];
                  y = cent.geometry.coordinates[1];
                  x1 = geom.coordinates[k][0];
                  y1 = geom.coordinates[k][1];
                  x2 = geom.coordinates[k + 1][0];
                  y2 = geom.coordinates[k + 1][1];
                  if (pointOnSegment(x, y, x1, y1, x2, y2)) {
                      onLine = true;
                      onSurface = true;
                  }
                  k++;
              }
          } else if (geom.type === 'MultiLineString') {
              var j = 0;
              while (j < geom.coordinates.length) {
                  onLine = false;
                  k = 0;
                  var line = geom.coordinates[j];
                  while (!onLine && k < line.length - 1) {
                      x = cent.geometry.coordinates[0];
                      y = cent.geometry.coordinates[1];
                      x1 = line[k][0];
                      y1 = line[k][1];
                      x2 = line[k + 1][0];
                      y2 = line[k + 1][1];
                      if (pointOnSegment(x, y, x1, y1, x2, y2)) {
                          onLine = true;
                          onSurface = true;
                      }
                      k++;
                  }
                  j++;
              }
          } else if (geom.type === 'Polygon' || geom.type === 'MultiPolygon') {
              if (booleanPointInPolygon(cent, geom)) {
                  onSurface = true;
              }
          }
          i++;
      }
      if (onSurface) {
          return cent;
      } else {
          var vertices = featureCollection([]);
          for (i = 0; i < fc.features.length; i++) {
              vertices.features = vertices.features.concat(explode(fc.features[i]).features);
          }
          // Remove distanceToPoint properties from nearestPoint()
          return point(nearestPoint(cent, vertices).geometry.coordinates);
      }
  }

  /**
   * Normalizes any GeoJSON to a FeatureCollection
   *
   * @private
   * @name normalize
   * @param {GeoJSON} geojson Any GeoJSON
   * @returns {FeatureCollection} FeatureCollection
   */
  function normalize(geojson) {
      if (geojson.type !== 'FeatureCollection') {
          if (geojson.type !== 'Feature') {
              return featureCollection([feature$1(geojson)]);
          }
          return featureCollection([geojson]);
      }
      return geojson;
  }

  function pointOnSegment(x, y, x1, y1, x2, y2) {
      var ab = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
      var ap = Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));
      var pb = Math.sqrt((x2 - x) * (x2 - x) + (y2 - y) * (y2 - y));
      return ab === ap + pb;
  }

  function ownKeys$14(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$14(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$14(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$14(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  /**
   * @param {number|number[]} lonOrCoordinates
   * @param {number} [lat]
   * @return {Point}
   */

  function createPointGeom(lonOrCoordinates, lat) {
    var coordinates = Array.isArray(lonOrCoordinates) ? lonOrCoordinates : [lonOrCoordinates, lat];
    return new geom.Point(coordinates);
  }
  /**
   * @param {Array<number[]>} points
   * @returns {LineString}
   */

  function createLineGeom(points) {
    return new geom.LineString(points);
  }
  /**
   * @param {Array<Array<number[]>>} rings
   * @returns {Polygon}
   */

  function createPolygonGeom(rings) {
    return new geom.Polygon(rings);
  }
  /**
   * @param {Array<number[]>} points
   * @returns {MultiPoint}
   */

  function createMultiPointGeom(points) {
    return new geom.MultiPoint(points);
  }
  /**
   * @param {Array<Array<number[]>>} lines
   * @returns {MultiLineString}
   */

  function createMultiLineGeom(lines) {
    return new geom.MultiLineString(lines);
  }
  /**
   * @param {Array<Array<Array<number[]>>>} polygons
   * @returns {MultiPolygon}
   */

  function createMultiPolygonGeom(polygons) {
    return new geom.MultiPolygon(polygons);
  }
  /**
   * @param {Geometry[]} geoms
   * @returns {GeometryCollection}
   */

  function createGeomCollection(geoms) {
    return new geom.GeometryCollection(geoms);
  }
  /**
   * @param {Coordinate|number[]} center
   * @param {number} radius
   * @return {Polygon}
   */

  function createCircularPolygon(center, radius) {
    return Polygon.circular(center, radius);
  }
  /**
   * @param {Geometry|Object} geom
   * @return {boolean}
   * @throws {Error}
   */

  function isMultiGeom(geom) {
    var multiTypes = [GeometryType.MULTI_POINT, GeometryType.MULTI_LINE_STRING, GeometryType.MULTI_POLYGON, GeometryType.GEOMETRY_COLLECTION];
    return multiTypes.includes(geom.type || geom.getType());
  }
  /**
   * @param {Geometry|Object} geom
   * @return {SimpleGeometry|Object}
   * @throws {Error}
   */

  function toSimpleGeom(geom$1) {
    if (geom$1 instanceof geom.Circle) {
      geom$1 = createPointGeom(geom$1.getCenter());
    } else if (geom$1.type === GeometryType.CIRCLE) {
      geom$1 = _objectSpread$14(_objectSpread$14({}, geom$1), {}, {
        type: GeometryType.POINT
      });
    }

    var type = geom$1.type || geom$1.getType();
    var complexTypes = [GeometryType.GEOMETRY_COLLECTION];

    if (complexTypes.includes(type) === false) {
      return geom$1;
    }

    return (geom$1.geometries || geom$1.getGeometries())[0];
  }
  /**
   * @param {Geometry|Object} geom
   * @param {number} [precision=COORD_PRECISION]
   * @return {Coordinate|undefined}
   */

  function findPointOnSurface(geom) {
    var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
    var simpleGeom = toSimpleGeom(geom);
    var pointFeature = pointOnFeature({
      type: simpleGeom.type || simpleGeom.getType(),
      coordinates: simpleGeom.coordinates || simpleGeom.getCoordinates()
    });

    if (pointFeature !== null && pointFeature !== void 0 && pointFeature.geometry) {
      return roundCoords(pointFeature.geometry.type, pointFeature.geometry.coordinates, precision);
    }
  }
  function getGeometryId(geometry) {
    if (geometry instanceof geom.Geometry) {
      return geometry.get('id');
    } else if (isPlainObject(geometry)) {
      return geometry.id;
    }

    throw new Error('Illegal geometry argument');
  }
  function setGeometryId(geometry, geometryId) {
    if (geometry instanceof geom.Geometry) {
      geometry.set('id', geometryId);
      return geometry;
    } else if (isPlainObject(geometry)) {
      geometry.id = geometryId;
      return geometry;
    }

    throw new Error('Illegal geometry argument');
  }
  function initializeGeometry(geometry, defaultGeometryId) {
    if (getGeometryId(geometry) == null) {
      setGeometryId(geometry, defaultGeometryId || v4());
    }

    return geometry;
  }
  /**
   * @param value
   * @return {boolean}
   */

  function isCircleGeom(value) {
    return getGeomType(value) === GeometryType.CIRCLE;
  }
  function getGeomCoords(geom) {
    if (!geom) return;
    var type = getGeomType(geom);

    switch (type) {
      case GeometryType.CIRCLE:
        return roundCoords(type, geom.coordinates || geom.getCenter());

      default:
        return roundCoords(type, geom.coordinates || geom.getCoordinates());
    }
  }
  function getGeomType(geom$1) {
    if (geom$1 instanceof geom.Geometry) {
      return geom$1.getType();
    }

    return geom$1 === null || geom$1 === void 0 ? void 0 : geom$1.type;
  }

  var _transforms;
  var EPSG_4326 = 'EPSG:4326';
  var EPSG_3857 = 'EPSG:3857';
  /**
   * @param {number[]} coordinate
   * @param {module:ol/proj.ProjectionLike} [projection=EPSG_3857]
   * @param {number} [precision=COORD_PRECISION]
   * @return {Coordinate|number[]}
   */

  function pointToLonLat(coordinate) {
    var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
    var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;
    if (!coordinate) return;
    return roundCoords(GeometryType.POINT, proj.toLonLat(coordinate, projection), precision);
  }
  /**
   * @param {number[]} coordinate
   * @param {module:ol/proj.ProjectionLike} [projection]
   * @param {number} [precision=COORD_PRECISION]
   * @return {number[]}
   */

  function pointFromLonLat(coordinate) {
    var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
    var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;
    if (!coordinate) return;
    return roundCoords(GeometryType.POINT, proj.fromLonLat(coordinate, projection), precision);
  }
  /**
   * @param {number[]} coordinate
   * @param {module:ol/proj.ProjectionLike} sourceProjection
   * @param {module:ol/proj.ProjectionLike} destProjection
   * @param {number} [precision=COORD_PRECISION]
   * @returns {number[]}
   */

  function transformPoint(coordinate, sourceProjection, destProjection) {
    var precision = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : COORD_PRECISION;
    if (!coordinate) return;
    return transform(coordinate, sourceProjection, destProjection, precision);
  }
  /**
   * @param {number[]} coordinate
   * @param {module:ol/proj.ProjectionLike} sourceProjection
   * @param {module:ol/proj.ProjectionLike} destProjection
   * @param {number} [precision=COORD_PRECISION]
   * @returns {number[]}
   */

  function transform(coordinate, sourceProjection, destProjection) {
    var precision = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : COORD_PRECISION;
    if (!coordinate) return;
    var coord = proj.transform(coordinate, sourceProjection, destProjection);

    if (coord.some(function (x) {
      return isNaN(x);
    })) {
      coord = proj.transform(proj.transform(coordinate, sourceProjection, EPSG_4326), EPSG_4326, destProjection);
    }

    return roundCoords(GeometryType.POINT, coord, precision);
  }
  /**
   * @param {Array<number[]>} coordinates
   * @param {module:ol/proj.ProjectionLike} [projection=EPSG_3857]
   * @param {number} [precision=COORD_PRECISION]
   * @return {Array<number[]>}
   */

  function lineToLonLat(coordinates) {
    var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
    var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;
    if (!coordinates) return;
    return coordinates.map(function (point) {
      return pointToLonLat(point, projection, precision);
    });
  }
  /**
   * @param {Array<number[]>} coordinates
   * @param {ProjectionLike} [projection=EPSG_3857]
   * @param {number} [precision=COORD_PRECISION]
   * @return {Array<number[]>}
   */

  function lineFromLonLat(coordinates) {
    var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
    var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;
    if (!coordinates) return;
    return coordinates.map(function (point) {
      return pointFromLonLat(point, projection, precision);
    });
  }
  /**
   * @param {Array<number[]>} coordinates
   * @param {module:ol/proj.ProjectionLike} sourceProjection
   * @param {module:ol/proj.ProjectionLike} destProjection
   * @param {number} [precision=COORD_PRECISION]
   * @returns {number[]}
   */

  function transformLine(coordinates, sourceProjection, destProjection) {
    var precision = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : COORD_PRECISION;
    if (!coordinates) return;
    return coordinates.map(function (point) {
      return transformPoint(point, sourceProjection, destProjection, precision);
    });
  }
  /**
   * @param {Array<Array<number[]>>} coordinates
   * @param {module:ol/proj.ProjectionLike} [projection=EPSG_3857]
   * @param {number} [precision=COORD_PRECISION]
   * @return {Array<Array<number[]>>}
   */

  function polygonToLonLat(coordinates) {
    var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
    var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;
    if (!coordinates) return;
    return coordinates.map(function (line) {
      return lineToLonLat(line, projection, precision);
    });
  }
  /**
   * @param {Array<Array<number[]>>} coordinates
   * @param {module:ol/proj.ProjectionLike} [projection=EPSG_3857]
   * @param {number} [precision=COORD_PRECISION]
   * @return {Array<Array<number[]>>}
   */

  function polygonFromLonLat(coordinates) {
    var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
    var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;
    if (!coordinates) return;
    return coordinates.map(function (line) {
      return lineFromLonLat(line, projection, precision);
    });
  }
  /**
   * @param {Array<Array<number[]>>} coordinates
   * @param {module:ol/proj.ProjectionLike} sourceProjection
   * @param {module:ol/proj.ProjectionLike} destProjection
   * @param {number} [precision=COORD_PRECISION]
   * @returns {*}
   */

  function transformPolygon(coordinates, sourceProjection, destProjection) {
    var precision = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : COORD_PRECISION;
    if (!coordinates) return;
    return coordinates.map(function (line) {
      return transformLine(line, sourceProjection, destProjection, precision);
    });
  }
  /**
   * @param {Array<number[]>} coordinates
   * @param {module:ol/proj.ProjectionLike} [projection=EPSG_3857]
   * @param {number} [precision=COORD_PRECISION]
   * @return {Array<number[]>}
   */

  function multiPointToLonLat(coordinates) {
    var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
    var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;
    if (!coordinates) return;
    return coordinates.map(function (point) {
      return pointToLonLat(point, projection, precision);
    });
  }
  /**
   * @param {Array<number[]>} coordinates
   * @param {module:ol/proj.ProjectionLike} [projection=EPSG_3857]
   * @param {number} [precision=COORD_PRECISION]
   * @return {Array<number[]>}
   */

  function multiPointFromLonLat(coordinates) {
    var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
    var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;
    if (!coordinates) return;
    return coordinates.map(function (point) {
      return pointFromLonLat(point, projection, precision);
    });
  }
  /**
   * @param {Array<number[]>} coordinates
   * @param {module:ol/proj.ProjectionLike} sourceProjection
   * @param {module:ol/proj.ProjectionLike} destProjection
   * @param {number} [precision=COORD_PRECISION]
   * @return {Array<number[]>}
   */

  function transformMultiPoint(coordinates, sourceProjection, destProjection) {
    var precision = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : COORD_PRECISION;
    if (!coordinates) return;
    return coordinates.map(function (point) {
      return transformPoint(point, sourceProjection, destProjection, precision);
    });
  }
  /**
   * @param {Array<Array<number[]>>} coordinates
   * @param {module:ol/proj.ProjectionLike} [projection=EPSG_3857]
   * @param {number} [precision=COORD_PRECISION]
   * @return {Array<Array<number[]>>}
   */

  function multiLineToLonLat(coordinates) {
    var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
    var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;
    if (!coordinates) return;
    return coordinates.map(function (line) {
      return lineToLonLat(line, projection, precision);
    });
  }
  /**
   * @param {Array<Array<number[]>>} coordinates
   * @param {module:ol/proj.ProjectionLike} [projection=EPSG_3857]
   * @param {number} [precision=COORD_PRECISION]
   * @return {Array<Array<number[]>>}
   */

  function multiLineFromLonLat(coordinates) {
    var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
    var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;
    if (!coordinates) return;
    return coordinates.map(function (line) {
      return lineFromLonLat(line, projection, precision);
    });
  }
  /**
   * @param {Array<Array<number[]>>} coordinates
   * @param {module:ol/proj.ProjectionLike} sourceProjection
   * @param {module:ol/proj.ProjectionLike} destProjection
   * @param {number} [precision=COORD_PRECISION]
   * @return {Array<Array<number[]>>}
   */

  function transformMultiLine(coordinates, sourceProjection, destProjection) {
    var precision = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : COORD_PRECISION;
    if (!coordinates) return;
    return coordinates.map(function (line) {
      return transformLine(line, sourceProjection, destProjection, precision);
    });
  }
  /**
   * @param {Array<Array<Array<number[]>>>} coordinates
   * @param {module:ol/proj.ProjectionLike} [projection=EPSG_3857]
   * @param {number} [precision=COORD_PRECISION]
   * @return {Array<Array<Array<number[]>>>}
   */

  function multiPolygonToLonLat(coordinates) {
    var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
    var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;
    if (!coordinates) return;
    return coordinates.map(function (polygon) {
      return polygonToLonLat(polygon, projection, precision);
    });
  }
  /**
   * @param {Array<Array<Array<number[]>>>} coordinates
   * @param {module:ol/proj.ProjectionLike} [projection=EPSG_3857]
   * @param {number} [precision=COORD_PRECISION]
   * @return {Array<Array<Array<number[]>>>}
   */

  function multiPolygonFromLonLat(coordinates) {
    var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
    var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;
    if (!coordinates) return;
    return coordinates.map(function (polygon) {
      return polygonFromLonLat(polygon, projection, precision);
    });
  }
  /**
   * @param {Array<Array<Array<number[]>>>} coordinates
   * @param {module:ol/proj.ProjectionLike} sourceProjection
   * @param {module:ol/proj.ProjectionLike} destProjection
   * @param {number} [precision=COORD_PRECISION]
   * @return {Array<Array<Array<number[]>>>}
   */

  function transformMultiPolygon(coordinates, sourceProjection, destProjection) {
    var precision = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : COORD_PRECISION;
    if (!coordinates) return;
    return coordinates.map(function (polygon) {
      return transformPolygon(polygon, sourceProjection, destProjection, precision);
    });
  }
  /**
   * Transforms by geom type
   * @type {Object<string, function>}
   */

  var transforms = (_transforms = {}, _defineProperty$1(_transforms, GeometryType.POINT, {
    toLonLat: pointToLonLat,
    fromLonLat: pointFromLonLat,
    transform: transformPoint
  }), _defineProperty$1(_transforms, GeometryType.LINE_STRING, {
    toLonLat: lineToLonLat,
    fromLonLat: lineFromLonLat,
    transform: transformLine
  }), _defineProperty$1(_transforms, GeometryType.POLYGON, {
    toLonLat: polygonToLonLat,
    fromLonLat: polygonFromLonLat,
    transform: transformPolygon
  }), _defineProperty$1(_transforms, GeometryType.MULTI_POINT, {
    toLonLat: multiPointToLonLat,
    fromLonLat: multiPointFromLonLat,
    transform: transformMultiPoint
  }), _defineProperty$1(_transforms, GeometryType.MULTI_LINE_STRING, {
    toLonLat: multiLineToLonLat,
    fromLonLat: multiLineFromLonLat,
    transform: transformMultiLine
  }), _defineProperty$1(_transforms, GeometryType.MULTI_POLYGON, {
    toLonLat: multiPolygonToLonLat,
    fromLonLat: multiPolygonFromLonLat,
    transform: transformMultiPolygon
  }), _defineProperty$1(_transforms, GeometryType.CIRCLE, {
    toLonLat: pointToLonLat,
    fromLonLat: pointFromLonLat,
    transform: transformPoint
  }), _transforms);
  /**
   * @param {number[]} extent
   * @param {module:ol/proj.ProjectionLike} sourceProjection
   * @param {module:ol/proj.ProjectionLike} destProjection
   * @param {number} [precision=COORD_PRECISION]
   * @return {number[]}
   */

  function transformExtent$1(extent, sourceProjection, destProjection) {
    var precision = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : COORD_PRECISION;
    if (!extent) return;
    if (extent.every(function (x) {
      return !isFinite(x);
    })) return extent;
    var ext = proj.transformExtent(extent, sourceProjection, destProjection);

    if (ext.some(function (x) {
      return isNaN(x);
    })) {
      ext = proj.transformExtent(proj.transformExtent(extent, sourceProjection, EPSG_4326), EPSG_4326, destProjection);
    }

    return roundExtent(ext, precision);
  }
  /**
   * @param {number[]} extent
   * @param {module:ol/proj.ProjectionLike} [projection=EPSG:3857]
   * @param {number} [precision=COORD_PRECISION]
   * @return {number[]}
   */

  function extentFromLonLat(extent) {
    var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
    var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;
    if (!extent) return;
    return transformExtent$1(extent, EPSG_4326, projection, precision);
  }
  /**
   * @param {number[]} extent
   * @param {module:ol/proj.ProjectionLike} [projection=EPSG:3857]
   * @param {number} [precision=COORD_PRECISION]
   * @return {number[]}
   */

  function extentToLonLat(extent) {
    var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
    var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;
    if (!extent) return;
    return transformExtent$1(extent, projection, EPSG_4326, precision);
  }
  function transformDistance(distance, sourceProjection, destProjection) {
    var precision = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : COORD_PRECISION;
    if (!distance) return;
    var line = transformLine([[0, 0], [distance, 0]], sourceProjection, destProjection, precision);
    return calcDistance(line[0], line[1]);
  }

  /* MIT license */

  var conversions = {
    rgb2hsl: rgb2hsl,
    rgb2hsv: rgb2hsv,
    rgb2hwb: rgb2hwb,
    rgb2cmyk: rgb2cmyk,
    rgb2keyword: rgb2keyword,
    rgb2xyz: rgb2xyz,
    rgb2lab: rgb2lab,
    rgb2lch: rgb2lch,

    hsl2rgb: hsl2rgb,
    hsl2hsv: hsl2hsv,
    hsl2hwb: hsl2hwb,
    hsl2cmyk: hsl2cmyk,
    hsl2keyword: hsl2keyword,

    hsv2rgb: hsv2rgb,
    hsv2hsl: hsv2hsl,
    hsv2hwb: hsv2hwb,
    hsv2cmyk: hsv2cmyk,
    hsv2keyword: hsv2keyword,

    hwb2rgb: hwb2rgb,
    hwb2hsl: hwb2hsl,
    hwb2hsv: hwb2hsv,
    hwb2cmyk: hwb2cmyk,
    hwb2keyword: hwb2keyword,

    cmyk2rgb: cmyk2rgb,
    cmyk2hsl: cmyk2hsl,
    cmyk2hsv: cmyk2hsv,
    cmyk2hwb: cmyk2hwb,
    cmyk2keyword: cmyk2keyword,

    keyword2rgb: keyword2rgb,
    keyword2hsl: keyword2hsl,
    keyword2hsv: keyword2hsv,
    keyword2hwb: keyword2hwb,
    keyword2cmyk: keyword2cmyk,
    keyword2lab: keyword2lab,
    keyword2xyz: keyword2xyz,

    xyz2rgb: xyz2rgb,
    xyz2lab: xyz2lab,
    xyz2lch: xyz2lch,

    lab2xyz: lab2xyz,
    lab2rgb: lab2rgb,
    lab2lch: lab2lch,

    lch2lab: lch2lab,
    lch2xyz: lch2xyz,
    lch2rgb: lch2rgb
  };


  function rgb2hsl(rgb) {
    var r = rgb[0]/255,
        g = rgb[1]/255,
        b = rgb[2]/255,
        min = Math.min(r, g, b),
        max = Math.max(r, g, b),
        delta = max - min,
        h, s, l;

    if (max == min)
      h = 0;
    else if (r == max)
      h = (g - b) / delta;
    else if (g == max)
      h = 2 + (b - r) / delta;
    else if (b == max)
      h = 4 + (r - g)/ delta;

    h = Math.min(h * 60, 360);

    if (h < 0)
      h += 360;

    l = (min + max) / 2;

    if (max == min)
      s = 0;
    else if (l <= 0.5)
      s = delta / (max + min);
    else
      s = delta / (2 - max - min);

    return [h, s * 100, l * 100];
  }

  function rgb2hsv(rgb) {
    var r = rgb[0],
        g = rgb[1],
        b = rgb[2],
        min = Math.min(r, g, b),
        max = Math.max(r, g, b),
        delta = max - min,
        h, s, v;

    if (max == 0)
      s = 0;
    else
      s = (delta/max * 1000)/10;

    if (max == min)
      h = 0;
    else if (r == max)
      h = (g - b) / delta;
    else if (g == max)
      h = 2 + (b - r) / delta;
    else if (b == max)
      h = 4 + (r - g) / delta;

    h = Math.min(h * 60, 360);

    if (h < 0)
      h += 360;

    v = ((max / 255) * 1000) / 10;

    return [h, s, v];
  }

  function rgb2hwb(rgb) {
    var r = rgb[0],
        g = rgb[1],
        b = rgb[2],
        h = rgb2hsl(rgb)[0],
        w = 1/255 * Math.min(r, Math.min(g, b)),
        b = 1 - 1/255 * Math.max(r, Math.max(g, b));

    return [h, w * 100, b * 100];
  }

  function rgb2cmyk(rgb) {
    var r = rgb[0] / 255,
        g = rgb[1] / 255,
        b = rgb[2] / 255,
        c, m, y, k;

    k = Math.min(1 - r, 1 - g, 1 - b);
    c = (1 - r - k) / (1 - k) || 0;
    m = (1 - g - k) / (1 - k) || 0;
    y = (1 - b - k) / (1 - k) || 0;
    return [c * 100, m * 100, y * 100, k * 100];
  }

  function rgb2keyword(rgb) {
    return reverseKeywords[JSON.stringify(rgb)];
  }

  function rgb2xyz(rgb) {
    var r = rgb[0] / 255,
        g = rgb[1] / 255,
        b = rgb[2] / 255;

    // assume sRGB
    r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
    g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
    b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

    var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
    var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
    var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

    return [x * 100, y *100, z * 100];
  }

  function rgb2lab(rgb) {
    var xyz = rgb2xyz(rgb),
          x = xyz[0],
          y = xyz[1],
          z = xyz[2],
          l, a, b;

    x /= 95.047;
    y /= 100;
    z /= 108.883;

    x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
    y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
    z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);

    l = (116 * y) - 16;
    a = 500 * (x - y);
    b = 200 * (y - z);

    return [l, a, b];
  }

  function rgb2lch(args) {
    return lab2lch(rgb2lab(args));
  }

  function hsl2rgb(hsl) {
    var h = hsl[0] / 360,
        s = hsl[1] / 100,
        l = hsl[2] / 100,
        t1, t2, t3, rgb, val;

    if (s == 0) {
      val = l * 255;
      return [val, val, val];
    }

    if (l < 0.5)
      t2 = l * (1 + s);
    else
      t2 = l + s - l * s;
    t1 = 2 * l - t2;

    rgb = [0, 0, 0];
    for (var i = 0; i < 3; i++) {
      t3 = h + 1 / 3 * - (i - 1);
      t3 < 0 && t3++;
      t3 > 1 && t3--;

      if (6 * t3 < 1)
        val = t1 + (t2 - t1) * 6 * t3;
      else if (2 * t3 < 1)
        val = t2;
      else if (3 * t3 < 2)
        val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
      else
        val = t1;

      rgb[i] = val * 255;
    }

    return rgb;
  }

  function hsl2hsv(hsl) {
    var h = hsl[0],
        s = hsl[1] / 100,
        l = hsl[2] / 100,
        sv, v;

    if(l === 0) {
        // no need to do calc on black
        // also avoids divide by 0 error
        return [0, 0, 0];
    }

    l *= 2;
    s *= (l <= 1) ? l : 2 - l;
    v = (l + s) / 2;
    sv = (2 * s) / (l + s);
    return [h, sv * 100, v * 100];
  }

  function hsl2hwb(args) {
    return rgb2hwb(hsl2rgb(args));
  }

  function hsl2cmyk(args) {
    return rgb2cmyk(hsl2rgb(args));
  }

  function hsl2keyword(args) {
    return rgb2keyword(hsl2rgb(args));
  }


  function hsv2rgb(hsv) {
    var h = hsv[0] / 60,
        s = hsv[1] / 100,
        v = hsv[2] / 100,
        hi = Math.floor(h) % 6;

    var f = h - Math.floor(h),
        p = 255 * v * (1 - s),
        q = 255 * v * (1 - (s * f)),
        t = 255 * v * (1 - (s * (1 - f))),
        v = 255 * v;

    switch(hi) {
      case 0:
        return [v, t, p];
      case 1:
        return [q, v, p];
      case 2:
        return [p, v, t];
      case 3:
        return [p, q, v];
      case 4:
        return [t, p, v];
      case 5:
        return [v, p, q];
    }
  }

  function hsv2hsl(hsv) {
    var h = hsv[0],
        s = hsv[1] / 100,
        v = hsv[2] / 100,
        sl, l;

    l = (2 - s) * v;
    sl = s * v;
    sl /= (l <= 1) ? l : 2 - l;
    sl = sl || 0;
    l /= 2;
    return [h, sl * 100, l * 100];
  }

  function hsv2hwb(args) {
    return rgb2hwb(hsv2rgb(args))
  }

  function hsv2cmyk(args) {
    return rgb2cmyk(hsv2rgb(args));
  }

  function hsv2keyword(args) {
    return rgb2keyword(hsv2rgb(args));
  }

  // http://dev.w3.org/csswg/css-color/#hwb-to-rgb
  function hwb2rgb(hwb) {
    var h = hwb[0] / 360,
        wh = hwb[1] / 100,
        bl = hwb[2] / 100,
        ratio = wh + bl,
        i, v, f, n;

    // wh + bl cant be > 1
    if (ratio > 1) {
      wh /= ratio;
      bl /= ratio;
    }

    i = Math.floor(6 * h);
    v = 1 - bl;
    f = 6 * h - i;
    if ((i & 0x01) != 0) {
      f = 1 - f;
    }
    n = wh + f * (v - wh);  // linear interpolation

    switch (i) {
      default:
      case 6:
      case 0: r = v; g = n; b = wh; break;
      case 1: r = n; g = v; b = wh; break;
      case 2: r = wh; g = v; b = n; break;
      case 3: r = wh; g = n; b = v; break;
      case 4: r = n; g = wh; b = v; break;
      case 5: r = v; g = wh; b = n; break;
    }

    return [r * 255, g * 255, b * 255];
  }

  function hwb2hsl(args) {
    return rgb2hsl(hwb2rgb(args));
  }

  function hwb2hsv(args) {
    return rgb2hsv(hwb2rgb(args));
  }

  function hwb2cmyk(args) {
    return rgb2cmyk(hwb2rgb(args));
  }

  function hwb2keyword(args) {
    return rgb2keyword(hwb2rgb(args));
  }

  function cmyk2rgb(cmyk) {
    var c = cmyk[0] / 100,
        m = cmyk[1] / 100,
        y = cmyk[2] / 100,
        k = cmyk[3] / 100,
        r, g, b;

    r = 1 - Math.min(1, c * (1 - k) + k);
    g = 1 - Math.min(1, m * (1 - k) + k);
    b = 1 - Math.min(1, y * (1 - k) + k);
    return [r * 255, g * 255, b * 255];
  }

  function cmyk2hsl(args) {
    return rgb2hsl(cmyk2rgb(args));
  }

  function cmyk2hsv(args) {
    return rgb2hsv(cmyk2rgb(args));
  }

  function cmyk2hwb(args) {
    return rgb2hwb(cmyk2rgb(args));
  }

  function cmyk2keyword(args) {
    return rgb2keyword(cmyk2rgb(args));
  }


  function xyz2rgb(xyz) {
    var x = xyz[0] / 100,
        y = xyz[1] / 100,
        z = xyz[2] / 100,
        r, g, b;

    r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
    g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
    b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

    // assume sRGB
    r = r > 0.0031308 ? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
      : r = (r * 12.92);

    g = g > 0.0031308 ? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
      : g = (g * 12.92);

    b = b > 0.0031308 ? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
      : b = (b * 12.92);

    r = Math.min(Math.max(0, r), 1);
    g = Math.min(Math.max(0, g), 1);
    b = Math.min(Math.max(0, b), 1);

    return [r * 255, g * 255, b * 255];
  }

  function xyz2lab(xyz) {
    var x = xyz[0],
        y = xyz[1],
        z = xyz[2],
        l, a, b;

    x /= 95.047;
    y /= 100;
    z /= 108.883;

    x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + (16 / 116);
    y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + (16 / 116);
    z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + (16 / 116);

    l = (116 * y) - 16;
    a = 500 * (x - y);
    b = 200 * (y - z);

    return [l, a, b];
  }

  function xyz2lch(args) {
    return lab2lch(xyz2lab(args));
  }

  function lab2xyz(lab) {
    var l = lab[0],
        a = lab[1],
        b = lab[2],
        x, y, z, y2;

    if (l <= 8) {
      y = (l * 100) / 903.3;
      y2 = (7.787 * (y / 100)) + (16 / 116);
    } else {
      y = 100 * Math.pow((l + 16) / 116, 3);
      y2 = Math.pow(y / 100, 1/3);
    }

    x = x / 95.047 <= 0.008856 ? x = (95.047 * ((a / 500) + y2 - (16 / 116))) / 7.787 : 95.047 * Math.pow((a / 500) + y2, 3);

    z = z / 108.883 <= 0.008859 ? z = (108.883 * (y2 - (b / 200) - (16 / 116))) / 7.787 : 108.883 * Math.pow(y2 - (b / 200), 3);

    return [x, y, z];
  }

  function lab2lch(lab) {
    var l = lab[0],
        a = lab[1],
        b = lab[2],
        hr, h, c;

    hr = Math.atan2(b, a);
    h = hr * 360 / 2 / Math.PI;
    if (h < 0) {
      h += 360;
    }
    c = Math.sqrt(a * a + b * b);
    return [l, c, h];
  }

  function lab2rgb(args) {
    return xyz2rgb(lab2xyz(args));
  }

  function lch2lab(lch) {
    var l = lch[0],
        c = lch[1],
        h = lch[2],
        a, b, hr;

    hr = h / 360 * 2 * Math.PI;
    a = c * Math.cos(hr);
    b = c * Math.sin(hr);
    return [l, a, b];
  }

  function lch2xyz(args) {
    return lab2xyz(lch2lab(args));
  }

  function lch2rgb(args) {
    return lab2rgb(lch2lab(args));
  }

  function keyword2rgb(keyword) {
    return cssKeywords[keyword];
  }

  function keyword2hsl(args) {
    return rgb2hsl(keyword2rgb(args));
  }

  function keyword2hsv(args) {
    return rgb2hsv(keyword2rgb(args));
  }

  function keyword2hwb(args) {
    return rgb2hwb(keyword2rgb(args));
  }

  function keyword2cmyk(args) {
    return rgb2cmyk(keyword2rgb(args));
  }

  function keyword2lab(args) {
    return rgb2lab(keyword2rgb(args));
  }

  function keyword2xyz(args) {
    return rgb2xyz(keyword2rgb(args));
  }

  var cssKeywords = {
    aliceblue:  [240,248,255],
    antiquewhite: [250,235,215],
    aqua: [0,255,255],
    aquamarine: [127,255,212],
    azure:  [240,255,255],
    beige:  [245,245,220],
    bisque: [255,228,196],
    black:  [0,0,0],
    blanchedalmond: [255,235,205],
    blue: [0,0,255],
    blueviolet: [138,43,226],
    brown:  [165,42,42],
    burlywood:  [222,184,135],
    cadetblue:  [95,158,160],
    chartreuse: [127,255,0],
    chocolate:  [210,105,30],
    coral:  [255,127,80],
    cornflowerblue: [100,149,237],
    cornsilk: [255,248,220],
    crimson:  [220,20,60],
    cyan: [0,255,255],
    darkblue: [0,0,139],
    darkcyan: [0,139,139],
    darkgoldenrod:  [184,134,11],
    darkgray: [169,169,169],
    darkgreen:  [0,100,0],
    darkgrey: [169,169,169],
    darkkhaki:  [189,183,107],
    darkmagenta:  [139,0,139],
    darkolivegreen: [85,107,47],
    darkorange: [255,140,0],
    darkorchid: [153,50,204],
    darkred:  [139,0,0],
    darksalmon: [233,150,122],
    darkseagreen: [143,188,143],
    darkslateblue:  [72,61,139],
    darkslategray:  [47,79,79],
    darkslategrey:  [47,79,79],
    darkturquoise:  [0,206,209],
    darkviolet: [148,0,211],
    deeppink: [255,20,147],
    deepskyblue:  [0,191,255],
    dimgray:  [105,105,105],
    dimgrey:  [105,105,105],
    dodgerblue: [30,144,255],
    firebrick:  [178,34,34],
    floralwhite:  [255,250,240],
    forestgreen:  [34,139,34],
    fuchsia:  [255,0,255],
    gainsboro:  [220,220,220],
    ghostwhite: [248,248,255],
    gold: [255,215,0],
    goldenrod:  [218,165,32],
    gray: [128,128,128],
    green:  [0,128,0],
    greenyellow:  [173,255,47],
    grey: [128,128,128],
    honeydew: [240,255,240],
    hotpink:  [255,105,180],
    indianred:  [205,92,92],
    indigo: [75,0,130],
    ivory:  [255,255,240],
    khaki:  [240,230,140],
    lavender: [230,230,250],
    lavenderblush:  [255,240,245],
    lawngreen:  [124,252,0],
    lemonchiffon: [255,250,205],
    lightblue:  [173,216,230],
    lightcoral: [240,128,128],
    lightcyan:  [224,255,255],
    lightgoldenrodyellow: [250,250,210],
    lightgray:  [211,211,211],
    lightgreen: [144,238,144],
    lightgrey:  [211,211,211],
    lightpink:  [255,182,193],
    lightsalmon:  [255,160,122],
    lightseagreen:  [32,178,170],
    lightskyblue: [135,206,250],
    lightslategray: [119,136,153],
    lightslategrey: [119,136,153],
    lightsteelblue: [176,196,222],
    lightyellow:  [255,255,224],
    lime: [0,255,0],
    limegreen:  [50,205,50],
    linen:  [250,240,230],
    magenta:  [255,0,255],
    maroon: [128,0,0],
    mediumaquamarine: [102,205,170],
    mediumblue: [0,0,205],
    mediumorchid: [186,85,211],
    mediumpurple: [147,112,219],
    mediumseagreen: [60,179,113],
    mediumslateblue:  [123,104,238],
    mediumspringgreen:  [0,250,154],
    mediumturquoise:  [72,209,204],
    mediumvioletred:  [199,21,133],
    midnightblue: [25,25,112],
    mintcream:  [245,255,250],
    mistyrose:  [255,228,225],
    moccasin: [255,228,181],
    navajowhite:  [255,222,173],
    navy: [0,0,128],
    oldlace:  [253,245,230],
    olive:  [128,128,0],
    olivedrab:  [107,142,35],
    orange: [255,165,0],
    orangered:  [255,69,0],
    orchid: [218,112,214],
    palegoldenrod:  [238,232,170],
    palegreen:  [152,251,152],
    paleturquoise:  [175,238,238],
    palevioletred:  [219,112,147],
    papayawhip: [255,239,213],
    peachpuff:  [255,218,185],
    peru: [205,133,63],
    pink: [255,192,203],
    plum: [221,160,221],
    powderblue: [176,224,230],
    purple: [128,0,128],
    rebeccapurple: [102, 51, 153],
    red:  [255,0,0],
    rosybrown:  [188,143,143],
    royalblue:  [65,105,225],
    saddlebrown:  [139,69,19],
    salmon: [250,128,114],
    sandybrown: [244,164,96],
    seagreen: [46,139,87],
    seashell: [255,245,238],
    sienna: [160,82,45],
    silver: [192,192,192],
    skyblue:  [135,206,235],
    slateblue:  [106,90,205],
    slategray:  [112,128,144],
    slategrey:  [112,128,144],
    snow: [255,250,250],
    springgreen:  [0,255,127],
    steelblue:  [70,130,180],
    tan:  [210,180,140],
    teal: [0,128,128],
    thistle:  [216,191,216],
    tomato: [255,99,71],
    turquoise:  [64,224,208],
    violet: [238,130,238],
    wheat:  [245,222,179],
    white:  [255,255,255],
    whitesmoke: [245,245,245],
    yellow: [255,255,0],
    yellowgreen:  [154,205,50]
  };

  var reverseKeywords = {};
  for (var key in cssKeywords) {
    reverseKeywords[JSON.stringify(cssKeywords[key])] = key;
  }

  var convert = function() {
     return new Converter();
  };

  for (var func in conversions) {
    // export Raw versions
    convert[func + "Raw"] =  (function(func) {
      // accept array or plain args
      return function(arg) {
        if (typeof arg == "number")
          arg = Array.prototype.slice.call(arguments);
        return conversions[func](arg);
      }
    })(func);

    var pair = /(\w+)2(\w+)/.exec(func),
        from = pair[1],
        to = pair[2];

    // export rgb2hsl and ["rgb"]["hsl"]
    convert[from] = convert[from] || {};

    convert[from][to] = convert[func] = (function(func) { 
      return function(arg) {
        if (typeof arg == "number")
          arg = Array.prototype.slice.call(arguments);
        
        var val = conversions[func](arg);
        if (typeof val == "string" || val === undefined)
          return val; // keyword

        for (var i = 0; i < val.length; i++)
          val[i] = Math.round(val[i]);
        return val;
      }
    })(func);
  }


  /* Converter does lazy conversion and caching */
  var Converter = function() {
     this.convs = {};
  };

  /* Either get the values for a space or
    set the values for a space, depending on args */
  Converter.prototype.routeSpace = function(space, args) {
     var values = args[0];
     if (values === undefined) {
        // color.rgb()
        return this.getValues(space);
     }
     // color.rgb(10, 10, 10)
     if (typeof values == "number") {
        values = Array.prototype.slice.call(args);        
     }

     return this.setValues(space, values);
  };
    
  /* Set the values for a space, invalidating cache */
  Converter.prototype.setValues = function(space, values) {
     this.space = space;
     this.convs = {};
     this.convs[space] = values;
     return this;
  };

  /* Get the values for a space. If there's already
    a conversion for the space, fetch it, otherwise
    compute it */
  Converter.prototype.getValues = function(space) {
     var vals = this.convs[space];
     if (!vals) {
        var fspace = this.space,
            from = this.convs[fspace];
        vals = convert[fspace][space](from);

        this.convs[space] = vals;
     }
    return vals;
  };

  ["rgb", "hsl", "hsv", "cmyk", "keyword"].forEach(function(space) {
     Converter.prototype[space] = function(vals) {
        return this.routeSpace(space, arguments);
     };
  });

  var colorConvert = convert;

  var parseColor = function (cstr) {
      var m, conv, parts, alpha;
      if (m = /^((?:rgb|hs[lv]|cmyk|xyz|lab)a?)\s*\(([^\)]*)\)/.exec(cstr)) {
          var name = m[1];
          var base = name.replace(/a$/, '');
          var size = base === 'cmyk' ? 4 : 3;
          conv = colorConvert[base];
          
          parts = m[2].replace(/^\s+|\s+$/g, '')
              .split(/\s*,\s*/)
              .map(function (x, i) {
                  if (/%$/.test(x) && i === size) {
                      return parseFloat(x) / 100;
                  }
                  else if (/%$/.test(x)) {
                      return parseFloat(x);
                  }
                  return parseFloat(x);
              })
          ;
          if (name === base) parts.push(1);
          alpha = parts[size] === undefined ? 1 : parts[size];
          parts = parts.slice(0, size);
          
          conv[base] = function () { return parts };
      }
      else if (/^#[A-Fa-f0-9]+$/.test(cstr)) {
          var base = cstr.replace(/^#/,'');
          var size = base.length;
          conv = colorConvert.rgb;
          parts = base.split(size === 3 ? /(.)/ : /(..)/);
          parts = parts.filter(Boolean)
              .map(function (x) {
                  if (size === 3) {
                      return parseInt(x + x, 16);
                  }
                  else {
                      return parseInt(x, 16)
                  }
              })
          ;
          alpha = 1;
          conv.rgb = function () { return parts };
          if (!parts[0]) parts[0] = 0;
          if (!parts[1]) parts[1] = 0;
          if (!parts[2]) parts[2] = 0;
      }
      else {
          conv = colorConvert.keyword;
          conv.keyword = function () { return cstr };
          parts = cstr;
          alpha = 1;
      }
      
      var res = {
          rgb: undefined,
          hsl: undefined,
          hsv: undefined,
          cmyk: undefined,
          keyword: undefined,
          hex: undefined
      };
      try { res.rgb = conv.rgb(parts); } catch (e) {}
      try { res.hsl = conv.hsl(parts); } catch (e) {}
      try { res.hsv = conv.hsv(parts); } catch (e) {}
      try { res.cmyk = conv.cmyk(parts); } catch (e) {}
      try { res.keyword = conv.keyword(parts); } catch (e) {}
      
      if (res.rgb) res.hex = '#' + res.rgb.map(function (x) {
          var s = x.toString(16);
          if (s.length === 1) return '0' + s;
          return s;
      }).join('');
      
      if (res.rgb) res.rgba = res.rgb.concat(alpha);
      if (res.hsl) res.hsla = res.hsl.concat(alpha);
      if (res.hsv) res.hsva = res.hsv.concat(alpha);
      if (res.cmyk) res.cmyka = res.cmyk.concat(alpha);
      
      return res;
  };

  function ownKeys$13(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$13(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$13(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$13(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function isStyle(style) {
    return style instanceof style$1.Style || style instanceof style$1.Image || style instanceof style$1.Fill || style instanceof style$1.Stroke || style instanceof style$1.Text || style instanceof Function;
  }

  function getStyleId(style) {
    if (isStyle(style)) {
      return style.id;
    }

    throw new Error('Illegal style argument');
  }
  function setStyleId(style, styleId) {
    if (isStyle(style)) {
      style.id = styleId;
      return style;
    }

    throw new Error('Illegal style argument');
  }
  function initializeStyle(style, defaultStyleId) {
    if (getStyleId(style) == null) {
      setStyleId(style, defaultStyleId || v4());
    }

    return style;
  }
  /**
   * @return {VlStyle[]}
   */

  function defaultStyle() {
    return [{
      fillColor: [255, 255, 255, 0.4],
      strokeColor: '#3399cc',
      strokeWidth: 1.25,
      imageRadius: 5
    }];
  }
  /**
   * @return {Object<GeometryType, VlStyle[]>}
   */

  function defaultEditStyle() {
    /** @type {Object<GeometryType, VlStyle[]>} */
    var styles = {};
    var white = [255, 255, 255, 1];
    var blue = [0, 153, 255, 1];
    var width = 3;
    styles[GeometryType.LINE_STRING] = [{
      strokeColor: white,
      strokeWidth: width + 2
    }, {
      strokeColor: blue,
      strokeWidth: width
    }];
    styles[GeometryType.MULTI_LINE_STRING] = styles[GeometryType.LINE_STRING];
    styles[GeometryType.POLYGON] = [{
      fillColor: [255, 255, 255, 0.5]
    }].concat(styles[GeometryType.LINE_STRING]);
    styles[GeometryType.MULTI_POLYGON] = styles[GeometryType.POLYGON];
    styles[GeometryType.CIRCLE] = styles[GeometryType.POLYGON].concat(styles[GeometryType.LINE_STRING]);
    styles[GeometryType.POINT] = [{
      imageRadius: width * 2,
      fillColor: blue,
      strokeColor: white,
      strokeWidth: width / 2,
      zIndex: Infinity
    }];
    styles[GeometryType.MULTI_POINT] = styles[GeometryType.POINT];
    styles[GeometryType.GEOMETRY_COLLECTION] = styles[GeometryType.POLYGON].concat(styles[GeometryType.LINE_STRING], styles[GeometryType.POINT]);
    return styles;
  }

  var isEmpty = function isEmpty(x) {
    if (x == null) return true;
    if (typeof x === 'number') return false;
    return (typeof x === 'string' || Array.isArray(x)) && !x.length || !Object.keys(x).length;
  };
  /**
   * @param {VlStyle} vlStyle
   * @param {function} [geomReader=identity]
   * @return {Style|undefined}
   */


  function createStyle(vlStyle) {
    var geomReader = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity$2;
    if (isEmpty(vlStyle)) return;
    var olStyle = {
      text: createTextStyle(vlStyle, 'text'),
      fill: createFillStyle(vlStyle, 'fill'),
      stroke: createStrokeStyle(vlStyle, 'stroke'),
      image: createImageStyle(vlStyle, 'image'),
      geometry: createGeomStyle(vlStyle, geomReader),
      zIndex: vlStyle.zIndex,
      renderer: vlStyle.renderer
    };

    if (!isEmpty(olStyle)) {
      return new style$1.Style(olStyle);
    }
  }
  /**
   * @param {*} color
   * @returns {*}
   */

  function normalizeColor(color) {
    var c = color;

    if (typeof color === 'string') {
      c = parseColor(color).rgba;
    }

    return c;
  }
  /**
   * @param {VlStyle} vlStyle
   * @param {string} [prefix]
   * @returns {Fill|undefined}
   */

  function createFillStyle(vlStyle) {
    var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    var prefixKey = addPrefix(prefix); // check on already compiled style existence

    if (vlStyle[prefixKey()] instanceof style$1.Fill) return vlStyle[prefixKey()];
    var keys = ['color'].reduce(function (keys, key) {
      return _objectSpread$13(_objectSpread$13({}, keys), {}, _defineProperty$1({}, prefixKey(key), key));
    }, {});
    var fillStyle = reduce(vlStyle, function (style, value, name) {
      if (!keys[name] || value == null) return style;

      switch (keys[name]) {
        case 'color':
          value = normalizeColor(value);
          break;
      }

      style[keys[name]] = value;
      return style;
    }, {});

    if (!isEmpty(fillStyle)) {
      return new style$1.Fill(fillStyle);
    }
  }
  /**
   * @param {VlStyle} vlStyle
   * @param {string} [prefix]
   * @returns {Stroke|undefined}
   */

  function createStrokeStyle(vlStyle) {
    var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    var prefixKey = addPrefix(prefix);
    if (vlStyle[prefixKey()] instanceof style$1.Stroke) return vlStyle[prefixKey()];
    var keys = ['color', 'width', 'miterLimit', 'lineCap', 'lineJoin', 'lineDash', 'lineDashOffset'].reduce(function (keys, key) {
      return _objectSpread$13(_objectSpread$13({}, keys), {}, _defineProperty$1({}, prefixKey(key), key));
    }, {});
    var strokeStyle = reduce(vlStyle, function (style, value, name) {
      if (!keys[name] || value == null) return style;

      switch (keys[name]) {
        case 'color':
          value = normalizeColor(value);
          break;
      }

      style[keys[name]] = value;
      return style;
    }, {});

    if (!isEmpty(strokeStyle)) {
      return new style$1.Stroke(strokeStyle);
    }
  }
  /**
   * @param {VlStyle} vlStyle
   * @param {string} [prefix]
   * @returns {Image|undefined}
   * @todo split to separate circle, regShape, Icon
   */

  function createImageStyle(vlStyle) {
    var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    var prefixKey = addPrefix(prefix);

    if (isEmpty(vlStyle[prefixKey('src')]) && isEmpty(vlStyle.image) && isEmpty(vlStyle[prefixKey('points')]) && !isNumeric$1(vlStyle[prefixKey('radius')])) {
      return;
    }

    if (vlStyle.image instanceof style$1.Image) return vlStyle.image;
    var imageStyle, Ctor;

    if (!isEmpty(vlStyle[prefixKey('src')]) || !isEmpty(vlStyle.image)) {
      // icon construction
      Ctor = style$1.Icon; // then create Icon options

      imageStyle = {
        anchor: vlStyle[prefixKey('anchor')],
        anchorOrigin: vlStyle[prefixKey('anchorOrigin')],
        anchorXUnits: vlStyle[prefixKey('anchorXUnits')],
        anchorYUnits: vlStyle[prefixKey('anchorYUnits')],
        color: vlStyle[prefixKey('color')],
        offset: vlStyle[prefixKey('offset')],
        offsetOrigin: vlStyle[prefixKey('offsetOrigin')],
        size: vlStyle[prefixKey('size')],
        img: vlStyle.image,
        imgSize: vlStyle[prefixKey('imgSize')],
        src: vlStyle[prefixKey('src')],
        crossOrigin: vlStyle[prefixKey('crossOrigin')]
      };
    } else if (vlStyle[prefixKey('points')] != null) {
      // regular shape construction
      Ctor = style$1.RegularShape; // create RegularShape options

      imageStyle = {
        points: vlStyle[prefixKey('points')],
        radius: vlStyle[prefixKey('radius')],
        radius1: vlStyle[prefixKey('radius1')],
        radius2: vlStyle[prefixKey('radius2')],
        angle: vlStyle[prefixKey('angle')]
      };
    } else {
      // circle construction
      Ctor = style$1.Circle; // create Circle options

      imageStyle = {
        radius: vlStyle[prefixKey('radius')]
      };
    }

    imageStyle = _objectSpread$13(_objectSpread$13({}, imageStyle), {}, {
      fill: createFillStyle(vlStyle, prefixKey('fill')),
      stroke: createStrokeStyle(vlStyle, prefixKey('stroke')),
      opacity: vlStyle[prefixKey('opacity')],
      scale: vlStyle[prefixKey('scale')],
      rotation: vlStyle[prefixKey('rotation')],
      rotateWithView: vlStyle[prefixKey('rotateWithView')],
      displacement: vlStyle[prefixKey('displacement')]
    });

    if (!isEmpty(imageStyle)) {
      return new Ctor(imageStyle);
    }
  }
  /**
   * @param {VlStyle} vlStyle
   * @param {string} [prefix]
   * @returns {Text|undefined}
   */

  function createTextStyle(vlStyle) {
    var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    if (vlStyle.text == null) return;
    if (vlStyle.text instanceof style$1.Text) return vlStyle.text;
    var prefixKey = addPrefix(prefix);
    var textStyle = {
      text: vlStyle.text,
      textAlign: vlStyle.textAlign,
      textBaseline: vlStyle.textBaseline,
      font: vlStyle[prefixKey('font')],
      scale: vlStyle[prefixKey('scale')],
      offsetX: vlStyle[prefixKey('offsetX')],
      offsetY: vlStyle[prefixKey('offsetY')],
      rotation: vlStyle[prefixKey('rotation')],
      rotateWithView: vlStyle[prefixKey('rotateWithView')],
      padding: vlStyle[prefixKey('padding')],
      maxAngle: vlStyle[prefixKey('maxAngle')],
      overflow: vlStyle[prefixKey('overflow')],
      placement: vlStyle[prefixKey('placement')],
      fill: createFillStyle(vlStyle, prefixKey('fill')),
      stroke: createStrokeStyle(vlStyle, prefixKey('stroke')),
      backgroundFill: createFillStyle(vlStyle, prefixKey('backgroundFill')),
      backgroundStroke: createStrokeStyle(vlStyle, prefixKey('backgroundStroke'))
    };

    if (!isEmpty(textStyle)) {
      return new style$1.Text(textStyle);
    }
  }
  /**
   * @param {VlStyle} vlStyle
   * @param {function} [geomReader=identity]
   * @return {Geometry|Object|function|undefined}
   */

  function createGeomStyle(vlStyle) {
    var geomReader = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity$2;

    if (isFunction$1(vlStyle.geom)) {
      return function __styleGeomFunc(feature) {
        return vlStyle.geom(feature);
      };
    }

    if (vlStyle.geom instanceof geom.Geometry) {
      return vlStyle.geom;
    }

    if (vlStyle.geom) {
      return geomReader(vlStyle.geom);
    }

    return null;
  }
  function dumpStyle(olStyle) {
    var geomWriter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity$2;
    if (!olStyle || isFunction$1(olStyle)) return;
    return _objectSpread$13(_objectSpread$13(_objectSpread$13(_objectSpread$13(_objectSpread$13(_objectSpread$13({}, dumpFillStyle(olStyle.getFill(), 'fill')), dumpStrokeStyle(olStyle.getStroke(), 'stroke')), dumpImageStyle(olStyle.getImage(), 'image')), dumpTextStyle(olStyle.getText(), 'text')), dumpGeomStyle(olStyle.getGeometry(), geomWriter)), {}, {
      zIndex: olStyle.getZIndex() // renderer: olStyle.getRenderer(),

    });
  }
  function dumpFillStyle(fillStyle) {
    var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    if (!fillStyle) return {};
    var prefixKey = addPrefix(prefix);
    return _defineProperty$1({}, prefixKey('color'), fillStyle.getColor());
  }
  function dumpStrokeStyle(strokeStyle) {
    var _ref2;

    var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    if (!strokeStyle) return {};
    var prefixKey = addPrefix(prefix);
    return _ref2 = {}, _defineProperty$1(_ref2, prefixKey('color'), strokeStyle.getColor()), _defineProperty$1(_ref2, prefixKey('width'), strokeStyle.getWidth()), _defineProperty$1(_ref2, prefixKey('miterLimit'), strokeStyle.getMiterLimit()), _defineProperty$1(_ref2, prefixKey('lineCap'), strokeStyle.getLineCap()), _defineProperty$1(_ref2, prefixKey('lineJoin'), strokeStyle.getLineJoin()), _defineProperty$1(_ref2, prefixKey('lineDash'), strokeStyle.getLineDash()), _defineProperty$1(_ref2, prefixKey('lineDashOffset'), strokeStyle.getLineDashOffset()), _ref2;
  }
  function dumpImageStyle(imageStyle) {
    var _common, _objectSpread4, _objectSpread6;

    var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    if (!imageStyle) return {};
    var prefixKey = addPrefix(prefix);
    var common = (_common = {}, _defineProperty$1(_common, prefixKey('opacity'), imageStyle.getOpacity()), _defineProperty$1(_common, prefixKey('scale'), imageStyle.getScale()), _defineProperty$1(_common, prefixKey('rotation'), imageStyle.getRotation()), _defineProperty$1(_common, prefixKey('rotateWithView'), imageStyle.getRotateWithView()), _defineProperty$1(_common, prefixKey('displacement'), imageStyle.getDisplacement()), _common);

    switch (true) {
      case imageStyle instanceof style$1.Icon:
        return _objectSpread$13(_objectSpread$13({}, common), {}, (_objectSpread4 = {}, _defineProperty$1(_objectSpread4, prefixKey('anchor'), imageStyle.anchor_.slice()), _defineProperty$1(_objectSpread4, prefixKey('anchorOrigin'), imageStyle.anchorOrigin_), _defineProperty$1(_objectSpread4, prefixKey('anchorXUnits'), imageStyle.anchorXUnits_), _defineProperty$1(_objectSpread4, prefixKey('anchorYUnits'), imageStyle.anchorYUnits_), _defineProperty$1(_objectSpread4, prefixKey('color'), isArray$2(imageStyle.getColor()) ? imageStyle.getColor().slice() : imageStyle.getColor()), _defineProperty$1(_objectSpread4, prefixKey('offset'), imageStyle.offset_.slice()), _defineProperty$1(_objectSpread4, prefixKey('offsetOrigin'), imageStyle.offsetOrigin_), _defineProperty$1(_objectSpread4, prefixKey('size'), isArray$2(imageStyle.getSize()) ? imageStyle.getSize().slice() : imageStyle.getSize()), _defineProperty$1(_objectSpread4, prefixKey('src'), imageStyle.getSrc()), _defineProperty$1(_objectSpread4, prefixKey('crossOrigin'), imageStyle.crossOrigin_), _objectSpread4));

      case imageStyle instanceof style$1.Circle:
        return _objectSpread$13(_objectSpread$13(_objectSpread$13(_objectSpread$13({}, common), dumpFillStyle(imageStyle.getFill(), prefixKey('fill'))), dumpStrokeStyle(imageStyle.getStroke(), prefixKey('stroke'))), {}, _defineProperty$1({}, prefixKey('radius'), imageStyle.getRadius()));

      case imageStyle instanceof style$1.RegularShape:
        return _objectSpread$13(_objectSpread$13(_objectSpread$13(_objectSpread$13({}, common), dumpFillStyle(imageStyle.getFill(), prefixKey('fill'))), dumpStrokeStyle(imageStyle.getStroke(), prefixKey('stroke'))), {}, (_objectSpread6 = {}, _defineProperty$1(_objectSpread6, prefixKey('points'), imageStyle.getPoints()), _defineProperty$1(_objectSpread6, prefixKey('radius'), imageStyle.getRadius()), _defineProperty$1(_objectSpread6, prefixKey('radius2'), imageStyle.getRadius2()), _defineProperty$1(_objectSpread6, prefixKey('angle'), imageStyle.getAngle()), _objectSpread6));

      default:
        return _objectSpread$13({}, common);
    }
  }
  function dumpTextStyle(textStyle) {
    var _objectSpread7;

    var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    if (!textStyle) return {};
    var prefixKey = addPrefix(prefix);
    return filter$1(_objectSpread$13(_objectSpread$13(_objectSpread$13(_objectSpread$13((_objectSpread7 = {
      text: textStyle.getText(),
      textAlign: textStyle.getTextAlign(),
      textBaseline: textStyle.getTextBaseline()
    }, _defineProperty$1(_objectSpread7, prefixKey('font'), textStyle.getFont()), _defineProperty$1(_objectSpread7, prefixKey('scale'), textStyle.getScale()), _defineProperty$1(_objectSpread7, prefixKey('rotation'), textStyle.getRotation()), _defineProperty$1(_objectSpread7, prefixKey('offsetX'), textStyle.getOffsetX()), _defineProperty$1(_objectSpread7, prefixKey('offsetY'), textStyle.getOffsetY()), _defineProperty$1(_objectSpread7, prefixKey('rotateWithView'), textStyle.getRotateWithView()), _defineProperty$1(_objectSpread7, prefixKey('padding'), textStyle.getPadding()), _defineProperty$1(_objectSpread7, prefixKey('maxAngle'), textStyle.getMaxAngle()), _defineProperty$1(_objectSpread7, prefixKey('overflow'), textStyle.getOverflow()), _defineProperty$1(_objectSpread7, prefixKey('placement'), textStyle.getPlacement()), _objectSpread7), dumpFillStyle(textStyle.getFill(), prefixKey('fill'))), dumpStrokeStyle(textStyle.getStroke(), prefixKey('stroke'))), dumpFillStyle(textStyle.getBackgroundFill(), prefixKey('backgroundFill'))), dumpStrokeStyle(textStyle.getBackgroundStroke(), prefixKey('backgroundStroke'))), function (value) {
      return value != null;
    });
  }
  function dumpGeomStyle(geom) {
    var geomWriter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity$2;
    if (!geom) return {};
    return {
      geom: geomWriter(geom)
    };
  }
  /**
   * @typedef {
   *            module:ol/style/Style~Style |
   *            module:ol/style/Image~ImageStyle |
   *            module:ol/style/Fill~Fill |
   *            module:ol/style/Stroke~Stroke |
   *            module:ol/style/Text~Text |
   *            module:ol/style/Style~StyleFunction
   *          } OlAllStyle
   */

  /**
   * @typedef {Object} VlStyle
   *
   * Shared
   * @property {string|number[]|undefined} fillColor
   * @property {string|number[]|undefined} strokeColor
   * @property {number|undefined} strokeWidth
   * @property {number|undefined} strokeMiterLimit
   * @property {number[]|undefined} strokeLineDash
   * @property {number|undefined} strokeLineDashOffset
   * @property {string|undefined} strokeLineCap
   * @property {string|undefined} strokeLineJoin
   * @property {number|undefined} zIndex
   * @property {Fill|undefined} fill
   * @property {Stroke|undefined} stroke
   * @property {RenderFunction|undefined} renderer
   *
   * Text only
   * @property {string|Text|undefined} text
   * @property {string|undefined} textFont
   * @property {number|string|undefined} textFontSize
   * @property {string|undefined} textFontWeight
   * @property {string|number[]|undefined} textFillColor
   * @property {string|number[]|undefined} textStrokeColor
   * @property {number|undefined} textStrokeWidth
   * @property {number|undefined} textStrokeMiterLimit
   * @property {number[]|undefined} textStrokeLineDash
   * @property {number|undefined} textStrokeLineDashOffset
   * @property {string|undefined} textStrokeLineCap
   * @property {string|undefined} textStrokeLineJoin
   * @property {number|undefined} textScale
   * @property {string|undefined} textAlign
   * @property {number|undefined} textRotation
   * @property {number|undefined} textOffsetX
   * @property {number|undefined} textOffsetY
   * @property {Stroke|undefined} textStroke
   * @property {Fill|undefined} textFill
   * @property {boolean|undefined} textRotateWithView
   * @property {number[]|undefined} textPadding
   * @property {number|undefined} textMaxAngle
   * @property {boolean|undefined} textOverflow
   * @property {string|undefined} textPlacement
   * @property {string|undefined} textBaseline
   * @property {Fill|undefined} textBackgroundFillColor
   * @property {Stroke|undefined} textBackgroundStrokeColor
   * @property {Stroke|undefined} textBackgroundStrokeWidth
   * @property {number|undefined} textBackgroundStrokeMiterLimit
   * @property {Stroke|undefined} textBackgroundStrokeLineDash
   * @property {number|undefined} textBackgroundStrokeLineDashOffset
   * @property {Stroke|undefined} textBackgroundStrokeCap
   * @property {Stroke|undefined} textBackgroundStrokeJoin
   *
   * Image only
   * @property {Image|undefined} image
   * @property {string|undefined} imageSrc
   * @property {number[]|undefined} imageSize
   * @property {number[]|undefined} imageImgSize
   * @property {number|undefined} imageOffset
   * @property {number[]|undefined} imageAnchor
   * @property {string|undefined} imageAnchorXUnits
   * @property {string|undefined} imageAnchorYUnits
   * @property {number|undefined} imageScale
   * @property {number|undefined} imageRotation
   * @property {number|undefined} imageRadius
   * @property {number|undefined} imageRadius1
   * @property {number|undefined} imageRadius2
   * @property {number|undefined} imagePoints
   * @property {number|undefined} imageAngle
   * @property {number|undefined} imageOpacity
   * @property {string|number[]|undefined} imageFillColor
   * @property {string|number[]|undefined} imageStrokeColor
   * @property {number|undefined} imageStrokeWidth
   * @property {number|undefined} imageStrokeMiterLimit
   * @property {number[]|undefined} imageStrokeLineDash
   * @property {number|undefined} imageStrokeLineDashOffset
   * @property {string|undefined} imageStrokeLineCap
   * @property {string|undefined} imageStrokeLineJoin
   * @property {IconOrigin|undefined} imageAnchorOrigin
   * @property {ColorLike|undefined} imageColor
   * @property {IconOrigin|undefined} imageOffsetOrigin
   * @property {Stroke|undefined} imageStroke
   * @property {Fill|undefined} imageFill
   * @property {string|undefined} imageCrossOrigin
   * @property {boolean|undefined} imageRotateWithView
   * @property {number[]|undefined} imageDisplacement
   *
   * @property {Geometry|Object|function|undefined} geom Coordinates should be in map projection
   */

  function ownKeys$12(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$12(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$12(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$12(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  function _createSuper$2(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = _getPrototypeOf$1(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$1(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$1(this, result); }; }

  function _isNativeReflectConstruct$2() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
  /**
   * @param {Object} [options]
   * @return {GeoJSON}
   */

  function createGeoJsonFmt(options) {
    return new GeoJSON(options);
  }
  /**
   * @param [options]
   * @return {MVT}
   */

  function createMvtFmt(options) {
    return new format.MVT(options);
  }
  var CIRCLE_SERIALIZE_PROP = 'vl_circle';
  var STYLE_SERIALIZE_PROP = 'vl_style';

  var GeoJSON = /*#__PURE__*/function (_BaseGeoJSON) {
    _inherits$1(GeoJSON, _BaseGeoJSON);

    var _super = _createSuper$2(GeoJSON);

    function GeoJSON() {
      var _this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck$1(this, GeoJSON);

      _this = _super.call(this, options);
      _this.defaultDecimals = options.decimals != null && options.decimals > -1 ? options.decimals : undefined;
      _this.defaultStyleReader = options.styleReader || noop$1;
      _this.defaultStyleWriter = options.styleWriter || noop$1;
      return _this;
    }

    _createClass$1(GeoJSON, [{
      key: "adaptOptions",
      value: function adaptOptions() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        if (options.decimals != null && options.decimals < 0) {
          options.decimals = undefined;
        }

        return _get$1(_getPrototypeOf$1(GeoJSON.prototype), "adaptOptions", this).call(this, _objectSpread$12({
          decimals: this.defaultDecimals,
          styleReader: this.defaultStyleReader,
          styleWriter: this.defaultStyleWriter
        }, options));
      }
    }, {
      key: "writeGeometryObject",
      value: function writeGeometryObject(geometry, options) {
        options = this.adaptOptions(options);

        if (isCircleGeom(geometry)) {
          var center = geometry.getCenter().slice();
          var end = [center[0] + geometry.getRadius(), center[1]];
          var radius = sphere.getLength(new geom.LineString([center, end]), options.featureProjection);
          center = transformPoint(center, options.featureProjection, EPSG_4326);
          geometry = createCircularPolygon(center, radius);
          options.featureProjection = EPSG_4326;
        }

        return _get$1(_getPrototypeOf$1(GeoJSON.prototype), "writeGeometryObject", this).call(this, geometry, options);
      }
    }, {
      key: "writeFeatureObject",
      value: function writeFeatureObject(feature, options) {
        var _this2 = this;

        options = this.adaptOptions(options);
        /** @type {GeoJSONFeature} */

        var object = {
          type: 'Feature',
          geometry: null,
          properties: null
        };
        var id = feature.getId();

        if (id !== undefined) {
          object.id = id;
        }
        /* eslint-disable quote-props */


        var geometry = feature.getGeometry();

        if (geometry) {
          object.geometry = this.writeGeometryObject(geometry, options);

          if (isCircleGeom(geometry)) {
            object.properties = _objectSpread$12(_objectSpread$12({}, object.properties || {}), {}, _defineProperty$1({}, CIRCLE_SERIALIZE_PROP, {
              center: transformPoint(geometry.getCenter(), options.featureProjection, options.dataProjection),
              radius: transformDistance(geometry.getRadius(), options.featureProjection, options.dataProjection)
            }));
          }
        }

        var properties = feature.getProperties();
        delete properties[feature.getGeometryName()];

        if (!isEmpty$1(properties)) {
          object.properties = _objectSpread$12(_objectSpread$12({}, object.properties || {}), clonePlainObject(omit(properties, 'features')));

          if (isArray$2(properties.features)) {
            object.properties.features = map$1(properties.features, function (feature) {
              if (feature instanceof ol.Feature) {
                return _this2.writeFeatureObject(feature, options);
              }

              return feature;
            });
          }
        }

        var style = feature.getStyle();

        if (style && !isFunction$1(style)) {
          isArray$2(style) || (style = [style]);
          object.properties = _objectSpread$12(_objectSpread$12({}, object.properties || {}), {}, _defineProperty$1({}, STYLE_SERIALIZE_PROP, style.map(function (style) {
            return options.styleWriter(style, function (geometry) {
              return _this2.writeGeometryObject(geometry, options);
            });
          })));
        }
        /* eslint-enable quote-props */


        return object;
      }
    }, {
      key: "readFeatureFromObject",
      value: function readFeatureFromObject(object, options) {
        var _this3 = this;

        options = this.adaptOptions(options);
        /**
         * @type {GeoJSONFeature}
         */

        var geoJSONFeature;

        if (object.type === 'Feature') {
          geoJSONFeature = clonePlainObject(object);
        } else {
          geoJSONFeature = {
            type: 'Feature',
            geometry: clonePlainObject(object),
            properties: null
          };
        }

        var feature = new ol.Feature();
        /* eslint-disable dot-notation */

        if (geoJSONFeature.properties && geoJSONFeature.properties[CIRCLE_SERIALIZE_PROP]) {
          options.circle = geoJSONFeature.properties[CIRCLE_SERIALIZE_PROP];
          delete geoJSONFeature.properties[CIRCLE_SERIALIZE_PROP];
        }

        var geometry = this.readGeometryFromObject(geoJSONFeature.geometry, options);

        if (this.geometryName_) {
          feature.setGeometryName(this.geometryName_);
        } else if (this.extractGeometryName_ && 'geometry_name' in geoJSONFeature !== undefined) {
          feature.setGeometryName(geoJSONFeature.geometry_name);
        }

        feature.setGeometry(geometry);

        if ('id' in geoJSONFeature) {
          feature.setId(geoJSONFeature.id);
        }

        if (geoJSONFeature.properties) {
          if (geoJSONFeature.properties[STYLE_SERIALIZE_PROP]) {
            var style = geoJSONFeature.properties[STYLE_SERIALIZE_PROP];
            isArray$2(style) || (style = [style]);
            feature.setStyle(style.map(function (style) {
              return options.styleReader(style, function (geometry) {
                return _this3.readGeometryFromObject(geometry, omit(options, ['circle']));
              });
            }));
            delete geoJSONFeature.properties[STYLE_SERIALIZE_PROP];
          }

          if (isArray$2(geoJSONFeature.properties.features)) {
            geoJSONFeature.properties.features = map$1(geoJSONFeature.properties.features, function (feature) {
              if (isGeoJSONFeature(feature)) {
                return _this3.readFeatureFromObject(feature, options);
              }

              return feature;
            });
          }

          feature.setProperties(geoJSONFeature.properties, true);
        }
        /* eslint-enable dot-notation */


        return feature;
      }
    }, {
      key: "readGeometryFromObject",
      value: function readGeometryFromObject(object, options) {
        var _options$circle, _options$circle2;

        options = this.adaptOptions(options);

        if ((_options$circle = options.circle) !== null && _options$circle !== void 0 && _options$circle.center && (_options$circle2 = options.circle) !== null && _options$circle2 !== void 0 && _options$circle2.radius) {
          return new geom.Circle(transformPoint(options.circle.center, options.dataProjection, options.featureProjection), transformDistance(options.circle.radius, options.dataProjection, options.featureProjection));
        }

        return _get$1(_getPrototypeOf$1(GeoJSON.prototype), "readGeometryFromObject", this).call(this, clonePlainObject(object), options);
      }
    }]);

    return GeoJSON;
  }(format.GeoJSON);
  function getGeoJsonFmt() {

    return createGeoJsonFmt({
      decimals: COORD_PRECISION,
      styleReader: createStyle,
      styleWriter: dumpStyle
    });
  }
  /**
   * @param {Feature} feature
   * @param {ProjectionLike|undefined} [featureProjection=EPSG:3857]
   * @param {ProjectionLike|undefined} [dataProjection=EPSG:4326]
   * @param {number} [decimals=COORD_PRECISION]
   * @return {Object}
   */

  function writeGeoJsonFeature(feature) {
    var featureProjection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
    var dataProjection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EPSG_4326;
    var decimals = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : COORD_PRECISION;
    if (!feature) return;
    return getGeoJsonFmt().writeFeatureObject(feature, {
      featureProjection: featureProjection,
      dataProjection: dataProjection,
      decimals: decimals
    });
  }
  /**
   * @param {Object} geoJsonFeature
   * @param {ProjectionLike|undefined} [featureProjection=EPSG:3857]
   * @param {ProjectionLike|undefined} [dataProjection=EPSG:4326]
   * @param {number} [decimals=COORD_PRECISION]
   * @return {Feature}
   */

  function readGeoJsonFeature(geoJsonFeature) {
    var featureProjection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
    var dataProjection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EPSG_4326;
    var decimals = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : COORD_PRECISION;
    if (!geoJsonFeature) return;
    return getGeoJsonFmt().readFeature(geoJsonFeature, {
      featureProjection: featureProjection,
      dataProjection: dataProjection,
      decimals: decimals
    });
  }
  /**
   * @param {Geometry} geometry
   * @param {ProjectionLike|undefined} [geometryProjection=EPSG:3857]
   * @param {ProjectionLike|undefined} [dataProjection=EPSG:4326]
   * @param {number} [decimals=COORD_PRECISION]
   * @return {Object}
   */

  function writeGeoJsonGeometry(geometry) {
    var geometryProjection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
    var dataProjection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EPSG_4326;
    var decimals = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : COORD_PRECISION;
    if (!geometry) return;
    return getGeoJsonFmt().writeGeometryObject(geometry, {
      featureProjection: geometryProjection,
      dataProjection: dataProjection,
      decimals: decimals
    });
  }
  /**
   * @param {Object|Object} geoJsonGeometry
   * @param {ProjectionLike|undefined} [geometryProjection=EPSG:3857]
   * @param {ProjectionLike|undefined} [dataProjection=EPSG:4326]
   * @param {number} [decimals=COORD_PRECISION]
   * @return {Geometry}
   */

  function readGeoJsonGeometry(geoJsonGeometry) {
    var geometryProjection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
    var dataProjection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EPSG_4326;
    var decimals = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : COORD_PRECISION;
    if (!geoJsonGeometry) return;
    dataProjection = readProjection(geoJsonGeometry, dataProjection);
    return getGeoJsonFmt().readGeometry(geoJsonGeometry, {
      featureProjection: geometryProjection,
      dataProjection: dataProjection,
      decimals: decimals
    });
  }
  function readProjection(geoJsonObj, defaultProjection) {
    return getGeoJsonFmt().readProjection(geoJsonObj) || defaultProjection;
  }
  /**
   * @param {Object} feature
   * @returns {boolean}
   */

  function isGeoJSONFeature(feature) {
    return isPlainObject(feature) && feature.type === 'Feature' && isGeoJSONGeometry(feature.geometry);
  }
  function isGeoJSONGeometry(geometry) {
    return isPlainObject(geometry) && Object.values(GeometryType).includes(geometry.type) && isArray$2(geometry.coordinates);
  }

  /**
   * @param {Object|module:ol/Feature~Feature|string|number} feature
   * @return {string|number}
   * @throws {Error}
   */

  function getFeatureId(feature) {
    if (feature instanceof ol.Feature) {
      return feature.getId();
    } else if (isPlainObject(feature)) {
      return feature.id;
    }

    throw new Error('Illegal feature format');
  }
  /**
   * @param {module:ol/Feature~Feature|Object} feature
   * @param {string} featureId
   * @returns {module:ol/Feature~Feature|Object}
   */

  function setFeatureId(feature, featureId) {
    if (feature instanceof ol.Feature) {
      feature.setId(featureId);
      return feature;
    } else if (isPlainObject(feature)) {
      feature.id = featureId;
      return feature;
    }

    throw new Error('Illegal feature format');
  }
  /**
   * @param {module:ol/Feature~Feature} feature
   * @param {string|undefined} defaultFeatureId
   * @returns {Feature}
   */

  function initializeFeature(feature, defaultFeatureId) {
    if (getFeatureId(feature) == null) {
      setFeatureId(feature, defaultFeatureId || v4());
    }

    return feature;
  }
  function getFeatureGeomName(feature) {
    if (feature instanceof ol.Feature) {
      return feature.getGeometryName();
    }

    return 'geometry';
  }
  function getFeatureGeom(feature) {
    if (feature instanceof ol.Feature) {
      return feature.getGeometry();
    } else if (isPlainObject(feature)) {
      return feature.geometry;
    }

    throw new Error('Illegal feature format');
  }
  function getFeatureProperties(feature) {
    if (!feature) return;
    return omit((feature instanceof ol.Feature ? feature.getProperties() : feature.properties) || {}, [getFeatureGeomName(feature), CIRCLE_SERIALIZE_PROP, STYLE_SERIALIZE_PROP]);
  }
  function setFeatureProperties(feature, properties) {
    if (!feature) return;
    properties = omit(properties || {}, [getFeatureGeomName(feature), CIRCLE_SERIALIZE_PROP, STYLE_SERIALIZE_PROP]);

    if (feature instanceof ol.Feature) {
      feature.setProperties(properties);
    } else {
      feature.properties = properties;
    }
  }

  /**
   * @param {module:ol/interaction/Interaction~Interaction|Object} interaction
   * @returns {string|null}
   */

  function getInteractionId(interaction) {
    if (interaction instanceof interaction$1.Interaction) {
      return interaction.get('id');
    }

    throw new Error('Illegal interaction argument');
  }
  /**
   * @param {module:ol/interaction/Interaction~Interaction|Object} interaction
   * @param {string} interactionId
   * @returns {module:ol/interaction/Interaction~Interaction|Object}
   */

  function setInteractionId(interaction, interactionId) {
    if (interaction instanceof interaction$1.Interaction) {
      interaction.set('id', interactionId);
      return interaction;
    }

    throw new Error('Illegal interaction argument');
  }
  function getInteractionPriority(interaction) {
    if (interaction instanceof interaction$1.Interaction) {
      return interaction.get('priority');
    }

    throw new Error('Illegal interaction argument');
  }
  function setInteractionPriority(interaction, priority) {
    if (interaction instanceof interaction$1.Interaction) {
      interaction.set('priority', priority);
      return interaction;
    }

    throw new Error('Illegal interaction argument');
  }
  function initializeInteraction(interaction, defaultInteractionId, defaultPriority) {
    if (getInteractionId(interaction) == null) {
      setInteractionId(interaction, defaultInteractionId || v4());
    }

    if (getInteractionPriority(interaction) == null) {
      setInteractionPriority(interaction, defaultPriority || 0);
    }

    return interaction;
  }

  function getLayerId(layer) {
    if (layer instanceof BaseLayer__default['default']) {
      return layer.get('id');
    }

    throw new Error('Illegal layer argument');
  }
  function setLayerId(layer, layerId) {
    if (layer instanceof BaseLayer__default['default']) {
      layer.set('id', layerId);
      return layer;
    }

    throw new Error('Illegal layer argument');
  }
  function initializeLayer(layer, defaultLayerId) {
    if (getLayerId(layer) == null) {
      setLayerId(layer, defaultLayerId || v4());
    }

    return layer;
  }

  function getMapId(map) {
    if (map instanceof ol.PluggableMap) {
      return map.get('id');
    }

    throw new Error('Illegal map argument');
  }
  function setMapId(map, mapId) {
    if (map instanceof ol.PluggableMap) {
      map.set('id', mapId);
      return map;
    }

    throw new Error('Illegal map argument');
  }
  function getMapDataProjection(map) {
    if (map instanceof ol.PluggableMap) {
      return map.get('dataProjection');
    }

    throw new Error('Illegal map argument');
  }
  function setMapDataProjection(map, dataProjection) {
    if (map instanceof ol.PluggableMap) {
      map.set('dataProjection', dataProjection);
      return map;
    }

    throw new Error('Illegal map argument');
  }

  function getOverlayId(overlay) {
    if (overlay instanceof ol.Overlay) {
      return overlay.get('id');
    }

    throw new Error('Illegal overlay argument');
  }
  function setOverlayId(overlay, overlayId) {
    if (overlay instanceof ol.Overlay) {
      overlay.set('id', overlayId);
      return overlay;
    }

    throw new Error('Illegal overlay argument');
  }
  function initializeOverlay(overlay, defaultOverlay) {
    if (getOverlayId(overlay) == null) {
      setOverlayId(overlay, defaultOverlay || v4());
    }

    return overlay;
  }

  function getSourceId(source) {
    if (source instanceof source$1.Source) {
      return source.get('id');
    }

    throw new Error('Illegal source argument');
  }
  function setSourceId(source, sourceId) {
    if (source instanceof source$1.Source) {
      source.set('id', sourceId);
      return source;
    }

    throw new Error('Illegal source argument');
  }
  function initializeSource(source, defaultSourceId) {
    if (getSourceId(source) == null) {
      setSourceId(source, defaultSourceId || v4());
    }

    return source;
  }
  function cleanSourceParams(params, filterKeys) {
    return reduce(params, function (params, value, key) {
      key = key.toUpperCase();

      if (filterKeys.includes(key)) {
        return params;
      }

      params[key] = value;
      return params;
    }, {});
  }

  /**
   * @module ol/proj/Units
   */
  /**
   * Projection units: `'degrees'`, `'ft'`, `'m'`, `'pixels'`, `'tile-pixels'` or
   * `'us-ft'`.
   * @enum {string}
   */
  var Units = {
      /**
       * Degrees
       * @api
       */
      DEGREES: 'degrees',
      /**
       * Feet
       * @api
       */
      FEET: 'ft',
      /**
       * Meters
       * @api
       */
      METERS: 'm',
      /**
       * Pixels
       * @api
       */
      PIXELS: 'pixels',
      /**
       * Tile Pixels
       * @api
       */
      TILE_PIXELS: 'tile-pixels',
      /**
       * US Feet
       * @api
       */
      USFEET: 'us-ft',
  };
  /**
   * Meters per unit lookup table.
   * @const
   * @type {Object<Units, number>}
   * @api
   */
  var METERS_PER_UNIT = {};
  // use the radius of the Normal sphere
  METERS_PER_UNIT[Units.DEGREES] = (2 * Math.PI * 6370997) / 360;
  METERS_PER_UNIT[Units.FEET] = 0.3048;
  METERS_PER_UNIT[Units.METERS] = 1;
  METERS_PER_UNIT[Units.USFEET] = 1200 / 3937;

  function extentFromProjection(projection) {
    projection = proj.get(projection);
    var extent = projection.getExtent();

    if (!extent) {
      var half = 180 * METERS_PER_UNIT[Units.DEGREES] / projection.getMetersPerUnit();
      extent = createOrUpdate(-half, -half, half, half);
    }

    return extent;
  }

  function getViewId(view) {
    if (view instanceof ol.View) {
      return view.get('id');
    }

    throw new Error('Illegal view argument');
  }
  function setViewId(view, viewId) {
    if (view instanceof ol.View) {
      view.set('id', viewId);
      return view;
    }

    throw new Error('Illegal view argument');
  }
  function initializeView(view, defaultViewId) {
    if (getViewId(view) == null) {
      setViewId(view, defaultViewId || v4());
    }

    return view;
  }

  function expandUrl$1(url) {
    var urls = [];
    var match = /\{([a-z])-([a-z])\}/.exec(url);

    if (match) {
      // char range
      var startCharCode = match[1].charCodeAt(0);
      var stopCharCode = match[2].charCodeAt(0);
      var charCode;

      for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
        urls.push(url.replace(match[0], String.fromCharCode(charCode)));
      }

      return urls;
    }

    match = /\{(\d+)-(\d+)\}/.exec(url);

    if (match) {
      // number range
      var stop1 = parseInt(match[2], 10);

      for (var i = parseInt(match[1], 10); i <= stop1; i++) {
        urls.push(url.replace(match[0], i.toString()));
      }

      return urls;
    }

    urls.push(url);
    return urls;
  }

  var olExt = /*#__PURE__*/Object.freeze({
    __proto__: null,
    expandUrl: expandUrl$1,
    getControlId: getControlId,
    setControlId: setControlId,
    initializeControl: initializeControl,
    COORD_PRECISION: COORD_PRECISION,
    roundExtent: roundExtent,
    roundPointCoords: roundPointCoords,
    roundLineCoords: roundLineCoords,
    roundPolygonCoords: roundPolygonCoords,
    roundMultiPointCoords: roundMultiPointCoords,
    roundMultiLineCoords: roundMultiLineCoords,
    roundMultiPolygonCoords: roundMultiPolygonCoords,
    roundCoords: roundCoords,
    flatCoords: flatCoords,
    isEqualCoord: isEqualCoord,
    calcDistance: calcDistance,
    isPointCoords: isPointCoords,
    isLineCoords: isLineCoords,
    isPolygonCoords: isPolygonCoords,
    isMultiPointCoords: isMultiPointCoords,
    isMultiLineCoords: isMultiLineCoords,
    isMultiPolygonCoords: isMultiPolygonCoords,
    createOrUpdate: createOrUpdate,
    getCorner: getCorner,
    getFeatureId: getFeatureId,
    setFeatureId: setFeatureId,
    initializeFeature: initializeFeature,
    getFeatureGeomName: getFeatureGeomName,
    getFeatureGeom: getFeatureGeom,
    getFeatureProperties: getFeatureProperties,
    setFeatureProperties: setFeatureProperties,
    createGeoJsonFmt: createGeoJsonFmt,
    createMvtFmt: createMvtFmt,
    CIRCLE_SERIALIZE_PROP: CIRCLE_SERIALIZE_PROP,
    STYLE_SERIALIZE_PROP: STYLE_SERIALIZE_PROP,
    getGeoJsonFmt: getGeoJsonFmt,
    writeGeoJsonFeature: writeGeoJsonFeature,
    readGeoJsonFeature: readGeoJsonFeature,
    writeGeoJsonGeometry: writeGeoJsonGeometry,
    readGeoJsonGeometry: readGeoJsonGeometry,
    readProjection: readProjection,
    isGeoJSONFeature: isGeoJSONFeature,
    isGeoJSONGeometry: isGeoJSONGeometry,
    createPointGeom: createPointGeom,
    createLineGeom: createLineGeom,
    createPolygonGeom: createPolygonGeom,
    createMultiPointGeom: createMultiPointGeom,
    createMultiLineGeom: createMultiLineGeom,
    createMultiPolygonGeom: createMultiPolygonGeom,
    createGeomCollection: createGeomCollection,
    createCircularPolygon: createCircularPolygon,
    isMultiGeom: isMultiGeom,
    toSimpleGeom: toSimpleGeom,
    findPointOnSurface: findPointOnSurface,
    getGeometryId: getGeometryId,
    setGeometryId: setGeometryId,
    initializeGeometry: initializeGeometry,
    isCircleGeom: isCircleGeom,
    getGeomCoords: getGeomCoords,
    getGeomType: getGeomType,
    getInteractionId: getInteractionId,
    setInteractionId: setInteractionId,
    getInteractionPriority: getInteractionPriority,
    setInteractionPriority: setInteractionPriority,
    initializeInteraction: initializeInteraction,
    getLayerId: getLayerId,
    setLayerId: setLayerId,
    initializeLayer: initializeLayer,
    getMapId: getMapId,
    setMapId: setMapId,
    getMapDataProjection: getMapDataProjection,
    setMapDataProjection: setMapDataProjection,
    getOverlayId: getOverlayId,
    setOverlayId: setOverlayId,
    initializeOverlay: initializeOverlay,
    EPSG_4326: EPSG_4326,
    EPSG_3857: EPSG_3857,
    pointToLonLat: pointToLonLat,
    pointFromLonLat: pointFromLonLat,
    transformPoint: transformPoint,
    transform: transform,
    lineToLonLat: lineToLonLat,
    lineFromLonLat: lineFromLonLat,
    transformLine: transformLine,
    polygonToLonLat: polygonToLonLat,
    polygonFromLonLat: polygonFromLonLat,
    transformPolygon: transformPolygon,
    multiPointToLonLat: multiPointToLonLat,
    multiPointFromLonLat: multiPointFromLonLat,
    transformMultiPoint: transformMultiPoint,
    multiLineToLonLat: multiLineToLonLat,
    multiLineFromLonLat: multiLineFromLonLat,
    transformMultiLine: transformMultiLine,
    multiPolygonToLonLat: multiPolygonToLonLat,
    multiPolygonFromLonLat: multiPolygonFromLonLat,
    transformMultiPolygon: transformMultiPolygon,
    transforms: transforms,
    transformExtent: transformExtent$1,
    extentFromLonLat: extentFromLonLat,
    extentToLonLat: extentToLonLat,
    transformDistance: transformDistance,
    getSourceId: getSourceId,
    setSourceId: setSourceId,
    initializeSource: initializeSource,
    cleanSourceParams: cleanSourceParams,
    getStyleId: getStyleId,
    setStyleId: setStyleId,
    initializeStyle: initializeStyle,
    defaultStyle: defaultStyle,
    defaultEditStyle: defaultEditStyle,
    createStyle: createStyle,
    normalizeColor: normalizeColor,
    createFillStyle: createFillStyle,
    createStrokeStyle: createStrokeStyle,
    createImageStyle: createImageStyle,
    createTextStyle: createTextStyle,
    createGeomStyle: createGeomStyle,
    dumpStyle: dumpStyle,
    dumpFillStyle: dumpFillStyle,
    dumpStrokeStyle: dumpStrokeStyle,
    dumpImageStyle: dumpImageStyle,
    dumpTextStyle: dumpTextStyle,
    dumpGeomStyle: dumpGeomStyle,
    extentFromProjection: extentFromProjection,
    getViewId: getViewId,
    setViewId: setViewId,
    initializeView: initializeView
  });

  /* global setTimeout, clearTimeout */

  var dist = function debounce(fn) {
    var wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    var lastCallAt = void 0;
    var deferred = void 0;
    var timer = void 0;
    var pendingArgs = [];
    return function debounced() {
      var currentWait = getWait(wait);
      var currentTime = new Date().getTime();

      var isCold = !lastCallAt || currentTime - lastCallAt > currentWait;

      lastCallAt = currentTime;

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (isCold && options.leading) {
        return options.accumulate ? Promise.resolve(fn.call(this, [args])).then(function (result) {
          return result[0];
        }) : Promise.resolve(fn.call.apply(fn, [this].concat(args)));
      }

      if (deferred) {
        clearTimeout(timer);
      } else {
        deferred = defer();
      }

      pendingArgs.push(args);
      timer = setTimeout(flush.bind(this), currentWait);

      if (options.accumulate) {
        var argsIndex = pendingArgs.length - 1;
        return deferred.promise.then(function (results) {
          return results[argsIndex];
        });
      }

      return deferred.promise;
    };

    function flush() {
      var thisDeferred = deferred;
      clearTimeout(timer);

      Promise.resolve(options.accumulate ? fn.call(this, pendingArgs) : fn.apply(this, pendingArgs[pendingArgs.length - 1])).then(thisDeferred.resolve, thisDeferred.reject);

      pendingArgs = [];
      deferred = null;
    }
  };

  function getWait(wait) {
    return typeof wait === 'function' ? wait() : wait;
  }

  function defer() {
    var deferred = {};
    deferred.promise = new Promise(function (resolve, reject) {
      deferred.resolve = resolve;
      deferred.reject = reject;
    });
    return deferred;
  }

  /**
   * @module ol/events/EventType
   */
  /**
   * @enum {string}
   * @const
   */
  var EventType = {
      /**
       * Generic change event. Triggered when the revision counter is increased.
       * @event module:ol/events/Event~BaseEvent#change
       * @api
       */
      CHANGE: 'change',
      /**
       * Generic error event. Triggered when an error occurs.
       * @event module:ol/events/Event~BaseEvent#error
       * @api
       */
      ERROR: 'error',
      BLUR: 'blur',
      CLEAR: 'clear',
      CONTEXTMENU: 'contextmenu',
      CLICK: 'click',
      DBLCLICK: 'dblclick',
      DRAGENTER: 'dragenter',
      DRAGOVER: 'dragover',
      DROP: 'drop',
      FOCUS: 'focus',
      KEYDOWN: 'keydown',
      KEYPRESS: 'keypress',
      LOAD: 'load',
      RESIZE: 'resize',
      TOUCHMOVE: 'touchmove',
      WHEEL: 'wheel',
  };

  /**
   * @module ol/ObjectEventType
   */
  /**
   * @enum {string}
   */
  var ObjectEventType = {
      /**
       * Triggered when a property is changed.
       * @event module:ol/Object.ObjectEvent#propertychange
       * @api
       */
      PROPERTYCHANGE: 'propertychange',
  };

  function isVueQuery(selector) {
      return selector._isVueQuery === true;
  }
  /**
   * Checks if a Vue component matches against a selector.
   * The selector can be either:
   * - a string (name of the component)
   * - a VueComponent object
   * - a VueQuery object
   */
  var matches = function (vm, selector) {
      if (!selector) {
          return true;
      }
      if (selector instanceof String || typeof selector === 'string') {
          return vm.$options.name === selector;
      }
      if (isVueQuery(selector)) {
          return selector.vm === vm;
      }
      return selector === vm;
  };
  /**
   * Get all children of a Vue component, optionally filtered by a selector.
   */
  var rawChildren = function (vm, selector) {
      var collected = [];
      vm.$children.forEach(function (child) {
          if (matches(child, selector)) {
              collected.push(child);
          }
      });
      return collected;
  };
  /**
   * Get all siblings of a Vue component, optionally filtered by a selector.
   * @param  {Boolean} withSelf Whether to include the current vm
   */
  var rawSiblings = function (vm, selector, withSelf) {
      if (withSelf === void 0) { withSelf = true; }
      if (isRoot(vm)) {
          return [];
      }
      var collected = rawChildren(vm.$parent, selector);
      if (!withSelf) {
          var index = collected.indexOf(vm);
          if (index > -1) {
              collected.splice(index, 1);
          }
      }
      return collected;
  };
  /**
   * Check if a Vue component is the root instance.
   */
  var isRoot = function (vm) {
      return vm.$root === vm;
  };
  /**
   * Get the first sibling of a Vue component filtered by a selector.
   */
  var siblingsWithSort = function (vm, selector, direction) {
      var siblings = rawSiblings(vm);
      if (!siblings.length) {
          return null;
      }
      var i = siblings.indexOf(vm);
      if (direction === "Ascending") {
          if (i === siblings.length - 1) {
              return null;
          }
          return matches(siblings[i + 1], selector) ? siblings[i + 1] : null;
      }
      if (i === 0) {
          return null;
      }
      return matches(siblings[i - 1], selector) ? siblings[i - 1] : null;
  };
  /**
   * Get all siblings of a Vue component filtered by a selector.
   */
  var siblingsAllWithSort = function (vm, selector, direction) {
      var siblings = rawSiblings(vm, selector);
      if (!siblings.length) {
          return [];
      }
      var i = siblings.indexOf(vm);
      return direction === "Ascending"
          ? siblings.slice(i + 1)
          : siblings.slice(0, i).reverse();
  };
  /**
   * Get all siblings of a Vue component filtered by a "filter" selector, and up to but
   * not including the "until" selector passed.
   */
  var siblingsUntilWithSort = function (vm, until, filter, direction) {
      var siblings = rawSiblings(vm);
      if (!siblings.length) {
          return [];
      }
      if (direction === "Descending") {
          siblings = siblings.reverse();
      }
      siblings = siblings.slice(siblings.indexOf(vm) + 1);
      if (!until) {
          return siblings;
      }
      var collected = [];
      for (var i = 0, j = siblings.length; i < j; ++i) {
          if (matches(siblings[i], until)) {
              break;
          }
          if (matches(siblings[i], filter)) {
              collected.push(siblings[i]);
          }
      }
      return collected;
  };

  var $ = function (vm) {
      if (Array.isArray(vm)) {
          // If the argument is an array, we VueQuery'fy the elements.
          return vm.map(function (c) {
              return $(c);
          });
      }
      // Avoid double encapsulation
      if (isVueQuery(vm)) {
          return vm;
      }
      // @ts-ignore
      if (!vm._isVue) {
          throw new Error('[VueQuery] Cannot instantiate on a non-Vue element');
      }
      if (!isRoot(vm) && !vm.$options.name) {
          throw new Error('[VueQuery] Non-root component must have a `name` option');
      }
      return {
          vm: vm,
          _isVueQuery: true,
          children: function (selector) {
              return $(rawChildren(vm, selector));
          },
          closest: function (selector) {
              if (matches(vm, selector)) {
                  return $(vm);
              }
              if (!vm.$parent) {
                  return null;
              }
              var $parent = $(vm.$parent);
              return $parent ? $parent.closest(selector) : null;
          },
          find: function (selector) {
              var _find = function (component) {
                  var collected = [];
                  if (!component.$children || !component.$children.length) {
                      return [];
                  }
                  component.$children.forEach(function (c) {
                      if (matches(c, selector)) {
                          collected.push(c);
                      }
                      collected = collected.concat(_find(c));
                  });
                  return collected;
              };
              return $(_find(vm));
          },
          has: function (selector) {
              if (!vm.$children || !vm.$children.length) {
                  return false;
              }
              for (var i = 0, j = vm.$children.length; i < j; ++i) {
                  if (matches(vm.$children[i], selector)) {
                      return true;
                  }
                  var $c = $(vm.$children[i]);
                  if (!$c) {
                      break;
                  }
                  return $c.has(selector);
              }
              return false;
          },
          is: function (selector) {
              if (Array.isArray(selector)) {
                  return selector.some(function (item) { return matches(vm, item); });
              }
              return matches(vm, selector);
          },
          next: function (selector) {
              var _next = siblingsWithSort(vm, selector ? selector : null, 'Ascending');
              return _next ? $(_next) : null;
          },
          nextAll: function (selector) {
              return $(siblingsAllWithSort(vm, selector ? selector : null, 'Ascending'));
          },
          nextUntil: function (until, filter) {
              return $(siblingsUntilWithSort(vm, until, filter, 'Ascending'));
          },
          parent: function (selector) {
              if (isRoot(vm)) {
                  return null;
              }
              return matches(vm.$parent, selector) ? $(vm.$parent) : null;
          },
          parents: function (selector) {
              var _parents = function (component) {
                  if (isRoot(component)) {
                      return [];
                  }
                  var collected = [];
                  if (matches(component.$parent, selector)) {
                      collected.push(component.$parent);
                  }
                  collected = collected.concat(_parents(component.$parent));
                  return collected;
              };
              return $(_parents(vm));
          },
          parentsUntil: function (until, filter) {
              var _parentsUntil = function (component) {
                  if (isRoot(component)) {
                      return [];
                  }
                  var collected = [];
                  if (until && matches(component.$parent, until)) {
                      return collected;
                  }
                  if (matches(component.$parent, filter)) {
                      collected.push(component.$parent);
                  }
                  return collected.concat(_parentsUntil(component.$parent));
              };
              return $(_parentsUntil(vm));
          },
          prev: function (selector) {
              var _prev = siblingsWithSort(vm, selector ? selector : null, 'Descending');
              return _prev ? $(_prev) : null;
          },
          prevAll: function (selector) {
              return $(siblingsAllWithSort(vm, selector ? selector : null, 'Descending'));
          },
          prevUntil: function (until, filter) {
              return $(siblingsUntilWithSort(vm, until, filter, 'Descending'));
          },
          siblings: function (selector) {
              var children = rawSiblings(vm, selector);
              var index = children.indexOf(vm);
              if (index > -1) {
                  children.splice(index, 1);
              }
              return $(children);
          }
      };
  };

  var vuequery = $;

  /**
   * Creates an Observable using OpenLayers event pattern that emits events coming from the given event target.
   *
   * @example **Subscribe on view center change events**
   * const map = ol.Map({ ... })
   * const changes = Observable.fromOlEvent(map.getView(), 'change:center')
   *
   * changes.subscribe(({ coordinate }) => console.log(coordinate))
   *
   * @param {module:ol/Observable~Observable} target OpenLayers event target.
   * @param {string|Object[]} eventName The event name of interest, being emitted by the `target`
   *                          or an array of events/selectors like `[{ event: 'event1', selector?: x => x }, ...]`.
   * @param {function(...*): *} [selector] An optional function to post-process results. It takes the arguments
   *    from the event handler and should return a single value.
   * @param {Observable[]} [pipeEach]
   * @return {Observable<T>}
   * @memberOf {Observable}
   */

  function fromOlEvent(target, eventName, selector) {
    var pipeEach = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];

    if (Array.isArray(eventName)) {
      return merge.apply(void 0, _toConsumableArray(eventName.map(function (elem) {
        var _fromOlEvent;

        var eventName, selector;

        if (_typeof(elem) === 'object') {
          eventName = elem.event;
          selector = elem.selector;
        } else {
          eventName = elem;
        }

        return (_fromOlEvent = fromOlEvent(target, eventName, selector)).pipe.apply(_fromOlEvent, _toConsumableArray(pipeEach));
      })));
    }

    selector || (selector = identity$2);
    return fromEventPattern(function (handler) {
      return target.on(eventName, handler);
    }, function (handler) {
      return target.un(eventName, handler);
    }).pipe(map(selector));
  }
  /**
   * Creates Observable from OpenLayers change:* event
   * @param {module:ol/Observable~Observable} target
   * @param {string|string[]} [prop]
   * @param {boolean|function(a, b):boolean|undefined} [distinct] Distinct values by isEqual fn or by custom comparator
   * @param {function|undefined} [selector] Custom selector
   * @param {Observable[]} [pipeEach]
   * @return {Observable<{prop: string, value: *}>}
   */

  function fromOlChangeEvent(target, prop, distinct, selector) {
    var pipeEach = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];

    if (Array.isArray(prop)) {
      return merge.apply(void 0, _toConsumableArray(prop.map(function (p) {
        var _fromOlChangeEvent;

        return (_fromOlChangeEvent = fromOlChangeEvent(target, p, distinct, selector)).pipe.apply(_fromOlChangeEvent, _toConsumableArray(pipeEach));
      })));
    }

    selector || (selector = identity$2);
    var event = "change:".concat(prop);
    var observable = fromOlEvent(target, event, function () {
      return target.get(prop);
    });
    var operations = [];

    if (distinct) {
      isFunction$1(distinct) || (distinct = isEqual);
      operations.push(distinctUntilChanged(distinct));
    }

    operations.push(map(function (value) {
      return selector({
        prop: prop,
        value: value
      });
    }));
    return observable.pipe.apply(observable, operations);
  }
  function fromVueEvent(target, eventName, selector) {
    if (Array.isArray(eventName)) {
      return merge.apply(void 0, _toConsumableArray(eventName.map(function (elem) {
        var eventName, selector;

        if (_typeof(elem) === 'object') {
          eventName = elem.event;
          selector = elem.selector;
        } else {
          eventName = elem;
        }

        return fromVueEvent(target, eventName, selector);
      })));
    }

    selector || (selector = identity$2);
    return fromEventPattern(function (handler) {
      return target.$on(eventName, handler);
    }, function (handler) {
      return target.$off(eventName, handler);
    }).pipe(map(selector));
  }
  function fromVueWatcher(target, exprOrFn) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    return new Observable(function (s) {
      return target.$watch(exprOrFn, function (value, previous) {
        return s.next({
          value: value,
          previous: previous
        });
      }, options);
    });
  }

  function bufferDebounceTime() {
    var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    return function (source) {
      var bufferedValues = [];
      return source.pipe(tap(function (value) {
        return bufferedValues.push(value);
      }), debounceTime(time), map(function () {
        return bufferedValues;
      }), tap(function () {
        bufferedValues = [];
      }));
    };
  }

  var rxExt = /*#__PURE__*/Object.freeze({
    __proto__: null,
    fromOlEvent: fromOlEvent,
    fromOlChangeEvent: fromOlChangeEvent,
    fromVueEvent: fromVueEvent,
    fromVueWatcher: fromVueWatcher,
    bufferDebounceTime: bufferDebounceTime
  });

  var EVENT_BUS_PROP = '$vlEventBus';
  var eventBus = {
    beforeCreate: function beforeCreate() {
      var _this = this;

      initEventBus(); // define local getter

      Object.defineProperties(this, {
        /**
         * @type {Vue}
         */
        $eventBus: {
          enumerable: true,
          get: function get() {
            return _this[EVENT_BUS_PROP];
          }
        }
      });
    }
  };

  function initEventBus() {
    if (hasProp(Vue__default['default'], EVENT_BUS_PROP) || hasProp(Vue__default['default'].prototype, EVENT_BUS_PROP)) return;
    var bus = new Vue__default['default']();

    if (!hasProp(Vue__default['default'], EVENT_BUS_PROP)) {
      Object.defineProperties(Vue__default['default'], _defineProperty$1({}, EVENT_BUS_PROP, {
        enumerable: true,
        get: function get() {
          return bus;
        }
      }));
    }

    if (!hasProp(Vue__default['default'].prototype, EVENT_BUS_PROP)) {
      Object.defineProperties(Vue__default['default'].prototype, _defineProperty$1({}, EVENT_BUS_PROP, {
        enumerable: true,
        get: function get() {
          return bus;
        }
      }));
    }
  }

  var IDENTITY_MAP_PROP = '$vlIdentityMap';
  var INSTANCES_POOL = 'instances';
  var identMap = {
    data: function data() {
      return {
        idents: stubObject()
      };
    },
    beforeCreate: function beforeCreate() {
      var _this = this;

      initIdentityMap(); // define local getter

      Object.defineProperties(this, {
        $identityMap: {
          enumerable: true,
          get: function get() {
            return _this[IDENTITY_MAP_PROP];
          }
        }
      });
    },
    destroyed: function destroyed() {
      this.unsetInstances();
    },
    methods: {
      /**
       * @param parts
       * @return {string}
       */
      makeIdent: function makeIdent() {
        for (var _len = arguments.length, parts = new Array(_len), _key = 0; _key < _len; _key++) {
          parts[_key] = arguments[_key];
        }

        return parts.filter(identity$2).join('.');
      },

      /**
       * Caches or reuse factory result in the identity map
       * and returns result.
       *
       * @param {string|undefined} ident
       * @param {function} factory
       * @returns {*}
       */
      instanceFactoryCall: function instanceFactoryCall(ident, factory) {
        if (ident && this.hasInstance(ident)) {
          return this.getInstance(ident);
        }

        var inst = factory();

        if (ident) {
          this.setInstance(ident, inst);
        }

        return inst;
      },

      /**
       * @param {string|undefined} ident
       * @returns {*}
       */
      getInstance: function getInstance(ident) {
        if (!ident || !this.hasInstance(ident)) return;
        this.idents[ident] = true;
        return this.$identityMap.get(ident, INSTANCES_POOL);
      },

      /**
       * @param ident
       * @param inst
       */
      setInstance: function setInstance(ident, inst) {
        if (!ident) return;
        this.idents[ident] = true;
        this.$identityMap.set(ident, inst, INSTANCES_POOL);
      },

      /**
       * @param {string|undefined} ident
       * @returns {*}
       */
      hasInstance: function hasInstance(ident) {
        if (!ident) return;
        return this.$identityMap.has(ident, INSTANCES_POOL);
      },

      /**
       * @param {string|undefined} ident
       * @return {void}
       */
      unsetInstance: function unsetInstance(ident) {
        if (!ident) return;
        delete this.idents[ident];
        this.$identityMap.unset(ident, INSTANCES_POOL);
      },

      /**
       * Unsets all self indets
       * @return {void}
       */
      unsetInstances: function unsetInstances() {
        keys(this.idents).forEach(this.unsetInstance.bind(this));
      },

      /**
       * @param {string|undefined} fromIdent
       * @param {string|undefined} toIdent
       * @returns {boolean}
       */
      moveInstance: function moveInstance(fromIdent, toIdent) {
        return this.$identityMap.move(fromIdent, toIdent, INSTANCES_POOL);
      }
    }
  };

  function initIdentityMap() {
    if (hasProp(Vue__default['default'], IDENTITY_MAP_PROP) || hasProp(Vue__default['default'].prototype, IDENTITY_MAP_PROP)) return;
    var imap = new IdentityMap();

    if (!hasProp(Vue__default['default'], IDENTITY_MAP_PROP)) {
      Object.defineProperties(Vue__default['default'], _defineProperty$1({}, IDENTITY_MAP_PROP, {
        enumerable: true,
        get: function get() {
          return imap;
        }
      }));
    }

    if (!hasProp(Vue__default['default'].prototype, IDENTITY_MAP_PROP)) {
      Object.defineProperties(Vue__default['default'].prototype, _defineProperty$1({}, IDENTITY_MAP_PROP, {
        enumerable: true,
        get: function get() {
          return imap;
        }
      }));
    }
  }

  /**
   * RxJS subscriptions manager.
   */

  var rxSubs = {
    beforeCreate: function beforeCreate() {
      /**
       * @type {Subscription[]}
       * @private
       */
      this._rxSubs = [];
    },
    destroyed: function destroyed() {
      this.unsubscribeAll();
    },
    methods: {
      /**
       * @return {void}
       * @protected
       */
      subscribeAll: function subscribeAll() {},

      /**
       * @return {void}
       * @protected
       */
      unsubscribeAll: function unsubscribeAll() {
        this._rxSubs.forEach(function (subs) {
          return subs.unsubscribe();
        });

        this._rxSubs = [];
      },

      /**
       * @param {Observable<T>} observable
       * @param {function} [next] Next handler or Observer object.
       * @param {function} [error] Error handler.
       * @param {function} [complete] Complete handler.
       * @return {Subscription}
       * @protected
       */
      subscribeTo: function subscribeTo(observable) {

        var next = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : noop$1;
        var error = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noop$1;
        var complete = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : noop$1;

        var errorWrap = function errorWrap(err) {

          error(err);
        };

        var subs = observable.pipe(retry(3)).subscribe(next, errorWrap, complete);

        this._rxSubs.push(subs);

        return subs;
      },
      unsubscribe: function unsubscribe(subs) {
        var idx = this._rxSubs.indexOf(subs);

        if (idx === -1) return;
        subs.unsubscribe();

        this._rxSubs.splice(idx, 1);
      }
    }
  };

  // const SERVICES_PROP = Symbol('services')

  var SERVICES_PROP = 'services';
  /**
   * Service container mixin
   */

  var services = {
    inject: {
      $services: SERVICES_PROP // todo works only in Vue 2.5.x
      // $services: {from: SERVICES_PROP, default: Object.create(null)},

    },
    provide: function provide() {
      return _defineProperty$1({}, SERVICES_PROP, this.getServices());
    },
    methods: {
      /**
       * @returns {Object}
       * @protected
       */
      getServices: function getServices() {
        return mergeDescriptors({}, this.$services || {});
      }
    },
    beforeCreate: function beforeCreate() {
      var source = this.$parent;

      while (source) {
        if (source._provided != null && source._provided[SERVICES_PROP] != null) {
          break;
        }

        source = source.$parent;
      }

      if (source == null || source._provided[SERVICES_PROP] == null) {
        delete this.$options.inject.$services;
      }
    }
  };

  function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf$1(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$1(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$1(this, result); }; }

  function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

  function ownKeys$11(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$11(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$11(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$11(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var VM_PROP = 'vm';
  var FRAME_TIME = 1000 / 60;
  var OlObjectState = {
    UNDEF: 'undef',
    CREATING: 'creating',
    CREATED: 'created',
    MOUNTING: 'mounting',
    MOUNTED: 'mounted',
    UNMOUNTING: 'unmounting',
    UNMOUNTED: 'unmounted',
    DESTROYING: 'destroying',
    DESTROYED: 'destroyed'
  };
  var OlObjectEvent = {
    CREATED: OlObjectState.CREATED,
    MOUNTED: OlObjectState.MOUNTED,
    UNMOUNTED: OlObjectState.UNMOUNTED,
    DESTROYED: OlObjectState.DESTROYED,
    ERROR: 'error'
  };
  var OlObjectAction = {
    CREATE: 'create',
    MOUNT: 'mount',
    UNMOUNT: 'unmount',
    DESTROY: 'destroy'
  };
  /**
   * Basic ol component mixin.
   * todo try to subscribe to generic change event here and update rev according to internal ol counter
   */

  var olCmp = {
    mixins: [identMap, rxSubs, services, eventBus],
    props: {
      /**
       * @type {string|number}
       */
      id: {
        type: [String, Number],
        default: v4,
        validator: function validator(value) {
          return value != null && value !== '';
        }
      },

      /**
       * Unique key for saving to identity map
       * @type {string|number|undefined}
       */
      ident: [String, Number]
    },
    data: function data() {
      return {
        rev: 0,
        currentId: this.id
      };
    },
    computed: {
      /**
       * @type {string}
       */
      vmClass: function vmClass() {
        return kebabCase(this.$options.name);
      },

      /**
       * @type {string}
       */
      vmId: function vmId() {
        return [this.vmClass, this.currentId].filter(identity$2).join('.');
      },

      /**
       * @type {string}
       */
      vmName: function vmName() {
        return [this.$options.name, this.currentId].filter(identity$2).join('.');
      },

      /**
       * @type {string|undefined}
       */
      olObjIdent: function olObjIdent() {
        if (!this.ident) return;
        return this.makeIdent(this.ident);
      }
    },
    watch: _objectSpread$11({
      rev: function rev() {
        if (!this.$olObject) return;

        if (this.currentId !== this.getIdInternal()) {
          this.currentId = this.getIdInternal();
        }
      }
    }, /*#__PURE__*/makeChangeOrRecreateWatchers(['id', 'currentId', 'olObjIdent'])),
    created: function created() {
      var _this = this;

      return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                /**
                 * @type {{warn: (function(...[*]): void), log: (function(...[*]): void), error: (function(...[*]): void)}}
                 * @private
                 */
                _this._logger = newLogger(_this.vmName);
                /**
                 * @type {number}
                 * @private
                 */

                _this._olObjectState = OlObjectState.UNDEF;
                /**
                 * @type {module:ol/Object~BaseObject}
                 * @private
                 */

                _this._olObject = undefined;
                /**
                 * @type {Observable}
                 * @private
                 */

                _this._olObjectEvents = newOlObjectEventsObs.call(_this);
                defineDebounceMethods.call(_this);
                defineServices$s.call(_this);
                _context.next = 8;
                return execInit.call(_this, false);

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    },
    mounted: function mounted() {
      var _this2 = this;

      return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
        return regenerator.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return execMount.call(_this2);

              case 2:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }))();
    },
    beforeDestroy: function beforeDestroy() {
      var _this3 = this;

      return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3() {
        return regenerator.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return execUnmount.call(_this3, true);

              case 2:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }))();
    },
    destroyed: function destroyed() {
      var _this4 = this;

      return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4() {
        return regenerator.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return execDeinit.call(_this4);

              case 2:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }))();
    },
    methods: {
      /**
       * @return {Promise<void>} Resolves when initialization completes
       * @protected
       */
      beforeInit: function beforeInit() {},

      /**
       * @return {Promise<void>} Resolves when initialization completes
       * @protected
       */
      init: function init() {
        var _this5 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee5() {
          return regenerator.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  _context5.next = 2;
                  return _this5.instanceFactoryCall(_this5.olObjIdent, _this5.createOlObject.bind(_this5));

                case 2:
                  _this5._olObject = _context5.sent;
                  _this5._olObject[VM_PROP] || (_this5._olObject[VM_PROP] = []); // for loaded from IdentityMap

                  if (!_this5._olObject[VM_PROP].includes(_this5)) {
                    _this5._olObject[VM_PROP].push(_this5);
                  }

                  _context5.next = 7;
                  return _this5.changed();

                case 7:
                  _this5.subscribeAll();

                case 8:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5);
        }))();
      },

      /**
       * @return {module:ol/Object~BaseObject|Promise<module:ol/Object~BaseObject>}
       * @protected
       * @abstract
       */
      createOlObject: function createOlObject() {
        throw new Error("".concat(this.vmName, " not implemented method: createOlObject()"));
      },

      /**
       * @return {Promise<void>}
       * @protected
       */
      deinit: function deinit() {
        var _this6 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee6() {
          return regenerator.wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  _this6.unsubscribeAll();

                  _this6.unsetInstances();

                  if (_this6._olObject) {
                    _this6._olObject[VM_PROP] = _this6._olObject[VM_PROP].filter(function (vm) {
                      return vm !== _this6;
                    });
                    _this6._olObject = undefined;
                  }

                case 3:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6);
        }))();
      },

      /**
       * @return {Promise<void>}
       * @protected
       */
      beforeMount: function beforeMount() {},

      /**
       * @return {Promise<void>}
       * @protected
       */
      mount: function mount() {},

      /**
       * @return {void|Promise<void>}
       * @protected
       */
      unmount: function unmount() {},

      /**
       * Refresh internal ol objects
       * @return {Promise<void>}
       */
      refresh: function refresh() {
        var _this7 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee7() {
          var olObj;
          return regenerator.wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  _context7.prev = 0;
                  _context7.next = 3;
                  return _this7.resolveOlObject();

                case 3:
                  olObj = _context7.sent;

                  if (!(olObj instanceof ol.Observable)) {
                    _context7.next = 6;
                    break;
                  }

                  return _context7.abrupt("return", new Promise(function (resolve) {
                    olObj.once('change', function () {
                      return resolve();
                    });
                    olObj.changed();
                  }));

                case 6:
                  _context7.next = 10;
                  break;

                case 8:
                  _context7.prev = 8;
                  _context7.t0 = _context7["catch"](0);

                case 10:
                  return _context7.abrupt("return", _this7.changed());

                case 11:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee7, null, [[0, 8]]);
        }))();
      },

      /**
       * @return {Promise<void>}
       */
      scheduleRefresh: function scheduleRefresh() {
        var _this8 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee8() {
          return regenerator.wrap(function _callee8$(_context8) {
            while (1) {
              switch (_context8.prev = _context8.next) {
                case 0:
                  _context8.prev = 0;
                  _context8.next = 3;
                  return _this8.debounceRefresh();

                case 3:
                  _context8.next = 7;
                  break;

                case 5:
                  _context8.prev = 5;
                  _context8.t0 = _context8["catch"](0);

                case 7:
                case "end":
                  return _context8.stop();
              }
            }
          }, _callee8, null, [[0, 5]]);
        }))();
      },

      /**
       * Internal usage only in components that doesn't support refreshing.
       * @return {Promise<void>}
       * @protected
       */
      remount: function remount() {
        var _this9 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee9() {
          return regenerator.wrap(function _callee9$(_context9) {
            while (1) {
              switch (_context9.prev = _context9.next) {
                case 0:
                  if (!(_this9.$olObjectState === OlObjectState.MOUNTED)) {
                    _context9.next = 8;
                    break;
                  }

                  _context9.next = 4;
                  return execUnmount.call(_this9);

                case 4:
                  _context9.next = 6;
                  return execMount.call(_this9);

                case 6:
                  _context9.next = 9;
                  break;

                case 8:

                case 9:
                case "end":
                  return _context9.stop();
              }
            }
          }, _callee9);
        }))();
      },

      /**
       * @return {Promise<void>}
       */
      scheduleRemount: function scheduleRemount() {
        var _this10 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee10() {
          return regenerator.wrap(function _callee10$(_context10) {
            while (1) {
              switch (_context10.prev = _context10.next) {
                case 0:
                  if (![OlObjectState.MOUNTING, OlObjectState.MOUNTED].includes(_this10.$olObjectState)) {
                    _context10.next = 6;
                    break;
                  }

                  _context10.next = 4;
                  return _this10.debounceRemount();

                case 4:
                  _context10.next = 7;
                  break;

                case 6:

                case 7:
                case "end":
                  return _context10.stop();
              }
            }
          }, _callee10);
        }))();
      },

      /**
       * Only for internal purpose to support watching for properties
       * for which OpenLayers doesn't provide setters.
       * @return {Promise}
       * @protected
       */
      recreate: function recreate() {
        var _this11 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee11() {
          var mounted;
          return regenerator.wrap(function _callee11$(_context11) {
            while (1) {
              switch (_context11.prev = _context11.next) {
                case 0:
                  if (![OlObjectState.CREATED, OlObjectState.MOUNTING, OlObjectState.MOUNTED, OlObjectState.UNMOUNTING, OlObjectState.UNMOUNTED].includes(_this11.$olObjectState)) {
                    _context11.next = 15;
                    break;
                  }

                  mounted = [OlObjectState.MOUNTING, OlObjectState.MOUNTED].includes(_this11.$olObjectState);

                  if (!mounted) {
                    _context11.next = 6;
                    break;
                  }

                  _context11.next = 6;
                  return execUnmount.call(_this11);

                case 6:
                  _context11.next = 8;
                  return execDeinit.call(_this11);

                case 8:
                  _context11.next = 10;
                  return execInit.call(_this11);

                case 10:
                  if (!mounted) {
                    _context11.next = 13;
                    break;
                  }

                  _context11.next = 13;
                  return execMount.call(_this11);

                case 13:
                  _context11.next = 16;
                  break;

                case 15:

                case 16:
                case "end":
                  return _context11.stop();
              }
            }
          }, _callee11);
        }))();
      },

      /**
       * @return {Promise<void>}
       */
      scheduleRecreate: function scheduleRecreate() {
        var _this12 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee12() {
          return regenerator.wrap(function _callee12$(_context12) {
            while (1) {
              switch (_context12.prev = _context12.next) {
                case 0:
                  if (![OlObjectState.CREATING, OlObjectState.CREATED, OlObjectState.MOUNTING, OlObjectState.MOUNTED, OlObjectState.UNMOUNTING, OlObjectState.UNMOUNTED].includes(_this12.$olObjectState)) {
                    _context12.next = 6;
                    break;
                  }

                  _context12.next = 4;
                  return _this12.debounceRecreate();

                case 4:
                  _context12.next = 7;
                  break;

                case 6:

                case 7:
                case "end":
                  return _context12.stop();
              }
            }
          }, _callee12);
        }))();
      },

      /**
       * Redefine for easy call in child components
       * @returns {Object}
       * @protected
       */
      getServices: function getServices() {
        return services.methods.getServices.call(this);
      },

      /**
       * @protected
       */
      subscribeAll: function subscribeAll() {
        subscribeToOlObjectEvents.call(this);
      },

      /**
       * @returns {Promise<Object>}
       * @throws {Error} If underlying OpenLayers object not initialized (incorrect initialization, already destroy).
       */
      resolveOlObject: function resolveOlObject() {
        var _this13 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee13() {
          return regenerator.wrap(function _callee13$(_context13) {
            while (1) {
              switch (_context13.prev = _context13.next) {
                case 0:
                  _context13.next = 2;
                  return _this13.$createPromise;

                case 2:
                  return _context13.abrupt("return", _this13.$olObject || function (e) {
                    throw e;
                  }(new OLObjectNotInitializedError("".concat(_this13.vmName, " OpenLayers object is undefined"))));

                case 3:
                case "end":
                  return _context13.stop();
              }
            }
          }, _callee13);
        }))();
      },

      /**
       * @return {Promise}
       */
      $nextTickPromise: function $nextTickPromise() {
        var _this14 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee14() {
          return regenerator.wrap(function _callee14$(_context14) {
            while (1) {
              switch (_context14.prev = _context14.next) {
                case 0:
                  return _context14.abrupt("return", new Promise(_this14.$nextTick.bind(_this14)));

                case 1:
                case "end":
                  return _context14.stop();
              }
            }
          }, _callee14);
        }))();
      },

      /**
       * @return {string|number}
       */
      getId: function getId() {
        return coalesce(this.$olObject && this.getIdInternal(), this.currentId);
      },

      /**
       * @return {*}
       * @protected
       */
      getIdInternal: function getIdInternal() {
        if (this.$olObject instanceof ol.Object) {
          return this.$olObject.get('id');
        }

        return this.$olObject.id;
      },

      /**
       * @param {string|number} id
       */
      setId: function setId(id) {
        assert$1(id != null && id !== '', 'Invalid id');

        if (this.currentId !== id) {
          this.currentId = id;
        }

        this.$olObject && this.setIdInternal(id);
      },

      /**
       * @param {*} id
       * @protected
       */
      setIdInternal: function setIdInternal(id) {
        if (this.$olObject instanceof ol.Object) {
          if (this.$olObject.get('id') !== id) {
            this.$olObject.set('id', id);
          }

          return;
        }

        if (this.$olObject.id !== id) {
          this.$olObject.id = id;
        }
      },

      /**
       * @return {Promise<void>}
       * @protected
       */
      changed: function changed() {
        var _this15 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee15() {
          return regenerator.wrap(function _callee15$(_context15) {
            while (1) {
              switch (_context15.prev = _context15.next) {
                case 0:
                  _this15.rev++;
                  _context15.next = 3;
                  return _this15.$nextTickPromise();

                case 3:
                case "end":
                  return _context15.stop();
              }
            }
          }, _callee15);
        }))();
      },

      /**
       * @param {string|number} value
       * @protected
       */
      idChanged: function idChanged(value) {
        this.setId(value);
      },

      /**
       * @param {string|number} value
       * @protected
       */
      currentIdChanged: function currentIdChanged(value) {
        if (value === this.id) return;
        this.$emit('update:id', value);
      },

      /**
       * @param {string|undefined} value
       * @param {string|undefined} prevValue
       * @protected
       */
      olObjIdentChanged: function olObjIdentChanged(value, prevValue) {
        if (value && prevValue) {
          this.moveInstance(value, prevValue);
        } else if (value && !prevValue && this.$olObject) {
          this.setInstance(value, this.$olObject);
        } else if (!value && prevValue) {
          this.unsetInstance(prevValue);
        }
      },

      /**
       * @protected
       */
      syncNonObservable: function syncNonObservable() {
        this.setId(this.getId());
      }
    }
  };

  function defineDebounceMethods() {
    this.debounceRefresh = dist(this.refresh.bind(this), FRAME_TIME);
    this.debounceRemount = dist(this.remount.bind(this), FRAME_TIME);
    this.debounceRecreate = dist(this.recreate.bind(this), FRAME_TIME);
    this.debounceChanged = dist(this.changed.bind(this), FRAME_TIME);
  }

  function defineServices$s() {
    var _this16 = this;

    Object.defineProperties(this, {
      $vq: {
        enumerable: true,
        get: function get() {
          return vuequery(_this16);
        }
      },

      /**
       * @type {{warn: (function(...[*]): void), log: (function(...[*]): void), error: (function(...[*]): void)}}
       */
      $logger: {
        enumerable: true,
        get: function get() {
          return _this16._logger;
        }
      },

      /**
       * @type {string}
       */
      $olObjectState: {
        enumerable: true,
        get: function get() {
          return _this16._olObjectState;
        }
      },

      /**
       * @type {module:ol/Object~BaseObject|undefined}
       */
      $olObject: {
        enumerable: true,
        get: function get() {
          return _this16._olObject;
        }
      },
      $olObjectEvents: {
        enumerable: true,
        get: function get() {
          return _this16._olObjectEvents;
        }
      },

      /**
       * @type {Promise<void>}
       */
      $createPromise: {
        enumerable: true,
        get: function get() {
          return newLifecyclePromise.call(_this16, OlObjectAction.CREATE, OlObjectEvent.CREATED, _defineProperty$1({}, OlObjectState.CREATING, [OlObjectAction.CREATE, OlObjectEvent.CREATED]));
        }
      },

      /**
       * @type {Promise<void>}
       */
      $mountPromise: {
        enumerable: true,
        get: function get() {
          return _this16.$createPromise.then(function () {
            var _newLifecyclePromise$2;

            return newLifecyclePromise.call(_this16, OlObjectAction.MOUNT, OlObjectEvent.MOUNTED, (_newLifecyclePromise$2 = {}, _defineProperty$1(_newLifecyclePromise$2, OlObjectState.CREATING, [OlObjectAction.CREATE, OlObjectEvent.CREATED]), _defineProperty$1(_newLifecyclePromise$2, OlObjectState.MOUNTING, [OlObjectAction.MOUNT, OlObjectEvent.MOUNTED]), _newLifecyclePromise$2));
          });
        }
      },

      /**
       * @type {Promise<void>}
       */
      $unmountPromise: {
        enumerable: true,
        get: function get() {
          return _this16.$mountPromise.then(function () {
            var _newLifecyclePromise$3;

            return newLifecyclePromise.call(_this16, OlObjectAction.UNMOUNT, OlObjectEvent.UNMOUNTED, (_newLifecyclePromise$3 = {}, _defineProperty$1(_newLifecyclePromise$3, OlObjectState.CREATING, [OlObjectAction.CREATE, OlObjectEvent.CREATED]), _defineProperty$1(_newLifecyclePromise$3, OlObjectState.MOUNTING, [OlObjectAction.MOUNT, OlObjectEvent.MOUNTED]), _defineProperty$1(_newLifecyclePromise$3, OlObjectState.UNMOUNTING, [OlObjectAction.UNMOUNT, OlObjectEvent.UNMOUNTED]), _newLifecyclePromise$3));
          });
        }
      },

      /**
       * @type {Promise<void>}
       */
      $destroyPromise: {
        enumerable: true,
        get: function get() {
          return _this16.$unmountPromise.then(function () {
            var _newLifecyclePromise$4;

            return newLifecyclePromise.call(_this16, OlObjectAction.DESTROY, OlObjectEvent.DESTROYED, (_newLifecyclePromise$4 = {}, _defineProperty$1(_newLifecyclePromise$4, OlObjectState.CREATING, [OlObjectAction.CREATE, OlObjectEvent.CREATED]), _defineProperty$1(_newLifecyclePromise$4, OlObjectState.MOUNTING, [OlObjectAction.MOUNT, OlObjectEvent.MOUNTED]), _defineProperty$1(_newLifecyclePromise$4, OlObjectState.UNMOUNTING, [OlObjectAction.UNMOUNT, OlObjectEvent.UNMOUNTED]), _defineProperty$1(_newLifecyclePromise$4, OlObjectState.DESTROYING, [OlObjectAction.DESTROY, OlObjectEvent.DESTROYED]), _newLifecyclePromise$4));
          });
        }
      }
    });
  }

  function newOlObjectEventsObs() {
    var _this17 = this;

    return merge.apply(void 0, _toConsumableArray(Object.values(OlObjectEvent).map(function (name) {
      return fromVueEvent(_this17.$eventBus, name, function (args) {
        return {
          name: name,
          args: isArray$2(args) ? args : [args]
        };
      }).pipe(filter(function (_ref) {
        var args = _ref.args;
        return args[0] === _this17 || args[1] === _this17;
      }));
    }))).pipe(publishReplay(), refCount());
  }

  function newLifecyclePromise(action, endEvent, startStates) {
    var _this18 = this;

    var newFinishObs = function newFinishObs(action, endEvent) {
      return race(_this18.$olObjectEvents.pipe(filter(function (_ref2) {
        var name = _ref2.name;
        return name === endEvent;
      })), _this18.$olObjectEvents.pipe(filter(function (_ref3) {
        var name = _ref3.name,
            args = _ref3.args;
        return name === OlObjectEvent.ERROR && args[0] instanceof LifecycleError && args[0].action === action;
      })));
    };

    return merge(newFinishObs(action, endEvent), this.$olObjectEvents.pipe(filter(function (_ref4) {
      var name = _ref4.name,
          args = _ref4.args;
      return name === OlObjectEvent.ERROR && args[0] instanceof CanceledError;
    }))).pipe(first(), mergeMap(function (evt) {
      var obs = of(evt); // If at the time of CancelError the ol object stay in some intermediate state
      // we need to delay observable emit until current hook complete

      if (evt.name === OlObjectEvent.ERROR && evt.args[0] instanceof CanceledError && startStates[_this18.$olObjectState] != null) {
        obs = obs.pipe(delayWhen(function () {
          return newFinishObs.apply(void 0, _toConsumableArray(startStates[_this18.$olObjectState]));
        }));
      }

      return obs;
    }), mergeMap(function (evt) {
      if (evt.name === OlObjectEvent.ERROR) {
        return throwError(evt.args[0]);
      }

      return of(evt);
    }), map(function (_ref5) {
      var args = _ref5.args;
      return args.length === 1 ? args[0] : args;
    })).toPromise();
  }
  /**
   * @param {boolean} [resetEventsObs=true]
   * @returns {Promise<void>}
   * @private
   */


  function execInit() {
    return _execInit.apply(this, arguments);
  }
  /**
   * @return {Promise<void>}
   * @private
   */


  function _execInit() {
    _execInit = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee16() {
      var resetEventsObs,
          prevState,
          canceled,
          lcErr,
          _args16 = arguments;
      return regenerator.wrap(function _callee16$(_context16) {
        while (1) {
          switch (_context16.prev = _context16.next) {
            case 0:
              resetEventsObs = _args16.length > 0 && _args16[0] !== undefined ? _args16[0] : true;
              prevState = this._olObjectState;

              if (resetEventsObs) {
                this._olObjectEvents = newOlObjectEventsObs.call(this);
              }

              this._olObjectEvents.subscribe();

              _context16.prev = 4;
              _context16.next = 7;
              return Promise.race([Promise.resolve(this.beforeInit()).then(function () {
                return false;
              }), this.$olObjectEvents.pipe(filter(function (_ref7) {
                var name = _ref7.name,
                    args = _ref7.args;
                return name === OlObjectEvent.ERROR && args[0] instanceof CanceledError;
              }), first()).toPromise().then(function () {
                return true;
              })]);

            case 7:
              canceled = _context16.sent;

              if (!canceled) {
                _context16.next = 11;
                break;
              }

              return _context16.abrupt("return");

            case 11:
              this._olObjectState = OlObjectState.CREATING;
              _context16.next = 14;
              return this.init();

            case 14:
              this._olObjectState = OlObjectState.CREATED;

              this.$emit(OlObjectEvent.CREATED, this);
              this.$eventBus.$emit(OlObjectEvent.CREATED, this);
              _context16.next = 27;
              break;

            case 20:
              _context16.prev = 20;
              _context16.t0 = _context16["catch"](4);
              lcErr = new LifecycleError(_context16.t0, this.vmName, OlObjectAction.CREATE);
              this._olObjectState = prevState;
              this.$emit(OlObjectEvent.ERROR, lcErr, this);
              this.$eventBus.$emit(OlObjectEvent.ERROR, lcErr, this);
              throw lcErr;

            case 27:
            case "end":
              return _context16.stop();
          }
        }
      }, _callee16, this, [[4, 20]]);
    }));
    return _execInit.apply(this, arguments);
  }

  function execMount() {
    return _execMount.apply(this, arguments);
  }
  /**
   * @param {boolean} [fireCancel=false]
   * @return {void|Promise<void>}
   * @private
   */


  function _execMount() {
    _execMount = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee17() {
      var prevState, canceled, lcErr;
      return regenerator.wrap(function _callee17$(_context17) {
        while (1) {
          switch (_context17.prev = _context17.next) {
            case 0:
              prevState = this._olObjectState;
              _context17.prev = 1;
              _context17.next = 4;
              return this.$createPromise;

            case 4:
              _context17.next = 6;
              return Promise.race([Promise.resolve(this.beforeMount()).then(function () {
                return false;
              }), this.$olObjectEvents.pipe(filter(function (_ref8) {
                var name = _ref8.name,
                    args = _ref8.args;
                return name === OlObjectEvent.ERROR && args[0] instanceof CanceledError;
              }), first()).toPromise().then(function () {
                return true;
              })]);

            case 6:
              canceled = _context17.sent;

              if (!canceled) {
                _context17.next = 10;
                break;
              }

              return _context17.abrupt("return");

            case 10:
              this._olObjectState = OlObjectState.MOUNTING;
              _context17.next = 13;
              return this.mount();

            case 13:
              this._olObjectState = OlObjectState.MOUNTED;

              this.$emit(OlObjectEvent.MOUNTED, this);
              this.$eventBus.$emit(OlObjectEvent.MOUNTED, this);
              _context17.next = 29;
              break;

            case 19:
              _context17.prev = 19;
              _context17.t0 = _context17["catch"](1);

              if (!(_context17.t0 instanceof CanceledError)) {
                _context17.next = 24;
                break;
              }

              return _context17.abrupt("return");

            case 24:
              lcErr = new LifecycleError(_context17.t0, this.vmName, OlObjectAction.MOUNT);
              this._olObjectState = prevState;
              this.$emit(OlObjectEvent.ERROR, lcErr, this);
              this.$eventBus.$emit(OlObjectEvent.ERROR, lcErr, this);
              throw lcErr;

            case 29:
            case "end":
              return _context17.stop();
          }
        }
      }, _callee17, this, [[1, 19]]);
    }));
    return _execMount.apply(this, arguments);
  }

  function execUnmount() {
    return _execUnmount.apply(this, arguments);
  }
  /**
   * @returns {Promise<void>}
   * @private
   */


  function _execUnmount() {
    _execUnmount = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee18() {
      var fireCancel,
          prevState,
          err,
          lcErr,
          _args18 = arguments;
      return regenerator.wrap(function _callee18$(_context18) {
        while (1) {
          switch (_context18.prev = _context18.next) {
            case 0:
              fireCancel = _args18.length > 0 && _args18[0] !== undefined ? _args18[0] : false;
              prevState = this._olObjectState;

              if (fireCancel) {
                if ([OlObjectState.UNDEF, OlObjectState.CREATING, OlObjectState.CREATED, OlObjectState.MOUNTING].includes(this.$olObjectState)) {
                  err = new CanceledError("".concat(this.vmName, " ol object lifecycle canceled"));
                  this.$emit(OlObjectEvent.ERROR, err, this);
                  this.$eventBus.$emit(OlObjectEvent.ERROR, err, this);
                }
              }

              _context18.prev = 3;
              _context18.prev = 4;
              _context18.next = 7;
              return this.$mountPromise;

            case 7:
              _context18.next = 18;
              break;

            case 9:
              _context18.prev = 9;
              _context18.t0 = _context18["catch"](4);

              if (!(_context18.t0 instanceof CanceledError)) {
                _context18.next = 17;
                break;
              }

              if (!(this.$olObjectState !== OlObjectState.MOUNTED)) {
                _context18.next = 15;
                break;
              }

              return _context18.abrupt("return");

            case 15:
              _context18.next = 18;
              break;

            case 17:
              throw _context18.t0;

            case 18:
              this._olObjectState = OlObjectState.UNMOUNTING;
              _context18.next = 21;
              return this.unmount();

            case 21:
              this._olObjectState = OlObjectState.UNMOUNTED;

              this.$emit(OlObjectEvent.UNMOUNTED, this);
              this.$eventBus.$emit(OlObjectEvent.UNMOUNTED, this);
              _context18.next = 34;
              break;

            case 27:
              _context18.prev = 27;
              _context18.t1 = _context18["catch"](3);
              lcErr = new LifecycleError(_context18.t1, this.vmName, OlObjectAction.UNMOUNT);
              this._olObjectState = prevState;
              this.$emit(OlObjectEvent.ERROR, this, lcErr);
              this.$eventBus.$emit(OlObjectEvent.ERROR, this, lcErr);
              throw lcErr;

            case 34:
            case "end":
              return _context18.stop();
          }
        }
      }, _callee18, this, [[3, 27], [4, 9]]);
    }));
    return _execUnmount.apply(this, arguments);
  }

  function execDeinit() {
    return _execDeinit.apply(this, arguments);
  }

  function _execDeinit() {
    _execDeinit = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee19() {
      var prevState, lcErr;
      return regenerator.wrap(function _callee19$(_context19) {
        while (1) {
          switch (_context19.prev = _context19.next) {
            case 0:
              prevState = this._olObjectState;
              _context19.prev = 1;
              _context19.prev = 2;
              _context19.next = 5;
              return this.$unmountPromise;

            case 5:
              _context19.next = 16;
              break;

            case 7:
              _context19.prev = 7;
              _context19.t0 = _context19["catch"](2);

              if (!(_context19.t0 instanceof CanceledError)) {
                _context19.next = 15;
                break;
              }

              if (!(this.$olObjectState !== OlObjectState.CREATED)) {
                _context19.next = 13;
                break;
              }

              return _context19.abrupt("return");

            case 13:
              _context19.next = 16;
              break;

            case 15:
              throw _context19.t0;

            case 16:
              this._olObjectState = OlObjectState.DESTROYING;
              _context19.next = 19;
              return this.deinit();

            case 19:
              this._olObjectState = OlObjectState.DESTROYED;

              this.$emit(OlObjectEvent.DESTROYED, this);
              this.$eventBus.$emit(OlObjectEvent.DESTROYED, this);
              _context19.next = 32;
              break;

            case 25:
              _context19.prev = 25;
              _context19.t1 = _context19["catch"](1);
              lcErr = new LifecycleError(_context19.t1, this.vmName, OlObjectAction.DESTROY);
              this._olObjectState = prevState;
              this.$emit(OlObjectEvent.ERROR, this, lcErr);
              this.$eventBus.$emit(OlObjectEvent.ERROR, this, lcErr);
              throw lcErr;

            case 32:
            case "end":
              return _context19.stop();
          }
        }
      }, _callee19, this, [[1, 25], [2, 7]]);
    }));
    return _execDeinit.apply(this, arguments);
  }

  function subscribeToOlObjectEvents() {
    var _this19 = this;

    if (this.$olObject instanceof ol.Observable) {
      var setterKey = addPrefix('set');
      var propChanges = fromOlChangeEvent(this.$olObject, ['id'], true, function (evt) {
        return _objectSpread$11(_objectSpread$11({}, evt), {}, {
          setter: _this19[setterKey(evt.prop)]
        });
      });
      this.subscribeTo(propChanges, function (_ref6) {
        var setter = _ref6.setter,
            value = _ref6.value;
        return setter(value);
      });
      this.subscribeTo(merge(fromOlEvent(this.$olObject, EventType.CHANGE), fromOlEvent(this.$olObject, ObjectEventType.PROPERTYCHANGE)), this.debounceChanged.bind(this));
      this.subscribeTo(fromOlEvent(this.$olObject, EventType.ERROR), function (evt) {
        return _this19.$emit(OlObjectEvent.ERROR, evt);
      });
    } else {
      this.subscribeTo(interval(FRAME_TIME), this.syncNonObservable.bind(this));
    }
  }

  var LifecycleError = /*#__PURE__*/function (_Error) {
    _inherits$1(LifecycleError, _Error);

    var _super = _createSuper$1(LifecycleError);

    function LifecycleError(err, vmName, action) {
      var _this20;

      _classCallCheck$1(this, LifecycleError);

      if (err instanceof LifecycleError) {
        err = err.err;
      }

      var baseMessage = "".concat(vmName, " ").concat(action, " ol object failed");
      var message = "".concat(baseMessage, ": ").concat(err.message);
      _this20 = _super.call(this, message);

      _defineProperty$1(_assertThisInitialized(_this20), "name", 'LifecycleError');

      _this20.vmName = vmName;
      _this20.action = action;
      _this20.err = err;

      if (err.stack) {
        _this20.stack = "".concat(baseMessage, ": ").concat(err.stack);
      } else {
        if (isFunction$1(Error.captureStackTrace)) {
          Error.captureStackTrace(_assertThisInitialized(_this20), _this20.constructor);
        } else {
          _this20.stack = new Error(message).stack;
        }
      }

      return _this20;
    }

    return LifecycleError;
  }( /*#__PURE__*/_wrapNativeSuper(Error));
  var CanceledError = /*#__PURE__*/function (_Error2) {
    _inherits$1(CanceledError, _Error2);

    var _super2 = _createSuper$1(CanceledError);

    function CanceledError(message) {
      var _this21;

      _classCallCheck$1(this, CanceledError);

      _this21 = _super2.call(this, message);

      _defineProperty$1(_assertThisInitialized(_this21), "name", 'CanceledError');

      if (isFunction$1(Error.captureStackTrace)) {
        Error.captureStackTrace(_assertThisInitialized(_this21), _this21.constructor);
      } else {
        _this21.stack = new Error(message).stack;
      }

      return _this21;
    }

    return CanceledError;
  }( /*#__PURE__*/_wrapNativeSuper(Error));
  function isCreateError(err) {
    return err instanceof LifecycleError && err.action === OlObjectAction.CREATE;
  }
  function isMountError(err) {
    return err instanceof LifecycleError && err.action === OlObjectAction.MOUNT;
  }
  function isUnmountError(err) {
    return err instanceof LifecycleError && err.action === OlObjectAction.UNMOUNT;
  }
  function isDestroyError(err) {
    return err instanceof LifecycleError && err.action === OlObjectAction.DESTROY;
  }
  var OLObjectNotInitializedError = /*#__PURE__*/function (_Error3) {
    _inherits$1(OLObjectNotInitializedError, _Error3);

    var _super3 = _createSuper$1(OLObjectNotInitializedError);

    function OLObjectNotInitializedError(message) {
      var _this22;

      _classCallCheck$1(this, OLObjectNotInitializedError);

      _this22 = _super3.call(this, message);

      _defineProperty$1(_assertThisInitialized(_this22), "name", 'OLObjectNotInitializedError');

      if (isFunction$1(Error.captureStackTrace)) {
        Error.captureStackTrace(_assertThisInitialized(_this22), _this22.constructor);
      } else {
        _this22.stack = new Error(message).stack;
      }

      return _this22;
    }

    return OLObjectNotInitializedError;
  }( /*#__PURE__*/_wrapNativeSuper(Error));
  function makeChangeOrRecreateWatchers(props) {
    var deepProps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    return makeWatchers(props, function (prop) {
      return {
        deep: deepProps.includes(prop),
        handler: function handler() {
          var handler = this["".concat(prop, "Changed")];

          if (isFunction$1(handler)) {
            return handler.apply(void 0, arguments);
          }

          if (isEqual(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1])) return;

          return this.scheduleRecreate();
        }
      };
    });
  }

  function ownKeys$10(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$10(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$10(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$10(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  var serialize = function serialize(value) {
    if (value == null) return;
    return _typeof(value) === 'object' ? JSON.stringify(value) : value;
  };

  var cleanArcGisSourceParams = function cleanArcGisSourceParams(params) {
    return cleanSourceParams(params, ['FORMAT', 'F', 'LAYERS', 'LAYERDEFS', 'DYNAMICLAYERS', 'DPI', 'TRANSPARENT', 'TIME', 'LAYERTIMEOPTIONS', 'GDBVERSION', 'MAPSCALE', 'ROTATION', 'DATUMTRANSFORMATIONS', 'MAPRANGEVALUES', 'LAYERRANGEVALUES', 'LAYERPARAMETERVALUES', 'HISTORICMOMENT']);
  };
  /**
   * Shared ArcGIS source params and methods.
   */


  var arcgisSource = {
    props: {
      // ArcGIS params from https://developers.arcgis.com/rest/services-reference/export-map.htm

      /**
       * @type {boolean}
       */
      hidpi: {
        type: Boolean,
        default: true
      },

      /**
       * @type {string}
       */
      format: {
        type: String,
        default: 'PNG32'
      },

      /**
       * @type {string|string[]|undefined}
       */
      layers: [String, Array],

      /**
       * @type {Object|string|undefined}
       */
      layerDefs: [Object, String],

      /**
       * @type {Object[]|string|undefined}
       */
      dynamicLayers: [Array, String],

      /**
       * @type {number|undefined}
       */
      dpi: Number,

      /**
       * @type {boolean}
       */
      transparent: {
        type: Boolean,
        default: true
      },

      /**
       * @type {string|string[]|undefined}
       */
      time: [String, Array],

      /**
       * @type {Object|string|undefined}
       */
      layerTimeOptions: [Object, String],

      /**
       * @type {string|undefined}
       */
      gdbVersion: String,

      /**
       * @type {string|undefined}
       */
      mapScale: String,

      /**
       * @type {number|undefined}
       */
      rotation: Number,

      /**
       * @type {Array|string|undefined}
       */
      datumTransformations: [Array, String],

      /**
       * @type {Array|string|undefined}
       */
      mapRangeValues: [Array, String],

      /**
       * @type {Array|string|undefined}
       */
      layerRangeValues: [Array, String],

      /**
       * @type {Array|string|undefined}
       */
      layerParameterValues: [Array, String],

      /**
       * @type {number|undefined}
       */
      historicMoment: Number,

      /**
       * Additional ArcGIS request parameters
       * @params {Object|undefined}
       */
      params: Object
    },
    data: function data() {
      return {
        currentParams: undefined
      };
    },
    computed: _objectSpread$10({
      /**
       * @returns {string|undefined}
       */
      inputLayers: function inputLayers() {
        return isArray$2(this.layers) ? this.layers.join(',') : this.layers;
      },

      /**
       * @type {string|undefined}
       */
      inputTime: function inputTime() {
        return isArray$2(this.time) ? this.time.join(',') : this.time;
      },

      /**
       * @return {undefined|string}
       */
      inputLayerDefs: function inputLayerDefs() {
        return serialize(this.layerDefs);
      },

      /**
       * @return {undefined|string}
       */
      inputDynamicLayers: function inputDynamicLayers() {
        return serialize(this.dynamicLayers);
      },

      /**
       * @return {undefined|string}
       */
      inputLayerTimeOptions: function inputLayerTimeOptions() {
        return serialize(this.layerTimeOptions);
      },

      /**
       * @return {undefined|string}
       */
      inputDatumTransformations: function inputDatumTransformations() {
        return serialize(this.datumTransformations);
      },

      /**
       * @return {undefined|string}
       */
      inputMapRangeValues: function inputMapRangeValues() {
        return serialize(this.mapRangeValues);
      },

      /**
       * @return {undefined|string}
       */
      inputLayerRangeValues: function inputLayerRangeValues() {
        return serialize(this.layerRangeValues);
      },

      /**
       * @return {undefined|string}
       */
      inputLayerParameterValues: function inputLayerParameterValues() {
        return serialize(this.layerParameterValues);
      },

      /**
       * @return {undefined|string}
       */
      inputHistoricMoment: function inputHistoricMoment() {
        return serialize(this.historicMoment);
      },

      /**
       * @returns {Object|null}
       */
      customParams: function customParams() {
        return this.params ? cleanArcGisSourceParams(this.params) : undefined;
      },

      /**
       * @returns {Object}
       */
      inputParams: function inputParams() {
        return _objectSpread$10(_objectSpread$10({}, this.customParams || {}), {}, {
          LAYERS: this.inputLayers,
          FORMAT: this.format,
          LAYERDEFS: this.inputLayerDefs,
          DYNAMICLAYERS: this.inputDynamicLayers,
          DPI: this.dpi,
          TRANSPARENT: this.transparent,
          TIME: this.inputTime,
          LAYERTIMEOPTIONS: this.inputLayerTimeOptions,
          GDBVERSION: this.gdbVersion,
          MAPSCALE: this.mapScale,
          ROTATION: this.rotation,
          DATUMTRANSFORMATIONS: this.inputDatumTransformations,
          MAPRANGEVALUES: this.inputMapRangeValues,
          LAYERRANGEVALUES: this.inputLayerRangeValues,
          LAYERPARAMETERVALUES: this.inputLayerParameterValues,
          HISTORICMOMENT: this.inputHistoricMoment
        });
      }
    }, /*#__PURE__*/reduce(['format', 'inputLayers', 'inputLayerDefs', 'inputDynamicLayers', 'dpi', 'transparent', 'inputTime', 'inputLayerTimeOptions', 'gdbVersion', 'mapScale', 'rotation', 'inputDatumTransformations', 'inputMapRangeValues', 'inputLayerRangeValues', 'inputLayerParameterValues', 'inputHistoricMoment'], function (props, inProp) {
      var prop = inProp.slice(0, 5) === 'input' ? lowerFirst(inProp.slice(5)) : inProp;
      var curProp = 'current' + upperFirst(prop);

      props[curProp] = function () {
        return coalesce((this.currentParams || {})[prop.toUpperCase()], (this.inputParams || {})[prop.toUpperCase()]);
      };

      return props;
    }, {})),
    watch: _objectSpread$10(_objectSpread$10({
      rev: function rev() {
        if (!this.$source) return;

        if (!isEqual(this.currentParams, this.$source.getParams())) {
          this.currentParams = this.$source.getParams();
        }
      }
    }, /*#__PURE__*/makeWatchers(['currentFormat', 'currentLayers', 'currentLayerDefs', 'currentDynamicLayers', 'currentDpi', 'currentTransparent', 'currentTime', 'currentLayerTimeOptions', 'currentGdbVersion', 'currentMapScale', 'currentRotation', 'currentDatumTransformations', 'currentMapRangeValues', 'currentLayerRangeValues', 'currentLayerParameterValues', 'currentHistoricMoment'], function (curProp) {
      return function (value) {
        var prop = lowerFirst(curProp.slice(7));
        var inProp = hasProp(this, 'input' + upperFirst(prop)) ? 'input' + upperFirst(prop) : prop;
        if (isEqual(value, this[inProp])) return;
        this.$emit('update:' + prop, isObjectLike(value) ? clonePlainObject(value) : value);
      };
    })), /*#__PURE__*/makeChangeOrRecreateWatchers(['hidpi', 'inputParams', 'currentParams'], ['inputParams', 'currentParams'])),
    created: function created() {
      this.currentParams = this.inputParams && clonePlainObject(this.inputParams);
    },
    methods: {
      /**
       * @returns {Object}
       */
      getParams: function getParams() {
        var _this$$source;

        return coalesce((_this$$source = this.$source) === null || _this$$source === void 0 ? void 0 : _this$$source.getParams(), this.currentParams);
      },

      /**
       * @param {Object} params
       */
      updateParams: function updateParams(params) {
        params = reduce(_objectSpread$10(_objectSpread$10({}, this.currentParams), params), function (params, value, name) {
          return _objectSpread$10(_objectSpread$10({}, params), {}, _defineProperty$1({}, name.toUpperCase(), value));
        }, {});

        if (!isEqual(params, this.currentParams)) {
          this.currentParams = params;
        }

        if (this.$source && !isEqual(params, this.$source.getParams())) {
          this.$source.updateParams(params);
        }
      },

      /**
       * @param {string} param
       * @param {*} value
       */
      updateParam: function updateParam(param, value) {
        this.updateParams(_defineProperty$1({}, param.toUpperCase(), value));
      },

      /**
       * @param {Object|undefined} value
       * @protected
       */
      inputParamsChanged: function inputParamsChanged(value) {
        this.updateParams(value);
      },

      /**
       * @param {Object|undefined} value
       * @protected
       */
      currentParamsChanged: function currentParamsChanged(value) {
        value = value ? cleanArcGisSourceParams(value) : undefined;
        if (isEqual(value, this.customParams)) return;
        this.$emit('update:params', value && clonePlainObject(value));
      }
    }
  };

  /**
   * Mixin with helpers for projection transforms between current view projection and global defined projection.
   */

  var projTransforms = {
    computed: {
      /**
       * @return {module:ol/proj~ProjectionLike}
       */
      resolvedViewProjection: function resolvedViewProjection() {
        return coalesce(this.viewProjection, // may or may not be present
        EPSG_3857);
      },

      /**
       * @return {module:ol/proj~ProjectionLike}
       */
      resolvedDataProjection: function resolvedDataProjection() {
        var _this$$options;

        return coalesce(this.dataProjection, // may or may not be present
        (_this$$options = this.$options) === null || _this$$options === void 0 ? void 0 : _this$$options.dataProjection, // may or may not be present
        this.resolvedViewProjection);
      }
    },
    watch: {
      resolvedViewProjection: function resolvedViewProjection() {
        return this.resolvedViewProjectionChanged.apply(this, arguments);
      },
      resolvedDataProjection: function resolvedDataProjection() {
        return this.resolvedDataProjectionChanged.apply(this, arguments);
      }
    },
    methods: {
      pointToViewProj: function pointToViewProj(point) {
        var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
        return transformPoint(point, this.resolvedDataProjection, this.resolvedViewProjection, precision);
      },
      pointToDataProj: function pointToDataProj(point) {
        var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
        return transformPoint(point, this.resolvedViewProjection, this.resolvedDataProjection, precision);
      },
      lineToViewProj: function lineToViewProj(line) {
        var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
        return transformLine(line, this.resolvedDataProjection, this.resolvedViewProjection, precision);
      },
      lineToDataProj: function lineToDataProj(line) {
        var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
        return transformLine(line, this.resolvedViewProjection, this.resolvedDataProjection, precision);
      },
      polygonToViewProj: function polygonToViewProj(polygon) {
        var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
        return transformPolygon(polygon, this.resolvedDataProjection, this.resolvedViewProjection, precision);
      },
      polygonToDataProj: function polygonToDataProj(polygon) {
        var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
        return transformPolygon(polygon, this.resolvedViewProjection, this.resolvedDataProjection, precision);
      },
      multiPointToViewProj: function multiPointToViewProj(multiPoint) {
        var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
        return transformMultiPoint(multiPoint, this.resolvedDataProjection, this.resolvedViewProjection, precision);
      },
      multiPointToDataProj: function multiPointToDataProj(multiPoint) {
        var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
        return transformMultiPoint(multiPoint, this.resolvedViewProjection, this.resolvedDataProjection, precision);
      },
      multiLineToViewProj: function multiLineToViewProj(multiLine) {
        var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
        return transformMultiLine(multiLine, this.resolvedDataProjection, this.resolvedViewProjection, precision);
      },
      multiLineToDataProj: function multiLineToDataProj(multiLine) {
        var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
        return transformMultiLine(multiLine, this.resolvedViewProjection, this.resolvedDataProjection, precision);
      },
      multiPolygonToViewProj: function multiPolygonToViewProj(multiPolygon) {
        var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
        return transformMultiPolygon(multiPolygon, this.resolvedDataProjection, this.resolvedViewProjection, precision);
      },
      multiPolygonToDataProj: function multiPolygonToDataProj(multiPolygon) {
        var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
        return transformMultiPolygon(multiPolygon, this.resolvedViewProjection, this.resolvedDataProjection, precision);
      },
      extentToViewProj: function extentToViewProj(extent) {
        var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
        return transformExtent$1(extent, this.resolvedDataProjection, this.resolvedViewProjection, precision);
      },
      extentToDataProj: function extentToDataProj(extent) {
        var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
        return transformExtent$1(extent, this.resolvedViewProjection, this.resolvedDataProjection, precision);
      },
      writeGeometryInDataProj: function writeGeometryInDataProj(geometry) {
        var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
        return writeGeoJsonGeometry(geometry, this.resolvedViewProjection, this.resolvedDataProjection, precision);
      },
      writeGeometryInViewProj: function writeGeometryInViewProj(geometry) {
        var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
        return writeGeoJsonGeometry(geometry, this.resolvedViewProjection, this.resolvedViewProjection, precision);
      },
      readGeometryInDataProj: function readGeometryInDataProj(geometry) {
        var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
        return readGeoJsonGeometry(geometry, this.resolvedViewProjection, this.resolvedDataProjection, precision);
      },
      readGeometryInViewProj: function readGeometryInViewProj(geometry) {
        var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
        return readGeoJsonGeometry(geometry, this.resolvedViewProjection, this.resolvedViewProjection, precision);
      },
      writeFeatureInDataProj: function writeFeatureInDataProj(feature) {
        var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
        return writeGeoJsonFeature(feature, this.resolvedViewProjection, this.resolvedDataProjection, precision);
      },
      writeFeatureInViewProj: function writeFeatureInViewProj(feature) {
        var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
        return writeGeoJsonFeature(feature, this.resolvedViewProjection, this.resolvedViewProjection, precision);
      },
      readFeatureInDataProj: function readFeatureInDataProj(feature) {
        var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
        return readGeoJsonFeature(feature, this.resolvedViewProjection, this.resolvedDataProjection, precision);
      },
      readFeatureInViewProj: function readFeatureInViewProj(feature) {
        var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
        return readGeoJsonFeature(feature, this.resolvedViewProjection, this.resolvedViewProjection, precision);
      },

      /**
       * @param {string} value
       * @param {string} prev
       * @protected
       */
      resolvedViewProjectionChanged: function resolvedViewProjectionChanged(value, prev) {
        if (value === prev) return;
        this.$emit('update:viewProjection', value);
      },

      /**
       * @param {string} value
       * @param {string} prev
       * @protected
       */
      resolvedDataProjectionChanged: function resolvedDataProjectionChanged(value, prev) {
        if (value === prev) return;
        this.$emit('update:dataProjection', value);
      }
    }
  };

  /**
   * Renders stub VNode for component.
   */

  var stubVNode = {
    /**
     * @param {function} h
     * @returns {VNode}
     */
    render: function render(h) {
      var _this$$options;

      var options = ((_this$$options = this.$options) === null || _this$$options === void 0 ? void 0 : _this$$options.stubVNode) || {}; // render as HTML comment

      if (options.empty) {
        var vnode = h();

        if (typeof options.empty === 'string') {
          vnode.text = options.empty;
        } else if (typeof options.empty === 'function') {
          vnode.text = options.empty.call(this);
        }

        return vnode;
      }

      var children;

      if (options.slots === false) {
        children = undefined;
      } else {
        children = extractChildren(this.$slots, options.slots);
      }

      var attrs = typeof options.attrs === 'function' ? options.attrs.call(this) : options.attrs;
      var data = {
        attrs: attrs,
        style: {
          display: 'none !important'
        }
      };
      return h(options.tag || 'i', data, children);
    }
  };

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArrayLimit(arr, i) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
  }

  var waitForMap = {
    methods: {
      beforeInit: function beforeInit() {
        var _this = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.prev = 0;
                  _context.next = 3;
                  return waitFor(function () {
                    return _this.$mapVm != null;
                  }, race(_this.$olObjectEvents.pipe(filter(function (_ref) {
                    var name = _ref.name,
                        args = _ref.args;
                    return name === OlObjectEvent.ERROR && args[0] instanceof CanceledError;
                  })), fromVueEvent(_this.$eventBus, OlObjectEvent.ERROR).pipe(filter(function (_ref2) {
                    var _ref3 = _slicedToArray(_ref2, 2),
                        err = _ref3[0],
                        vm = _ref3[1];

                    return isCreateError(err) && hasProp(vm, '$map') && _this.$vq.closest(vm);
                  }))).pipe(mapTo(stubTrue())));

                case 3:
                  if (_this.$mapVm.resolvedViewProjection !== _this.viewProjection) {
                    _this.viewProjection = _this.$mapVm.resolvedViewProjection;
                  }

                  if (_this.$mapVm.resolvedDataProjection !== _this.dataProjection) {
                    _this.dataProjection = _this.$mapVm.resolvedDataProjection;
                  }

                  _this.subscribeTo(fromVueWatcher(_this, function () {
                    return _this.$mapVm.resolvedViewProjection;
                  }), function (_ref4) {
                    var value = _ref4.value;

                    if (value !== _this.viewProjection) {
                      _this.viewProjection = value;
                    }
                  });

                  _this.subscribeTo(fromVueWatcher(_this, function () {
                    return _this.$mapVm.resolvedDataProjection;
                  }), function (_ref5) {
                    var value = _ref5.value;

                    if (value !== _this.dataProjection) {
                      _this.dataProjection = value;
                    }
                  });

                  _context.next = 9;
                  return _this.$nextTickPromise();

                case 9:
                  return _context.abrupt("return", olCmp.methods.beforeInit.call(_this));

                case 12:
                  _context.prev = 12;
                  _context.t0 = _context["catch"](0);
                  _context.t0.message = "".concat(_this.vmName, " wait for $mapVm injection: ").concat(_context.t0.message);
                  throw _context.t0;

                case 16:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee, null, [[0, 12]]);
        }))();
      }
    }
  };

  function ownKeys$$(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$$(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$$(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$$(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  /**
   * Base layer mixin.
   */

  var baseLayer = {
    mixins: [stubVNode, projTransforms, olCmp, waitForMap],
    stubVNode: {
      attrs: function attrs() {
        return {
          id: this.vmId,
          class: this.vmClass
        };
      }
    },
    props: {
      // ol/layer/Base

      /**
       * A CSS class name to set to the layer element.
       * @type {string}
       */
      className: {
        type: String,
        default: 'ol-layer'
      },

      /**
       * @type {number}
       */
      opacity: {
        type: Number,
        default: 1
      },

      /**
       * @type {boolean}
       */
      visible: {
        type: Boolean,
        default: true
      },

      /**
       * @type {number[]|undefined}
       */
      extent: {
        type: Array,
        validator: function validator(value) {
          return value.length === 4 && value.every(isNumber$1);
        }
      },

      /**
       * @type {string|undefined}
       */
      extentProjection: {
        type: String,
        validator: function validator(value) {
          return !!proj.get(value);
        }
      },

      /**
       * @type {number|undefined}
       */
      zIndex: Number,

      /**
       * @type {number|undefined}
       */
      minResolution: Number,

      /**
       * @type {number|undefined}
       */
      maxResolution: Number,

      /**
       * @type {number|undefined}
       */
      minZoom: Number,

      /**
       * @type {number|undefined}
       */
      maxZoom: Number
    },
    data: function data() {
      return {
        viewProjection: EPSG_3857,
        dataProjection: EPSG_3857,
        currentExtentViewProj: roundExtent(this.extent),
        currentMaxResolution: this.maxResolution,
        currentMinResolution: this.minResolution,
        currentMaxZoom: this.maxZoom,
        currentMinZoom: this.minZoom,
        currentOpacity: this.opacity,
        currentVisible: this.visible,
        currentZIndex: this.zIndex
      };
    },
    computed: {
      resolvedExtentProjection: function resolvedExtentProjection() {
        return coalesce(this.extentProjection, this.resolvedDataProjection);
      },
      extentDataProj: function extentDataProj() {
        return roundExtent(this.extent);
      },
      extentViewProj: function extentViewProj() {
        return transformExtent$1(this.extent, this.resolvedExtentProjection, this.resolvedViewProjection);
      },
      currentExtentDataProj: function currentExtentDataProj() {
        return transformExtent$1(this.currentExtentViewProj, this.resolvedViewProjection, this.resolvedExtentProjection);
      }
    },
    watch: _objectSpread$$({
      rev: function rev() {
        if (!this.$layer) return;

        if (!isEqual(this.currentExtentViewProj, this.$layer.getExtent())) {
          this.currentExtentViewProj = this.$layer.getExtent();
        }

        if (this.currentMaxResolution !== this.$layer.getMaxResolution()) {
          this.currentMaxResolution = this.$layer.getMaxResolution();
        }

        if (this.currentMinResolution !== this.$layer.getMinResolution()) {
          this.currentMinResolution = this.$layer.getMinResolution();
        }

        if (this.currentMaxZoom !== this.$layer.getMaxZoom()) {
          this.currentMaxZoom = this.$layer.getMaxZoom();
        }

        if (this.currentMinZoom !== this.$layer.getMinZoom()) {
          this.currentMinZoom = this.$layer.getMinZoom();
        }

        if (this.currentOpacity !== this.$layer.getOpacity()) {
          this.currentOpacity = this.$layer.getOpacity();
        }

        if (this.currentVisible !== this.$layer.getVisible()) {
          this.currentVisible = this.$layer.getVisible();
        }

        if (this.currentZIndex !== this.$layer.getZIndex()) {
          this.currentZIndex = this.$layer.getZIndex();
        }
      }
    }, /*#__PURE__*/makeChangeOrRecreateWatchers(['className', 'opacity', 'currentOpacity', 'visible', 'currentVisible', 'extentViewProj', 'currentExtentDataProj', 'zIndex', 'currentZIndex', 'minResolution', 'currentMinResolution', 'maxResolution', 'currentMaxResolution', 'minZoom', 'currentMinZoom', 'maxZoom', 'currentMaxZoom'], ['extentViewProj', 'currentExtentDataProj'])),
    created: function created() {
      var _this$extentViewProj;

      defineServices$r.call(this);
      this.currentExtentViewProj = (_this$extentViewProj = this.extentViewProj) === null || _this$extentViewProj === void 0 ? void 0 : _this$extentViewProj.slice();
    },
    methods: {
      /**
       * @return {Promise<void>}
       * @protected
       */
      beforeInit: function beforeInit() {
        var _this = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return Promise.all([olCmp.methods.beforeInit.call(_this), waitForMap.methods.beforeInit.call(_this)]);

                case 2:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      },

      /**
       * @return {Promise<module:ol/layer/Base~BaseLayer>}
       * @protected
       */
      createOlObject: function createOlObject() {
        var _this2 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.t0 = initializeLayer;
                  _context2.next = 3;
                  return _this2.createLayer();

                case 3:
                  _context2.t1 = _context2.sent;
                  _context2.t2 = _this2.currentId;
                  return _context2.abrupt("return", (0, _context2.t0)(_context2.t1, _context2.t2));

                case 6:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }))();
      },

      /**
       * @return {module:ol/layer/Base~BaseLayer|Promise<module:ol/layer/Base~BaseLayer>}
       * @protected
       * @abstract
       */
      createLayer: function createLayer() {
        throw new Error("".concat(this.vmName, " not implemented method: createLayer"));
      },

      /**
       * @return {Promise<void>}
       * @protected
       */
      mount: function mount() {
        var _this3 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3() {
          var _this3$$layersContain;

          return regenerator.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  (_this3$$layersContain = _this3.$layersContainer) === null || _this3$$layersContain === void 0 ? void 0 : _this3$$layersContain.addLayer(_this3);
                  return _context3.abrupt("return", olCmp.methods.mount.call(_this3));

                case 2:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }))();
      },

      /**
       * @return {Promise<void>}
       * @protected
       */
      unmount: function unmount() {
        var _this4 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4() {
          var _this4$$layersContain;

          return regenerator.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  (_this4$$layersContain = _this4.$layersContainer) === null || _this4$$layersContain === void 0 ? void 0 : _this4$$layersContain.removeLayer(_this4);
                  return _context4.abrupt("return", olCmp.methods.unmount.call(_this4));

                case 2:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4);
        }))();
      },

      /**
       * @returns {Object}
       * @protected
       */
      getServices: function getServices() {
        var vm = this;
        return mergeDescriptors(olCmp.methods.getServices.call(this), {
          get layerVm() {
            return vm;
          }

        });
      },

      /**
       * @return {void}
       * @protected
       */
      subscribeAll: function subscribeAll() {
        olCmp.methods.subscribeAll.call(this);
        subscribeToLayerEvents$4.call(this);
      },

      /**
       * @returns {string|number}
       * @protected
       */
      getIdInternal: function getIdInternal() {
        return getLayerId(this.$layer);
      },

      /**
       * @param {string|number} id
       * @protected
       */
      setIdInternal: function setIdInternal(id) {
        if (id === this.getIdInternal()) return;
        setLayerId(this.$layer, id);
      },

      /**
       * @return {Promise<module:ol/layer/Base~BaseLayer>}
       */
      resolveLayer: olCmp.methods.resolveOlObject,

      /**
       * @param {boolean} [viewProj=false]
       * @returns {number[]|undefined}
       */
      getExtent: function getExtent() {
        var viewProj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

        if (!this.$layer) {
          return viewProj ? this.currentExtentViewProj : this.currentExtentDataProj;
        }

        var extent = this.$layer.getExtent();
        if (viewProj) return roundExtent(extent);
        return transformExtent$1(extent, this.resolvedViewProjection, this.resolvedExtentProjection);
      },

      /**
       * @param {number[]} extent
       * @param {boolean} [viewProj=false]
       */
      setExtent: function setExtent(extent) {
        var viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        assert$1(extent == null || isArray$2(extent) && extent.length === 4, 'Invalid extent');
        extent = viewProj ? roundExtent(extent) : transformExtent$1(extent, this.resolvedExtentProjection, this.resolvedViewProjection);

        if (!isEqual(extent, this.currentExtentViewProj)) {
          this.currentExtentViewProj = extent;
        }

        if (this.$layer && !isEqual(extent, this.$layer.getExtent())) {
          this.$layer.setExtent(extent);
        }
      },

      /**
       * @returns {number|undefined}
       */
      getMaxResolution: function getMaxResolution() {
        var _this$$layer;

        return coalesce((_this$$layer = this.$layer) === null || _this$$layer === void 0 ? void 0 : _this$$layer.getMaxResolution(), this.currentMaxResolution);
      },

      /**
       * @param {number} resolution
       */
      setMaxResolution: function setMaxResolution(resolution) {
        resolution = Number(resolution);
        assert$1(isNumber$1(resolution), 'Invalid max resolution');

        if (resolution !== this.currentMaxResolution) {
          this.currentMaxResolution = resolution;
        }

        if (this.$layer && resolution !== this.$layer.getMaxResolution()) {
          this.$layer.setMaxResolution(resolution);
        }
      },

      /**
       * @returns {number|undefined}
       */
      getMinResolution: function getMinResolution() {
        var _this$$layer2;

        return coalesce((_this$$layer2 = this.$layer) === null || _this$$layer2 === void 0 ? void 0 : _this$$layer2.getMinResolution(), this.currentMinResolution);
      },

      /**
       * @param {number} resolution
       */
      setMinResolution: function setMinResolution(resolution) {
        resolution = Number(resolution);
        assert$1(isNumber$1(resolution), 'Invalid min resolution');

        if (resolution !== this.currentMinResolution) {
          this.currentMinResolution = resolution;
        }

        if (this.$layer && resolution !== this.$layer.getMinResolution()) {
          this.$layer.getMinResolution(resolution);
        }
      },

      /**
       * @returns {number}
       */
      getMaxZoom: function getMaxZoom() {
        var _this$$layer3;

        return coalesce((_this$$layer3 = this.$layer) === null || _this$$layer3 === void 0 ? void 0 : _this$$layer3.getMaxZoom(), this.currentMaxZoom);
      },

      /**
       * @param {number} zoom
       */
      setMaxZoom: function setMaxZoom(zoom) {
        zoom = Number(zoom);
        assert$1(isNumber$1(zoom), 'Invalid max zoom');

        if (zoom !== this.currentMaxZoom) {
          this.currentMaxZoom = zoom;
        }

        if (this.$layer && zoom !== this.$layer.getMaxZoom()) {
          this.$layer.setMaxZoom(zoom);
        }
      },

      /**
       * @returns {number}
       */
      getMinZoom: function getMinZoom() {
        var _this$$layer4;

        return coalesce((_this$$layer4 = this.$layer) === null || _this$$layer4 === void 0 ? void 0 : _this$$layer4.getMinZoom(), this.currentMinZoom);
      },

      /**
       * @param {number} zoom
       */
      setMinZoom: function setMinZoom(zoom) {
        zoom = Number(zoom);
        assert$1(isNumber$1(zoom), 'Invalid min zoom');

        if (zoom !== this.currentMinZoom) {
          this.currentMinZoom = zoom;
        }

        if (this.$layer && zoom !== this.$layer.getMinZoom()) {
          this.$layer.setMinZoom(zoom);
        }
      },

      /**
       * @returns {number}
       */
      getOpacity: function getOpacity() {
        var _this$$layer5;

        return coalesce((_this$$layer5 = this.$layer) === null || _this$$layer5 === void 0 ? void 0 : _this$$layer5.getOpacity(), this.currentOpacity);
      },

      /**
       * @param {number} opacity
       */
      setOpacity: function setOpacity(opacity) {
        opacity = Number(opacity);
        assert$1(isNumber$1(opacity), 'Invalid opacity');

        if (opacity !== this.currentOpacity) {
          this.currentOpacity = opacity;
        }

        if (this.$layer && opacity !== this.$layer.getOpacity()) {
          this.$layer.setOpacity(opacity);
        }
      },

      /**
       * @returns {boolean}
       */
      getVisible: function getVisible() {
        var _this$$layer6;

        return coalesce((_this$$layer6 = this.$layer) === null || _this$$layer6 === void 0 ? void 0 : _this$$layer6.getVisible(), this.currentVisible);
      },

      /**
       * @param {boolean} visible
       */
      setVisible: function setVisible(visible) {
        visible = !!visible;

        if (visible !== this.currentVisible) {
          this.currentVisible = visible;
        }

        if (this.$layer && visible !== this.$layer.getVisible()) {
          this.$layer.setVisible(visible);
        }
      },

      /**
       * @returns {number}
       */
      getZIndex: function getZIndex() {
        var _this$$layer7;

        return coalesce((_this$$layer7 = this.$layer) === null || _this$$layer7 === void 0 ? void 0 : _this$$layer7.getZIndex(), this.currentZIndex);
      },

      /**
       * @param {number} zIndex
       */
      setZIndex: function setZIndex(zIndex) {
        zIndex = Number(zIndex);
        assert$1(isNumber$1(zIndex), 'Invalid zIndex');

        if (zIndex !== this.currentZIndex) {
          this.currentZIndex = zIndex;
        }

        if (this.$layer && zIndex !== this.$layer.getZIndex()) {
          this.$layer.setZIndex(zIndex);
        }
      },

      /**
       * @param {number[]} pixel
       * @return {boolean}
       */
      isAtPixel: function isAtPixel(pixel) {
        var _this5 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee5() {
          var layer;
          return regenerator.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  _context5.next = 2;
                  return _this5.resolveLayer();

                case 2:
                  layer = _context5.sent;
                  return _context5.abrupt("return", _this5.$mapVm.forEachLayerAtPixel(pixel, function (mapLayer) {
                    return mapLayer === layer;
                  }));

                case 4:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5);
        }))();
      },

      /**
       * @param {number} value
       * @protected
       */
      opacityChanged: function opacityChanged(value) {
        this.setOpacity(value);
      },

      /**
       * @param {number} value
       * @protected
       */
      currentOpacityChanged: function currentOpacityChanged(value) {
        if (value === this.opacity) return;
        this.$emit('update:opacity', value);
      },

      /**
       * @param {boolean} value
       * @protected
       */
      visibleChanged: function visibleChanged(value) {
        this.setVisible(value);
      },

      /**
       * @param {boolean} value
       * @protected
       */
      currentVisibleChanged: function currentVisibleChanged(value) {
        if (value === this.visible) return;
        this.$emit('update:visible', value);
      },

      /**
       * @param {number[]|undefined} value
       * @protected
       */
      extentViewProjChanged: function extentViewProjChanged(value) {
        this.setExtent(value, true);
      },

      /**
       * @param {number[]|undefined} value
       * @protected
       */
      currentExtentDataProjChanged: function currentExtentDataProjChanged(value) {
        if (isEqual(value, this.extentDataProj)) return;
        this.$emit('update:extent', value.slice());
      },

      /**
       * @param {number|undefined} value
       * @protected
       */
      zIndexChanged: function zIndexChanged(value) {
        this.setZIndex(value);
      },

      /**
       * @param {number|undefined} value
       * @protected
       */
      currentZIndexChanged: function currentZIndexChanged(value) {
        if (value === this.zIndex) return;
        this.$emit('update:zIndex', value);
      },

      /**
       * @param {number|undefined} value
       * @protected
       */
      minResolutionChanged: function minResolutionChanged(value) {
        this.setMinResolution(value);
      },

      /**
       * @param {number|undefined} value
       * @protected
       */
      currentMinResolutionChanged: function currentMinResolutionChanged(value) {
        if (value === this.minResolution) return;
        this.$emit('update:minResolution', value);
      },

      /**
       * @param {number|undefined} value
       * @protected
       */
      maxResolutionChanged: function maxResolutionChanged(value) {
        this.setMaxResolution(value);
      },

      /**
       * @param {number|undefined} value
       * @protected
       */
      currentMaxResolutionChanged: function currentMaxResolutionChanged(value) {
        if (value === this.maxResolution) return;
        this.$emit('update:maxResolution', value);
      },

      /**
       * @param {number|undefined} value
       * @protected
       */
      minZoomChanged: function minZoomChanged(value) {
        this.setMinZoom(value);
      },

      /**
       * @param {number|undefined} value
       * @protected
       */
      currentMinZoomChanged: function currentMinZoomChanged(value) {
        if (value === this.minZoom) return;
        this.$emit('update:minZoom', value);
      },

      /**
       * @param {number|undefined} value
       * @protected
       */
      maxZoomChanged: function maxZoomChanged(value) {
        this.setMaxZoom(value);
      },

      /**
       * @param {number|undefined} value
       * @protected
       */
      currentMaxZoomChanged: function currentMaxZoomChanged(value) {
        if (value === this.maxZoom) return;
        this.$emit('update:maxZoom', value);
      }
    }
  };

  function defineServices$r() {
    var _this6 = this;

    Object.defineProperties(this, {
      /**
       * @type {module:ol/layer/Base~BaseLayer|undefined}
       */
      $layer: {
        enumerable: true,
        get: function get() {
          return _this6.$olObject;
        }
      },

      /**
       * @type {Object|undefined}
       */
      $mapVm: {
        enumerable: true,
        get: function get() {
          var _this6$$services;

          return (_this6$$services = _this6.$services) === null || _this6$$services === void 0 ? void 0 : _this6$$services.mapVm;
        }
      },

      /**
       * @type {Object|undefined}
       */
      $viewVm: {
        enumerable: true,
        get: function get() {
          var _this6$$services2;

          return (_this6$$services2 = _this6.$services) === null || _this6$$services2 === void 0 ? void 0 : _this6$$services2.viewVm;
        }
      },

      /**
       * @type {Object|undefined}
       */
      $layersContainer: {
        enumerable: true,
        get: function get() {
          var _this6$$services3;

          return (_this6$$services3 = _this6.$services) === null || _this6$$services3 === void 0 ? void 0 : _this6$$services3.layersContainer;
        }
      }
    });
  }

  function subscribeToLayerEvents$4() {
    return _subscribeToLayerEvents$3.apply(this, arguments);
  }

  function _subscribeToLayerEvents$3() {
    _subscribeToLayerEvents$3 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee6() {
      var _this7 = this;

      var setterKey, propChanges;
      return regenerator.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              setterKey = addPrefix('set');
              propChanges = fromOlChangeEvent(this.$layer, ['opacity', 'visible', 'zIndex', 'minResolution', 'maxResolution', 'minZoom', 'maxZoom', 'extent'], true, function (evt) {
                return _objectSpread$$(_objectSpread$$({}, evt), {}, {
                  setter: function setter(val) {
                    var args = [val];

                    if (evt.prop === 'extent') {
                      args.push(true);
                    }

                    _this7[setterKey(evt.prop)].apply(_this7, args);
                  }
                });
              });
              this.subscribeTo(propChanges, function (_ref) {
                var setter = _ref.setter,
                    value = _ref.value;
                return setter(value);
              });

            case 3:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this);
    }));
    return _subscribeToLayerEvents$3.apply(this, arguments);
  }

  /**
   * @module ol/CollectionEventType
   */
  /**
   * @enum {string}
   */
  var CollectionEventType = {
      /**
       * Triggered when an item is added to the collection.
       * @event module:ol/Collection.CollectionEvent#add
       * @api
       */
      ADD: 'add',
      /**
       * Triggered when an item is removed from the collection.
       * @event module:ol/Collection.CollectionEvent#remove
       * @api
       */
      REMOVE: 'remove',
  };

  function ownKeys$_(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$_(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$_(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$_(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  /**
   * @typedef {module:ol/control/Control~Control|Object} ControlLike
   */

  /**
   * Controls collection
   */

  var controlsContainer = {
    mixins: [identMap, rxSubs],
    computed: {
      /**
       * @type {string|undefined}
       */
      controlsCollectionIdent: function controlsCollectionIdent() {
        if (!this.olObjIdent) return;
        return this.makeIdent(this.olObjIdent, 'controls_collection');
      }
    },
    watch: _objectSpread$_({}, /*#__PURE__*/makeChangeOrRecreateWatchers(['controlsCollectionIdent'])),
    created: function created() {
      /**
       * @type {module:ol/Collection~Collection<module:ol/control/Control~Control>}
       * @private
       */
      this._controlsCollection = this.instanceFactoryCall(this.controlsCollectionIdent, function () {
        return new ol.Collection();
      });
      this._controlSubs = {};
      defineServices$q.call(this);
    },
    methods: {
      /**
       * @returns {{readonly controlsContainer: Object}}
       * @protected
       */
      getServices: function getServices() {
        var vm = this;
        return {
          get controlsContainer() {
            return vm;
          }

        };
      },

      /**
       * @return {void}
       * @protected
       */
      subscribeAll: function subscribeAll() {
        subscribeToCollectionEvents$4.call(this);
      },

      /**
       * @param {ControlLike[]|module:ol/Collection~Collection<ControlLike>} defaultControls
       */
      initDefaultControls: function initDefaultControls(defaultControls) {
        var _this = this;

        this.getControls().forEach(function (control) {
          if (control.get('vl_default')) {
            _this.removeControl(control);
          }
        });
        var controls;

        if (isArray$2(defaultControls) || defaultControls instanceof ol.Collection) {
          controls = defaultControls;
        } else if (defaultControls !== false) {
          controls = control.defaults(isPlainObject(defaultControls) ? defaultControls : undefined);
        }

        if (controls) {
          controls.forEach(function (control) {
            return control.set('vl_default', true);
          });
          this.addControls(controls);
        }
      },

      /**
       * @param {ControlLike} control
       * @return {Control}
       */
      initializeControl: function initializeControl$1(control$1) {
        var _control;

        control$1 = ((_control = control$1) === null || _control === void 0 ? void 0 : _control.$control) || control$1;
        instanceOf(control$1, control.Control);
        return initializeControl(control$1);
      },

      /**
       * @param {ControlLike[]|module:ol/Collection~Collection<ControlLike>} controls
       */
      addControls: function addControls(controls) {
        forEach(controls, this.addControl.bind(this));
      },

      /**
       * @param {ControlLike} control
       */
      addControl: function addControl(control) {
        control = this.initializeControl(control);
        if (this.getControlById(getControlId(control))) return;
        this.$controlsCollection.push(control);
      },

      /**
       * @param {ControlLike[]|module:ol/Collection~Collection<ControlLike>} controls
       */
      removeControls: function removeControls(controls) {
        forEach(controls, this.removeControl.bind(this));
      },

      /**
       * @param {ControlLike} control
       */
      removeControl: function removeControl(control) {
        var _control2;

        control = this.getControlById(getControlId(((_control2 = control) === null || _control2 === void 0 ? void 0 : _control2.$control) || control));
        if (!control) return;
        this.$controlsCollection.remove(control);
      },

      /**
       * @return {void}
       */
      clearControls: function clearControls() {
        this.$controlsCollection.clear();
      },

      /**
       * @returns {Array<module:ol/control/Control~Control>}
       */
      getControls: function getControls() {
        return this.$controlsCollection.getArray().slice();
      },

      /**
       * @returns {module:ol/Collection~Collection<module:ol/control/Control~Control>}
       */
      getControlsCollection: function getControlsCollection() {
        return this._controlsCollection;
      },

      /**
       * @param {string|number} controlId
       * @returns {ControlLike}
       */
      getControlById: function getControlById(controlId) {
        return find(this.getControls(), function (control) {
          return getControlId(control) === controlId;
        });
      },

      /**
       * @param {string|undefined} value
       * @param {string|undefined} prevValue
       * @protected
       */
      controlsCollectionIdentChanged: function controlsCollectionIdentChanged(value, prevValue) {
        if (value && prevValue) {
          this.moveInstance(value, prevValue);
        } else if (value && !prevValue && this.$controlsCollection) {
          this.setInstance(value, this.$controlsCollection);
        } else if (!value && prevValue) {
          this.unsetInstance(prevValue);
        }
      }
    }
  };

  function defineServices$q() {
    Object.defineProperties(this, {
      $controlsCollection: {
        enumerable: true,
        get: this.getControlsCollection
      }
    });
  }

  function subscribeToCollectionEvents$4() {
    var _this2 = this;

    var adds = fromOlEvent(this.$controlsCollection, CollectionEventType.ADD).pipe(map(function (evt) {
      return _objectSpread$_(_objectSpread$_({}, evt), {}, {
        element: _this2.initializeControl(evt.element)
      });
    }), tap(function (_ref) {
      var element = _ref.element;
      var uid = util.getUid(element);
      var propChanges = fromOlChangeEvent(element, 'id', true);
      _this2._controlSubs[uid] = _this2.subscribeTo(propChanges, _this2.scheduleRefresh.bind(_this2));
    }));
    var removes = fromOlEvent(this.$controlsCollection, CollectionEventType.REMOVE).pipe(tap(function (_ref2) {
      var element = _ref2.element;
      var uid = util.getUid(element);

      if (_this2._controlSubs[uid]) {
        _this2.unsubscribe(_this2._controlSubs[uid]);

        delete _this2._controlSubs[uid];
      }
    }));
    var events = merge(adds, removes).pipe(bufferDebounceTime(FRAME_TIME));
    this.subscribeTo(events, /*#__PURE__*/function () {
      var _ref3 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(events) {
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _this2.debounceChanged();

              case 2:
                forEach(events, function (_ref4) {
                  var type = _ref4.type,
                      element = _ref4.element;

                  _this2.$emit(type + 'control', element); // todo remove in v0.13.x


                  _this2.$emit(type + ':control', element);
                });

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function (_x) {
        return _ref3.apply(this, arguments);
      };
    }());
  }

  /**
   * @typedef {Geometry|Object} GeometryLike
   */

  /**
   * @typedef {Object} GeometryTarget
   * @property {function(): Geometry|undefined} getGeometry
   * @property {function(Geometry|undefined): void} setGeometry
   */

  /**
   * Geometry container
   */

  var geometryContainer = {
    mixins: [projTransforms],
    created: function created() {
      this._geometry = undefined;
      this._geometryVm = undefined;
      defineService.call(this);
    },
    methods: {
      /**
       * @returns {{readonly geometryContainer: Object}}
       * @protected
       */
      getServices: function getServices() {
        var vm = this;
        return {
          get geometryContainer() {
            return vm;
          }

        };
      },

      /**
       * @return {GeometryTarget|undefined}
       * @protected
       */
      getGeometryTarget: function getGeometryTarget() {
        throw new Error("".concat(this.vmName, " not implemented method: getGeometryTarget()"));
      },

      /**
       * @return {module:ol/geom/Geometry~Geometry|undefined}
       */
      getGeometry: function getGeometry() {
        var _this$getGeometryTarg;

        return coalesce((_this$getGeometryTarg = this.getGeometryTarget()) === null || _this$getGeometryTarg === void 0 ? void 0 : _this$getGeometryTarg.getGeometry(), this._geometry);
      },

      /**
       * @return {Object}
       */
      getGeometryVm: function getGeometryVm() {
        return this._geometryVm;
      },

      /**
       * @param {GeometryLike|undefined} geom
       * @param {boolean} [viewProj=false]
       */
      setGeometry: function setGeometry(geom$1) {
        var _geom;

        var viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        geom$1 = ((_geom = geom$1) === null || _geom === void 0 ? void 0 : _geom.$geometry) || geom$1;

        if (isGeoJSONGeometry(geom$1)) {
          if (viewProj) {
            geom$1 = this.readGeometryInViewProj(geom$1);
          } else {
            geom$1 = this.readGeometryInDataProj(geom$1);
          }
        }

        geom$1 || (geom$1 = undefined);
        assert$1(!geom$1 || geom$1 instanceof geom.Geometry, 'Invalid geometry');
        var geomTarget = this.getGeometryTarget();

        if (geomTarget && geom$1 !== geomTarget.getGeometry()) {
          geomTarget.setGeometry(geom$1);
          this.scheduleRefresh();
        }

        if (geom$1 !== this._geometry) {
          var _geom2;

          this._geometry = geom$1;
          this._geometryVm = ((_geom2 = geom$1) === null || _geom2 === void 0 ? void 0 : _geom2.vm) && geom$1.vm[0];
          this.scheduleRefresh();
        }
      }
    }
  };

  function defineService() {
    Object.defineProperties(this, {
      $geometry: {
        enumerable: true,
        get: this.getGeometry
      },
      $geometryVm: {
        enumerable: true,
        get: this.getGeometryVm
      }
    });
  }

  /**
   * @typedef {
   *            module:ol/style/Style~Style |
   *            Array<module:ol/style/Style~Style> |
   *            module:ol/style/Style~StyleFunction
   *          } OlStyleLike
   */

  /**
   * @typedef {Object} StyleTarget
   * @property {function(OlStyleLike|undefined): void} setStyle
   * @property {function(): OlStyleLike|undefined} getStyle
   */

  /**
   * @typedef {OlStyleLike|Object} StyleLike
   */

  /**
   * Style container mixin.
   */

  var styleContainer = {
    created: function created() {
      this._style = undefined;
      defineServices$p.call(this);
    },
    methods: {
      /**
       * @returns {{readonly styleContainer: Object}}
       * @protected
       */
      getServices: function getServices() {
        var vm = this;
        return {
          get styleContainer() {
            return vm;
          }

        };
      },

      /**
       * Default style factory
       * @return {OlStyleLike|undefined}
       * @protected
       */
      getDefaultStyle: function getDefaultStyle() {},

      /**
       * Returns OL object that can be styled (i.e. has setStyle/getStyle methods) or undefined
       * @return {StyleTarget|undefined}
       * @protected
       * @abstract
       */
      getStyleTarget: function getStyleTarget() {
        throw new Error("".concat(this.vmName, " not implemented method: getStyleTarget()"));
      },

      /**
       * @return {StyleLike|undefined}
       */
      getStyle: function getStyle() {
        var _this$getStyleTarget;

        return coalesce((_this$getStyleTarget = this.getStyleTarget()) === null || _this$getStyleTarget === void 0 ? void 0 : _this$getStyleTarget.getStyle(), this._style);
      },

      /**
       * @param {StyleLike} style
       */
      addStyle: function addStyle(style) {
        if (!style) return;
        var olStyle = (style === null || style === void 0 ? void 0 : style.$style) || style;
        var currentStyle = this._style;

        if (isFunction$1(olStyle)) {

          currentStyle = style;
        } else {
          if (!isArray$2(currentStyle)) {

            currentStyle = [];
          }

          if (!currentStyle.includes(olStyle)) {
            currentStyle.push(olStyle);
          }
        }

        this.setStyle(currentStyle);
      },

      /**
       * @param {StyleLike|undefined} style
       */
      removeStyle: function removeStyle(style) {
        var _style;

        if (!style) return;
        style = ((_style = style) === null || _style === void 0 ? void 0 : _style.$style) || style;
        var currentStyle = this._style;

        if (currentStyle === style) {
          currentStyle = undefined;
        } else if (isArray$2(currentStyle)) {
          currentStyle = currentStyle.filter(function (s) {
            return s !== style;
          });

          if (currentStyle.length === 0) {
            currentStyle = undefined;
          }
        }

        this.setStyle(currentStyle);
      },

      /**
       * @param {StyleLike|undefined} style
       */
      setStyle: function setStyle(style) {
        style || (style = undefined);

        if (style) {
          if (hasProp(style, '$style') || hasProp(style, '$styleFunction')) {
            style = style.$style || style.$styleFunction;
          } else if (isArray$2(style)) {
            style = style.map(function (style) {
              return (style === null || style === void 0 ? void 0 : style.$style) || style;
            });
          }

          if (isFunction$1(style)) {
            style = this.createStyleFunc(style, this.getDefaultStyle());
          } else {
            isArray$2(style) || (style = [style]);
            style.length > 0 || (style = undefined);
          }
        }

        var styleTarget = this.getStyleTarget();

        if (styleTarget && !isEqual(style, styleTarget.getStyle())) {
          styleTarget.setStyle(style);
          this.scheduleRefresh();
        }

        if (!isEqual(style, this._style)) {
          this._style = style;
          this.scheduleRefresh();
        }
      },

      /**
       * Style function factory
       * @param {StyleLike|undefined} style
       * @param {StyleLike|undefined} defaultStyle
       * @returns {module:ol/style/Style~StyleFunction}
       * @protected
       */
      createStyleFunc: function createStyleFunc(style, defaultStyle) {
        return function __styleFunc(feature, resolution) {
          if (!feature.getGeometry()) return;
          var compiledStyle;

          if (style && isFunction$1(style)) {
            // style - custom ol/style/Style~StyleFunction
            compiledStyle = style(feature, resolution);
          } else if (isArray$2(style)) {
            // style - array of ol/style/Style objects
            compiledStyle = style.slice();
          } // not empty or null style


          if (compiledStyle == null || isArray$2(compiledStyle) && compiledStyle.length || compiledStyle instanceof style$1.Style) {
            return compiledStyle;
          } // fallback to default style


          if (defaultStyle) {
            return isFunction$1(defaultStyle) ? defaultStyle(feature, resolution) : defaultStyle;
          }

          return null;
        };
      }
    }
  };

  function defineServices$p() {
    Object.defineProperties(this, {
      $style: {
        enumerable: true,
        get: this.getStyle
      }
    });
  }

  function ownKeys$Z(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$Z(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$Z(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$Z(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  /**
   * A vector object for geographic features with a geometry and other attribute properties,
   * similar to the features in vector file formats like **GeoJSON**.
   */

  var feature = {
    mixins: [stubVNode, projTransforms, geometryContainer, styleContainer, olCmp, waitForMap],
    stubVNode: {
      empty: false,
      attrs: function attrs() {
        return {
          id: this.vmId,
          class: this.vmClass
        };
      }
    },
    props: {
      properties: {
        type: Object,
        default: stubObject
      }
    },
    data: function data() {
      return {
        viewProjection: EPSG_3857,
        dataProjection: EPSG_3857,
        currentProperties: clonePlainObject(this.properties),
        currentGeometryName: 'geometry'
      };
    },
    computed: {
      geometryDataProj: function geometryDataProj() {
        if (!(this.rev && this.$geometry)) return;
        return this.writeGeometryInDataProj(this.$geometry);
      },
      geometryViewProj: function geometryViewProj() {
        if (!(this.rev && this.$geometry)) return;
        return this.writeGeometryInViewProj(this.$geometry);
      },
      pointDataProj: function pointDataProj() {
        return this.pointToDataProj(this.pointViewProj);
      },
      pointViewProj: function pointViewProj() {
        if (!(this.rev && this.$geometry)) return;
        return findPointOnSurface(this.$geometry);
      },
      style: function style() {
        var _this = this;

        if (!(this.rev && this.$style)) return;
        var style = this.$style;
        if (isFunction$1(style)) return style;
        if (!style) return;
        isArray$2(style) || (style = [style]);
        return style.map(function (style) {
          return dumpStyle(style, function (geom) {
            return _this.writeGeometryInDataProj(geom);
          });
        });
      }
    },
    watch: _objectSpread$Z({
      rev: function rev() {
        if (!this.$feature) return;

        if (!isEqual(this.currentProperties, getFeatureProperties(this.$feature))) {
          this.currentProperties = getFeatureProperties(this.$feature);
        }

        if (this.currentGeometryName !== this.$feature.getGeometryName()) {
          this.currentGeometryName = this.$feature.getGeometryName();
        }
      }
    }, /*#__PURE__*/makeChangeOrRecreateWatchers(['properties', 'currentProperties', 'currentGeometryName', 'geometryDataProj', 'pointDataProj', 'style'], ['properties', 'currentProperties', 'geometryDataProj', 'pointDataProj', 'style'])),
    created: function created() {
      defineServices$o.call(this);
    },
    methods: {
      /**
       * @return {Promise<void>}
       * @protected
       */
      beforeInit: function beforeInit() {
        var _this2 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return Promise.all([olCmp.methods.beforeInit.call(_this2), waitForMap.methods.beforeInit.call(_this2)]);

                case 2:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      },

      /**
       * Create feature without inner style applying, feature level style
       * will be applied in the layer level style function.
       * @return {module:ol/Feature~Feature}
       * @protected
       */
      createOlObject: function createOlObject() {
        var feature = initializeFeature(this.createFeature(), this.currentId);
        feature.setGeometryName(this.currentGeometryName);
        feature.setGeometry(this.$geometry);
        feature.setStyle(this.$style);
        return feature;
      },

      /**
       * @returns {Feature}
       */
      createFeature: function createFeature() {
        return new ol.Feature(this.currentProperties);
      },

      /**
       * @return {Promise<void>}
       * @protected
       */
      beforeMount: function beforeMount() {
        var _this3 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.prev = 0;
                  _context2.next = 3;
                  return waitFor(function () {
                    return _this3.$geometryVm != null;
                  }, race(_this3.$olObjectEvents.pipe(filter(function (_ref) {
                    var name = _ref.name,
                        args = _ref.args;
                    return name === OlObjectEvent.ERROR && args[0] instanceof CanceledError;
                  })), fromVueEvent(_this3.$eventBus, ObjectEventType.ERROR).pipe(filter(function (_ref2) {
                    var _vm$$vq;

                    var _ref3 = _slicedToArray(_ref2, 2),
                        err = _ref3[0],
                        vm = _ref3[1];

                    return (isCreateError(err) || isMountError(err)) && hasProp(vm, '$geometry') && ((_vm$$vq = vm.$vq) === null || _vm$$vq === void 0 ? void 0 : _vm$$vq.closest(_this3));
                  }))).pipe(mapTo(stubTrue())));

                case 3:
                  return _context2.abrupt("return", olCmp.methods.beforeMount.call(_this3));

                case 6:
                  _context2.prev = 6;
                  _context2.t0 = _context2["catch"](0);
                  _context2.t0.message = "".concat(_this3.vmName, " wait for $geometry failed: ").concat(_context2.t0.message);
                  throw _context2.t0;

                case 10:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, null, [[0, 6]]);
        }))();
      },

      /**
       * @return {Promise<void>}
       * @protected
       */
      mount: function mount() {
        var _this4 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3() {
          var _this4$$featuresConta;

          return regenerator.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  (_this4$$featuresConta = _this4.$featuresContainer) === null || _this4$$featuresConta === void 0 ? void 0 : _this4$$featuresConta.addFeature(_this4);
                  return _context3.abrupt("return", olCmp.methods.mount.call(_this4));

                case 2:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }))();
      },

      /**
       * @return {Promise<void>}
       * @protected
       */
      unmount: function unmount() {
        var _this5 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4() {
          var _this5$$featuresConta;

          return regenerator.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  (_this5$$featuresConta = _this5.$featuresContainer) === null || _this5$$featuresConta === void 0 ? void 0 : _this5$$featuresConta.removeFeature(_this5);
                  return _context4.abrupt("return", olCmp.methods.unmount.call(_this5));

                case 2:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4);
        }))();
      },

      /**
       * @return {void}
       * @protected
       */
      subscribeAll: function subscribeAll() {
        olCmp.methods.subscribeAll.call(this);
        subscribeToEvents$2.call(this);
      },

      /**
       * @return {Object}
       * @protected
       */
      getServices: function getServices() {
        var vm = this;
        return mergeDescriptors(olCmp.methods.getServices.call(this), geometryContainer.methods.getServices.call(this), styleContainer.methods.getServices.call(this), {
          get featureVm() {
            return vm;
          }

        });
      },

      /**
       * @return {string|number}
       */
      getIdInternal: function getIdInternal() {
        return getFeatureId(this.$feature);
      },

      /**
       * @param {string|number} id
       * @return {void}
       */
      setIdInternal: function setIdInternal(id) {
        if (id === this.getIdInternal()) return;
        setFeatureId(this.$feature, id);
      },

      /**
       * @return {Promise<Feature>}
       */
      resolveFeature: olCmp.methods.resolveOlObject,

      /**
       * @return {Feature}
       * @protected
       */
      getGeometryTarget: function getGeometryTarget() {
        return this.$feature;
      },

      /**
       * @return {Feature}
       * @protected
       */
      getStyleTarget: function getStyleTarget() {
        return this.$feature;
      },

      /**
       * @return {string}
       */
      getGeometryName: function getGeometryName() {
        var _this$$feature;

        return coalesce((_this$$feature = this.$feature) === null || _this$$feature === void 0 ? void 0 : _this$$feature.getGeometryName(), this.currentGeometryName);
      },

      /**
       * @param {string} geometryName
       */
      setGeometryName: function setGeometryName(geometryName) {
        assert$1(isString(geometryName) && !isEmpty$2(geometryName), 'Invalid geometry name');

        if (geometryName !== this.currentGeometryName) {
          this.currentGeometryName = geometryName;
        }

        if (this.$feature && geometryName !== this.$feature.getGeometryName()) {
          this.$feature.setGeometryName(geometryName);
        }
      },

      /**
       * @return {Object}
       */
      getProperties: function getProperties() {
        return coalesce(this.$feature && getFeatureProperties(this.$feature), this.currentProperties);
      },

      /**
       * @param {Object} properties
       */
      setProperties: function setProperties(properties) {
        properties = getFeatureProperties({
          properties: properties
        });

        if (!isEqual(properties, this.currentProperties)) {
          this.currentProperties = properties;
        }

        if (this.$feature && !isEqual(properties, getFeatureProperties(this.$feature))) {
          setFeatureProperties(this.$feature, properties);
        }
      },

      /**
       * Checks if feature lies at `pixel`.
       * @param {number[]} pixel
       * @return {Promise<boolean>}
       */
      isAtPixel: function isAtPixel(pixel) {
        var _this6 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee5() {
          var selfFeature, layerFilter, selfLayer;
          return regenerator.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  _context5.next = 2;
                  return _this6.resolveFeature();

                case 2:
                  selfFeature = _context5.sent;

                  if (!_this6.$layerVm) {
                    _context5.next = 8;
                    break;
                  }

                  _context5.next = 6;
                  return _this6.$layerVm.resolveLayer();

                case 6:
                  selfLayer = _context5.sent;

                  layerFilter = function layerFilter(layer) {
                    return layer === selfLayer;
                  };

                case 8:
                  return _context5.abrupt("return", _this6.$mapVm.forEachFeatureAtPixel(pixel, function (feature) {
                    return feature === selfFeature;
                  }, {
                    layerFilter: layerFilter
                  }));

                case 9:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5);
        }))();
      },

      /**
       * @param {Object|undefined} value
       * @protected
       */
      propertiesChanged: function propertiesChanged(value) {
        this.setProperties(value);
      },

      /**
       * @param {Object|undefined} value
       * @protected
       */
      currentPropertiesChanged: function currentPropertiesChanged(value) {
        if (isEqual(value, this.properties)) return;
        this.$emit('update:properties', value && clonePlainObject(value));
      },

      /**
       * @param {string} value
       * @param {string} prev
       * @protected
       */
      currentGeometryNameChanged: function currentGeometryNameChanged(value, prev) {
        if (value === prev) return;
        this.$emit('update:geometryName', value);
      },

      /**
       * @param {Object|undefined} value
       * @param {Object|undefined} prev
       * @protected
       */
      geometryDataProjChanged: function geometryDataProjChanged(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit('update:geometry', value && clonePlainObject(value));
      },

      /**
       * @param {Object|undefined} value
       * @param {Object|undefined} prev
       * @protected
       */
      pointDataProjChanged: function pointDataProjChanged(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit('update:point', value && clonePlainObject(value));
      },

      /**
       * @param {Object|Function|Array|undefined} value
       * @param {Object|Function|Array|undefined} prev
       * @protected
       */
      styleChanged: function styleChanged(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit('update:style', isObjectLike(value) ? clonePlainObject(value) : value);
      }
    }
  };

  function defineServices$o() {
    var _this7 = this;

    Object.defineProperties(this, {
      $feature: {
        enumerable: true,
        get: function get() {
          return _this7.$olObject;
        }
      },
      $layerVm: {
        enumerable: true,
        get: function get() {
          var _this7$$services;

          return (_this7$$services = _this7.$services) === null || _this7$$services === void 0 ? void 0 : _this7$$services.layerVm;
        }
      },
      $mapVm: {
        enumerable: true,
        get: function get() {
          var _this7$$services2;

          return (_this7$$services2 = _this7.$services) === null || _this7$$services2 === void 0 ? void 0 : _this7$$services2.mapVm;
        }
      },
      $featuresContainer: {
        enumerable: true,
        get: function get() {
          var _this7$$services3;

          return (_this7$$services3 = _this7.$services) === null || _this7$$services3 === void 0 ? void 0 : _this7$$services3.featuresContainer;
        }
      }
    });
  }

  function subscribeToEvents$2() {
    return _subscribeToEvents$2.apply(this, arguments);
  }

  function _subscribeToEvents$2() {
    _subscribeToEvents$2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee6() {
      var _this8 = this;

      var propChanges;
      return regenerator.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              propChanges = fromOlEvent(this.$feature, ObjectEventType.PROPERTYCHANGE, function (_ref4) {
                var key = _ref4.key;

                switch (key) {
                  case _this8.$feature.getGeometryName():
                    return {
                      prop: 'geometry',
                      value: _this8.$feature.getGeometry(),
                      setter: function setter(geom) {
                        return _this8.setGeometry(geom, true);
                      }
                    };

                  default:
                    return {
                      prop: 'properties',
                      value: getFeatureProperties(_this8.$feature),
                      setter: _this8.setProperties
                    };
                }
              }).pipe(distinctUntilChanged(isEqual));
              this.subscribeTo(propChanges, function (_ref5) {
                var setter = _ref5.setter,
                    value = _ref5.value;
                return setter(value);
              });

            case 2:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6, this);
    }));
    return _subscribeToEvents$2.apply(this, arguments);
  }

  var featureHelper = {
    methods: {
      /**
       * @param {FeatureLike} feature
       * @param {boolean} [viewProj=false]
       * @return {Feature}
       * @protected
       */
      initializeFeature: function initializeFeature$1(feature) {
        var _feature;

        var viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        feature = ((_feature = feature) === null || _feature === void 0 ? void 0 : _feature.$feature) || feature;

        if (isPlainObject(feature)) {
          if (viewProj) {
            feature = this.readFeatureInViewProj(feature);
          } else {
            feature = this.readFeatureInDataProj(feature);
          }
        }

        return initializeFeature(feature);
      },

      /**
       * @param {module:ol/Feature~Feature} feature
       * @param {module:ol/Feature~Feature} newFeature
       * @protected
       */
      updateFeature: function updateFeature(feature, newFeature) {
        var _this$$mapVm;

        if ((_this$$mapVm = this.$mapVm) !== null && _this$$mapVm !== void 0 && _this$$mapVm.isInteracting()) return;
        var featureJson = this.writeFeatureInViewProj(feature);
        var newFeatureJson = this.writeFeatureInViewProj(newFeature);
        if (isEqual(featureJson, newFeatureJson)) return;

        if (getFeatureId(feature) !== getFeatureId(newFeature)) {
          setFeatureId(feature, getFeatureId(newFeature));
        }

        var properties = getFeatureProperties(newFeature);
        var currentProperties = getFeatureProperties(feature);

        if (!isEqual(properties, currentProperties)) {
          setFeatureProperties(feature, properties);
        }

        var geomJson = get$1(newFeatureJson, "properties.".concat(CIRCLE_SERIALIZE_PROP)) || newFeatureJson.geometry || null;
        var currentGeomJson = get$1(featureJson, "properties.".concat(CIRCLE_SERIALIZE_PROP)) || featureJson.geometry || null;

        if (!isEqual(geomJson, currentGeomJson)) {
          feature.setGeometry(newFeature.getGeometry() || null);
        }

        var style = newFeature.getStyle();
        var currentStyle = feature.getStyle();

        if (isFunction$1(currentStyle) && isFunction$1(style)) {
          if (currentStyle !== style) {
            feature.setStyle(style);
          }
        } else if (isFunction$1(style)) {
          feature.setStyle(style);
        }

        var styleJson = get$1(newFeatureJson, "properties.".concat(STYLE_SERIALIZE_PROP)) || null;
        var currentStyleJson = get$1(featureJson, "properties.".concat(STYLE_SERIALIZE_PROP)) || null;

        if (!isEqual(styleJson, currentStyleJson)) {
          feature.setStyle(style);
        }
      }
    }
  };

  function ownKeys$Y(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$Y(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$Y(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$Y(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  /**
   * @typedef {module:ol/Feature~Feature|Object} FeatureLike
   */

  /**
   * Features container
   */

  var featuresContainer = {
    mixins: [identMap, rxSubs, projTransforms, featureHelper],
    computed: {
      /**
       * @returns {string|undefined}
       */
      featuresCollectionIdent: function featuresCollectionIdent() {
        if (!this.olObjIdent) return;
        return this.makeIdent(this.olObjIdent, 'features_collection');
      }
    },
    watch: _objectSpread$Y({}, /*#__PURE__*/makeChangeOrRecreateWatchers(['featuresCollectionIdent'])),
    created: function created() {
      /**
       * @type {module:ol/Collection~Collection<module:ol/Feature~Feature>}
       * @private
       */
      this._featuresCollection = this.instanceFactoryCall(this.featuresCollectionIdent, function () {
        return new ol.Collection();
      });
      this._featureSubs = {};
      defineServices$n.call(this);
    },
    methods: {
      /**
       * @returns {{readonly featuresContainer: Object}}
       * @protected
       */
      getServices: function getServices() {
        var vm = this;
        return {
          get featuresContainer() {
            return vm;
          }

        };
      },

      /**
       * @return {void}
       * @protected
       */
      subscribeAll: function subscribeAll() {
        subscribeToCollectionEvents$3.call(this);
      },

      /**
       * @param {FeatureLike[]|module:ol/Collection~Collection<FeatureLike>} features
       * @param {boolean} [viewProj=false]
       */
      addFeatures: function addFeatures(features) {
        var _this = this;

        var viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        forEach(features, function (feature) {
          return _this.addFeature(feature, viewProj);
        });
      },

      /**
       * @param {FeatureLike} feature
       * @param {boolean} [viewProj=false]
       */
      addFeature: function addFeature(feature) {
        var viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        feature = this.initializeFeature(feature, viewProj); // todo add hash {featureId => featureIdx, ....}

        var foundFeature = this.getFeatureById(getFeatureId(feature));

        if (foundFeature == null) {
          this.$featuresCollection.push(feature);
        } else {
          this.updateFeature(foundFeature, feature);
        }
      },

      /**
       * @param {FeatureLike[]|module:ol/Collection~Collection<FeatureLike>} features
       */
      removeFeatures: function removeFeatures(features) {
        forEach(features, this.removeFeature.bind(this));
      },

      /**
       * @param {FeatureLike} feature
       */
      removeFeature: function removeFeature(feature) {
        var _feature;

        feature = this.getFeatureById(getFeatureId(((_feature = feature) === null || _feature === void 0 ? void 0 : _feature.$feature) || feature));
        if (!feature) return;
        this.$featuresCollection.remove(feature);
      },

      /**
       * @return {void}
       */
      clearFeatures: function clearFeatures() {
        this.$featuresCollection.clear();
      },

      /**
       * @param {string|number} featureId
       * @return {module:ol/Feature~Feature|undefined}
       */
      getFeatureById: function getFeatureById(featureId) {
        // todo add hash {featureId => featureIdx, ....}
        return find(this.getFeatures(), function (feature) {
          return getFeatureId(feature) === featureId;
        });
      },

      /**
       * @return {Array<module:ol/Feature~Feature>}
       */
      getFeatures: function getFeatures() {
        return this.$featuresCollection.getArray().slice();
      },

      /**
       * @return {module:ol/Collection~Collection<module:ol/Feature~Feature>}
       */
      getFeaturesCollection: function getFeaturesCollection() {
        return this._featuresCollection;
      },

      /**
       * @param {function} callback
       * @return {*}
       */
      forEachFeature: function forEachFeature(callback) {
        var res;
        this.$featuresCollection.forEach(function () {
          res = callback.apply(void 0, arguments);
        });
        return res;
      },

      /**
       * @param {number[]} extent
       * @param {function} callback
       * @param {boolean} [viewProj=false]
       * @returns {*}
       */
      forEachFeatureInExtent: function forEachFeatureInExtent(extent, callback) {
        var viewProj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        extent = viewProj ? roundExtent(extent) : this.extentToViewProj(extent);
        return this.forEachFeature(function (feature) {
          var geometry = feature.getGeometry();

          if (geometry && geometry.intersectsExtent(extent)) {
            var result = callback(feature);

            if (result) {
              return result;
            }
          }
        });
      },

      /**
       * @param {number[]} extent
       * @param {function} callback
       * @param {boolean} [viewProj=false]
       * @returns {*}
       */
      forEachFeatureIntersectingExtent: function forEachFeatureIntersectingExtent(extent, callback) {
        var viewProj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        return this.forEachFeatureInExtent(extent, callback, viewProj);
      },

      /**
       * @param {number[]} coordinate
       * @param {boolean} [viewProj=false]
       * @returns {Array<module:ol/Feature~Feature>}
       */
      getFeaturesAtCoordinate: function getFeaturesAtCoordinate(coordinate) {
        var viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        return this.getFeaturesInExtent([coordinate[0], coordinate[1], coordinate[0], coordinate[1]], viewProj);
      },

      /**
       * @param {number[]} extent
       * @param {boolean} [viewProj=false]
       * @returns {Array<module:ol/Feature~Feature>}
       */
      getFeaturesInExtent: function getFeaturesInExtent(extent) {
        var viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var features = [];
        this.forEachFeatureIntersectingExtent(extent, function (feature) {
          features.push(feature);
        }, viewProj);
        return features;
      },

      /**
       * @param {number[]} coordinate
       * @param {function} [filter]
       * @param {boolean} [viewProj=false]
       * @returns {module:ol/Feature~Feature}
       */
      getClosestFeatureToCoordinate: function getClosestFeatureToCoordinate(coordinate) {
        var filter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity$2;
        var viewProj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        coordinate = viewProj ? roundPointCoords(coordinate) : this.pointToViewProj(coordinate);
        var closestFeature;
        var minSquaredDistance = Infinity;
        this.forEachFeature(function (feature) {
          if (!filter(feature)) return;
          var geometry = feature.getGeometry();
          if (!geometry) return;
          var closestPoint = geometry.getClosestPoint(coordinate);
          var prevSquaredDistance = minSquaredDistance;
          minSquaredDistance = Math.pow(closestPoint[0] - coordinate[0], 2) + Math.pow(closestPoint[1] - coordinate[1]);

          if (minSquaredDistance < prevSquaredDistance) {
            closestFeature = feature;
          }
        });
        return closestFeature;
      },

      /**
       * @param {boolean} [viewProj=false]
       * @returns {number[]}
       */
      getFeaturesExtent: function getFeaturesExtent() {
        var viewProj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        var extent;
        this.forEachFeature(function (feature) {
          var geometry = feature.getGeometry();
          if (!geometry) return;
          var geomExtent = geometry.getExtent();

          if (!extent) {
            extent = geomExtent;
          } else {
            extent = [geomExtent[0] < extent[0] ? geomExtent[0] : extent[0], geomExtent[1] < extent[1] ? geomExtent[1] : extent[1], geomExtent[2] > extent[2] ? geomExtent[2] : extent[2], geomExtent[3] > extent[3] ? geomExtent[3] : extent[3]];
          }
        });
        return viewProj ? extent : this.extentToDataProj(extent);
      },

      /**
       * @param {string|undefined} value
       * @param {string|undefined} prevValue
       * @protected
       */
      featuresCollectionIdentChanged: function featuresCollectionIdentChanged(value, prevValue) {
        if (value && prevValue) {
          this.moveInstance(value, prevValue);
        } else if (value && !prevValue && this.$featuresCollection) {
          this.setInstance(value, this.$featuresCollection);
        } else if (!value && prevValue) {
          this.unsetInstance(prevValue);
        }
      }
    }
  };

  function defineServices$n() {
    Object.defineProperties(this, {
      $featuresCollection: {
        enumerable: true,
        get: this.getFeaturesCollection
      }
    });
  }

  function subscribeToCollectionEvents$3() {
    var _this2 = this;

    var adds = fromOlEvent(this.$featuresCollection, CollectionEventType.ADD).pipe(map(function (evt) {
      return _objectSpread$Y(_objectSpread$Y({}, evt), {}, {
        element: _this2.initializeFeature(evt.element)
      });
    }), tap(function (_ref) {
      var element = _ref.element;
      var uid = util.getUid(element);
      var propChanges = fromOlEvent(element, ObjectEventType.PROPERTYCHANGE);
      var changes = fromOlEvent(element, EventType.CHANGE);
      var events = merge(propChanges, changes).pipe(distinctUntilChanged(isEqual));
      _this2._featureSubs[uid] = _this2.subscribeTo(events, _this2.debounceChanged.bind(_this2));
    }));
    var removes = fromOlEvent(this.$featuresCollection, CollectionEventType.REMOVE).pipe(tap(function (_ref2) {
      var element = _ref2.element;
      var uid = util.getUid(element);

      if (_this2._featureSubs[uid]) {
        _this2.unsubscribe(_this2._featureSubs[uid]);

        delete _this2._featureSubs[uid];
      }
    }));
    var events = merge(adds, removes).pipe(map(function (_ref3) {
      var type = _ref3.type,
          element = _ref3.element;
      var viewProj = _this2.resolvedViewProjection;
      var dataProj = _this2.resolvedDataProjection;
      return {
        type: type,
        feature: element,

        get json() {
          if (!this._json) {
            this._json = writeGeoJsonFeature(this.feature, viewProj, dataProj, COORD_PRECISION);
          }

          return this._json;
        }

      };
    }), bufferDebounceTime(FRAME_TIME));
    this.subscribeTo(events, /*#__PURE__*/function () {
      var _ref4 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(events) {
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _this2.debounceChanged();

              case 2:
                forEach(events, function (evt) {
                  _this2.$emit(evt.type + 'feature', evt); // todo remove in v0.13.x


                  _this2.$emit(evt.type + ':feature', evt.feature);
                });

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function (_x) {
        return _ref4.apply(this, arguments);
      };
    }());
  }

  /**
   * @typedef {module:ol/style/Fill~Fill|Object|undefined} FillStyleLike
   */

  /**
   * @typedef {Object} FillStyleTarget
   * @property {function(): module:ol/style/Fill~Fill|undefined} getFill
   * @property {function(module:ol/style/Fill~Fill|undefined): void} setFill
   */

  /**
   * Fill style container.
   */

  var fillStyleContainer = {
    created: function created() {
      this._fill = undefined;
      this._fillVm = undefined;
      defineServices$m.call(this);
    },
    methods: {
      /**
       * @returns {{readonly fillStyleContainer: Object}}
       */
      getServices: function getServices() {
        var vm = this;
        return {
          get fillStyleContainer() {
            return vm;
          }

        };
      },

      /**
       * @return {FillStyleTarget}
       */
      getFillStyleTarget: function getFillStyleTarget() {
        throw new Error("".concat(this.vmName, " not implemented method: getFillStyleTarget()"));
      },

      /**
       * @returns {module:ol/style/Fill~Fill|undefined}
       */
      getFill: function getFill() {
        var _this$getFillStyleTar;

        return coalesce((_this$getFillStyleTar = this.getFillStyleTarget()) === null || _this$getFillStyleTar === void 0 ? void 0 : _this$getFillStyleTar.getFill(), this._fill);
      },

      /**
       * @return {Object}
       */
      getFillVm: function getFillVm() {
        return this._fillVm;
      },

      /**
       * @param {module:ol/style/Fill~Fill|undefined} fill
       */
      setFill: function setFill(fill) {
        var _fill;

        fill = ((_fill = fill) === null || _fill === void 0 ? void 0 : _fill.$style) || fill;
        fill || (fill = undefined);
        assert$1(!fill || fill instanceof style$1.Fill, 'Invalid fill style');

        if (fill !== this._fill) {
          var _fill2;

          this._fill = fill;
          this._fillVm = ((_fill2 = fill) === null || _fill2 === void 0 ? void 0 : _fill2.vm) && fill.vm[0];
          this.scheduleRefresh();
        }

        var fillTarget = this.getFillStyleTarget();

        if (fillTarget && fill !== fillTarget.getFill()) {
          fillTarget.setFill(fill);
          this.scheduleRefresh();
        }
      }
    }
  };

  function defineServices$m() {
    Object.defineProperties(this, {
      $fill: {
        enumerable: true,
        get: this.getFill
      },
      $fillVm: {
        enumerable: true,
        get: this.getFillVm
      }
    });
  }

  function ownKeys$X(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$X(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$X(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$X(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  /**
   * Base geometry mixin.
   */

  var geometry = {
    mixins: [stubVNode, projTransforms, olCmp, waitForMap],
    stubVNode: {
      empty: function empty() {
        return this.vmId;
      }
    },
    data: function data() {
      return {
        viewProjection: EPSG_3857,
        dataProjection: EPSG_3857,
        extentViewProj: undefined
      };
    },
    computed: {
      type: function type() {
        if (!(this.rev && this.$geometry)) return;
        return this.getType();
      },
      extentDataProj: function extentDataProj() {
        return this.extentToDataProj(this.extentViewProj);
      }
    },
    watch: _objectSpread$X({
      rev: function rev() {
        if (!this.$geometry) return;

        if (!isEqual(this.extentViewProj, this.$geometry.getExtent())) {
          this.extentViewProj = this.$geometry.getExtent().slice();
        }
      }
    }, /*#__PURE__*/makeChangeOrRecreateWatchers(['extentDataProj'], ['extentDataProj'])),
    created: function created() {
      defineServices$l.call(this);
    },
    methods: {
      /**
       * @return {Promise<void>}
       * @protected
       */
      beforeInit: function beforeInit() {
        var _this = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return Promise.all([olCmp.methods.beforeInit.call(_this), waitForMap.methods.beforeInit.call(_this)]);

                case 2:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      },

      /**
       * @return {Promise<module:ol/geom/Geometry~Geometry>}
       * @protected
       */
      createOlObject: function createOlObject() {
        var _this2 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.t0 = initializeGeometry;
                  _context2.next = 3;
                  return _this2.createGeometry();

                case 3:
                  _context2.t1 = _context2.sent;
                  _context2.t2 = _this2.currentId;
                  return _context2.abrupt("return", (0, _context2.t0)(_context2.t1, _context2.t2));

                case 6:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }))();
      },

      /**
       * @return {module:ol/geom/Geometry~Geometry|Promise<module:ol/geom/Geometry~Geometry>}
       * @protected
       * @abstract
       */
      createGeometry: function createGeometry() {
        throw new Error("".concat(this.vmName, " not implemented method: createGeometry()"));
      },

      /**
       * @return {Promise<void>}
       * @protected
       */
      mount: function mount() {
        var _this3 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3() {
          var _this3$$geometryConta;

          return regenerator.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  (_this3$$geometryConta = _this3.$geometryContainer) === null || _this3$$geometryConta === void 0 ? void 0 : _this3$$geometryConta.setGeometry(_this3);
                  return _context3.abrupt("return", olCmp.methods.mount.call(_this3));

                case 2:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }))();
      },

      /**
       * @return {Promise<void>}
       * @protected
       */
      unmount: function unmount() {
        var _this4 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4() {
          var _this4$$geometryConta;

          return regenerator.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  if (((_this4$$geometryConta = _this4.$geometryContainer) === null || _this4$$geometryConta === void 0 ? void 0 : _this4$$geometryConta.getGeometryVm()) === _this4) {
                    _this4.$geometryContainer.setGeometry(null);
                  }

                  return _context4.abrupt("return", olCmp.methods.unmount.call(_this4));

                case 2:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4);
        }))();
      },

      /**
       * @return {Object}
       * @protected
       */
      getServices: function getServices() {
        var vm = this;
        return mergeDescriptors(olCmp.methods.getServices.call(this), {
          get geometryVm() {
            return vm;
          }

        });
      },

      /**
       * @returns {void}
       */
      subscribeAll: function subscribeAll() {
        olCmp.methods.subscribeAll.call(this);
        subscribeToGeometryEvents.call(this);
      },

      /**
       * @returns {string|number}
       */
      getIdInternal: function getIdInternal() {
        return getGeometryId(this.$geometry);
      },

      /**
       * @param {string|number} id
       */
      setIdInternal: function setIdInternal(id) {
        if (id === this.getIdInternal()) return;
        setGeometryId(this.$geometry, id);
      },

      /**
       * @return {Promise<module:ol/geom/Geometry~Geometry>}
       */
      resolveGeometry: olCmp.methods.resolveOlObject,

      /**
       * @returns {string}
       */
      getType: function getType() {
        var _this$$geometry;

        return coalesce((_this$$geometry = this.$geometry) === null || _this$$geometry === void 0 ? void 0 : _this$$geometry.getType(), this.type);
      },

      /**
       * @param {boolean} [viewProj=false]
       * @returns {number[]}
       */
      getExtent: function getExtent() {
        var _this$$geometry2;

        var viewProj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        var extent = coalesce((_this$$geometry2 = this.$geometry) === null || _this$$geometry2 === void 0 ? void 0 : _this$$geometry2.getExtent(), this.extentViewProj);
        return viewProj ? roundExtent(extent) : this.extentToDataProj(extent);
      },

      /**
       * @param {number[]} point
       * @param {boolean} [viewProj=false]
       * @returns {Promise<number[]>}
       */
      getClosestPoint: function getClosestPoint(point) {
        var _arguments = arguments,
            _this5 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee5() {
          var viewProj, closestPoint;
          return regenerator.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  viewProj = _arguments.length > 1 && _arguments[1] !== undefined ? _arguments[1] : false;
                  point = viewProj ? roundPointCoords(point) : _this5.pointToViewProj(point);
                  _context5.next = 4;
                  return _this5.resolveGeometry();

                case 4:
                  closestPoint = _context5.sent.getClosestPoint(point);
                  return _context5.abrupt("return", viewProj ? roundPointCoords(closestPoint) : _this5.pointToDataProj(closestPoint));

                case 6:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5);
        }))();
      },

      /**
       * @param {number[]} coordinate
       * @param {boolean} [viewProj=false]
       * @returns {Promise<boolean>}
       */
      intersectsCoordinate: function intersectsCoordinate(coordinate) {
        var _arguments2 = arguments,
            _this6 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee6() {
          var viewProj;
          return regenerator.wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  viewProj = _arguments2.length > 1 && _arguments2[1] !== undefined ? _arguments2[1] : false;
                  coordinate = viewProj ? roundPointCoords(coordinate) : _this6.pointToViewProj(coordinate);
                  _context6.next = 4;
                  return _this6.resolveGeometry();

                case 4:
                  return _context6.abrupt("return", _context6.sent.intersectsCoordinate(coordinate));

                case 5:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6);
        }))();
      },

      /**
       * @param {number[]} extent
       * @param {boolean} [viewProj=false]
       * @returns {Promise<boolean>}
       */
      intersectsExtent: function intersectsExtent(extent) {
        var _arguments3 = arguments,
            _this7 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee7() {
          var viewProj;
          return regenerator.wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  viewProj = _arguments3.length > 1 && _arguments3[1] !== undefined ? _arguments3[1] : false;
                  extent = viewProj ? roundExtent(extent) : _this7.extentToViewProj(extent);
                  _context7.next = 4;
                  return _this7.resolveGeometry();

                case 4:
                  return _context7.abrupt("return", _context7.sent.intersectsExtent(extent));

                case 5:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee7);
        }))();
      },

      /**
       * @param {number} angle Angle in radians
       * @param {number[]} anchor
       * @param {boolean} [viewProj=false]
       * @returns {Promise<void>}
       */
      rotate: function rotate(angle, anchor) {
        var _arguments4 = arguments,
            _this8 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee8() {
          var viewProj;
          return regenerator.wrap(function _callee8$(_context8) {
            while (1) {
              switch (_context8.prev = _context8.next) {
                case 0:
                  viewProj = _arguments4.length > 2 && _arguments4[2] !== undefined ? _arguments4[2] : false;
                  anchor = viewProj ? roundPointCoords(anchor) : _this8.pointToViewProj(anchor);
                  _context8.next = 4;
                  return _this8.resolveGeometry();

                case 4:
                  _context8.sent.rotate(angle, anchor);

                case 5:
                case "end":
                  return _context8.stop();
              }
            }
          }, _callee8);
        }))();
      },

      /**
       * @param {number} sx
       * @param {number} [sy]
       * @param {number[]} [anchor]
       * @param {boolean} [viewProj=false]
       * @returns {Promise<void>}
       */
      scale: function scale(sx, sy, anchor) {
        var _arguments5 = arguments,
            _this9 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee9() {
          var viewProj, _ref, _ref2, _ref3, _ref4;

          return regenerator.wrap(function _callee9$(_context9) {
            while (1) {
              switch (_context9.prev = _context9.next) {
                case 0:
                  viewProj = _arguments5.length > 3 && _arguments5[3] !== undefined ? _arguments5[3] : false;
                  anchor = viewProj ? roundPointCoords(anchor) : _this9.pointToViewProj(anchor);
                  _ref = viewProj ? roundPointCoords([sx, 0]) : _this9.pointToViewProj([sx, 0]);
                  _ref2 = _slicedToArray(_ref, 1);
                  sx = _ref2[0];
                  _ref3 = viewProj ? roundPointCoords([0, sy]) : _this9.pointToViewProj([0, sy]);
                  _ref4 = _slicedToArray(_ref3, 2);
                  sy = _ref4[1];
                  _context9.next = 10;
                  return _this9.resolveGeometry();

                case 10:
                  _context9.sent.scale(sx, sy, anchor);

                case 11:
                case "end":
                  return _context9.stop();
              }
            }
          }, _callee9);
        }))();
      },

      /**
       * @param {number} tolerance
       * @returns {Promise<module:ol/geom/Geometry~Geometry>}
       */
      simplify: function simplify(tolerance) {
        var _this10 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee10() {
          return regenerator.wrap(function _callee10$(_context10) {
            while (1) {
              switch (_context10.prev = _context10.next) {
                case 0:
                  _context10.next = 2;
                  return _this10.resolveGeometry();

                case 2:
                  return _context10.abrupt("return", _context10.sent.simplify(tolerance));

                case 3:
                case "end":
                  return _context10.stop();
              }
            }
          }, _callee10);
        }))();
      },

      /**
       * @param dx
       * @param dy
       * @param {boolean} [viewProj=false]
       * @returns {Promise<*>}
       */
      translate: function translate(dx, dy) {
        var _arguments6 = arguments,
            _this11 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee11() {
          var viewProj, _ref5, _ref6, _ref7, _ref8;

          return regenerator.wrap(function _callee11$(_context11) {
            while (1) {
              switch (_context11.prev = _context11.next) {
                case 0:
                  viewProj = _arguments6.length > 2 && _arguments6[2] !== undefined ? _arguments6[2] : false;
                  _ref5 = viewProj ? roundPointCoords([dx, 0]) : _this11.pointToViewProj([dx, 0]);
                  _ref6 = _slicedToArray(_ref5, 1);
                  dx = _ref6[0];
                  _ref7 = viewProj ? roundPointCoords([0, dy]) : _this11.pointToViewProj([0, dy]);
                  _ref8 = _slicedToArray(_ref7, 2);
                  dy = _ref8[1];
                  _context11.next = 9;
                  return _this11.resolveGeometry();

                case 9:
                  return _context11.abrupt("return", _context11.sent.translate(dx, dy));

                case 10:
                case "end":
                  return _context11.stop();
              }
            }
          }, _callee11);
        }))();
      },

      /**
       * @param {number[]} value
       * @param {number[]} prev
       * @protected
       */
      extentDataProjChanged: function extentDataProjChanged(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit('update:extent', value === null || value === void 0 ? void 0 : value.slice());
      }
    }
  };

  function defineServices$l() {
    var _this12 = this;

    Object.defineProperties(this, {
      /**
       * @type {module:ol/geom/Geometry~Geometry|undefined}
       */
      $geometry: {
        enumerable: true,
        get: function get() {
          return _this12.$olObject;
        }
      },

      /**
       * @type {Object|undefined}
       */
      $mapVm: {
        enumerable: true,
        get: function get() {
          var _this12$$services;

          return (_this12$$services = _this12.$services) === null || _this12$$services === void 0 ? void 0 : _this12$$services.mapVm;
        }
      },

      /**
       * @type {Object|undefined}
       */
      $viewVm: {
        enumerable: true,
        get: function get() {
          var _this12$$services2;

          return (_this12$$services2 = _this12.$services) === null || _this12$$services2 === void 0 ? void 0 : _this12$$services2.viewVm;
        }
      },

      /**
       * @type {Object|undefined}
       */
      $geometryContainer: {
        enumerable: true,
        get: function get() {
          var _this12$$services3;

          return (_this12$$services3 = _this12.$services) === null || _this12$$services3 === void 0 ? void 0 : _this12$$services3.geometryContainer;
        }
      }
    });
  }

  function subscribeToGeometryEvents() {
    return _subscribeToGeometryEvents.apply(this, arguments);
  }

  function _subscribeToGeometryEvents() {
    _subscribeToGeometryEvents = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee12() {
      return regenerator.wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
            case "end":
              return _context12.stop();
          }
        }
      }, _callee12);
    }));
    return _subscribeToGeometryEvents.apply(this, arguments);
  }

  /**
   * @module ol/render/EventType
   */
  /**
   * @enum {string}
   */
  var RenderEventType = {
      /**
       * Triggered before a layer is rendered.
       * @event module:ol/render/Event~RenderEvent#prerender
       * @api
       */
      PRERENDER: 'prerender',
      /**
       * Triggered after a layer is rendered.
       * @event module:ol/render/Event~RenderEvent#postrender
       * @api
       */
      POSTRENDER: 'postrender',
      /**
       * Triggered before layers are rendered.
       * The event object will not have a `context` set.
       * @event module:ol/render/Event~RenderEvent#precompose
       * @api
       */
      PRECOMPOSE: 'precompose',
      /**
       * Triggered after all layers are rendered.
       * The event object will not have a `context` set.
       * @event module:ol/render/Event~RenderEvent#postcompose
       * @api
       */
      POSTCOMPOSE: 'postcompose',
      /**
       * Triggered when rendering is complete, i.e. all sources and tiles have
       * finished loading for the current viewport, and all tiles are faded in.
       * The event object will not have a `context` set.
       * @event module:ol/render/Event~RenderEvent#rendercomplete
       * @api
       */
      RENDERCOMPLETE: 'rendercomplete',
  };

  /**
   * @typedef {Source|Object} SourceLike
   */

  /**
   * @typedef {Object} SourceTarget
   * @property {function(): Source|undefined} getSource
   * @property {function(Source|undefined): void} setSource
   */

  /**
   * Source container mixin.
   */

  var sourceContainer = {
    created: function created() {
      /**
       * @type {module:ol/source/Source~Source|undefined}
       * @private
       */
      this._source = undefined;
      /**
       * @type {Object|undefined}
       * @private
       */

      this._sourceVm = undefined;
      defineServices$k.call(this);
    },
    methods: {
      /**
       * @returns {{readonly sourceContainer: Object}}
       * @protected
       */
      getServices: function getServices() {
        var vm = this;
        return {
          get sourceContainer() {
            return vm;
          }

        };
      },

      /**
       * @return {SourceTarget|undefined}
       * @protected
       */
      getSourceTarget: function getSourceTarget() {
        throw new Error("".concat(this.vmName, " not implemented method: getSourceTarget()"));
      },

      /**
       * @return {module:ol/source/Source~Source|undefined}
       */
      getSource: function getSource() {
        var _this$getSourceTarget;

        return coalesce((_this$getSourceTarget = this.getSourceTarget()) === null || _this$getSourceTarget === void 0 ? void 0 : _this$getSourceTarget.getSource(), this._source);
      },

      /**
       * @return {Object}
       */
      getSourceVm: function getSourceVm() {
        return this._sourceVm;
      },

      /**
       * @param {SourceLike|undefined} source
       */
      setSource: function setSource(source) {
        var _source;

        source = ((_source = source) === null || _source === void 0 ? void 0 : _source.$source) || source;
        source || (source = undefined);
        assert$1(!source || source instanceof source$1.Source, 'Invalid source');
        var sourceTarget = this.getSourceTarget();

        if (sourceTarget && source !== sourceTarget.getSource()) {
          sourceTarget.setSource(source);
          this.scheduleRefresh();
        }

        if (source !== this._source) {
          var _source2;

          this._source = source;
          this._sourceVm = ((_source2 = source) === null || _source2 === void 0 ? void 0 : _source2.vm) && source.vm[0];
          this.scheduleRefresh();
        }
      }
    }
  };

  function defineServices$k() {
    Object.defineProperties(this, {
      $source: {
        enumerable: true,
        get: this.getSource
      },
      $sourceVm: {
        enumerable: true,
        get: this.getSourceVm
      }
    });
  }

  function ownKeys$W(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$W(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$W(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$W(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  /**
   * Base simple layer mixin.
   */

  var layer = {
    mixins: [sourceContainer, baseLayer],
    props: {
      // ol/layer/Layer

      /**
       * @type {function|undefined}
       */
      render: Function,
      // custom

      /**
       * @type {boolean}
       */
      overlay: {
        type: Boolean,
        default: false
      }
    },
    computed: {
      source: function source() {
        if (!(this.rev && this.$source)) return;
        return {
          id: getSourceId(this.$source),
          type: this.$source.constructor.name
        };
      }
    },
    watch: _objectSpread$W({}, /*#__PURE__*/makeChangeOrRecreateWatchers(['source', 'render', 'overlay'], ['source'])),
    methods: {
      /**
       * @return {Promise<void>}
       * @protected
       */
      mount: function mount() {
        var _this = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (!(_this.overlay && _this.$mapVm)) {
                    _context.next = 3;
                    break;
                  }

                  _this.setMap(_this.$mapVm);

                  return _context.abrupt("return");

                case 3:
                  return _context.abrupt("return", baseLayer.methods.mount.call(_this));

                case 4:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      },

      /**
       * @return {Promise<void>}
       * @protected
       */
      unmount: function unmount() {
        var _this2 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  if (!_this2.overlay) {
                    _context2.next = 3;
                    break;
                  }

                  _this2.setMap(null);

                  return _context2.abrupt("return");

                case 3:
                  return _context2.abrupt("return", baseLayer.methods.unmount.call(_this2));

                case 4:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }))();
      },

      /**
       * @returns {Object}
       * @protected
       */
      getServices: function getServices() {
        return mergeDescriptors(baseLayer.methods.getServices.call(this), sourceContainer.methods.getServices.call(this));
      },

      /**
       * @return {void}
       * @protected
       */
      subscribeAll: function subscribeAll() {
        baseLayer.methods.subscribeAll.call(this);
        subscribeToLayerEvents$3.call(this);
      },

      /**
       * @return {module:ol/layer/Base~BaseLayer}
       * @protected
       */
      getSourceTarget: function getSourceTarget() {
        return this.$layer;
      },

      /**
       * @returns {module:ol/renderer/Layer~LayerRenderer}
       */
      getRenderer: function getRenderer() {
        var _this$$layer;

        return (_this$$layer = this.$layer) === null || _this$$layer === void 0 ? void 0 : _this$$layer.getRenderer();
      },

      /**
       * @param {module:ol/Map~Map|Object|undefined} map
       */
      setMap: function setMap(map) {
        var _map, _this$$layer2;

        map = ((_map = map) === null || _map === void 0 ? void 0 : _map.$map) || map;
        (_this$$layer2 = this.$layer) === null || _this$$layer2 === void 0 ? void 0 : _this$$layer2.setMap(map);
      },

      /**
       * @param {string|undefined} value
       * @param {string|undefined} prev
       * @protected
       */
      sourceChanged: function sourceChanged(value, prev) {
        if (value === prev) return;
        this.$emit('update:source', value);
      }
    }
  };

  function subscribeToLayerEvents$3() {
    return _subscribeToLayerEvents$2.apply(this, arguments);
  }

  function _subscribeToLayerEvents$2() {
    _subscribeToLayerEvents$2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3() {
      var _this3 = this;

      var setterKey, sourceChanges, renderEvents;
      return regenerator.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              setterKey = addPrefix('set');
              sourceChanges = fromOlChangeEvent(this.$layer, 'source', true).pipe(tap(function (_ref) {
                var source = _ref.value;

                if (_this3._sourceSubs) {
                  _this3.unsubscribe(_this3._sourceSubs);
                }

                if (source) {
                  _this3._sourceSubs = _this3.subscribeTo(fromOlChangeEvent(source, 'id', true), _this3.scheduleRefresh.bind(_this3));
                }
              }), map(function (evt) {
                return _objectSpread$W(_objectSpread$W({}, evt), {}, {
                  setter: _this3[setterKey(evt.prop)]
                });
              }));
              this.subscribeTo(sourceChanges, function (_ref2) {
                var setter = _ref2.setter,
                    value = _ref2.value;
                return setter(value);
              });
              renderEvents = fromOlEvent(this.$layer, [RenderEventType.PRERENDER, RenderEventType.POSTRENDER]);
              this.subscribeTo(renderEvents, function (evt) {
                return _this3.$emit(evt.type, evt);
              });

            case 5:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));
    return _subscribeToLayerEvents$2.apply(this, arguments);
  }

  var imageLayer = {
    mixins: [layer]
  };

  /**
   * @module ol/source/State
   */
  /**
   * @enum {string}
   * State of the source, one of 'undefined', 'loading', 'ready' or 'error'.
   */
  var SourceState = {
      UNDEFINED: 'undefined',
      LOADING: 'loading',
      READY: 'ready',
      ERROR: 'error',
  };

  function ownKeys$V(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$V(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$V(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$V(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var validateAttributions = /*#__PURE__*/or(isString, isFunction$1, function (value) {
    return isArray$2(value) && value.every(isString);
  });
  /**
   * Base source mixin.
   */

  var source = {
    mixins: [stubVNode, projTransforms, olCmp, waitForMap],
    stubVNode: {
      empty: function empty() {
        return this.vmId;
      }
    },
    props: {
      // ol/source/Source

      /**
       * @type {string|string[]|undefined}
       */
      attributions: {
        type: [String, Array, Function],
        validator: validateAttributions
      },

      /**
       * @type {boolean}
       */
      attributionsCollapsible: {
        type: Boolean,
        default: true
      },

      /**
       * @type {string|undefined}
       */
      projection: {
        type: String,
        validator: function validator(value) {
          return !!proj.get(value);
        }
      },

      /**
       * @type {boolean}
       */
      wrapX: {
        type: Boolean,
        default: true
      },

      /**
       * @type {string|undefined}
       */
      state: {
        type: String,
        default: SourceState.READY,
        validator: function validator(value) {
          return Object.values(SourceState).includes(value);
        }
      }
    },
    data: function data() {
      return {
        viewProjection: EPSG_3857,
        dataProjection: EPSG_3857,
        currentAttributions: adaptAttributions(this.attributions),
        currentState: this.state
      };
    },
    computed: {
      inputAttributions: function inputAttributions() {
        return adaptAttributions(this.attributions);
      },
      currentResolutions: function currentResolutions() {
        return this.rev ? this.getResolutions() : [];
      },
      resolvedDataProjection: function resolvedDataProjection() {
        var _this$$options;

        return coalesce(this.projection, this.dataProjection, // may or may not be present
        (_this$$options = this.$options) === null || _this$$options === void 0 ? void 0 : _this$$options.dataProjection, // may or may not be present
        this.resolvedViewProjection);
      }
    },
    watch: _objectSpread$V({
      rev: function rev() {
        if (!this.$source) return;

        if (this.currentAttributions !== this.$source.getAttributions()) {
          this.currentAttributions = this.$source.getAttributions();
        }

        if (this.currentState !== this.$source.getState()) {
          this.currentState = this.$source.getState();
        }
      }
    }, /*#__PURE__*/makeChangeOrRecreateWatchers(['inputAttributions', 'currentAttributions', 'state', 'currentState', 'attributionsCollapsible', 'projection', 'wrapX', 'currentResolutions'], ['inputAttributions', 'currentAttributions', 'currentResolutions'])),
    created: function created() {
      defineServices$j.call(this);
    },
    methods: {
      /**
       * @return {Promise<void>}
       * @protected
       */
      beforeInit: function beforeInit() {
        var _this = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return Promise.all([olCmp.methods.beforeInit.call(_this), waitForMap.methods.beforeInit.call(_this)]);

                case 2:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      },

      /**
       * @return {Promise<module:ol/source/Source~Source>}
       * @protected
       */
      createOlObject: function createOlObject() {
        var _this2 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.t0 = initializeSource;
                  _context2.next = 3;
                  return _this2.createSource();

                case 3:
                  _context2.t1 = _context2.sent;
                  _context2.t2 = _this2.currentId;
                  return _context2.abrupt("return", (0, _context2.t0)(_context2.t1, _context2.t2));

                case 6:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }))();
      },

      /**
       * @return {module:ol/source/Source~Source|Promise<module:ol/source/Source~Source>}
       * @protected
       * @abstract
       */
      createSource: function createSource() {
        throw new Error("".concat(this.vmName, " not implemented method: createSource()"));
      },

      /**
       * @return {Promise<void>}
       * @protected
       */
      mount: function mount() {
        var _this3 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3() {
          var _this3$$sourceContain;

          return regenerator.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  (_this3$$sourceContain = _this3.$sourceContainer) === null || _this3$$sourceContain === void 0 ? void 0 : _this3$$sourceContain.setSource(_this3);
                  return _context3.abrupt("return", olCmp.methods.mount.call(_this3));

                case 2:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }))();
      },

      /**
       * @return {Promise<void>}
       * @protected
       */
      unmount: function unmount() {
        var _this4 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4() {
          var _this4$$sourceContain;

          return regenerator.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  if (((_this4$$sourceContain = _this4.$sourceContainer) === null || _this4$$sourceContain === void 0 ? void 0 : _this4$$sourceContain.getSourceVm()) === _this4) {
                    _this4.$sourceContainer.setSource(null);
                  }

                  return _context4.abrupt("return", olCmp.methods.unmount.call(_this4));

                case 2:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4);
        }))();
      },

      /**
       * @returns {Promise<void>}
       */
      refresh: function refresh() {
        var _this5 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee5() {
          var source;
          return regenerator.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  _context5.next = 2;
                  return _this5.resolveSource();

                case 2:
                  source = _context5.sent;
                  return _context5.abrupt("return", new Promise(function (resolve) {
                    source.once('change', function () {
                      return resolve();
                    });
                    source.refresh();
                  }));

                case 4:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5);
        }))();
      },

      /**
       * @return {Object}
       * @protected
       */
      getServices: function getServices() {
        var vm = this;
        return mergeDescriptors(olCmp.methods.getServices.call(this), {
          get sourceVm() {
            return vm;
          }

        });
      },

      /**
       * @protected
       */
      subscribeAll: function subscribeAll() {
        olCmp.methods.subscribeAll.call(this);
        subscribeToSourceEvents$4.call(this);
      },

      /**
       * @returns {string|number}
       * @protected
       */
      getIdInternal: function getIdInternal() {
        return getSourceId(this.$source);
      },

      /**
       * @param {string|number} id
       * @protected
       */
      setIdInternal: function setIdInternal(id) {
        if (id === this.getIdInternal()) return;
        setSourceId(this.$source, id);
      },

      /**
       * @return {Promise<module:ol/source/Source~Source>}
       */
      resolveSource: olCmp.methods.resolveOlObject,

      /**
       * @returns {string|string[]|undefined}
       */
      getAttributions: function getAttributions() {
        var _this$$source;

        return coalesce((_this$$source = this.$source) === null || _this$$source === void 0 ? void 0 : _this$$source.getAttributions(), this.currentAttributions);
      },

      /**
       * @param {string} attributions
       */
      setAttributions: function setAttributions(attributions) {
        assert$1(!attributions || validateAttributions(attributions), 'Invalid attributions');
        attributions = adaptAttributions(attributions);

        if (!isEqual(attributions, this.currentAttributions)) {
          this.currentAttributions = attributions;
        }

        if (this.$source && !isEqual(attributions, this.$source.getAttributions())) {
          this.$source.setAttributions(attributions);
        }
      },

      /**
       * @returns {boolean}
       */
      getAttributionsCollapsible: function getAttributionsCollapsible() {
        var _this$$source2;

        return coalesce((_this$$source2 = this.$source) === null || _this$$source2 === void 0 ? void 0 : _this$$source2.getAttributionsCollapsible(), this.attributionsCollapsible);
      },

      /**
       * @returns {module:ol/proj/Projection~Projection}
       */
      getProjection: function getProjection() {
        var _this$$source3;

        return coalesce((_this$$source3 = this.$source) === null || _this$$source3 === void 0 ? void 0 : _this$$source3.getProjection(), proj.get(this.resolvedDataProjection));
      },

      /**
       * @returns {string}
       */
      getState: function getState() {
        var _this$$source4;

        return coalesce((_this$$source4 = this.$source) === null || _this$$source4 === void 0 ? void 0 : _this$$source4.getState(), this.currentState);
      },

      /**
       * @returns {boolean}
       */
      getWrapX: function getWrapX() {
        var _this$$source5;

        return coalesce((_this$$source5 = this.$source) === null || _this$$source5 === void 0 ? void 0 : _this$$source5.getWrapX(), this.wrapX);
      },

      /**
       * @returns {number[]}
       */
      getResolutions: function getResolutions() {
        try {
          var _this$$source6;

          // can be not implemented in source class
          return coalesce((_this$$source6 = this.$source) === null || _this$$source6 === void 0 ? void 0 : _this$$source6.getResolutions(), []);
        } catch (err) {
          return [];
        }
      },

      /**
       * @param {string|string[]|Function|undefined} value
       * @protected
       */
      inputAttributionsChanged: function inputAttributionsChanged(value) {
        this.setAttributions(value);
      },

      /**
       * @param {string|string[]|Function|undefined} value
       * @protected
       */
      currentAttributionsChanged: function currentAttributionsChanged(value) {
        if (isEqual(value, this.inputAttributions)) return;
        this.$emit('update:attributions', value);
      },

      /**
       * @param {string} value
       * @protected
       */
      stateChanged: function stateChanged(value) {
        if (value === this.currentState) return;

        this.currentState = value;
        return this.scheduleRecreate();
      },

      /**
       * @param {string} value
       * @protected
       */
      currentStateChanged: function currentStateChanged(value) {
        if (value === this.state) return;
        this.$emit('update:state', value);
      },

      /**
       * @param {number[]} value
       * @param {number[]} prev
       * @protected
       */
      currentResolutionsChanged: function currentResolutionsChanged(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit('update:resolutions', value === null || value === void 0 ? void 0 : value.slice());
      }
    }
  };

  function defineServices$j() {
    var _this6 = this;

    Object.defineProperties(this, {
      /**
       * @type {module:ol/source/Source~Source|undefined}
       */
      $source: {
        enumerable: true,
        get: function get() {
          return _this6.$olObject;
        }
      },

      /**
       * @type {Object|undefined}
       */
      $mapVm: {
        enumerable: true,
        get: function get() {
          var _this6$$services;

          return (_this6$$services = _this6.$services) === null || _this6$$services === void 0 ? void 0 : _this6$$services.mapVm;
        }
      },

      /**
       * @type {Object|undefined}
       */
      $viewVm: {
        enumerable: true,
        get: function get() {
          var _this6$$services2;

          return (_this6$$services2 = _this6.$services) === null || _this6$$services2 === void 0 ? void 0 : _this6$$services2.viewVm;
        }
      },

      /**
       * @type {Object|undefined}
       */
      $sourceContainer: {
        enumerable: true,
        get: function get() {
          var _this6$$services3;

          return (_this6$$services3 = _this6.$services) === null || _this6$$services3 === void 0 ? void 0 : _this6$$services3.sourceContainer;
        }
      }
    });
  }

  function subscribeToSourceEvents$4() {}

  function adaptAttributions(attributions) {
    if (!attributions) return;
    if (isFunction$1(attributions)) return attributions;
    return function () {
      return isArray$2(attributions) ? attributions : [attributions];
    };
  }

  function ownKeys$U(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$U(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$U(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$U(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var ImageSourceEventType = {
    IMAGELOADSTART: 'imageloadstart',
    IMAGELOADEND: 'imageloadend',
    IMAGELOADERROR: 'imageloaderror'
  };
  /**
   * Base image source mixin.
   */

  var imageSource = {
    mixins: [source],
    props: {
      // ol/source/Image

      /**
       * @type {string}
       */
      projection: _objectSpread$U(_objectSpread$U({}, source.props.projection), {}, {
        default: EPSG_3857
      }),

      /**
       * @type {number[]|undefined}
       */
      resolutions: Array
    },
    computed: {
      inputResolutions: function inputResolutions() {
        var _this$resolutions;

        return (_this$resolutions = this.resolutions) === null || _this$resolutions === void 0 ? void 0 : _this$resolutions.slice();
      }
    },
    watch: _objectSpread$U({}, /*#__PURE__*/makeChangeOrRecreateWatchers(['inputResolutions'], ['inputResolutions'])),
    methods: {
      /**
       * @protected
       */
      subscribeAll: function subscribeAll() {
        source.methods.subscribeAll.call(this);
        subscribeToSourceEvents$3.call(this);
      },
      attributionsCollapsibleChanged: noop$1,
      wrapXChanged: noop$1
    }
  };

  function subscribeToSourceEvents$3() {
    return _subscribeToSourceEvents$1.apply(this, arguments);
  }

  function _subscribeToSourceEvents$1() {
    _subscribeToSourceEvents$1 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
      var _this = this;

      var events;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              events = fromOlEvent(this.$source, [ImageSourceEventType.IMAGELOADSTART, ImageSourceEventType.IMAGELOADEND, ImageSourceEventType.IMAGELOADERROR]);
              this.subscribeTo(events, function (evt) {
                return _this.$emit(evt.type, evt);
              });

            case 2:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));
    return _subscribeToSourceEvents$1.apply(this, arguments);
  }

  /**
   * Basic style mixin.
   */

  var style = {
    mixins: [stubVNode, olCmp],
    stubVNode: {
      empty: function empty() {
        return this.vmId;
      }
    },
    created: function created() {
      defineServices$i.call(this);
    },
    methods: {
      /**
       * @return {Promise<void>}
       * @protected
       */
      beforeInit: function beforeInit() {
        return olCmp.methods.beforeInit.call(this);
      },

      /**
       * @return {OlStyle|Promise<OlStyle>}
       * @protected
       */
      createOlObject: function createOlObject() {
        var _this = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.t0 = initializeStyle;
                  _context.next = 3;
                  return _this.createStyle();

                case 3:
                  _context.t1 = _context.sent;
                  _context.t2 = _this.currentId;
                  return _context.abrupt("return", (0, _context.t0)(_context.t1, _context.t2));

                case 6:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      },

      /**
       * @return {OlStyle|Promise<OlStyle>}
       * @protected
       * @abstract
       */
      createStyle: function createStyle() {
        throw new Error("".concat(this.vmName, " not implemented method: createStyle()"));
      },

      /**
       * @return {Promise<void>}
       */
      mount: function mount() {
        var _this2 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.next = 2;
                  return olCmp.methods.mount.call(_this2);

                case 2:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }))();
      },

      /**
       * @return {Promise<void>}
       */
      unmount: function unmount() {
        var _this3 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3() {
          return regenerator.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _context3.next = 2;
                  return olCmp.methods.unmount.call(_this3);

                case 2:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }))();
      },

      /**
       * @return {Promise<void>}
       */
      remount: function remount() {
        var _this4 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4() {
          return regenerator.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  _context4.next = 2;
                  return olCmp.methods.remount.call(_this4);

                case 2:
                  _context4.next = 4;
                  return _this4.refresh();

                case 4:
                  if (!_this4.$mapVm) {
                    _context4.next = 7;
                    break;
                  }

                  _context4.next = 7;
                  return _this4.$mapVm.render();

                case 7:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4);
        }))();
      },

      /**
       * @return {Promise<void>}
       */
      refresh: function refresh() {
        var _this5 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee5() {
          return regenerator.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  _context5.next = 2;
                  return olCmp.methods.refresh.call(_this5);

                case 2:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5);
        }))();
      },

      /**
       * @return {Object}
       * @protected
       */
      getServices: function getServices() {
        var vm = this;
        return mergeDescriptors(olCmp.methods.getServices.call(this), {
          get styleVm() {
            return vm;
          }

        });
      },

      /**
       * @protected
       */
      subscribeAll: function subscribeAll() {
        olCmp.methods.subscribeAll.call(this);
      },

      /**
       * @param {string|number} id
       */
      setId: function setId(id) {
        assert$1(id != null && id !== '', 'Invalid id');

        if (this.currentId !== id) {
          this.currentId = id;
          this.scheduleRefresh();
        }

        this.$olObject && this.setIdInternal(id);
      },

      /**
       * @returns {string|number}
       */
      getIdInternal: function getIdInternal() {
        return getStyleId(this.$style);
      },

      /**
       * @param {string|number} id
       * @returns {void}
       */
      setIdInternal: function setIdInternal(id) {
        if (id === this.getIdInternal()) return;
        setStyleId(this.$style, id);
        this.scheduleRefresh();
      },

      /**
       * @return {Promise<OlStyle>}
       */
      resolveStyle: olCmp.methods.resolveOlObject,

      /**
       * @protected
       */
      syncNonObservable: function syncNonObservable() {
        olCmp.methods.syncNonObservable.call(this);
      }
    }
  };

  function defineServices$i() {
    var _this6 = this;

    Object.defineProperties(this, {
      /**
       * @type {OlStyle|undefined}
       */
      $style: {
        enumerable: true,
        get: function get() {
          return _this6.$olObject;
        }
      },

      /**
       * @type {Object|undefined}
       */
      $styleContainer: {
        enumerable: true,
        get: function get() {
          var _this6$$services;

          return (_this6$$services = _this6.$services) === null || _this6$$services === void 0 ? void 0 : _this6$$services.styleContainer;
        }
      }
    });
  }

  function ownKeys$T(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$T(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$T(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$T(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var imageStyle = {
    mixins: [style],
    stubVNode: {
      empty: false,
      attrs: function attrs() {
        return {
          id: this.vmId,
          class: this.vmClass
        };
      }
    },
    props: {
      // ol/style/Image

      /**
       * @type {number}
       */
      opacity: {
        type: Number,
        default: 1
      },

      /**
       * @type {boolean}
       */
      rotateWithView: Boolean,

      /**
       * @type {number}
       */
      rotation: {
        type: Number,
        default: 0
      },

      /**
       * @type {number}
       */
      scale: {
        type: Number,
        default: 1
      },
      displacement: {
        type: Array,
        default: function _default() {
          return [0, 0];
        }
      }
    },
    data: function data() {
      return {
        currentOpacity: this.opacity,
        currentRotateWithView: this.rotateWithView,
        currentRotation: this.rotation,
        currentScale: this.scale
      };
    },
    computed: {
      inputDisplacement: function inputDisplacement() {
        var _this$displacement;

        return (_this$displacement = this.displacement) === null || _this$displacement === void 0 ? void 0 : _this$displacement.slice();
      }
    },
    watch: _objectSpread$T({
      rev: function rev() {
        if (!this.$style) return;
        this.setOpacity(this.getOpacity());
        this.setRotateWithView(this.getRotateWithView());
        this.setRotation(this.getRotation());
        this.setScale(this.getScale());
      }
    }, /*#__PURE__*/makeChangeOrRecreateWatchers(['opacity', 'currentOpacity', 'rotateWithView', 'currentRotateWithView', 'rotation', 'currentRotation', 'scale', 'currentScale', 'inputDisplacement'], ['inputDisplacement'])),
    created: function created() {
      defineServices$h.call(this);
    },
    methods: {
      /**
       * @return {Promise<void>}
       * @protected
       */
      mount: function mount() {
        var _this = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          var _this$$imageStyleCont;

          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  (_this$$imageStyleCont = _this.$imageStyleContainer) === null || _this$$imageStyleCont === void 0 ? void 0 : _this$$imageStyleCont.setImage(_this);
                  return _context.abrupt("return", style.methods.mount.call(_this));

                case 2:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      },

      /**
       * @return {Promise<void>}
       * @protected
       */
      unmount: function unmount() {
        var _this2 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
          var _this2$$imageStyleCon;

          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  if (!(((_this2$$imageStyleCon = _this2.$imageStyleContainer) === null || _this2$$imageStyleCon === void 0 ? void 0 : _this2$$imageStyleCon.getImageVm()) === _this2)) {
                    _context2.next = 3;
                    break;
                  }

                  _context2.next = 3;
                  return _this2.$imageStyleContainer.setImage(null);

                case 3:
                  return _context2.abrupt("return", style.methods.unmount.call(_this2));

                case 4:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }))();
      },

      /**
       * @return {Promise<void>}
       */
      refresh: function refresh() {
        var _this3 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3() {
          var _this3$$imageStyleCon;

          return regenerator.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _context3.next = 2;
                  return Promise.all([style.methods.refresh.call(_this3), (_this3$$imageStyleCon = _this3.$imageStyleContainer) === null || _this3$$imageStyleCon === void 0 ? void 0 : _this3$$imageStyleCon.refresh()]);

                case 2:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }))();
      },

      /**
       * @protected
       */
      syncNonObservable: function syncNonObservable() {
        style.methods.syncNonObservable.call(this);
        this.setOpacity(this.getOpacity());
        this.setRotateWithView(this.getRotateWithView());
        this.setRotation(this.getRotation());
        this.setScale(this.getScale());
      },

      /**
       * @returns {number}
       */
      getOpacity: function getOpacity() {
        var _this$$style;

        return coalesce((_this$$style = this.$style) === null || _this$$style === void 0 ? void 0 : _this$$style.getOpacity(), this.currentOpacity);
      },

      /**
       * @param {number} opacity
       */
      setOpacity: function setOpacity(opacity) {
        if (opacity !== this.currentOpacity) {
          this.currentOpacity = opacity;
          this.scheduleRefresh();
        }

        if (this.$style && opacity !== this.$style.getOpacity()) {
          this.$style.setOpacity(opacity);
          this.scheduleRefresh();
        }
      },

      /**
       * @returns {boolean}
       */
      getRotateWithView: function getRotateWithView() {
        var _this$$style2;

        return coalesce((_this$$style2 = this.$style) === null || _this$$style2 === void 0 ? void 0 : _this$$style2.getRotateWithView(), this.currentRotateWithView);
      },

      /**
       * @param {boolean} rotateWithView
       */
      setRotateWithView: function setRotateWithView(rotateWithView) {
        if (rotateWithView !== this.currentRotateWithView) {
          this.currentRotateWithView = rotateWithView;
          this.scheduleRefresh();
        }

        if (this.$style && rotateWithView !== this.$style.getRotateWithView()) {
          this.$style.setRotateWithView(rotateWithView);
          this.scheduleRefresh();
        }
      },

      /**
       * @returns {number}
       */
      getRotation: function getRotation() {
        var _this$$style3;

        return coalesce((_this$$style3 = this.$style) === null || _this$$style3 === void 0 ? void 0 : _this$$style3.getRotation(), this.currentRotation);
      },

      /**
       * @param {number} rotation
       */
      setRotation: function setRotation(rotation) {
        if (rotation !== this.currentRotation) {
          this.currentRotation = rotation;
          this.scheduleRefresh();
        }

        if (this.$style && rotation !== this.$style.getRotation()) {
          this.$style.setRotation(rotation);
          this.scheduleRefresh();
        }
      },

      /**
       * @returns {number}
       */
      getScale: function getScale() {
        var _this$$style4;

        return coalesce((_this$$style4 = this.$style) === null || _this$$style4 === void 0 ? void 0 : _this$$style4.getScale(), this.currentScale);
      },

      /**
       * @param {number} scale
       */
      setScale: function setScale(scale) {
        if (scale !== this.currentScale) {
          this.currentScale = scale;
          this.scheduleRefresh();
        }

        if (this.$style && scale !== this.$style.getScale()) {
          this.$style.setScale(scale);
          this.scheduleRefresh();
        }
      },

      /**
       * @return {number[]}
       */
      getDisplacement: function getDisplacement() {
        var _this$$style5;

        return coalesce((_this$$style5 = this.$style) === null || _this$$style5 === void 0 ? void 0 : _this$$style5.getDisplacement(), this.inputDisplacement);
      },

      /**
       * @param {number} value
       * @protected
       */
      opacityChanged: function opacityChanged(value) {
        this.setOpacity(value);
      },

      /**
       * @param {number} value
       * @protected
       */
      currentOpacityChanged: function currentOpacityChanged(value) {
        if (value === this.opacity) return;
        this.$emit('update:opacity', value);
      },

      /**
       * @param {boolean} value
       * @protected
       */
      rotateWithViewChanged: function rotateWithViewChanged(value) {
        this.setRotateWithView(value);
      },

      /**
       * @param {boolean} value
       * @protected
       */
      currentRotateWithViewChanged: function currentRotateWithViewChanged(value) {
        if (value === this.rotateWithView) return;
        this.$emit('update:rotateWithView', value);
      },

      /**
       * @param {number} value
       * @protected
       */
      rotationChanged: function rotationChanged(value) {
        this.setRotation(value);
      },

      /**
       * @param {number} value
       * @protected
       */
      currentRotationChanged: function currentRotationChanged(value) {
        if (value === this.rotation) return;
        this.$emit('update:rotation', value);
      },

      /**
       * @param {number} value
       * @protected
       */
      scaleChanged: function scaleChanged(value) {
        this.setScale(value);
      },

      /**
       * @param {number} value
       * @protected
       */
      currentScaleChanged: function currentScaleChanged(value) {
        if (value === this.scale) return;
        this.$emit('update:scale', value);
      }
    }
  };

  function defineServices$h() {
    var _this4 = this;

    Object.defineProperties(this, {
      /**
       * @type {Object|undefined}
       */
      $imageStyleContainer: {
        enumerable: true,
        get: function get() {
          var _this4$$services;

          return (_this4$$services = _this4.$services) === null || _this4$$services === void 0 ? void 0 : _this4$$services.imageStyleContainer;
        }
      }
    });
  }

  /**
   * @typedef {module:ol/style/Image~ImageStyle|Object|undefined} ImageStyleLike
   */

  /**
   * @typedef {Object} ImageStyleTarget
   * @property {function(): module:ol/style/Image~ImageStyle|undefined} getImage
   * @property {function(module:ol/style/Image~ImageStyle|undefined): void} setImage
   */

  /**
   * Image style container.
   */

  var imageStyleContainer = {
    created: function created() {
      this._image = undefined;
      this._imageVm = undefined;
      defineServices$g.call(this);
    },
    methods: {
      /**
       * @returns {{readonly imageStyleContainer: Object}}
       */
      getServices: function getServices() {
        var vm = this;
        return {
          get imageStyleContainer() {
            return vm;
          }

        };
      },

      /**
       * @return {ImageStyleTarget|undefined}
       */
      getImageStyleTarget: function getImageStyleTarget() {
        throw new Error("".concat(this.vmName, " not implemented method: getImageStyleTarget()"));
      },

      /**
       * @returns {module:ol/style/Image~ImageStyle|undefined}
       */
      getImage: function getImage() {
        var _this$getImageStyleTa;

        return coalesce((_this$getImageStyleTa = this.getImageStyleTarget()) === null || _this$getImageStyleTa === void 0 ? void 0 : _this$getImageStyleTa.getImage(), this._image);
      },

      /**
       * @return {Object}
       */
      getImageVm: function getImageVm() {
        return this._imageVm;
      },

      /**
       * @param {module:ol/style/Image~ImageStyle|undefined} image
       */
      setImage: function setImage(image) {
        var _image;

        image = ((_image = image) === null || _image === void 0 ? void 0 : _image.$style) || image;
        image || (image = undefined);
        assert$1(!image || image instanceof style$1.Image, 'Invalid image style');
        var imageTarget = this.getImageStyleTarget();

        if (imageTarget && image !== imageTarget.getImage()) {
          imageTarget.setImage(image);
          this.scheduleRefresh();
        }

        if (image !== this._image) {
          var _image2;

          this._image = image;
          this._imageVm = ((_image2 = image) === null || _image2 === void 0 ? void 0 : _image2.vm) && image.vm[0];
          this.scheduleRefresh();
        }
      }
    }
  };

  function defineServices$g() {
    Object.defineProperties(this, {
      $image: {
        enumerable: true,
        get: this.getImage
      },
      $imageVm: {
        enumerable: true,
        get: this.getImageVm
      }
    });
  }

  function ownKeys$S(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$S(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$S(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$S(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  /**
   * Base interaction mixin.
   */

  var interaction = {
    mixins: [stubVNode, projTransforms, olCmp, waitForMap],
    stubVNode: {
      empty: function empty() {
        return this.vmId;
      }
    },
    props: {
      /**
       * @type {boolean}
       */
      active: {
        type: Boolean,
        default: true
      },

      /**
       * Priority of interactions in the event handling stream.
       * The higher the value, the sooner it will handle map event.
       * @type {number}
       */
      priority: {
        type: Number,
        default: 0
      }
    },
    data: function data() {
      return {
        viewProjection: EPSG_3857,
        dataProjection: EPSG_3857,
        currentActive: this.active,
        currentPriority: this.priority,
        interacting: false
      };
    },
    watch: _objectSpread$S({
      rev: function rev() {
        if (!this.$interaction) return;

        if (this.currentActive !== this.$interaction.getActive()) {
          this.currentActive = this.$interaction.getActive();
        }

        if (this.currentPriority !== getInteractionPriority(this.$interaction)) {
          this.currentPriority = getInteractionPriority(this.$interaction);
        }
      }
    }, /*#__PURE__*/makeChangeOrRecreateWatchers(['active', 'currentActive', 'priority', 'currentPriority'])),
    created: function created() {
      defineServices$f.call(this);
    },
    methods: {
      /**
       * @return {Promise<void>}
       * @protected
       */
      beforeInit: function beforeInit() {
        var _this = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return Promise.all([olCmp.methods.beforeInit.call(_this), waitForMap.methods.beforeInit.call(_this)]);

                case 2:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      },

      /**
       * @return {Promise<module:ol/interaction/Interaction~Interaction>}
       * @protected
       */
      createOlObject: function createOlObject() {
        var _this2 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
          var interaction;
          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.t0 = initializeInteraction;
                  _context2.next = 3;
                  return _this2.createInteraction();

                case 3:
                  _context2.t1 = _context2.sent;
                  _context2.t2 = _this2.currentId;
                  _context2.t3 = _this2.currentPriority;
                  interaction = (0, _context2.t0)(_context2.t1, _context2.t2, _context2.t3);
                  interaction.setActive(_this2.currentActive);
                  interaction.set('interacting', _this2.interacting);
                  return _context2.abrupt("return", interaction);

                case 10:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }))();
      },

      /**
       * @return {module:ol/interaction/Interaction~Interaction|Promise<module:ol/interaction/Interaction~Interaction>}
       * @protected
       * @abstract
       */
      createInteraction: function createInteraction() {
        throw new Error("".concat(this.vmName, " not implemented method: createInteraction()"));
      },

      /**
       * @return {Promise<void>}
       * @protected
       */
      mount: function mount() {
        var _this3 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3() {
          var _this3$$interactionsC;

          return regenerator.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  (_this3$$interactionsC = _this3.$interactionsContainer) === null || _this3$$interactionsC === void 0 ? void 0 : _this3$$interactionsC.addInteraction(_this3);
                  return _context3.abrupt("return", olCmp.methods.mount.call(_this3));

                case 2:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }))();
      },

      /**
       * @return {Promise<void>}
       * @protected
       */
      unmount: function unmount() {
        var _this4 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4() {
          var _this4$$interactionsC;

          return regenerator.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  (_this4$$interactionsC = _this4.$interactionsContainer) === null || _this4$$interactionsC === void 0 ? void 0 : _this4$$interactionsC.removeInteraction(_this4);
                  return _context4.abrupt("return", olCmp.methods.unmount.call(_this4));

                case 2:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4);
        }))();
      },

      /**
       * @returns {Object}
       * @protected
       */
      getServices: function getServices() {
        var vm = this;
        return mergeDescriptors(olCmp.methods.getServices.call(this), {
          get interactionVm() {
            return vm;
          }

        });
      },

      /**
       * @returns {void}
       */
      subscribeAll: function subscribeAll() {
        olCmp.methods.subscribeAll.call(this);
        subscribeToInteractionEvents.call(this);
      },

      /**
       * @return {Promise<module:ol/interaction/Interaction~Interaction>}
       */
      resolveInteraction: olCmp.methods.resolveOlObject,

      /**
       * @returns {string|number}
       */
      getIdInternal: function getIdInternal() {
        return getInteractionId(this.$interaction);
      },

      /**
       * @param {string|number} id
       * @returns {void}
       */
      setIdInternal: function setIdInternal(id) {
        if (id === this.getIdInternal()) return;
        setInteractionId(this.$interaction, id);
      },

      /**
       * @returns {boolean}
       */
      getActive: function getActive() {
        var _this$$interaction;

        return coalesce((_this$$interaction = this.$interaction) === null || _this$$interaction === void 0 ? void 0 : _this$$interaction.getActive(), this.currentActive);
      },

      /**
       * @param {boolean} active
       */
      setActive: function setActive(active) {
        active = !!active;

        if (active !== this.currentActive) {
          this.currentActive = active;
        }

        if (this.$interaction && active !== this.$interaction.getActive()) {
          this.$interaction.setActive(active);
        }
      },

      /**
       * @returns {number}
       */
      getPriority: function getPriority() {
        return coalesce(this.$interaction && getInteractionPriority(this.$interaction), this.currentPriority);
      },

      /**
       * @param {number} priority
       */
      setPriority: function setPriority(priority) {
        var _this$$interactionsCo;

        assert$1(isNumber$1(priority), 'Invalid priority');

        if (priority !== this.currentPriority) {
          this.currentPriority = priority;
        }

        if (this.$interaction && priority !== getInteractionPriority(this.$interaction)) {
          setInteractionPriority(this.$interaction, priority);
        } // eslint-disable-next-line no-unused-expressions


        (_this$$interactionsCo = this.$interactionsContainer) === null || _this$$interactionsCo === void 0 ? void 0 : _this$$interactionsCo.sortInteractions();
      },

      /**
       * @return {module:ol/Map~Map|undefined}
       */
      getMap: function getMap() {
        var _this$$interaction2;

        return coalesce((_this$$interaction2 = this.$interaction) === null || _this$$interaction2 === void 0 ? void 0 : _this$$interaction2.getMap(), this.$map);
      },
      // /**
      //  * @param {module:ol/Map~Map} map
      //  */
      // setMap (map) {
      //   this.$interaction?.setMap(map)
      // },
      setInteracting: function setInteracting(flag) {
        flag = !!flag;

        if (flag !== this.interacting) {
          this.interacting = flag;
        }

        if (this.$interaction && flag !== this.$interaction.get('interacting')) {
          this.$interaction.set('interacting', flag);
        }
      },
      isInteracting: function isInteracting() {
        var _this$$interaction3;

        return coalesce((_this$$interaction3 = this.$interaction) === null || _this$$interaction3 === void 0 ? void 0 : _this$$interaction3.get('interacting'), this.interacting);
      },

      /**
       * @param {boolean} value
       * @protected
       */
      activeChanged: function activeChanged(value) {
        this.setActive(value);
      },

      /**
       * @param {boolean} value
       * @protected
       */
      currentActiveChanged: function currentActiveChanged(value) {
        if (value === this.active) return;
        this.$emit('update:active', value);
      },

      /**
       * @param {number} value
       * @protected
       */
      priorityChanged: function priorityChanged(value) {
        this.setPriority(value);
      },

      /**
       * @param {number} value
       * @protected
       */
      currentPriorityChanged: function currentPriorityChanged(value) {
        if (value === this.priority) return;
        this.$emit('update:priority', value);
      }
    }
  };

  function defineServices$f() {
    var _this5 = this;

    Object.defineProperties(this, {
      /**
       * @type {module:ol/interaction/Interaction~Interaction|undefined}
       */
      $interaction: {
        enumerable: true,
        get: function get() {
          return _this5.$olObject;
        }
      },

      /**
       * @type {Object|undefined}
       */
      $mapVm: {
        enumerable: true,
        get: function get() {
          var _this5$$services;

          return (_this5$$services = _this5.$services) === null || _this5$$services === void 0 ? void 0 : _this5$$services.mapVm;
        }
      },

      /**
       * @type {Object|undefined}
       */
      $viewVm: {
        enumerable: true,
        get: function get() {
          var _this5$$services2;

          return (_this5$$services2 = _this5.$services) === null || _this5$$services2 === void 0 ? void 0 : _this5$$services2.viewVm;
        }
      },

      /**
       * @type {Object|undefined}
       */
      $interactionsContainer: {
        enumerable: true,
        get: function get() {
          var _this5$$services3;

          return (_this5$$services3 = _this5.$services) === null || _this5$$services3 === void 0 ? void 0 : _this5$$services3.interactionsContainer;
        }
      }
    });
  }

  function subscribeToInteractionEvents() {
    return _subscribeToInteractionEvents.apply(this, arguments);
  }

  function _subscribeToInteractionEvents() {
    _subscribeToInteractionEvents = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee5() {
      var _this6 = this;

      var setterKey, propChanges;
      return regenerator.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              setterKey = addPrefix('current');
              propChanges = fromOlChangeEvent(this.$interaction, ['active', 'priority'], true, function (evt) {
                return _objectSpread$S(_objectSpread$S({}, evt), {}, {
                  setter: _this6[setterKey(evt.prop)]
                });
              });
              this.subscribeTo(propChanges, function (_ref) {
                var setter = _ref.setter,
                    value = _ref.value;
                return setter(value);
              });

            case 3:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5, this);
    }));
    return _subscribeToInteractionEvents.apply(this, arguments);
  }

  function ownKeys$R(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$R(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$R(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$R(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  /**
   * @typedef {module:ol/interaction/Interaction~Interaction|Object} InteractionLike
   */

  /**
   * Interactions container
   */

  var interactionsContainer = {
    mixins: [identMap, rxSubs],
    computed: {
      /**
       * @returns {string|undefined}
       */
      interactionsCollectionIdent: function interactionsCollectionIdent() {
        if (!this.olObjIdent) return;
        return this.makeIdent(this.olObjIdent, 'interactions_collection');
      }
    },
    watch: _objectSpread$R({}, /*#__PURE__*/makeChangeOrRecreateWatchers(['interactionsCollectionIdent'])),
    created: function created() {
      /**
       * @type {module:ol/Collection~Collection<module:ol/interaction/Interaction~Interaction>}
       * @private
       */
      this._interactionsCollection = this.instanceFactoryCall(this.interactionsCollectionIdent, function () {
        return new ol.Collection();
      });
      this._interactionSubs = {};
      defineServices$e.call(this);
    },
    methods: {
      /**
       * @returns {{readonly interactionsContainer: Object}}
       * @protected
       */
      getServices: function getServices() {
        var vm = this;
        return {
          get interactionsContainer() {
            return vm;
          }

        };
      },

      /**
       * @return {void}
       * @protected
       */
      subscribeAll: function subscribeAll() {
        subscribeToCollectionEvents$2.call(this);
      },

      /**
       * @param {InteractionLike[]|module:ol/Collection~Collection<InteractionLike>} defaultInteractions
       */
      initDefaultInteractions: function initDefaultInteractions(defaultInteractions) {
        var _this = this;

        this.getInteractions().forEach(function (interaction) {
          if (interaction.get('vl_default')) {
            _this.removeInteraction(interaction);
          }
        });
        var interactions;

        if (isArray$2(defaultInteractions) || defaultInteractions instanceof ol.Collection) {
          interactions = defaultInteractions;
        } else if (defaultInteractions !== false) {
          interactions = interaction$1.defaults(isPlainObject(defaultInteractions) ? this.defaultInteractions : undefined);
        }

        if (interactions) {
          interactions.forEach(function (interaction) {
            return interaction.set('vl_default', true);
          });
          this.addInteractions(interactions);
        }
      },

      /**
       * @param {InteractionLike} interaction
       * @return {Interaction}
       */
      initializeInteraction: function initializeInteraction$1(interaction) {
        var _interaction;

        interaction = ((_interaction = interaction) === null || _interaction === void 0 ? void 0 : _interaction.$interaction) || interaction;
        instanceOf(interaction, interaction$1.Interaction);
        return initializeInteraction(interaction);
      },

      /**
       * @param {InteractionLike[]|module:ol/Collection~Collection<InteractionLike>} interactions
       */
      addInteractions: function addInteractions(interactions) {
        forEach(interactions, this.addInteraction.bind(this));
      },

      /**
       * @param {InteractionLike} interaction
       */
      addInteraction: function addInteraction(interaction) {
        interaction = this.initializeInteraction(interaction);
        if (this.getInteractionById(getInteractionId(interaction))) return;
        this.$interactionsCollection.push(interaction);
        this.sortInteractions();
      },

      /**
       * @param {InteractionLike[]|module:ol/Collection~Collection<InteractionLike>} interactions
       */
      removeInteractions: function removeInteractions(interactions) {
        forEach(interactions, this.removeInteraction.bind(this));
      },

      /**
       * @param {InteractionLike} interaction
       */
      removeInteraction: function removeInteraction(interaction) {
        var _interaction2;

        interaction = this.getInteractionById(getInteractionId(((_interaction2 = interaction) === null || _interaction2 === void 0 ? void 0 : _interaction2.$interaction) || interaction));
        if (!interaction) return;
        this.$interactionsCollection.remove(interaction);
        this.sortInteractions();
      },

      /**
       * @return {void}
       */
      clearInteractions: function clearInteractions() {
        this.$interactionsCollection.clear();
      },

      /**
       * @return {module:ol/interaction/Interaction~Interaction[]}
       */
      getInteractions: function getInteractions() {
        return this.$interactionsCollection.getArray().slice();
      },

      /**
       * @return {module:ol/Collection~Collection<module:ol/interaction/Interaction~Interaction>}
       */
      getInteractionsCollection: function getInteractionsCollection() {
        return this._interactionsCollection;
      },

      /**
       * @param {string|number} interactionId
       * @return {module:ol/interaction/Interaction~Interaction|undefined}
       */
      getInteractionById: function getInteractionById(interactionId) {
        return find(this.getInteractions(), function (interaction) {
          return getInteractionId(interaction) === interactionId;
        });
      },

      /**
       * @param {function} [sorter]
       */
      sortInteractions: function sortInteractions(sorter) {
        sorter || (sorter = this.getDefaultInteractionsSorter());
        this.$interactionsCollection.getArray().sort(sorter);
      },

      /**
       * @return {function(): number}
       * @protected
       */
      getDefaultInteractionsSorter: function getDefaultInteractionsSorter() {
        // sort interactions by priority in asc order
        // the higher the priority, the earlier the interaction handles the event
        return function (a, b) {
          var ap = getInteractionPriority(a) || 0;
          var bp = getInteractionPriority(b) || 0;
          return ap === bp ? 0 : ap - bp;
        };
      },

      /**
       * @param {string|undefined} value
       * @param {string|undefined} prevValue
       * @protected
       */
      interactionsCollectionIdentChanged: function interactionsCollectionIdentChanged(value, prevValue) {
        if (value && prevValue) {
          this.moveInstance(value, prevValue);
        } else if (value && !prevValue && this.$interactionsCollection) {
          this.setInstance(value, this.$interactionsCollection);
        } else if (!value && prevValue) {
          this.unsetInstance(prevValue);
        }
      }
    }
  };

  function defineServices$e() {
    Object.defineProperties(this, {
      $interactionsCollection: {
        enumerable: true,
        get: this.getInteractionsCollection
      }
    });
  }

  function subscribeToCollectionEvents$2() {
    var _this2 = this;

    var adds = fromOlEvent(this.$interactionsCollection, CollectionEventType.ADD).pipe(map(function (evt) {
      return _objectSpread$R(_objectSpread$R({}, evt), {}, {
        element: _this2.initializeInteraction(evt.element)
      });
    }), tap(function (_ref) {
      var element = _ref.element;
      var uid = util.getUid(element);
      var propChanges = fromOlChangeEvent(element, 'id', true);
      _this2._interactionSubs[uid] = _this2.subscribeTo(propChanges, _this2.scheduleRefresh.bind(_this2));
    }));
    var removes = fromOlEvent(this.$interactionsCollection, CollectionEventType.REMOVE).pipe(tap(function (_ref2) {
      var element = _ref2.element;
      var uid = util.getUid(element);

      if (_this2._interactionSubs[uid]) {
        _this2.unsubscribe(_this2._interactionSubs[uid]);

        delete _this2._interactionSubs[uid];
      }
    }));
    var events = merge(adds, removes).pipe(bufferDebounceTime(FRAME_TIME));
    this.subscribeTo(events, /*#__PURE__*/function () {
      var _ref3 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(events) {
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _this2.debounceChanged();

              case 2:
                forEach(events, function (_ref4) {
                  var type = _ref4.type,
                      element = _ref4.element;

                  _this2.$emit(type + 'interaction', element); // todo remove in v0.13.x


                  _this2.$emit(type + ':interaction', element);
                });

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function (_x) {
        return _ref3.apply(this, arguments);
      };
    }());
  }

  function ownKeys$Q(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$Q(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$Q(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$Q(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  /**
   * @typedef {module:ol/layer/Base~BaseLayer|Object} LayerLike
   */

  /**
   * Layers container mixin.
   */

  var layersContainer = {
    mixins: [identMap, rxSubs],
    computed: {
      /**
       * @returns {string|undefined}
       */
      layersCollectionIdent: function layersCollectionIdent() {
        if (!this.olObjIdent) return;
        return this.makeIdent(this.olObjIdent, 'layers_collection');
      }
    },
    watch: _objectSpread$Q({}, /*#__PURE__*/makeChangeOrRecreateWatchers(['layersCollectionIdent'])),
    created: function created() {
      /**
       * @type {module:ol/Collection~Collection<module:ol/layer/Base~BaseLayer>}
       * @private
       */
      this._layersCollection = this.instanceFactoryCall(this.layersCollectionIdent, function () {
        return new ol.Collection();
      });
      this._layerSubs = {};
      defineServices$d.call(this);
    },
    methods: {
      /**
       * @returns {{readonly layersContainer: Object}}
       * @protected
       */
      getServices: function getServices() {
        var vm = this;
        return {
          get layersContainer() {
            return vm;
          }

        };
      },

      /**
       * @return {void}
       * @protected
       */
      subscribeAll: function subscribeAll() {
        subscribeToCollectionEvents$1.call(this);
      },

      /**
       * @param {LayerLike} layer
       * @return {BaseLayer}
       */
      initializeLayer: function initializeLayer$1(layer) {
        var _layer;

        layer = ((_layer = layer) === null || _layer === void 0 ? void 0 : _layer.$layer) || layer;
        instanceOf(layer, BaseLayer__default['default']);
        return initializeLayer(layer);
      },

      /**
       * @param {LayerLike[]|module:ol/Collection~Collection<LayerLike>} layers
       */
      addLayers: function addLayers(layers) {
        forEach(layers, this.addLayer.bind(this));
      },

      /**
       * @param {LayerLike} layer
       */
      addLayer: function addLayer(layer) {
        layer = this.initializeLayer(layer);
        if (this.getLayerById(getLayerId(layer))) return;
        this.$layersCollection.push(layer);
      },

      /**
       * @param {LayerLike[]|module:ol/Collection~Collection<LayerLike>} layers
       */
      removeLayers: function removeLayers(layers) {
        forEach(layers, this.removeLayer.bind(this));
      },

      /**
       * @param {LayerLike} layer
       */
      removeLayer: function removeLayer(layer) {
        var _layer2;

        layer = this.getLayerById(getLayerId(((_layer2 = layer) === null || _layer2 === void 0 ? void 0 : _layer2.$layer) || layer));
        if (!layer) return;
        this.$layersCollection.remove(layer);
      },

      /**
       * @return {void}
       */
      clearLayers: function clearLayers() {
        this.$layersCollection.clear();
      },

      /**
       * @return {Array<module:ol/layer/Base~BaseLayer>}
       */
      getLayers: function getLayers() {
        return this.$layersCollection.getArray().slice();
      },

      /**
       * @return {module:ol/Collection~Collection<module:ol/layer/Base~BaseLayer>}
       */
      getLayersCollection: function getLayersCollection() {
        return this._layersCollection;
      },

      /**
       * @param {string|number} layerId
       * @return {module:ol/layer/Base~BaseLayer|undefined}
       */
      getLayerById: function getLayerById(layerId) {
        return find(this.getLayers(), function (layer) {
          return getLayerId(layer) === layerId;
        });
      },

      /**
       * @param {string|undefined} value
       * @param {string|undefined} prevValue
       * @protected
       */
      layersCollectionIdentChanged: function layersCollectionIdentChanged(value, prevValue) {
        if (value && prevValue) {
          this.moveInstance(value, prevValue);
        } else if (value && !prevValue && this.$layersCollection) {
          this.setInstance(value, this.$layersCollection);
        } else if (!value && prevValue) {
          this.unsetInstance(prevValue);
        }
      }
    }
  };

  function defineServices$d() {
    Object.defineProperties(this, {
      $layersCollection: {
        enumerable: true,
        get: this.getLayersCollection
      }
    });
  }

  function subscribeToCollectionEvents$1() {
    var _this = this;

    var adds = fromOlEvent(this.$layersCollection, CollectionEventType.ADD).pipe(map(function (evt) {
      return _objectSpread$Q(_objectSpread$Q({}, evt), {}, {
        element: _this.initializeLayer(evt.element)
      });
    }), tap(function (_ref) {
      var element = _ref.element;
      var uid = util.getUid(element);
      var propChanges = fromOlChangeEvent(element, 'id', true);
      _this._layerSubs[uid] = _this.subscribeTo(propChanges, _this.scheduleRefresh.bind(_this));
    }));
    var removes = fromOlEvent(this.$layersCollection, CollectionEventType.REMOVE).pipe(tap(function (_ref2) {
      var element = _ref2.element;
      var uid = util.getUid(element);

      if (_this._layerSubs[uid]) {
        _this.unsubscribe(_this._layerSubs[uid]);

        delete _this._layerSubs[uid];
      }
    }));
    var events = merge(adds, removes).pipe(bufferDebounceTime(FRAME_TIME));
    this.subscribeTo(events, /*#__PURE__*/function () {
      var _ref3 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(events) {
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _this.debounceChanged();

              case 2:
                forEach(events, function (_ref4) {
                  var type = _ref4.type,
                      element = _ref4.element;

                  _this.$emit(type + 'layer', element); // todo remove in v0.13.x


                  _this.$emit(type + ':layer', element);
                });

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function (_x) {
        return _ref3.apply(this, arguments);
      };
    }());
  }

  function ownKeys$P(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$P(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$P(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$P(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  /**
   * @typedef {module:ol/Overlay~Overlay|Object} OverlayLike
   */

  /**
   * Overlays container mixin.
   */

  var overlaysContainer = {
    mixins: [identMap, rxSubs],
    computed: {
      /**
       * @returns {string|undefined}
       */
      overlaysCollectionIdent: function overlaysCollectionIdent() {
        if (!this.olObjIdent) return;
        return this.makeIdent(this.olObjIdent, 'overlays_collection');
      }
    },
    watch: _objectSpread$P({}, /*#__PURE__*/makeChangeOrRecreateWatchers(['overlaysCollectionIdent'])),
    created: function created() {
      /**
       * @type {module:ol/Collection~Collection<module:ol/Overlay~Overlay>}
       * @private
       */
      this._overlaysCollection = this.instanceFactoryCall(this.overlaysCollectionIdent, function () {
        return new ol.Collection();
      });
      this._overlaySubs = {};
      defineServices$c.call(this);
    },
    methods: {
      /**
       * @returns {readonly overlaysContainer: Object}}
       * @protected
       */
      getServices: function getServices() {
        var vm = this;
        return {
          get overlaysContainer() {
            return vm;
          }

        };
      },

      /**
       * @return {void}
       * @protected
       */
      subscribeAll: function subscribeAll() {
        subscribeToCollectionEvents.call(this);
      },

      /**
       * @param {OverlayLike} overlay
       * @return {Overlay}
       */
      initializeOverlay: function initializeOverlay$1(overlay) {
        var _overlay;

        overlay = ((_overlay = overlay) === null || _overlay === void 0 ? void 0 : _overlay.$overlay) || overlay;
        instanceOf(overlay, ol.Overlay);
        return initializeOverlay(overlay);
      },

      /**
       * @param {OverlayLike[]|module:ol/Collection~Collection<OverlayLike>} overlays
       */
      addOverlays: function addOverlays(overlays) {
        forEach(overlays, this.addOverlay.bind(this));
      },

      /**
       * @param {OverlayLike} overlay
       */
      addOverlay: function addOverlay(overlay) {
        overlay = this.initializeOverlay(overlay);
        if (this.getOverlayById(getOverlayId(overlay))) return;
        this.$overlaysCollection.push(overlay);
      },

      /**
       * @param {OverlayLike[]|module:ol/Collection~Collection<OverlayLike>} overlays
       */
      removeOverlays: function removeOverlays(overlays) {
        forEach(overlays, this.removeOverlay.bind(this));
      },

      /**
       * @param {OverlayLike} overlay
       */
      removeOverlay: function removeOverlay(overlay) {
        var _overlay2;

        overlay = this.getOverlayById(getOverlayId(((_overlay2 = overlay) === null || _overlay2 === void 0 ? void 0 : _overlay2.$overlay) || overlay));
        if (!overlay) return;
        this.$overlaysCollection.remove(overlay);
      },

      /**
       * @return {void}
       */
      clearOverlays: function clearOverlays() {
        this.$overlaysCollection.clear();
      },

      /**
       * @return {Array<module:ol/Overlay~Overlay>}
       */
      getOverlays: function getOverlays() {
        return this.$overlaysCollection.getArray().slice();
      },

      /**
       * @return {module:ol/Collection~Collection<module:ol/Overlay~Overlay>}
       */
      getOverlaysCollection: function getOverlaysCollection() {
        return this._overlaysCollection;
      },

      /**
       * @param {string|number} overlayId
       * @return {module:ol/Overlay~Overlay|undefined}
       */
      getOverlayById: function getOverlayById(overlayId) {
        return find(this.getOverlays(), function (overlay) {
          return getOverlayId(overlay) === overlayId;
        });
      },

      /**
       * @param {string|undefined} value
       * @param {string|undefined} prevValue
       * @protected
       */
      overlaysCollectionIdentChanged: function overlaysCollectionIdentChanged(value, prevValue) {
        if (value && prevValue) {
          this.moveInstance(value, prevValue);
        } else if (value && !prevValue && this.$overlaysCollection) {
          this.setInstance(value, this.$overlaysCollection);
        } else if (!value && prevValue) {
          this.unsetInstance(prevValue);
        }
      }
    }
  };

  function defineServices$c() {
    Object.defineProperties(this, {
      $overlaysCollection: {
        enumerable: true,
        get: this.getOverlaysCollection
      }
    });
  }

  function subscribeToCollectionEvents() {
    var _this = this;

    var adds = fromOlEvent(this.$overlaysCollection, CollectionEventType.ADD).pipe(map(function (evt) {
      return _objectSpread$P(_objectSpread$P({}, evt), {}, {
        element: _this.initializeOverlay(evt.element)
      });
    }), tap(function (_ref) {
      var element = _ref.element;
      var uid = util.getUid(element);
      var propChanges = fromOlChangeEvent(element, 'id', true);
      _this._overlaySubs[uid] = _this.subscribeTo(propChanges, _this.scheduleRefresh.bind(_this));
    }));
    var removes = fromOlEvent(this.$overlaysCollection, CollectionEventType.REMOVE).pipe(tap(function (_ref2) {
      var element = _ref2.element;
      var uid = util.getUid(element);

      if (_this._overlaySubs[uid]) {
        _this.unsubscribe(_this._overlaySubs[uid]);

        delete _this._overlaySubs[uid];
      }
    }));
    var events = merge(adds, removes).pipe(bufferDebounceTime(FRAME_TIME));
    this.subscribeTo(events, /*#__PURE__*/function () {
      var _ref3 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(events) {
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _this.debounceChanged();

              case 2:
                forEach(events, function (_ref4) {
                  var type = _ref4.type,
                      element = _ref4.element;

                  _this.$emit(type + 'overlay', element); // todo remove in v0.13.x


                  _this.$emit(type + ':overlay', element);
                });

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));

      return function (_x) {
        return _ref3.apply(this, arguments);
      };
    }());
  }

  /**
   * @typedef {module:ol/style/Stroke~Stroke|Object|undefined} StrokeStyleLike
   */

  /**
   * @typedef {Object} StrokeStyleTarget
   * @property {function(): module:ol/style/Stroke~Stroke|undefined} getStroke
   * @property {function(module:ol/style/Stroke~Stroke|undefined): void} setStroke
   */

  /**
   * Stroke style container.
   */

  var strokeStyleContainer = {
    created: function created() {
      this._stroke = undefined;
      this._strokeVm = undefined;
      defineServices$b.call(this);
    },
    methods: {
      /**
       * @returns {{readonly strokeStyleContainer: Object}}
       */
      getServices: function getServices() {
        var vm = this;
        return {
          get strokeStyleContainer() {
            return vm;
          }

        };
      },

      /**
       * @return {StrokeStyleTarget}
       */
      getStrokeStyleTarget: function getStrokeStyleTarget() {
        throw new Error("".concat(this.vmName, " not implemented method: getStrokeStyleTarget()"));
      },

      /**
       * @returns {module:ol/style/Stroke~Stroke|undefined}
       */
      getStroke: function getStroke() {
        var _this$getStrokeStyleT;

        return coalesce((_this$getStrokeStyleT = this.getStrokeStyleTarget()) === null || _this$getStrokeStyleT === void 0 ? void 0 : _this$getStrokeStyleT.getStroke(), this._stroke);
      },

      /**
       * @return {Object}
       */
      getStrokeVm: function getStrokeVm() {
        return this._strokeVm;
      },

      /**
       * @param {module:ol/style/Stroke~Stroke|undefined} stroke
       */
      setStroke: function setStroke(stroke) {
        var _stroke;

        stroke = ((_stroke = stroke) === null || _stroke === void 0 ? void 0 : _stroke.$style) || stroke;
        stroke || (stroke = undefined);
        assert$1(!stroke || stroke instanceof style$1.Stroke, 'Invalid stroke');
        var strokeTarget = this.getStrokeStyleTarget();

        if (strokeTarget && stroke !== strokeTarget.getStroke()) {
          strokeTarget.setStroke(stroke);
          this.scheduleRefresh();
        }

        if (stroke !== this._stroke) {
          var _stroke2;

          this._stroke = stroke;
          this._strokeVm = ((_stroke2 = stroke) === null || _stroke2 === void 0 ? void 0 : _stroke2.vm) && stroke.vm[0];
          this.scheduleRefresh();
        }
      }
    }
  };

  function defineServices$b() {
    Object.defineProperties(this, {
      $stroke: {
        enumerable: true,
        get: this.getStroke
      },
      $strokeVm: {
        enumerable: true,
        get: this.getStrokeVm
      }
    });
  }

  function ownKeys$O(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$O(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$O(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$O(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var regShapeStyle = {
    mixins: [fillStyleContainer, strokeStyleContainer, imageStyle],
    props: {
      // ol/style/RegularShape
      points: Number,
      radius: Number,
      radius1: Number,
      radius2: Number,
      angle: {
        type: Number,
        default: 0
      }
    },
    computed: {
      stroke: function stroke() {
        if (!(this.rev && this.$stroke)) return;
        return dumpStrokeStyle(this.$stroke);
      },
      fill: function fill() {
        if (!(this.rev && this.$fill)) return;
        return dumpFillStyle(this.$fill);
      }
    },
    watch: _objectSpread$O({}, /*#__PURE__*/makeChangeOrRecreateWatchers(['points', 'radius', 'radius1', 'radius2', 'angle', 'stroke', 'fill'], ['stroke', 'fill'])),
    methods: {
      /**
       * @returns {Object}
       * @protected
       */
      getServices: function getServices() {
        return mergeDescriptors(style.methods.getServices.call(this), fillStyleContainer.methods.getServices.call(this), strokeStyleContainer.methods.getServices.call(this));
      },

      /**
       * @protected
       */
      syncNonObservable: function syncNonObservable() {
        imageStyle.methods.syncNonObservable.call(this);
      },

      /**
       * @return {FillStyleTarget}
       * @protected
       */
      getFillStyleTarget: function getFillStyleTarget() {
        var _this = this;

        return {
          getFill: function getFill() {
            var _this$$style;

            return (_this$$style = _this.$style) === null || _this$$style === void 0 ? void 0 : _this$$style.getFill();
          },
          setFill: function setFill() {

            _this.scheduleRecreate();
          }
        };
      },

      /**
       * @return {StrokeStyleTarget}
       * @protected
       */
      getStrokeStyleTarget: function getStrokeStyleTarget() {
        var _this2 = this;

        return {
          getStroke: function getStroke() {
            var _this2$$style;

            return (_this2$$style = _this2.$style) === null || _this2$$style === void 0 ? void 0 : _this2$$style.getStroke();
          },
          setStroke: function setStroke() {

            _this2.scheduleRecreate();
          }
        };
      },
      getAnchor: function getAnchor() {
        var _this$$style2;

        return (_this$$style2 = this.$style) === null || _this$$style2 === void 0 ? void 0 : _this$$style2.getAnchor();
      },
      getAngle: function getAngle() {
        var _this$$style3;

        return coalesce((_this$$style3 = this.$style) === null || _this$$style3 === void 0 ? void 0 : _this$$style3.getAngle(), this.angle);
      },
      getImage: function getImage() {
        var _this$$style4;

        return (_this$$style4 = this.$style) === null || _this$$style4 === void 0 ? void 0 : _this$$style4.getImage();
      },
      getOrigin: function getOrigin() {
        var _this$$style5;

        return (_this$$style5 = this.$style) === null || _this$$style5 === void 0 ? void 0 : _this$$style5.getOrigin();
      },
      getPoints: function getPoints() {
        var _this$$style6;

        return coalesce((_this$$style6 = this.$style) === null || _this$$style6 === void 0 ? void 0 : _this$$style6.getPoints(), this.points);
      },
      getRadius: function getRadius() {
        var _this$$style7;

        return coalesce((_this$$style7 = this.$style) === null || _this$$style7 === void 0 ? void 0 : _this$$style7.getRadius(), this.radius);
      },
      getRadius2: function getRadius2() {
        var _this$$style8;

        return coalesce((_this$$style8 = this.$style) === null || _this$$style8 === void 0 ? void 0 : _this$$style8.getRadius2(), this.radius2);
      },
      getSize: function getSize() {
        var _this$$style9;

        return (_this$$style9 = this.$style) === null || _this$$style9 === void 0 ? void 0 : _this$$style9.getSize();
      },

      /**
       * @param {Object|undefined} value
       * @param {Object|undefined} prev
       * @protected
       */
      strokeChanged: function strokeChanged(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit('update:stroke', value && clonePlainObject(value));
      },

      /**
       * @param {Object|undefined} value
       * @param {Object|undefined} prev
       * @protected
       */
      fillChanged: function fillChanged(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit('update:fill', value && clonePlainObject(value));
      }
    }
  };

  /**
   * @module ol/geom/GeometryLayout
   */
  /**
   * The coordinate layout for geometries, indicating whether a 3rd or 4th z ('Z')
   * or measure ('M') coordinate is available. Supported values are `'XY'`,
   * `'XYZ'`, `'XYM'`, `'XYZM'`.
   * @enum {string}
   */
  var GeometryLayout = {
      XY: 'XY',
      XYZ: 'XYZ',
      XYM: 'XYM',
      XYZM: 'XYZM',
  };

  function ownKeys$N(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$N(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$N(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$N(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  /**
   * Base simple geometry with coordinates mixin.
   */

  var simpleGeometry = {
    mixins: [geometry],
    props: {
      // ol/geom/SimpleGeometry

      /**
       * @type {number[]} Coordinates in map data projection
       */
      coordinates: {
        type: Array,
        required: true,
        validator: /*#__PURE__*/negate(isEmpty$2)
      } // todo add support of coord layout
      // /**
      //  * @type {string}
      //  */
      // layout: {
      //   type: String,
      //   default: GeometryLayout.XY,
      //   validator: value => Object.values(GeometryLayout).includes(value.toUpperCase()),
      // },

    },
    data: function data() {
      return {
        currentCoordinatesViewProj: clonePlainObject(this.coordinates)
      };
    },
    computed: {
      coordinatesDataProj: function coordinatesDataProj() {
        return roundCoords(this.type, this.coordinates);
      },
      coordinatesViewProj: function coordinatesViewProj() {
        return this.coordinatesToViewProj(this.coordinates);
      },
      currentCoordinatesDataProj: function currentCoordinatesDataProj() {
        return this.coordinatesToDataProj(this.currentCoordinatesViewProj);
      },
      pointDataProj: function pointDataProj() {
        return this.rev ? this.findPointOnSurface() : findPointOnSurface({
          type: this.type,
          coordinates: this.coordinatesDataProj
        });
      },
      pointViewProj: function pointViewProj() {
        return this.rev ? this.findPointOnSurface(true) : findPointOnSurface({
          type: this.type,
          coordinates: this.coordinatesViewProj
        });
      }
    },
    watch: _objectSpread$N({
      rev: function rev() {
        if (!this.$geometry) return;

        if (!isEqualCoord({
          coordinates: this.currentCoordinatesViewProj,
          extent: boundingExtent(this.currentCoordinatesViewProj)
        }, {
          coordinates: this.$geometry.getCoordinates(),
          extent: this.$geometry.getExtent()
        })) {
          this.currentCoordinatesViewProj = this.$geometry.getCoordinates();
        }
      }
    }, /*#__PURE__*/makeChangeOrRecreateWatchers(['coordinatesViewProj', 'currentCoordinatesDataProj', 'pointDataProj'], ['coordinatesViewProj', 'currentCoordinatesDataProj', 'pointDataProj'])),
    created: function created() {
      this.currentCoordinatesViewProj = clonePlainObject(this.coordinatesViewProj);
      this.extentViewProj = boundingExtent(this.currentCoordinatesViewProj);
    },
    methods: {
      /**
       * @returns {function}
       */
      getCoordinatesTransformFunction: function getCoordinatesTransformFunction() {
        return transforms[this.getType()].transform;
      },

      /**
       * @param {number[]} coordinates
       * @returns {Promise<number[]>}
       */
      coordinatesToDataProj: function coordinatesToDataProj(coordinates) {
        var transform = this.getCoordinatesTransformFunction();
        return transform(coordinates, this.resolvedViewProjection, this.resolvedDataProjection);
      },

      /**
       * @param {number[]} coordinates
       * @returns {Promise<number[]>}
       */
      coordinatesToViewProj: function coordinatesToViewProj(coordinates) {
        var transform = this.getCoordinatesTransformFunction();
        return transform(coordinates, this.resolvedDataProjection, this.resolvedViewProjection);
      },

      /**
       * @param {boolean} [viewProj=false]
       * @return {number[]}
       */
      getCoordinates: function getCoordinates() {
        var _this$$geometry;

        var viewProj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        var coordinates = coalesce((_this$$geometry = this.$geometry) === null || _this$$geometry === void 0 ? void 0 : _this$$geometry.getCoordinates(), this.currentCoordinatesViewProj);
        return viewProj ? roundCoords(this.getType(), coordinates) : this.coordinatesToDataProj(coordinates);
      },

      /**
       * @param {number[]} coordinates
       * @param {boolean} [viewProj=false]
       */
      setCoordinates: function setCoordinates(coordinates) {
        var viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        assert$1(isArray$2(coordinates), 'Invalid coordinates');
        coordinates = viewProj ? roundCoords(this.getType(), coordinates) : this.coordinatesToViewProj(coordinates);
        var extent = boundingExtent(coordinates);

        if (!isEqualCoord({
          coordinates: coordinates,
          extent: extent
        }, {
          coordinates: this.currentCoordinatesViewProj,
          extent: this.extentViewProj
        })) {
          this.currentCoordinatesViewProj = coordinates;
        }

        if (this.$geometry && !isEqualCoord({
          coordinates: coordinates,
          extent: extent
        }, {
          coordinates: this.$geometry.getCoordinates(),
          extent: this.$geometry.getExtent()
        })) {
          this.$geometry.setCoordinates(coordinates);
        }
      },

      /**
       * @param {boolean} [viewProj=false]
       * @returns {number[]>}
       */
      getFirstCoordinate: function getFirstCoordinate() {
        var viewProj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        var coordinate;

        if (this.$geometry) {
          coordinate = this.$geometry.getFirstCoordinate();
        } else {
          switch (this.getType()) {
            case GeometryType.POINT:
            case GeometryType.CIRCLE:
              coordinate = this.currentCoordinatesViewProj;
              break;

            case GeometryType.LINE_STRING:
            case GeometryType.MULTI_POINT:
              coordinate = this.currentCoordinatesViewProj[0];
              break;

            case GeometryType.POLYGON:
            case GeometryType.MULTI_LINE_STRING:
              coordinate = this.currentCoordinatesViewProj[0][0];
              break;

            case GeometryType.MULTI_POLYGON:
              coordinate = this.currentCoordinatesViewProj[0][0][0];
              break;
          }
        }

        return viewProj ? roundPointCoords(coordinate) : this.pointToDataProj(coordinate);
      },

      /**
       * @param {boolean} [viewProj=false]
       * @returns {number[]}
       */
      getLastCoordinate: function getLastCoordinate() {
        var viewProj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        var coordinate;

        if (this.$geometry) {
          coordinate = this.$geometry.getLastCoordinate();
        } else {
          var arr;

          switch (this.getType()) {
            case GeometryType.POINT:
            case GeometryType.CIRCLE:
              coordinate = this.currentCoordinatesViewProj;
              break;

            case GeometryType.LINE_STRING:
            case GeometryType.MULTI_POINT:
              coordinate = this.currentCoordinatesViewProj[this.currentCoordinatesViewProj.length - 1];
              break;

            case GeometryType.POLYGON:
            case GeometryType.MULTI_LINE_STRING:
              arr = this.currentCoordinatesViewProj[this.currentCoordinatesViewProj.length - 1];
              coordinate = arr[arr.length - 1];
              break;

            case GeometryType.MULTI_POLYGON:
              arr = this.currentCoordinatesViewProj[this.currentCoordinatesViewProj.length - 1];
              arr = arr[arr.length - 1];
              coordinate = arr[arr.length - 1];
              break;
          }
        }

        return viewProj ? roundPointCoords(coordinate) : this.pointToDataProj(coordinate);
      },

      /**
       * @returns {string}
       */
      getLayout: function getLayout() {
        var _this$$geometry2;

        return coalesce((_this$$geometry2 = this.$geometry) === null || _this$$geometry2 === void 0 ? void 0 : _this$$geometry2.getLayout(), GeometryLayout.XY);
      },

      /**
       * @param {boolean} [viewProj=false]
       * @return {number[]|undefined}
       */
      findPointOnSurface: function findPointOnSurface$1() {
        var viewProj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        return findPointOnSurface({
          type: this.getType(),
          coordinates: this.getCoordinates(viewProj)
        });
      },

      /**
       * @param {number[]} value
       * @protected
       */
      coordinatesViewProjChanged: function coordinatesViewProjChanged(value) {
        this.setCoordinates(value, true);
      },

      /**
       * @param {number[]} value
       * @protected
       */
      currentCoordinatesDataProjChanged: function currentCoordinatesDataProjChanged(value) {
        if (isEqual(value, this.coordinatesDataProj)) return;
        this.$emit('update:coordinates', clonePlainObject(value));
      },

      /**
       * @param {number[]} value
       * @param {number[]} prev
       * @protected
       */
      pointDataProjChanged: function pointDataProjChanged(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit('update:point', value === null || value === void 0 ? void 0 : value.slice());
      }
    }
  };

  function boundingExtent(coordinates) {
    if (!coordinates) return;

    if (!isArray$2(coordinates[0])) {
      coordinates = [coordinates];
    }

    return extent.boundingExtent(coordinates);
  }

  /**
   * @typedef {module:ol/style/Text~Text|Object|undefined} TextStyleLike
   */

  /**
   * @typedef {Object} TextStyleTarget
   * @property {function(): module:ol/style/Text~Text|undefined} getText
   * @property {function(module:ol/style/Text~Text|undefined): void} setText
   */

  /**
   * Text style container.
   */

  var textStyleContainer = {
    created: function created() {
      this._text = undefined;
      this._textVm = undefined;
      defineServices$a.call(this);
    },
    methods: {
      /**
       * @returns {{readonly textStyleContainer: Object}}
       */
      getServices: function getServices() {
        var vm = this;
        return {
          get textStyleContainer() {
            return vm;
          }

        };
      },

      /**
       * @return {TextStyleTarget|undefined}
       */
      getTextStyleTarget: function getTextStyleTarget() {
        throw new Error("".concat(this.vmName, " not implemented method: getTextStyleTarget()"));
      },

      /**
       * @returns {module:ol/style/Text~Text|null}
       */
      getText: function getText() {
        var _this$getTextStyleTar;

        return coalesce((_this$getTextStyleTar = this.getTextStyleTarget()) === null || _this$getTextStyleTar === void 0 ? void 0 : _this$getTextStyleTar.getText(), this._text);
      },

      /**
       * @return {Object}
       */
      getTextVm: function getTextVm() {
        return this._textVm;
      },

      /**
       * @param {module:ol/style/Text~Text|undefined} text
       */
      setText: function setText(text) {
        var _text;

        text = ((_text = text) === null || _text === void 0 ? void 0 : _text.$style) || text;
        text || (text = undefined);
        assert$1(!text || text instanceof style$1.Text, 'Invalid text style');
        var textTarget = this.getTextStyleTarget();

        if (textTarget && text !== textTarget.getText()) {
          textTarget.setText(text);
          this.scheduleRefresh();
        }

        if (text !== this._text) {
          var _text2;

          this._text = text;
          this._textVm = ((_text2 = text) === null || _text2 === void 0 ? void 0 : _text2.vm) && text.vm[0];
          this.scheduleRefresh();
        }
      }
    }
  };

  function defineServices$a() {
    Object.defineProperties(this, {
      $text: {
        enumerable: true,
        get: this.getText
      },
      $textVm: {
        enumerable: true,
        get: this.getTextVm
      }
    });
  }

  /**
   * @module ol/source/TileEventType
   */
  /**
   * @enum {string}
   */
  var TileEventType = {
      /**
       * Triggered when a tile starts loading.
       * @event module:ol/source/Tile.TileSourceEvent#tileloadstart
       * @api
       */
      TILELOADSTART: 'tileloadstart',
      /**
       * Triggered when a tile finishes loading, either when its data is loaded,
       * or when loading was aborted because the tile is no longer needed.
       * @event module:ol/source/Tile.TileSourceEvent#tileloadend
       * @api
       */
      TILELOADEND: 'tileloadend',
      /**
       * Triggered if tile loading results in an error.
       * @event module:ol/source/Tile.TileSourceEvent#tileloaderror
       * @api
       */
      TILELOADERROR: 'tileloaderror',
  };

  function ownKeys$M(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$M(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$M(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$M(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var tileSource = {
    mixins: [source],
    props: {
      // ol/source/Tile

      /**
       * @type {number|undefined}
       */
      cacheSize: Number,

      /**
       * @type {boolean|undefined}
       */
      opaque: Boolean,

      /**
       * @type {number}
       */
      tilePixelRatio: {
        type: Number,
        default: 1
      },

      /**
       * @type {function|undefined}
       */
      tileGridFactory: Function,

      /**
       * @type {number}
       */
      transition: Number,

      /**
       * @type {string|undefined}
       */
      tileKey: String,

      /**
       * @type {number}
       */
      zDirection: {
        type: Number,
        default: 0
      }
    },
    data: function data() {
      return {
        tileGrid: undefined
      };
    },
    computed: {
      /**
       * @type {string|undefined}
       */
      tileGridIdent: function tileGridIdent() {
        if (!this.olObjIdent) return;
        return this.makeIdent(this.olObjIdent, 'tile_grid');
      },

      /**
       * @returns {function|undefined}
       */
      derivedTileGridFactory: function derivedTileGridFactory() {
        return this.tileGridFactory;
      },

      /**
       * @returns {function|undefined}
       */
      inputTileGridFactory: function inputTileGridFactory() {
        if (!isFunction$1(this.derivedTileGridFactory)) return;
        return sealFactory(this.derivedTileGridFactory.bind(this));
      },

      /**
       * @returns {string}
       */
      resolvedDataProjection: function resolvedDataProjection() {
        return coalesce(this.projection, this.resolvedViewProjection);
      }
    },
    watch: _objectSpread$M({
      rev: function rev() {
        if (!this.$source) return;

        if (this.tileGrid !== this.$source.getTileGrid()) {
          this.tileGrid = this.$source.getTileGrid();
        }
      }
    }, /*#__PURE__*/makeChangeOrRecreateWatchers(['tileGridIdent', 'inputTileGridFactory', 'tileGrid', 'tileKey', 'opaque', 'tilePixelRatio', 'cacheSize', 'transition', 'zDirection'])),
    created: function created() {
      if (isFunction$1(this.inputTileGridFactory)) {
        this.tileGrid = this.instanceFactoryCall(this.tileGridIdent, this.inputTileGridFactory.bind(this));
      }
    },
    methods: {
      /**
       * @protected
       */
      subscribeAll: function subscribeAll() {
        source.methods.subscribeAll.call(this);
      },

      /**
       * @returns {module:ol/tilegrid/TileGrid~TileGrid|undefined}
       */
      getTileGrid: function getTileGrid() {
        var _this$$source;

        return coalesce((_this$$source = this.$source) === null || _this$$source === void 0 ? void 0 : _this$$source.getTileGrid(), this.tileGrid);
      },

      /**
       * @param {string|undefined} value
       * @param {string|undefined} prevValue
       * @protected
       */
      tileGridIdentChanged: function tileGridIdentChanged(value, prevValue) {
        if (value && prevValue) {
          this.moveInstance(value, prevValue);
        } else if (value && !prevValue && this.tileGrid) {
          this.setInstance(value, this.tileGrid);
        } else if (!value && prevValue) {
          this.unsetInstance(prevValue);
        }
      },

      /**
       * @param {function|undefined} value
       * @return {Promise<void>}
       * @protected
       */
      inputTileGridFactoryChanged: function inputTileGridFactoryChanged(value) {
        while (this.hasInstance(this.tileGridIdent)) {
          this.unsetInstance(this.tileGridIdent);
        }

        if (isFunction$1(value)) {
          this.tileGrid = this.instanceFactoryCall(this.tileGridIdent, value.bind(this));
        } else {
          this.tileGrid = null;
        }
      }
    }
  };

  function ownKeys$L(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$L(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$L(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$L(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var isNotEmptyString$1 = /*#__PURE__*/and(isString, negate(isEmpty$2));
  var isArrayOfNotEmptyStrings = /*#__PURE__*/and(isArray$2, function (value) {
    return value.every(isNotEmptyString$1);
  });
  var urlTileSource = {
    mixins: [tileSource],
    props: {
      // ol/source/UrlTile

      /**
       * @type {function|undefined}
       */
      tileLoadFunction: Function,

      /**
       * @type {function|undefined}
       * @deprecated
       * @todo remove in v0.13.x
       */
      tileUrlFunc: Function,

      /**
       * @type {function|undefined}
       */
      tileUrlFunction: Function,

      /**
       * @type {string|undefined}
       */
      url: {
        type: String,
        validator: isNotEmptyString$1
      },

      /**
       * @type {string[]|undefined}
       */
      urls: {
        type: Array,
        validator: isArrayOfNotEmptyStrings
      }
    },
    data: function data() {
      return {
        currentTileLoadFunction: undefined,
        currentTileUrlFunction: undefined,
        currentUrls: []
      };
    },
    computed: {
      urlTokens: function urlTokens() {
        return [];
      },
      inputUrl: function inputUrl() {
        if (!this.url) return;
        return replaceTokens(this.url, pick(this, this.urlTokens));
      },
      parsedUrls: function parsedUrls() {
        var urls = [];

        if (this.urls && this.urls.length > 0) {
          urls.push.apply(urls, _toConsumableArray(this.urls));
        } else if (this.url) {
          urls.push(this.url);
        }

        var tokens = pick(this, this.urlTokens);
        return urls.map(function (url) {
          return replaceTokens(url, tokens);
        });
      },
      inputUrls: function inputUrls() {
        return this.parsedUrls.reduce(function (urls, url) {
          return urls.concat.apply(urls, _toConsumableArray(expandUrl$1(url)));
        }, []);
      },
      inputTileUrlFunction: function inputTileUrlFunction() {
        return coalesce(this.tileUrlFunction, this.tileUrlFunc);
      },
      inputTileLoadFunction: function inputTileLoadFunction() {
        return this.tileLoadFunction;
      }
    },
    watch: _objectSpread$L({
      rev: function rev() {
        if (!this.$source) return;

        if (this.currentTileLoadFunction !== this.$source.getTileLoadFunction()) {
          this.currentTileLoadFunction = this.$source.getTileLoadFunction();
        }

        if (this.currentTileUrlFunction !== this.$source.getTileUrlFunction()) {
          this.currentTileUrlFunction = this.$source.getTileUrlFunction();
        }

        if (!isEqual(this.currentUrls, this.$source.getUrls()) && !this.inputTileUrlFunction) {
          this.currentUrls = this.$source.getUrls();
        }
      }
    }, /*#__PURE__*/makeChangeOrRecreateWatchers(['inputUrls', 'currentUrls', 'inputTileUrlFunction', 'currentTileUrlFunction', 'inputTileLoadFunction', 'currentTileLoadFunction'], ['inputUrls', 'currentUrls'])),
    created: function created() {
      var _this$inputUrls;

      this.currentUrls = (_this$inputUrls = this.inputUrls) === null || _this$inputUrls === void 0 ? void 0 : _this$inputUrls.slice();
      this.currentTileUrlFunction = this.inputTileUrlFunction;
      this.currentTileLoadFunction = this.inputTileLoadFunction;
    },
    updated: function updated() {
    },
    methods: {
      /**
       * @returns {void}
       */
      subscribeAll: function subscribeAll() {
        tileSource.methods.subscribeAll.call(this);
        subscribeToSourceEvents$2.call(this);
      },

      /**
       * @returns {module:ol/Tile.LoadFunction}
       */
      getTileLoadFunction: function getTileLoadFunction() {
        var _this$$source;

        return coalesce((_this$$source = this.$source) === null || _this$$source === void 0 ? void 0 : _this$$source.getTileLoadFunction(), this.currentTileLoadFunction);
      },

      /**
       * @param {module:ol/Tile.LoadFunction} tileLoadFunction
       */
      setTileLoadFunction: function setTileLoadFunction(tileLoadFunction) {
        assert$1(isFunction$1(tileLoadFunction), 'Invalid tile load function');

        if (tileLoadFunction !== this.currentTileLoadFunction) {
          this.currentTileLoadFunction = tileLoadFunction;
        }

        if (this.$source && tileLoadFunction !== this.$source.getTileLoadFunction()) {
          this.$source.setTileLoadFunction(tileLoadFunction);
        }
      },

      /**
       * @returns {module:ol/Tile.UrlFunction}
       */
      getTileUrlFunction: function getTileUrlFunction() {
        var _this$$source2;

        return coalesce((_this$$source2 = this.$source) === null || _this$$source2 === void 0 ? void 0 : _this$$source2.getTileUrlFunction(), this.currentTileUrlFunction);
      },

      /**
       * @param {module:ol/Tile.UrlFunction} tileUrlFunction
       * @param {number} [tileKey]
       */
      setTileUrlFunction: function setTileUrlFunction(tileUrlFunction, tileKey) {
        var _this$inputUrls2;

        assert$1(isFunction$1(tileUrlFunction), 'Invalid tile url function');
        tileKey || (tileKey = coalesce((_this$inputUrls2 = this.inputUrls) === null || _this$inputUrls2 === void 0 ? void 0 : _this$inputUrls2.join('\n'), v4()));

        if (tileUrlFunction !== this.currentTileUrlFunction) {
          this.currentTileUrlFunction = tileUrlFunction;
        }

        if (this.$source && tileUrlFunction !== this.$source.getTileUrlFunction()) {
          this.$source.setTileUrlFunction(tileUrlFunction, tileKey);
        }
      },

      /**
       * @returns {string[]|undefined}
       */
      getUrls: function getUrls() {
        var _this$$source3;

        return coalesce((_this$$source3 = this.$source) === null || _this$$source3 === void 0 ? void 0 : _this$$source3.getUrls(), this.currentUrls);
      },

      /**
       * @param {string[]} urls
       */
      setUrls: function setUrls(urls) {
        assert$1(isArrayOfNotEmptyStrings(urls), 'Invalid urls');
        urls = urls.slice();

        if (!isEqual(urls, this.currentUrls)) {
          this.currentUrls = urls;
        }

        if (this.$source) {
          if (this.inputTileUrlFunction) {
            this.$source.setTileUrlFunction(this.inputTileUrlFunction, urls.join('\n'));
          } else if (!isEqual(urls, this.$source.getUrls())) {
            this.$source.setUrls(urls);
          }
        }
      },

      /**
       * @param {string} url
       */
      setUrl: function setUrl(url) {
        assert$1(isNotEmptyString$1(url), 'Invalid url');
        this.setUrls(expandUrl$1(url));
      },

      /**
       * @param {string[]} value
       * @protected
       */
      inputUrlsChanged: function inputUrlsChanged(value) {
        this.setUrls(value);
      },

      /**
       * @param {string[]} value
       * @protected
       */
      currentUrlsChanged: function currentUrlsChanged(value) {
        if (isEqual(value, this.urls)) return;
        this.$emit('update:urls', value === null || value === void 0 ? void 0 : value.slice());
      },

      /**
       * @param {function|undefined} value
       * @protected
       */
      inputTileUrlFunctionChanged: function inputTileUrlFunctionChanged(value) {
        this.setTileUrlFunction(value);
      },

      /**
       * @param {function|undefined} value
       * @protected
       */
      currentTileUrlFunctionChanged: function currentTileUrlFunctionChanged(value) {
        if (value === this.inputTileUrlFunction) return;
        this.$emit('update:tileUrlFunction', value);
      },

      /**
       * @param {function|undefined} value
       * @protected
       */
      inputTileLoadFunctionChanged: function inputTileLoadFunctionChanged(value) {
        this.setTileLoadFunction(value);
      },

      /**
       * @param {function|undefined} value
       * @protected
       */
      currentTileLoadFunctionChanged: function currentTileLoadFunctionChanged(value) {
        if (value === this.inputTileLoadFunction) return;
        this.$emit('update:tileLoadFunction', value);
      }
    }
  };

  function subscribeToSourceEvents$2() {
    return _subscribeToSourceEvents.apply(this, arguments);
  }

  function _subscribeToSourceEvents() {
    _subscribeToSourceEvents = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
      var _this = this;

      var events;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              events = fromOlEvent(this.$source, [TileEventType.TILELOADSTART, TileEventType.TILELOADEND, TileEventType.TILELOADERROR]);
              this.subscribeTo(events, function (evt) {
                return _this.$emit(evt.type, evt);
              });

            case 2:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));
    return _subscribeToSourceEvents.apply(this, arguments);
  }

  function ownKeys$K(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$K(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$K(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$K(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  /**
   * Base tile image source mixin.
   */

  var tileImageSource = {
    mixins: [urlTileSource],
    props: {
      // ol/source/TileImage

      /**
       * @type {string|undefined}
       */
      crossOrigin: String,

      /**
       * @type {number|undefined}
       */
      reprojectionErrorThreshold: Number,

      /**
       * @type {string|undefined}
       */
      tileClass: String,

      /**
       * @type {boolean}
       */
      imageSmoothing: {
        type: Boolean,
        default: true
      }
    },
    watch: _objectSpread$K({}, /*#__PURE__*/makeChangeOrRecreateWatchers(['crossOrigin', 'reprojectionErrorThreshold', 'tileClass', 'imageSmoothing'])),
    methods: {
      setRenderReprojectionEdges: function setRenderReprojectionEdges(render) {
        var _this = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return _this.resolveSource();

                case 2:
                  _context.sent.setRenderReprojectionEdges(render);

                case 3:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      }
    }
  };

  function ownKeys$J(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$J(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$J(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$J(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  /**
   * Base tile layer mixin.
   */

  var tileLayer = {
    mixins: [layer],
    props: {
      // ol/layer/BaseTile

      /**
       * @type {number}
       */
      preload: {
        type: Number,
        default: 0
      },

      /**
       * @type {boolean}
       */
      useInterimTilesOnError: {
        type: Boolean,
        default: true
      }
    },
    data: function data() {
      return {
        currentPreload: this.preload,
        currentUseInterimTilesOnError: this.useInterimTilesOnError
      };
    },
    watch: _objectSpread$J({
      rev: function rev() {
        if (!this.$layer) return;

        if (this.currentPreload !== this.$layer.getPreload()) {
          this.currentPreload = this.$layer.getPreload();
        }

        if (this.currentUseInterimTilesOnError !== this.$layer.getUseInterimTilesOnError()) {
          this.currentUseInterimTilesOnError = this.$layer.getUseInterimTilesOnError();
        }
      }
    }, /*#__PURE__*/makeChangeOrRecreateWatchers(['preload', 'currentPreload', 'useInterimTilesOnError', 'currentUseInterimTilesOnError'])),
    methods: {
      /**
       * @protected
       */
      subscribeAll: function subscribeAll() {
        layer.methods.subscribeAll.call(this);
        subscribeToLayerEvents$2.call(this);
      },

      /**
       * @returns {number}
       */
      getPreload: function getPreload() {
        var _this$$layer;

        return coalesce((_this$$layer = this.$layer) === null || _this$$layer === void 0 ? void 0 : _this$$layer.getPreload(), this.currentPreload);
      },

      /**
       * @param {number} preload
       */
      setPreload: function setPreload(preload) {
        preload = Number(preload);
        assert$1(isNumber$1(preload), 'Invalid preload');

        if (preload !== this.currentPreload) {
          this.currentPreload = preload;
        }

        if (this.$layer && preload !== this.$layer.getPreload()) {
          this.$layer.setPreload(preload);
        }
      },

      /**
       * @returns {boolean}
       */
      getUseInterimTilesOnError: function getUseInterimTilesOnError() {
        var _this$$layer2;

        return coalesce((_this$$layer2 = this.$layer) === null || _this$$layer2 === void 0 ? void 0 : _this$$layer2.getUseInterimTilesOnError(), this.currentUseInterimTilesOnError);
      },

      /**
       * @param {boolean} useInterimTilesOnError
       */
      setUseInterimTilesOnError: function setUseInterimTilesOnError(useInterimTilesOnError) {
        useInterimTilesOnError = !!useInterimTilesOnError;

        if (useInterimTilesOnError !== this.currentUseInterimTilesOnError) {
          this.currentUseInterimTilesOnError = useInterimTilesOnError;
        }

        if (this.$layer && useInterimTilesOnError !== this.$layer.getUseInterimTilesOnError()) {
          this.$layer.setUseInterimTilesOnError(useInterimTilesOnError);
        }
      },

      /**
       * @param {number} value
       * @protected
       */
      preloadChanged: function preloadChanged(value) {
        this.setPreload(value);
      },

      /**
       * @param {number} value
       * @protected
       */
      currentPreloadChanged: function currentPreloadChanged(value) {
        if (value === this.preload) return;
        this.$emit('update:preload', value);
      },

      /**
       * @param {boolean} value
       * @protected
       */
      useInterimTilesOnErrorChanged: function useInterimTilesOnErrorChanged(value) {
        this.setUseInterimTilesOnError(value);
      },

      /**
       * @param {boolean} value
       * @protected
       */
      currentUseInterimTilesOnErrorChanged: function currentUseInterimTilesOnErrorChanged(value) {
        if (value === this.useInterimTilesOnError) return;
        this.$emit('update:useInterimTilesOnError', value);
      }
    }
  };

  function subscribeToLayerEvents$2() {
    return _subscribeToLayerEvents$1.apply(this, arguments);
  }

  function _subscribeToLayerEvents$1() {
    _subscribeToLayerEvents$1 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
      var _this = this;

      var setterKey, propChanges;
      return regenerator.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              setterKey = addPrefix('current');
              propChanges = fromOlChangeEvent(this.$layer, ['preload', 'useInterimTilesOnError'], true, function (evt) {
                return _objectSpread$J(_objectSpread$J({}, evt), {}, {
                  setter: _this[setterKey(evt.prop)]
                });
              });
              this.subscribeTo(propChanges, function (_ref) {
                var setter = _ref.setter,
                    value = _ref.value;
                return setter(value);
              });

            case 3:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));
    return _subscribeToLayerEvents$1.apply(this, arguments);
  }

  function ownKeys$I(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$I(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$I(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$I(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var vectorLayer = {
    mixins: [styleContainer, layer],
    props: {
      // ol/layer/BaseVector

      /**
       * @type {function|undefined}
       */
      renderOrder: Function,

      /**
       * @type {number}
       */
      renderBuffer: {
        type: Number,
        default: 100
      },

      /**
       * @type {boolean}
       */
      declutter: Boolean,

      /**
       * When set to `true`, feature batches will be recreated during animations.
       * @type {boolean}
       */
      updateWhileAnimating: Boolean,

      /**
       * When set to `true`, feature batches will be recreated during interactions.
       * @type {boolean}
       */
      updateWhileInteracting: Boolean
    },
    computed: {
      style: function style() {
        var _this = this;

        if (!(this.rev && this.$style)) return;
        var style = this.$style;
        if (isFunction$1(style)) return style;
        if (!style) return;
        isArray$2(style) || (style = [style]);
        return style.map(function (style) {
          return dumpStyle(style, function (geom) {
            return _this.writeGeometryInDataProj(geom);
          });
        });
      }
    },
    watch: _objectSpread$I({}, /*#__PURE__*/makeChangeOrRecreateWatchers(['renderOrder', 'renderBuffer', 'declutter', 'updateWhileAnimating', 'updateWhileInteracting', 'style'], ['style'])),
    methods: {
      /**
       * @returns {Object}
       * @protected
       */
      getServices: function getServices() {
        return mergeDescriptors(layer.methods.getServices.call(this), styleContainer.methods.getServices.call(this));
      },

      /**
       * @protected
       */
      subscribeAll: function subscribeAll() {
        layer.methods.subscribeAll.call(this);
        subscribeToLayerEvents$1.call(this);
      },

      /**
       * @return {StyleTarget|undefined}
       */
      getStyleTarget: function getStyleTarget() {
        return this.$layer;
      },

      /**
       * @param {number[]} pixel
       * @return {Promise<Array<module:ol/Feature~Feature>>}
       */
      getFeatures: function getFeatures(pixel) {
        var _this2 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return _this2.resolveLayer();

                case 2:
                  return _context.abrupt("return", _context.sent.getFeatures(pixel));

                case 3:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      },

      /**
       * @param {Object|Function|Array|undefined} value
       * @param {Object|Function|Array|undefined} prev
       * @protected
       */
      styleChanged: function styleChanged(value, prev) {
        if (isEqual(value, prev)) return;

        if (isPlainObject(value) || isArray$2(value)) {
          value = clonePlainObject(value);
        }

        this.$emit('update:style', value);
      }
    }
  };

  function subscribeToLayerEvents$1() {
    return _subscribeToLayerEvents.apply(this, arguments);
  }

  function _subscribeToLayerEvents() {
    _subscribeToLayerEvents = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
      return regenerator.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _subscribeToLayerEvents.apply(this, arguments);
  }

  function ownKeys$H(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$H(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$H(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$H(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var isNotEmptyString = /*#__PURE__*/and(isString, negate(isEmpty$2));
  /**
   * Basic vector source mixin.
   */

  var vectorSource = {
    mixins: [featureHelper, featuresContainer, source],
    stubVNode: {
      empty: false,
      attrs: function attrs() {
        return {
          id: this.vmId,
          class: this.vmClass
        };
      }
    },
    props: {
      // ol/source/Vector

      /**
       * @type {Object[]}
       */
      features: {
        type: Array,
        default: stubArray,
        validator: function validator(value) {
          return every(value, isGeoJSONFeature);
        }
      },

      /**
       * Source format factory
       * @type {function} formatFactory
       */
      formatFactory: {
        type: Function,
        default: getGeoJsonFmt
      },

      /**
       * Feature loader.
       * Feature loader should load features from some remote service, decode them and pas to `features` prop to render.
       * @type {module:ol/featureloader~FeatureLoader|undefined} loader
       */
      loader: Function,

      /**
       * @deprecated Use `loader` prop instead
       * @todo remove in v0.13.x
       */
      loaderFactory: Function,

      /**
       * Loading strategy factory.
       * Extent here in map view projection.
       * @type {function} strategyFactory
       */
      loadingStrategy: {
        type: Function // default: loadAll,

      },

      /**
       * @deprecated Use `loadingStrategy` prop instead
       * @todo remove in v0.13.x
       */
      strategyFactory: Function,

      /**
       * String or url factory
       * @type {string|function} url
       */
      url: {
        type: [String, Function],
        validator: function validator(value) {
          return isFunction$1(value) || isNotEmptyString(value);
        }
      },

      /**
       * @type {boolean}
       */
      overlaps: {
        type: Boolean,
        default: true
      },

      /**
       * @type {boolean}
       */
      useSpatialIndex: {
        type: Boolean,
        default: true
      }
    },
    data: function data() {
      return {
        /**
         * @returns {module:ol/format/Feature~FeatureFormat|undefined}
         */
        format: undefined,
        currentUrl: undefined,
        currentLoader: undefined
      };
    },
    computed: {
      featuresDataProj: function featuresDataProj() {
        return map$1(this.features, function (feature) {
          return initializeFeature(clonePlainObject(feature));
        });
      },
      featuresViewProj: function featuresViewProj() {
        var _this = this;

        return map$1(this.features, function (feature) {
          return initializeFeature(_this.writeFeatureInViewProj(_this.readFeatureInDataProj(feature)));
        });
      },
      currentFeaturesDataProj: function currentFeaturesDataProj() {
        var _this2 = this;

        if (!this.rev) return [];
        return map$1(this.getFeatures(), function (feature) {
          return _this2.writeFeatureInDataProj(feature);
        });
      },
      currentFeaturesViewProj: function currentFeaturesViewProj() {
        var _this3 = this;

        if (!this.rev) return [];
        return map$1(this.getFeatures(), function (feature) {
          return _this3.writeFeatureInViewProj(feature);
        });
      },
      extentDataProj: function extentDataProj() {
        return this.rev ? this.getExtent() : undefined;
      },
      extentViewProj: function extentViewProj() {
        return this.rev ? this.getExtent(true) : undefined;
      },
      inputUrl: function inputUrl() {
        return this.createUrlFunc(this.url);
      },
      inputLoader: function inputLoader() {
        var loader = this.loader;

        if (!loader && this.loaderFactory) {
          loader = this.loaderFactory();
        }

        return this.createLoaderFunc(loader);
      },
      inputLoadingStrategy: function inputLoadingStrategy() {
        var loadingStrategy = this.loadingStrategy;

        if (!loadingStrategy && this.strategyFactory) {
          loadingStrategy = this.strategyFactory();
        }

        return loadingStrategy || loadingstrategy.all;
      },
      formatIdent: function formatIdent() {
        if (!this.olObjIdent) return;
        return this.makeIdent(this.olObjIdent, 'format');
      },
      inputFormatFactory: function inputFormatFactory() {
        return sealFactory(this.formatFactory.bind(this));
      }
    },
    watch: _objectSpread$H({
      rev: function rev() {
        if (!this.$source) return;

        if (this.currentUrl !== this.$source.getUrl()) {
          this.currentUrl = this.$source.getUrl();
        }
      }
    }, /*#__PURE__*/makeChangeOrRecreateWatchers(['featuresViewProj', 'currentFeaturesDataProj', 'extentDataProj', 'inputUrl', 'currentUrl', 'inputLoader', 'currentLoader', 'inputLoadingStrategy', 'inputFormatFactory', 'formatIdent', 'format', 'overlaps', 'useSpatialIndex'], ['featuresViewProj', 'currentFeaturesDataProj', 'extentDataProj'])),
    created: function created() {

      if (isFunction$1(this.inputFormatFactory)) {
        this.format = this.instanceFactoryCall(this.formatIdent, this.inputFormatFactory.bind(this));
      }

      this.currentUrl = this.inputUrl;
      this.currentLoader = this.inputLoader;
    },
    updated: function updated() {
    },
    methods: {
      /**
       * @return {module:ol/source/Vector~VectorSource}
       * @protected
       */
      createSource: function createSource() {
        return new source$1.Vector({
          // ol/source/Source
          attributions: this.currentAttributions,
          projection: this.resolvedDataProjection,
          wrapX: this.wrapX,
          // ol/source/Vector
          format: this.format,
          loader: this.currentLoader,
          strategy: this.inputLoadingStrategy,
          url: this.currentUrl,
          overlaps: this.overlaps,
          useSpatialIndex: this.useSpatialIndex,
          features: this.$featuresCollection
        });
      },

      /**
       * @return {Object}
       * @protected
       */
      getServices: function getServices() {
        var vm = this;
        return mergeDescriptors(source.methods.getServices.call(this), {
          get featuresContainer() {
            return vm;
          }

        });
      },

      /**
       * @protected
       */
      subscribeAll: function subscribeAll() {
        source.methods.subscribeAll.call(this);
        featuresContainer.methods.subscribeAll.call(this);
        subscribeToSourceEvents$1.call(this);
      },

      /**
       * @param {FeatureLike[]|module:ol/Collection~Collection<FeatureLike>} features
       * @param {boolean} [viewProj=false]
       */
      addFeatures: function addFeatures(features) {
        var _this4 = this;

        var viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        if (!this.$source) {
          return featuresContainer.methods.addFeatures.call(this, features, viewProj);
        }

        var newFeatures = [];
        forEach(features || [], function (feature) {
          feature = _this4.initializeFeature(feature, viewProj);
          instanceOf(feature, ol.Feature);

          var foundFeature = _this4.$source.getFeatureById(getFeatureId(feature));

          if (foundFeature) {
            _this4.updateFeature(foundFeature, feature);
          } else {
            newFeatures.push(feature);
          }
        });
        if (!newFeatures.length) return;
        this.$source.addFeatures(newFeatures);
      },

      /**
       * @param {FeatureLike} feature
       * @param {boolean} [viewProj=false]
       */
      addFeature: function addFeature(feature) {
        var viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        if (!this.$source) {
          return featuresContainer.methods.addFeature.call(this, feature, viewProj);
        }

        feature = this.initializeFeature(feature, viewProj);
        var foundFeature = this.$source.getFeatureById(getFeatureId(feature));

        if (foundFeature == null) {
          this.$source.addFeature(feature);
        } else {
          this.updateFeature(foundFeature, feature);
        }
      },

      /**
       * @param {FeatureLike[]|module:ol/Collection~Collection<FeatureLike>} features
       */
      removeFeatures: function removeFeatures(features) {
        var _this5 = this;

        if (!this.$source) {
          return featuresContainer.methods.removeFeatures.call(this, features);
        }

        var changed = false;
        forEach(features, function (feature) {
          feature = _this5.getFeatureById(getFeatureId(feature));
          if (!feature) return;
          var featureKey = ol.getUid(feature);

          if (featureKey in _this5.$source.nullGeometryFeatures_) {
            delete _this5.$source.nullGeometryFeatures_[featureKey];
          } else {
            if (_this5.$source.featuresRtree_) {
              _this5.$source.featuresRtree_.remove(feature);
            }
          }

          _this5.$source.removeFeatureInternal(feature);

          changed = true;
        });
        if (!changed) return;
        this.$source.changed();
      },

      /**
       * @param {FeatureLike} feature
       */
      removeFeature: function removeFeature(feature) {
        var _feature;

        if (!this.$source) {
          return featuresContainer.methods.removeFeature.call(this, feature);
        }

        feature = this.$source.getFeatureById(getFeatureId(((_feature = feature) === null || _feature === void 0 ? void 0 : _feature.$feature) || feature));
        if (!feature) return;
        this.$source.removeFeature(feature);
      },

      /**
       * @param {string} featureId
       * @return {module:ol/Feature~Feature|undefined}
       */
      getFeatureById: function getFeatureById(featureId) {
        if (this.$source) {
          return this.$source.getFeatureById(featureId);
        }

        return featuresContainer.methods.getFeatureById.call(this, featureId);
      },

      /**
       * @return {Array<module:ol/Feature~Feature>}
       */
      getFeatures: function getFeatures() {
        var _this$$source;

        return coalesce((_this$$source = this.$source) === null || _this$$source === void 0 ? void 0 : _this$$source.getFeatures(), featuresContainer.methods.getFeatures.call(this));
      },

      /**
       * @return {module:ol/Collection~Collection|undefined}
       */
      getFeaturesCollection: function getFeaturesCollection() {
        var _this$$source2;

        return coalesce((_this$$source2 = this.$source) === null || _this$$source2 === void 0 ? void 0 : _this$$source2.getFeaturesCollection(), this._featuresCollection);
      },

      /**
       * @return {boolean}
       */
      isEmpty: function isEmpty() {
        var _this$$source3;

        return coalesce((_this$$source3 = this.$source) === null || _this$$source3 === void 0 ? void 0 : _this$$source3.isEmpty(), this.$featuresCollection.getLength() === 0);
      },

      /**
       * @param {boolean} [fast]
       * @return {Promise<void>}
       */
      clear: function clear(fast) {
        var _this6 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          var source;
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (_this6.$source) {
                    _context.next = 2;
                    break;
                  }

                  return _context.abrupt("return", _this6.clearFeatures());

                case 2:
                  _context.next = 4;
                  return _this6.resolveSource();

                case 4:
                  source = _context.sent;
                  return _context.abrupt("return", new Promise(function (resolve) {
                    source.once('change', function () {
                      return resolve();
                    });
                    source.clear();
                  }));

                case 6:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      },

      /**
       * @param {function} callback
       * @returns {*}
       */
      forEachFeature: function forEachFeature(callback) {
        if (this.$source) {
          return this.$source.forEachFeature(callback);
        }

        return featuresContainer.methods.forEachFeature.call(this, callback);
      },

      /**
       * @param {number[]} extent
       * @param {function} callback
       * @param {boolean} [viewProj=false]
       * @returns {*}
       */
      forEachFeatureInExtent: function forEachFeatureInExtent(extent, callback) {
        var viewProj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        extent = viewProj ? roundExtent(extent) : this.extentToViewProj(extent);

        if (this.$source) {
          return this.$source.forEachFeatureInExtent(extent, callback);
        }

        return featuresContainer.methods.forEachFeatureInExtent.call(this, extent, callback, true);
      },

      /**
       * @param {number[]} extent
       * @param {function} callback
       * @param {boolean} [viewProj=false]
       * @returns {*}
       */
      forEachFeatureIntersectingExtent: function forEachFeatureIntersectingExtent(extent, callback) {
        var viewProj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        extent = viewProj ? roundExtent(extent) : this.extentToViewProj(extent);

        if (this.$source) {
          return this.$source.forEachFeatureIntersectingExtent(extent, callback);
        }

        return featuresContainer.methods.forEachFeatureIntersectingExtent.call(this, extent, callback, true);
      },

      /**
       * @param {number[]} coordinate
       * @param {boolean} [viewProj=false]
       * @returns {Array<module:ol/Feature~Feature>}
       */
      getFeaturesAtCoordinate: function getFeaturesAtCoordinate(coordinate) {
        var viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        coordinate = viewProj ? roundPointCoords(coordinate) : this.pointToViewProj(coordinate);

        if (this.$source) {
          return this.$source.getFeaturesAtCoordinate(coordinate);
        }

        return featuresContainer.methods.getFeaturesAtCoordinate.call(this, coordinate, true);
      },

      /**
       * @param {number[]} extent
       * @param {boolean} [viewProj=false]
       * @returns {Array<module:ol/Feature~Feature>}
       */
      getFeaturesInExtent: function getFeaturesInExtent(extent) {
        var viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        extent = viewProj ? roundExtent(extent) : this.extentToViewProj(extent);

        if (this.$source) {
          return this.$source.getFeaturesInExtent(extent);
        }

        return featuresContainer.methods.getFeaturesInExtent.call(this, extent, true);
      },

      /**
       * @param {number[]} coordinate
       * @param {function} [filter]
       * @param {boolean} [viewProj=false]
       * @returns {module:ol/Feature~Feature}
       */
      getClosestFeatureToCoordinate: function getClosestFeatureToCoordinate(coordinate) {
        var filter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity$2;
        var viewProj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        coordinate = viewProj ? roundPointCoords(coordinate) : this.pointToViewProj(coordinate);

        if (this.$source) {
          return this.$source.getClosestFeatureToCoordinate(coordinate, filter);
        }

        return featuresContainer.methods.getClosestFeatureToCoordinate.call(this, coordinate, filter, true);
      },

      /**
       * @param {boolean} [viewProj=false]
       * @returns {number[]}
       */
      getExtent: function getExtent() {
        var viewProj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        var extent;

        if (this.$source) {
          extent = this.$source.getExtent();
        } else {
          extent = featuresContainer.methods.getFeaturesExtent.call(this, true);
        }

        return viewProj ? extent : this.extentToDataProj(extent);
      },

      /**
       * @returns {module:ol/format/Feature~FeatureFormat|undefined}
       */
      getFormat: function getFormat() {
        var _this$$source4;

        return coalesce((_this$$source4 = this.$source) === null || _this$$source4 === void 0 ? void 0 : _this$$source4.getFormat(), this.format);
      },

      /**
       * @returns {Promise<string|function|undefined>}
       */
      getUrl: function getUrl() {
        var _this$$source5;

        return coalesce((_this$$source5 = this.$source) === null || _this$$source5 === void 0 ? void 0 : _this$$source5.getUrl(), this.currentUrl);
      },

      /**
       * @param {string|function} url
       */
      setUrl: function setUrl(url) {
        url = this.createUrlFunc(url);

        if (url !== this.currentUrl) {
          this.currentUrl = url;
        }

        if (this.$source && url !== this.$source.getUrl()) {
          this.$source.setUrl(url);
        }
      },

      /**
       * @param {function} loader
       */
      setLoader: function setLoader(loader) {
        loader = this.createLoaderFunc(loader);

        if (loader !== this.currentLoader) {
          var _this$$source6;

          this.currentLoader = loader;
          (_this$$source6 = this.$source) === null || _this$$source6 === void 0 ? void 0 : _this$$source6.setLoader(loader);
        }
      },

      /**
       * @param {number[]} extent
       * @param {boolean} [viewProj=false]
       */
      removeLoadedExtent: function removeLoadedExtent(extent) {
        var _this$$source7;

        var viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        extent = viewProj ? roundExtent(extent) : this.extentToViewProj(extent);
        (_this$$source7 = this.$source) === null || _this$$source7 === void 0 ? void 0 : _this$$source7.removeLoadedExtent(extent);
      },

      /**
       * @param {string|function|undefined} url
       * @return {function|undefined}
       * @protected
       */
      createUrlFunc: function createUrlFunc(url) {
        if (!url) return;

        if (!isFunction$1(url)) {
          url = constant(url);
        }

        return this.wrapUrlFunc(url);
      },

      /**
       * @param {function} urlFunc
       * @returns {function}
       * @protected
       */
      wrapUrlFunc: function wrapUrlFunc(urlFunc) {
        var _this7 = this;

        var fn = urlFunc;

        if (!fn.wrapped) {
          fn = function fn(extent, resolution, projection) {
            extent = transformExtent(extent, projection, _this7.resolvedDataProjection);
            projection = _this7.resolvedDataProjection;
            return urlFunc(extent, resolution, projection);
          };

          fn.wrapped = true;
        }

        return fn;
      },

      /**
       * @param {function|undefined} loader
       * @return {function|undefined}
       * @protected
       */
      createLoaderFunc: function createLoaderFunc(loader) {
        if (!isFunction$1(loader)) return;
        return this.wrapLoaderFunc(loader);
      },

      /**
       * @param {function} loaderFunc
       * @returns {Function}
       * @protected
       */
      wrapLoaderFunc: function wrapLoaderFunc(loaderFunc) {
        var _this8 = this;

        var fn = loaderFunc;

        if (!fn.wrapped) {
          fn = /*#__PURE__*/function () {
            var _ref = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2(extent, resolution, projection) {
              var features;
              return regenerator.wrap(function _callee2$(_context2) {
                while (1) {
                  switch (_context2.prev = _context2.next) {
                    case 0:
                      _context2.next = 2;
                      return loaderFunc(transformExtent(extent, projection, _this8.resolvedDataProjection), resolution, _this8.resolvedDataProjection);

                    case 2:
                      features = _context2.sent;

                      if (!(isArray$2(features) && features[0] instanceof ol.Feature)) {
                        features = _this8.readSource(features);
                      }

                      if (isArray$2(features)) {
                        _this8.addFeatures(features);
                      }

                    case 5:
                    case "end":
                      return _context2.stop();
                  }
                }
              }, _callee2);
            }));

            return function fn(_x, _x2, _x3) {
              return _ref.apply(this, arguments);
            };
          }();

          fn.wrapped = true;
        }

        return fn;
      },

      /**
       * @param {*} data
       * @returns {Array<module:ol/Feature~Feature>}
       */
      readSource: function readSource(data) {
        return this.getFormat().readFeatures(data, {
          featureProjection: this.resolvedViewProjection,
          dataProjection: this.resolvedDataProjection
        });
      },

      /**
       * @param {GeoJSONFeature[]} value
       * @protected
       */
      featuresViewProjChanged: function featuresViewProjChanged(value) {
        // add new features
        this.addFeatures(value, true); // remove non-matched features

        this.removeFeatures(difference(this.getFeatures(), value, function (a, b) {
          return getFeatureId(a) === getFeatureId(b);
        }));
      },

      /**
       * @param {GeoJSONFeature[]} value
       * @protected
       */
      currentFeaturesDataProjChanged: function currentFeaturesDataProjChanged(value) {
        if (isEqual(value, this.featuresDataProj)) return;
        this.$emit('update:features', clonePlainObject(value));
      },

      /**
       * @param {number[]|undefined} value
       * @param {number[]|undefined} prev
       * @protected
       */
      extentDataProjChanged: function extentDataProjChanged(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit('update:extent', value === null || value === void 0 ? void 0 : value.slice());
      },

      /**
       * @param {string|function|undefined} value
       * @protected
       */
      inputUrlChanged: function inputUrlChanged(value) {
        this.setUrl(value);
      },

      /**
       * @param {string|function|undefined} value
       * @protected
       */
      currentUrlChanged: function currentUrlChanged(value) {
        if (value === this.inputUrl) return;
        this.$emit('update:url', value);
      },

      /**
       * @param {function|undefined} value
       * @protected
       */
      inputLoaderChanged: function inputLoaderChanged(value) {
        this.setLoader(value);
      },

      /**
       * @param {function|undefined} value
       * @protected
       */
      currentLoaderChanged: function currentLoaderChanged(value) {
        if (value === this.inputLoader) return;
        this.$emit('update:loader', value);
      },

      /**
       * @param {string|undefined} value
       * @param {string|undefined} prevValue
       * @protected
       */
      formatIdentChanged: function formatIdentChanged(value, prevValue) {
        if (value && prevValue) {
          this.moveInstance(value, prevValue);
        } else if (value && !prevValue && this.format) {
          this.setInstance(value, this.format);
        } else if (!value && prevValue) {
          this.unsetInstance(prevValue);
        }
      },

      /**
       * @param {function} value
       * @protected
       */
      inputFormatFactoryChanged: function inputFormatFactoryChanged(value) {
        while (this.hasInstance(this.formatIdent)) {
          this.unsetInstance(this.formatIdent);
        }

        if (isFunction$1(value)) {
          this.format = this.instanceFactoryCall(this.formatIdent, value.bind(this));
        } else {
          this.format = undefined;
        }
      },
      // skip not used watchers
      attributionsCollapsibleChanged: noop$1,
      stateChanged: noop$1
    }
  };

  function subscribeToSourceEvents$1() {}

  function transformExtent(extent, sourceProj, destProj) {
    extent = extent.slice();

    if (isFinite(extent[0]) && isFinite(extent[1])) {
      var _transform = transform([extent[0], extent[1]], sourceProj, destProj);

      var _transform2 = _slicedToArray(_transform, 2);

      extent[0] = _transform2[0];
      extent[1] = _transform2[1];
    }

    if (isFinite(extent[2]) && isFinite(extent[3])) {
      var _transform3 = transform([extent[2], extent[3]], sourceProj, destProj);

      var _transform4 = _slicedToArray(_transform3, 2);

      extent[2] = _transform4[0];
      extent[3] = _transform4[1];
    }

    return extent;
  }

  /**
   * @module ol/source/WMSServerType
   */
  /**
   * Available server types: `'carmentaserver'`, `'geoserver'`, `'mapserver'`,
   *     `'qgis'`. These are servers that have vendor parameters beyond the WMS
   *     specification that OpenLayers can make use of.
   * @enum {string}
   */
  var WMSServerType = {
      /**
       * HiDPI support for [Carmenta Server](https://www.carmenta.com/en/products/carmenta-server)
       * @api
       */
      CARMENTA_SERVER: 'carmentaserver',
      /**
       * HiDPI support for [GeoServer](https://geoserver.org/)
       * @api
       */
      GEOSERVER: 'geoserver',
      /**
       * HiDPI support for [MapServer](https://mapserver.org/)
       * @api
       */
      MAPSERVER: 'mapserver',
      /**
       * HiDPI support for [QGIS](https://qgis.org/)
       * @api
       */
      QGIS: 'qgis',
  };

  function ownKeys$G(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$G(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$G(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$G(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  var cleanWmsSourceParams = function cleanWmsSourceParams(params) {
    return cleanSourceParams(params, ['LAYERS', 'VERSION', 'STYLES', 'FORMAT', 'TRANSPARENT', 'BGCOLOR', 'TIME']);
  };
  /**
   * Basic WMS params and methods mixin.
   */


  var wmsSource = {
    props: {
      /**
       * @type {boolean}
       */
      hidpi: {
        type: Boolean,
        default: true
      },

      /**
       * @type {string|undefined}
       */
      serverType: {
        type: String,
        validator: function validator(value) {
          return Object.values(WMSServerType).includes(value);
        }
      },

      /**
       * @type {string|string[]}
       */
      layers: {
        type: String,
        required: true
      },

      /**
       * WMS Request styles
       * @type {string|string[]|undefined}
       */
      styles: String,

      /**
       * @type {string}
       */
      version: {
        type: String,
        default: '1.3.0'
      },

      /**
       * @type {boolean}
       */
      transparent: {
        type: Boolean,
        default: true
      },

      /**
       * @type {string}
       */
      format: {
        type: String,
        default: 'image/png'
      },

      /**
       * @type {string|undefined}
       */
      bgColor: String,

      /**
       * @type {string|undefined}
       */
      time: String,

      /**
       * Additional WMS request parameters
       * @type {Object|undefined}
       */
      params: Object
    },
    data: function data() {
      return {
        currentParams: undefined
      };
    },
    computed: _objectSpread$G({
      /**
       * @returns {string}
       */
      inputLayers: function inputLayers() {
        return isArray$2(this.layers) ? this.layers.join(',') : this.layers;
      },

      /**
       * @returns {string|undefined}
       */
      inputStyles: function inputStyles() {
        return isArray$2(this.styles) ? this.styles.join(',') : this.styles;
      },

      /**
       * @returns {Object|null}
       */
      customParams: function customParams() {
        return this.params ? cleanWmsSourceParams(this.params) : undefined;
      },

      /**
       * @returns {Object}
       */
      inputParams: function inputParams() {
        return _objectSpread$G(_objectSpread$G({}, this.customParams || {}), {}, {
          LAYERS: this.inputLayers,
          STYLES: this.inputStyles,
          VERSION: this.version,
          FORMAT: this.format,
          TRANSPARENT: this.transparent,
          BGCOLOR: this.bgColor,
          TIME: this.time
        });
      }
    }, /*#__PURE__*/reduce(['inputLayers', 'inputStyles', 'version', 'format', 'transparent', 'bgColor', 'time'], function (props, inProp) {
      var prop = inProp.slice(0, 5) === 'input' ? lowerFirst(inProp.slice(5)) : inProp;
      var curProp = 'current' + upperFirst(prop);

      props[curProp] = function () {
        return coalesce((this.currentParams || {})[prop.toUpperCase()], (this.inputParams || {})[prop.toUpperCase()]);
      };

      return props;
    }, {})),
    watch: _objectSpread$G(_objectSpread$G({
      rev: function rev() {
        if (!this.$source) return;

        if (!isEqual(this.currentParams, this.$source.getParams())) {
          this.currentParams = this.$source.getParams();
        }
      }
    }, /*#__PURE__*/makeWatchers(['currentLayers', 'currentStyles', 'currentVersion', 'currentFormat', 'currentTransparent', 'currentBgColor', 'currentTime'], function (curProp) {
      return function (value) {
        var prop = lowerFirst(curProp.slice(7));
        var inProp = hasProp(this, 'input' + upperFirst(prop)) ? 'input' + upperFirst(prop) : prop;
        if (isEqual(value, this[inProp])) return;
        this.$emit('update:' + prop, isObjectLike(value) ? clonePlainObject(value) : value);
      };
    })), /*#__PURE__*/makeChangeOrRecreateWatchers(['hidpi', 'serverType', 'inputParams', 'currentParams'], ['inputParams', 'currentParams'])),
    created: function created() {
      this.currentParams = this.inputParams && clonePlainObject(this.inputParams);
    },
    methods: {
      /**
       * @param {number[]} coordinate
       * @param {number} [resolution]
       * @param {string} [projection]
       * @param {Object|undefined} [params] GetFeatureInfo params. `info_format` at least should be provided.
       *                          If `query_layers` is not provided then the layers specified in the `layers` prop will be used.
       *                          `version` should not be specified here (value from `version` prop will be used).
       * @return {Promise<string|undefined>}
       */
      getFeatureInfoUrl: function getFeatureInfoUrl(coordinate, resolution, projection) {
        var _arguments = arguments,
            _this = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          var _this$$viewVm;

          var params;
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  params = _arguments.length > 3 && _arguments[3] !== undefined ? _arguments[3] : {};
                  resolution || (resolution = (_this$$viewVm = _this.$viewVm) === null || _this$$viewVm === void 0 ? void 0 : _this$$viewVm.getResolution());
                  projection || (projection = _this.resolvedDataProjection);
                  _context.next = 5;
                  return _this.resolveSource();

                case 5:
                  return _context.abrupt("return", _context.sent.getFeatureInfoUrl(coordinate, resolution, projection, params));

                case 6:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      },

      /**
       * @param {number} resolution
       * @param {Object|undefined} [params]
       * @return {Promise<string|undefined>}
       */
      getLegendUrl: function getLegendUrl(resolution) {
        var _arguments2 = arguments,
            _this2 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
          var params;
          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  params = _arguments2.length > 1 && _arguments2[1] !== undefined ? _arguments2[1] : {};
                  _context2.next = 3;
                  return _this2.resolveSource();

                case 3:
                  return _context2.abrupt("return", _context2.sent.getLegendUrl(resolution, params));

                case 4:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }))();
      },

      /**
       * @returns {Object}
       */
      getParams: function getParams() {
        var _this$$source;

        return coalesce((_this$$source = this.$source) === null || _this$$source === void 0 ? void 0 : _this$$source.getParams(), this.currentParams);
      },

      /**
       * @param {Object} params
       */
      updateParams: function updateParams(params) {
        params = reduce(_objectSpread$G(_objectSpread$G({}, this.currentParams), params), function (params, value, name) {
          return _objectSpread$G(_objectSpread$G({}, params), {}, _defineProperty$1({}, name.toUpperCase(), value));
        }, {});

        if (!isEqual(params, this.currentParams)) {
          this.currentParams = params;
        }

        if (this.$source && !isEqual(params, this.$source.getParams())) {
          this.$source.updateParams(params);
        }
      },

      /**
       * @param {string} param
       * @param {*} value
       */
      updateParam: function updateParam(param, value) {
        this.updateParams(_defineProperty$1({}, param.toUpperCase(), value));
      },

      /**
       * @param {Object|undefined} value
       * @protected
       */
      inputParamsChanged: function inputParamsChanged(value) {
        this.updateParams(value);
      },

      /**
       * @param {Object|undefined} value
       * @protected
       */
      currentParamsChanged: function currentParamsChanged(value) {
        value = value ? cleanWmsSourceParams(value) : undefined;
        if (isEqual(value, this.customParams)) return;
        this.$emit('update:params', value && clonePlainObject(value));
      }
    }
  };

  /*!
  OpenLayers tile url function to load tile seeded with TileCache url scheme

  @package ol-tilecache
  @author Vladimir Vershinin <ghettovoice@gmail.com>
  @version 7.0.0
  @licence MIT
  @copyright (c) 2016-2020, Vladimir Vershinin <ghettovoice@gmail.com>
  */

  /**
   * This file is part of ol-tilecache package.
   * @module ol-tilecache
   * @license MIT
   * @author Vladimir Vershinin
   */

  /**
   * Left zero pad.
   *
   * @param {string | number} num
   * @param {number} places
   * @returns {string}
   */
  function zeroPad(num, places) {
    var zero = places - num.toString().length + 1;
    return (new Array(parseInt(zero > 0 && zero, 10)).join("0") + num).toString().slice(-places);
  }
  /**
   * The % operator in JavaScript returns the remainder of a / b, but differs from
   * some other languages in that the result will have the same sign as the
   * dividend. For example, -1 % 8 == -1, whereas in some other languages
   * (such as Python) the result would be 7. This function emulates the more
   * correct modulo behavior, which is useful for certain applications such as
   * calculating an offset index in a circular list.
   *
   * @param {number} a The dividend.
   * @param {number} b The divisor.
   * @return {number} a % b where the result is between 0 and b (either 0 <= x < b
   *     or b < x <= 0, depending on the sign of b).
   * @link https://closure-library.googlecode.com/git-history/docs/local_closure_goog_math_math.js.source.html#line73
   */

  function modulo(a, b) {
    var m = a % b;
    return m * b < 0 ? m + b : m;
  }

  /**
   * This file is part of ol-tilecache package.
   * @module ol-tilecache
   * @license MIT
   * @author Vladimir Vershinin
   */
  var zRegEx = /{z}/g;
  var zPadRegEx = /{0z}/g;
  var xRegEx = /{x\d?}/g;
  var yRegEx = /{y\d?}/g;
  var dashYRegEx = /{-y\d?}/g;
  /**
   * Basic create factory.
   *
   * @param {string} url Url template
   * @param {TileGrid} [tileGrid] Tile grid.
   * @returns {function(tileCoord: TileCoord)}
   * @static
   * @public
   */

  function createTileUrlFunction(url) {
    var tileGrid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : tilegrid.createXYZ();
    return createTileUrlFunctionFromTemplates(expandUrl(url), tileGrid);
  }
  /**
   * Creates tile URL function from single template.
   *
   * @param {string} template Source url
   * @param {TileGrid} [tileGrid] Tile grid.
   * @returns {function(tileCoord: TileCoord)}
   * @private
   */

  function createTileUrlFunctionFromTemplate(template) {
    var tileGrid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : tilegrid.createXYZ();
    return (
      /**
       * @param {TileCoord} tileCoord Tile Coordinate.
       * @return {string | undefined} Tile URL.
       */
      function (tileCoord) {
        if (tileCoord != null) {
          return template.replace(zRegEx, zoomReplacer(tileCoord[0])).replace(zPadRegEx, zoomReplacer(tileCoord[0], true)).replace(xRegEx, coordReplacer(tileCoord[1])).replace(yRegEx, coordReplacer(tileCoord[2])).replace(dashYRegEx, function (part) {
            var z = tileCoord[0];
            var range = tileGrid.getFullTileRange(z);
            if (!range) throw new Error('The {-y} placeholder requires a tile grid with extent.');
            var y = range.getHeight() - tileCoord[2] - 1;
            return coordReplacer(y)(part);
          });
        }
      }
    );
  }
  /**
   * Creates tile URL function from multiple templates.
   *
   * @param {string[]} templates Url templates
   * @param {TileGrid} [tileGrid] Tile grid.
   * @returns {function(tileCoord: TileCoord)}
   * @private
   */

  function createTileUrlFunctionFromTemplates(templates) {
    var tileGrid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : tilegrid.createXYZ();
    return createTileUrlFunctionFromTileUrlFunctions(templates.map(function (tileUrlFunction) {
      return createTileUrlFunctionFromTemplate(tileUrlFunction, tileGrid);
    }));
  }
  /**
   * @param zoom
   * @param pad
   * @returns {function}
   * @private
   */

  function zoomReplacer(zoom, pad) {
    return function () {
      return pad ? zeroPad(zoom, 2) : zoom.toString();
    };
  }
  /**
   * @param coord
   * @returns {function}
   * @private
   */


  function coordReplacer(coord) {
    return function (part) {
      var match = part.match(/\d/);

      if (match) {
        return zeroPad(coord, 9).slice((match[0] - 1) * 3, match[0] * 3);
      }

      return coord.toString();
    };
  }
  /**
   * @param {string} url
   * @returns {Array.<string>}
   * @private
   */


  function expandUrl(url) {
    var urls = [];
    var match = /{(\d)-(\d)}/.exec(url) || /{([a-z])-([a-z])}/.exec(url);

    if (match) {
      var startCharCode = match[1].charCodeAt(0);
      var stopCharCode = match[2].charCodeAt(0);

      for (var charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
        urls.push(url.replace(match[0], String.fromCharCode(charCode)));
      }
    } else {
      urls.push(url);
    }

    return urls;
  }
  /**
   * @param {Array.<function(tileCoord: TileCoord)>} tileUrlFunctions
   * @returns {function(tileCoord: TileCoord)}
   * @private
   */


  function createTileUrlFunctionFromTileUrlFunctions(tileUrlFunctions) {
    if (tileUrlFunctions.length === 1) {
      return tileUrlFunctions[0];
    }

    return (
      /**
       * @param {TileCoord} tileCoord Tile Coordinate.
       * @param {number} pixelRatio Pixel ratio.
       * @param {Projection} projection Projection.
       * @return {string | undefined} Tile URL.
       */
      function (tileCoord, pixelRatio, projection) {
        if (tileCoord != null) {
          var h = (tileCoord[1] << tileCoord[0]) + tileCoord[2];
          var index = modulo(h, tileUrlFunctions.length);
          return tileUrlFunctions[index](tileCoord, pixelRatio, projection);
        }
      }
    );
  }

  if (typeof window !== 'undefined' && _typeof$1(window.ol) === 'object') {
    window.ol.tileCacheUrlFn = {
      createTileUrlFunction: createTileUrlFunction,
      createTileUrlFunctionFromTemplate: createTileUrlFunctionFromTemplate,
      createTileUrlFunctionFromTemplates: createTileUrlFunctionFromTemplates
    };
  }

  function ownKeys$F(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$F(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$F(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$F(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  var validateMinZoom = function validateMinZoom(value) {
    return value >= 0;
  };

  var validateTileSize$1 = /*#__PURE__*/or(isNumber$1, and(isArray$2, function (value) {
    return value.length === 2 && value.every(isNumber$1);
  }));
  /**
   * Base XYZ source mixin.
   */

  var xyzSource = {
    mixins: [tileImageSource],
    props: {
      /* eslint-disable vue/require-prop-types */
      // ol/source/Source
      projection: _objectSpread$F(_objectSpread$F({}, source.props.projection), {}, {
        default: EPSG_3857
      }),

      /* eslint-enable vue/require-prop-types */
      // ol/source/XYZ
      maxZoom: {
        type: Number,
        default: 42
      },
      minZoom: {
        type: Number,
        default: 0,
        validator: validateMinZoom
      },
      maxResolution: Number,
      tileSize: {
        type: [Number, Array],
        default: function _default() {
          return [256, 256];
        },
        validator: validateTileSize$1
      }
    },
    computed: {
      inputTileSize: function inputTileSize() {
        return isArray$2(this.tileSize) ? this.tileSize.slice() : [this.tileSize, this.tileSize];
      },
      derivedTileGridFactory: function derivedTileGridFactory() {
        if (isFunction$1(this.tileGridFactory)) {
          return this.tileGridFactory;
        }

        var extent = extentFromProjection(this.resolvedDataProjection);
        var maxZoom = this.maxZoom;
        var minZoom = this.minZoom;
        var maxResolution = this.maxResolution;
        var tileSize = this.inputTileSize;
        return function () {
          return tilegrid.createXYZ({
            extent: extent,
            maxZoom: maxZoom,
            minZoom: minZoom,
            maxResolution: maxResolution,
            tileSize: tileSize
          });
        };
      },
      inputTileUrlFunction: function inputTileUrlFunction() {
        var urlFunc = coalesce(this.tileUrlFunction, this.tileUrlFunc);
        if (isFunction$1(urlFunc)) return urlFunc;
        if (this.currentUrls.length === 0) return;
        return createTileUrlFunctionFromTemplates(this.currentUrls, this.tileGrid);
      }
    },
    methods: {
      /**
       * @return {module:ol/source/XYZ~XYZSource}
       * @protected
       */
      createSource: function createSource() {
        return new source$1.XYZ({
          // ol/source/Source
          attributions: this.currentAttributions,
          attributionsCollapsible: this.attributionsCollapsible,
          projection: this.resolvedDataProjection,
          wrapX: this.wrapX,
          // ol/source/Tile
          cacheSize: this.cacheSize,
          opaque: this.opaque,
          tilePixelRatio: this.tilePixelRatio,
          transition: this.transition,
          zDirection: this.zDirection,
          tileGrid: this.tileGrid,
          // ol/source/UrlTile
          tileLoadFunction: this.currentTileLoadFunction,
          tileUrlFunction: this.currentTileUrlFunction,
          // ol/source/TileImage
          crossOrigin: this.crossOrigin,
          reprojectionErrorThreshold: this.reprojectionErrorThreshold,
          tileClass: this.tileClass,
          imageSmoothing: this.imageSmoothing
        });
      },
      tileKeyChanged: noop$1,
      // input tileKey is not allowed in XYZ constructor
      stateChanged: noop$1 // input state is not allowed in XYZ constructor

    }
  };

  var mixins = /*#__PURE__*/Object.freeze({
    __proto__: null,
    arcgisSource: arcgisSource,
    baseLayer: baseLayer,
    controlsContainer: controlsContainer,
    eventBus: eventBus,
    feature: feature,
    featureHelper: featureHelper,
    featuresContainer: featuresContainer,
    fillStyleContainer: fillStyleContainer,
    geometry: geometry,
    geometryContainer: geometryContainer,
    identMap: identMap,
    imageLayer: imageLayer,
    imageSource: imageSource,
    imageStyle: imageStyle,
    imageStyleContainer: imageStyleContainer,
    interaction: interaction,
    interactionsContainer: interactionsContainer,
    layer: layer,
    layersContainer: layersContainer,
    olCmp: olCmp,
    overlaysContainer: overlaysContainer,
    projTransforms: projTransforms,
    regShapeStyle: regShapeStyle,
    rxSubs: rxSubs,
    services: services,
    simpleGeometry: simpleGeometry,
    source: source,
    sourceContainer: sourceContainer,
    strokeStyleContainer: strokeStyleContainer,
    stubVNode: stubVNode,
    style: style,
    styleContainer: styleContainer,
    textStyleContainer: textStyleContainer,
    tileImageSource: tileImageSource,
    tileLayer: tileLayer,
    tileSource: tileSource,
    urlTileSource: urlTileSource,
    vectorLayer: vectorLayer,
    vectorSource: vectorSource,
    waitForMap: waitForMap,
    wmsSource: wmsSource,
    xyzSource: xyzSource,
    EVENT_BUS_PROP: EVENT_BUS_PROP,
    IDENTITY_MAP_PROP: IDENTITY_MAP_PROP,
    INSTANCES_POOL: INSTANCES_POOL,
    VM_PROP: VM_PROP,
    FRAME_TIME: FRAME_TIME,
    OlObjectState: OlObjectState,
    OlObjectEvent: OlObjectEvent,
    OlObjectAction: OlObjectAction,
    LifecycleError: LifecycleError,
    CanceledError: CanceledError,
    isCreateError: isCreateError,
    isMountError: isMountError,
    isUnmountError: isUnmountError,
    isDestroyError: isDestroyError,
    makeChangeOrRecreateWatchers: makeChangeOrRecreateWatchers,
    SERVICES_PROP: SERVICES_PROP
  });

  function ownKeys$E(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$E(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$E(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$E(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var script$S = {
    name: 'VlSourceBingmaps',
    mixins: [tileImageSource],
    props: {
      // ol/source/BingMaps

      /**
       * Enables hidpi tiles.
       * @type {boolean}
       */
      hidpi: {
        type: Boolean,
        default: false
      },

      /**
       * Culture code.
       * @type {string}
       */
      culture: {
        type: String,
        default: 'en-us'
      },

      /**
       * Bing Maps API key.
       * @type {string}
       */
      apiKey: {
        type: String,
        required: true
      },

      /**
       * Type of imagery.
       * @type {string}
       */
      imagerySet: {
        type: String,
        required: true
      },

      /**
       * @type {number}
       */
      maxZoom: {
        type: Number,
        default: 21
      }
    },
    computed: {
      tileGridIdent: noop$1,
      inputTileGridFactory: noop$1,
      inputUrl: noop$1,
      inputUrls: noop$1,
      inputTileUrlFunction: noop$1,
      inputAttributions: noop$1
    },
    watch: _objectSpread$E({}, /*#__PURE__*/makeChangeOrRecreateWatchers(['hidpi', 'culture', 'apiKey', 'imagerySet', 'maxZoom'])),
    methods: {
      /**
       * @return {module:ol/source/BingMaps}
       * @protected
       */
      createSource: function createSource() {
        return new source$1.BingMaps({
          // ol/source/Source
          wrapX: this.wrapX,
          // ol/source/Tile
          cacheSize: this.cacheSize,
          opaque: this.opaque,
          transition: this.transition,
          // ol/source/UrlTile
          tileLoadFunction: this.currentTileLoadFunction,
          // ol/source/TileImage
          reprojectionErrorThreshold: this.reprojectionErrorThreshold,
          imageSmoothing: this.imageSmoothing,
          // ol/source/BingMaps
          hidpi: this.hidpi,
          culture: this.culture,
          key: this.apiKey,
          imagerySet: this.imagerySet,
          maxZoom: this.maxZoom
        });
      },
      getApiKey: function getApiKey() {
        var _this$$source;

        return coalesce((_this$$source = this.$source) === null || _this$$source === void 0 ? void 0 : _this$$source.getApiKey(), this.apiKey);
      },
      getImagerySet: function getImagerySet() {
        var _this$$source2;

        return coalesce((_this$$source2 = this.$source) === null || _this$$source2 === void 0 ? void 0 : _this$$source2.getImagerySet(), this.imagerySet);
      },
      stateChanged: noop$1,
      attributionsCollapsibleChanged: noop$1,
      projectionChanged: noop$1,
      tileGridIdentChanged: noop$1,
      inputTileGridFactoryChanged: noop$1,
      tileGridChanged: noop$1,
      tileKeyChanged: noop$1,
      tilePixelRatioChanged: noop$1,
      zDirectionChanged: noop$1,
      inputTileUrlFunctionChanged: noop$1,
      inputUrlsChanged: noop$1,
      crossOriginChanged: noop$1,
      tileClassChanged: noop$1
    }
  };

  function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
      if (typeof shadowMode !== 'boolean') {
          createInjectorSSR = createInjector;
          createInjector = shadowMode;
          shadowMode = false;
      }
      // Vue.extend constructor export interop.
      const options = typeof script === 'function' ? script.options : script;
      // render functions
      if (template && template.render) {
          options.render = template.render;
          options.staticRenderFns = template.staticRenderFns;
          options._compiled = true;
          // functional template
          if (isFunctionalTemplate) {
              options.functional = true;
          }
      }
      // scopedId
      if (scopeId) {
          options._scopeId = scopeId;
      }
      let hook;
      if (moduleIdentifier) {
          // server build
          hook = function (context) {
              // 2.3 injection
              context =
                  context || // cached call
                      (this.$vnode && this.$vnode.ssrContext) || // stateful
                      (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional
              // 2.2 with runInNewContext: true
              if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
                  context = __VUE_SSR_CONTEXT__;
              }
              // inject component styles
              if (style) {
                  style.call(this, createInjectorSSR(context));
              }
              // register component module identifier for async chunk inference
              if (context && context._registeredComponents) {
                  context._registeredComponents.add(moduleIdentifier);
              }
          };
          // used by ssr in case component is cached and beforeCreate
          // never gets called
          options._ssrRegister = hook;
      }
      else if (style) {
          hook = shadowMode
              ? function (context) {
                  style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
              }
              : function (context) {
                  style.call(this, createInjector(context));
              };
      }
      if (hook) {
          if (options.functional) {
              // register for functional component in vue file
              const originalRender = options.render;
              options.render = function renderWithStyleInjection(h, context) {
                  hook.call(context);
                  return originalRender(h, context);
              };
          }
          else {
              // inject component registration as beforeCreate hook
              const existing = options.beforeCreate;
              options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
          }
      }
      return script;
  }

  /* script */
  var __vue_script__$S = script$S;
  /* template */

  /* style */

  var __vue_inject_styles__$S = undefined;
  /* scoped */

  var __vue_scope_id__$S = undefined;
  /* module identifier */

  var __vue_module_identifier__$S = undefined;
  /* functional template */

  var __vue_is_functional_template__$S = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$S = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$S, __vue_script__$S, __vue_scope_id__$S, __vue_is_functional_template__$S, __vue_module_identifier__$S, false, undefined, undefined, undefined);

  /**
   * @param {Vue} Vue
   * @param {VueLayersOptions} [options]
   */

  function plugin$A(Vue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$A.installed) {
      return;
    }

    plugin$A.installed = true;
    options = pick(options, 'dataProjection');
    Object.assign(__vue_component__$S, options);
    Vue.component(__vue_component__$S.name, __vue_component__$S);
  }

  var BingmapsSource = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': plugin$A,
    install: plugin$A,
    Source: __vue_component__$S
  });

  var script$R = {
    name: 'VlSourceInnerAdapter',
    mixins: [stubVNode, sourceContainer, olCmp],
    stubVNode: {
      empty: false,
      attrs: function attrs() {
        return {
          id: this.vmId,
          class: this.vmClass
        };
      }
    },
    computed: {
      source: function source() {
        if (!(this.rev && this.$source)) return;
        return {
          id: getSourceId(this.$source),
          type: this.$source.constructor.name
        };
      }
    },
    watch: {
      source: {
        deep: true,
        handler: function handler(value, prev) {
          if (isEqual(value, prev)) return;
          this.$emit('update:source', value && clonePlainObject(value));
        }
      }
    },
    created: function created() {
      var _this = this;

      Object.defineProperties(this, {
        $innerSourceContainer: {
          enumerable: true,
          get: function get() {
            var _this$$services;

            return (_this$$services = _this.$services) === null || _this$$services === void 0 ? void 0 : _this$$services.innerSourceContainer;
          }
        }
      });
    },
    methods: {
      createOlObject: function createOlObject() {
        var obj = stubObject();
        obj.id = this.currentId;
        return obj;
      },
      getServices: function getServices() {
        return mergeDescriptors(olCmp.methods.getServices.call(this), sourceContainer.methods.getServices.call(this));
      },
      getSourceTarget: function getSourceTarget() {
        var _this2 = this;

        return {
          getSource: function getSource() {
            var _this2$$innerSourceCo;

            return (_this2$$innerSourceCo = _this2.$innerSourceContainer) === null || _this2$$innerSourceCo === void 0 ? void 0 : _this2$$innerSourceCo.getInnerSource();
          },
          setSource: function setSource(source) {
            var _this2$$innerSourceCo2;

            return (_this2$$innerSourceCo2 = _this2.$innerSourceContainer) === null || _this2$$innerSourceCo2 === void 0 ? void 0 : _this2$$innerSourceCo2.setInnerSource(source);
          }
        };
      }
    }
  };

  /* script */
  var __vue_script__$R = script$R;
  /* template */

  /* style */

  var __vue_inject_styles__$R = undefined;
  /* scoped */

  var __vue_scope_id__$R = undefined;
  /* module identifier */

  var __vue_module_identifier__$R = undefined;
  /* functional template */

  var __vue_is_functional_template__$R = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$R = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$R, __vue_script__$R, __vue_scope_id__$R, __vue_is_functional_template__$R, __vue_module_identifier__$R, false, undefined, undefined, undefined);

  function ownKeys$D(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$D(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$D(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$D(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var script$Q = {
    name: 'VlSourceCluster',
    components: {
      InnerSource: __vue_component__$R
    },
    mixins: [vectorSource],
    props: {
      distance: {
        type: Number,
        default: 20
      },
      geometryFunction: {
        type: Function // default: defaultGeomFunc,

      },

      /**
       * @deprecated
       * @todo remove later
       */
      geomFunc: Function,

      /**
       * @deprecated Use geomFunc prop instead.
       * @todo remove in v0.13.x
       */
      geomFuncFactory: Function
    },
    data: function data() {
      return {
        currentDistance: this.distance
      };
    },
    computed: {
      inputGeometryFunction: function inputGeometryFunction() {
        var geomFunc = this.geometryFunction || this.geomFunc;

        if (!geomFunc && this.geomFuncFactory) {
          geomFunc = this.geomFuncFactory();
        }

        return geomFunc || defaultGeomFunc;
      },
      innerSource: function innerSource() {
        if (!(this.rev && this.$innerSource)) return;
        return {
          id: getSourceId(this.$innerSource),
          type: this.$innerSource.constructor.name
        };
      },
      inputUrl: noop$1,
      inputLoader: noop$1,
      inputLoadingStrategy: noop$1,
      formatIdent: noop$1,
      inputFormatFactory: noop$1
    },
    watch: _objectSpread$D({
      rev: function rev() {
        if (!this.$source) return;

        if (this.currentDistance !== this.$source.getDistance()) {
          this.currentDistance = this.$source.getDistance();
        }
      },
      distance: function distance(value) {
        this.setDistance(value);
      },
      currentDistance: function currentDistance(value) {
        if (value === this.distance) return;
        this.$emit('update:distance', value);
      },
      innerSource: {
        deep: true,
        handler: function handler(value, prev) {
          if (value === prev) return;
          this.$emit('update:innerSource', value && clonePlainObject(value));
        }
      }
    }, /*#__PURE__*/makeChangeOrRecreateWatchers(['inputGeometryFunction'])),
    created: function created() {

      this._innerSource = undefined;
      this._innerSourceVm = undefined;
      defineServices$9.call(this);
    },
    updated: function updated() {
    },
    methods: {
      createSource: function createSource() {
        return new source$1.Cluster({
          // ol/source/Source
          attributions: this.currentAttributions,
          wrapX: this.wrapX,
          // ol/source/Cluster
          source: this.$innerSource,
          distance: this.currentDistance,
          geometryFunction: this.inputGeometryFunction
        });
      },
      getServices: function getServices() {
        var vm = this;
        return mergeDescriptors(vectorSource.methods.getServices.call(this), {
          get innerSourceContainer() {
            return vm;
          }

        });
      },
      getDistance: function getDistance() {
        var _this$$source;

        return coalesce((_this$$source = this.$source) === null || _this$$source === void 0 ? void 0 : _this$$source.getDistance(), this.currentDistance);
      },
      setDistance: function setDistance(distance) {
        assert$1(isNumber$1(distance), 'Invalid distance');

        if (distance !== this.currentDistance) {
          this.currentDistance = distance;
        }

        if (this.$source && distance !== this.$source.getDistance()) {
          this.$source.setDistance(distance);
        }
      },
      getInnerSource: function getInnerSource() {
        return this._innerSource;
      },
      getInnerSourceVm: function getInnerSourceVm() {
        return this._innerSourceVm;
      },
      setInnerSource: function setInnerSource(innerSource) {
        var _innerSource;

        innerSource = ((_innerSource = innerSource) === null || _innerSource === void 0 ? void 0 : _innerSource.$source) || innerSource;
        assert$1(!innerSource || innerSource instanceof source$1.Source);
        innerSource || (innerSource = undefined);

        if (innerSource !== this._innerSource) {
          var _innerSource2;

          this._innerSource = innerSource;
          this._innerSourceVm = ((_innerSource2 = innerSource) === null || _innerSource2 === void 0 ? void 0 : _innerSource2.vm) && innerSource.vm[0];
          this.scheduleRefresh();
        }

        if (this.$source && innerSource !== this.$source.getSource()) {
          this.$source.setSource(innerSource);
          this.scheduleRefresh();
        }
      },
      projectionChanged: noop$1,
      inputUrlChanged: noop$1,
      inputLoaderChanged: noop$1,
      inputLoadingStrategyChanged: noop$1,
      inputFormatFactoryChanged: noop$1,
      formatIdentChanged: noop$1,
      formatChanged: noop$1,
      overlapsChanged: noop$1,
      useSpatialIndexChanged: noop$1
    }
  };

  function defineServices$9() {
    Object.defineProperties(this, {
      $innerSource: {
        enumerable: true,
        get: this.getInnerSource
      },
      $innerSourceVm: {
        enumerable: true,
        get: this.getInnerSourceVm
      }
    });
  }

  function defaultGeomFunc(feature) {
    var geometry = feature.getGeometry();
    if (!geometry) return;
    var coordinate = findPointOnSurface(geometry);

    if (coordinate) {
      return createPointGeom(coordinate);
    }
  }

  /* script */
  var __vue_script__$Q = script$Q;
  /* template */

  var __vue_render__$a = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('i', {
      class: _vm.vmClass,
      staticStyle: {
        "display": "none !important"
      },
      attrs: {
        "id": _vm.vmId
      }
    }, [_c('InnerSource', {
      attrs: {
        "id": 'vl-' + _vm.currentId + '-inner-source'
      }
    }, [_vm._t("default")], 2)], 1);
  };

  var __vue_staticRenderFns__$a = [];
  /* style */

  var __vue_inject_styles__$Q = undefined;
  /* scoped */

  var __vue_scope_id__$Q = undefined;
  /* module identifier */

  var __vue_module_identifier__$Q = undefined;
  /* functional template */

  var __vue_is_functional_template__$Q = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$Q = /*#__PURE__*/normalizeComponent({
    render: __vue_render__$a,
    staticRenderFns: __vue_staticRenderFns__$a
  }, __vue_inject_styles__$Q, __vue_script__$Q, __vue_scope_id__$Q, __vue_is_functional_template__$Q, __vue_module_identifier__$Q, false, undefined, undefined, undefined);

  function plugin$z(Vue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$z.installed) {
      return;
    }

    plugin$z.installed = true;
    options = pick(options, 'dataProjection');
    Object.assign(__vue_component__$Q, options);
    Vue.component(__vue_component__$Q.name, __vue_component__$Q);
  }

  var ClusterSource = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': plugin$z,
    install: plugin$z,
    Source: __vue_component__$Q
  });

  function ownKeys$C(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$C(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$C(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$C(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

  var transformType = /*#__PURE__*/function transformType(type) {
    return upperFirst(camelCase(type));
  };

  var script$P = {
    name: 'VlInteractionDraw',
    mixins: [interaction, styleContainer],
    stubVNode: {
      empty: false,
      attrs: function attrs() {
        return {
          id: this.vmId,
          class: this.vmClass
        };
      }
    },
    props: {
      /**
       * Target source or collection identifier from IdentityMap.
       * @type {String}
       */
      source: {
        type: String,
        required: true
      },

      /**
       * The maximum distance in pixels between "down" and "up" for a "up" event to be considered a "click" event and
       * actually add a point/vertex to the geometry being drawn. Default is 6 pixels. That value was chosen for the
       * draw interaction to behave correctly on mouse as well as on touch devices.
       * @type {number}
       */
      clickTolerance: {
        type: Number,
        default: 6
      },

      /**
       * Pixel distance for snapping to the drawing finish.
       * @type {number}
       */
      snapTolerance: {
        type: Number,
        default: 12
      },

      /**
       * Drawing type ('Point', 'LineString', 'Polygon', 'MultiPoint', 'MultiLineString', 'MultiPolygon' or 'Circle').
       * @type {string}
       */
      type: {
        type: String,
        required: true,
        validator: function validator(value) {
          return Object.values(GeometryType).includes(transformType(value));
        }
      },

      /**
       * Stop click, singleclick, and doubleclick events from firing during drawing.
       * @type {boolean}
       */
      stopClick: {
        type: Boolean,
        default: false
      },

      /**
       * The number of points that can be drawn before a polygon ring or line string is finished.
       * @type {number|undefined}
       */
      maxPoints: Number,

      /**
       * The number of points that must be drawn before a polygon ring or line string can be finished.
       * Default is `3` for polygon rings and `2` for line strings.
       * @type {number|undefined}
       */
      minPoints: Number,

      /**
       * A function that takes an ol.MapBrowserEvent and returns a boolean to indicate whether the drawing can be finished.
       * @type {function|undefined}
       */
      finishCondition: Function,

      /**
       * Function that is called when a geometry's coordinates are updated.
       * @type {function|undefined}
       */
      geometryFunction: Function,

      /**
       * Name of the geometry attribute for newly created features.
       * @type {string}
       */
      geometryName: {
        type: String,
        default: 'geometry'
      },

      /**
       * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.
       * By default `ol.events.condition.noModifierKeys`, i.e. a click, adds a vertex or deactivates freehand drawing.
       * @type {function|undefined}
       */
      condition: {
        type: Function,
        default: condition.noModifierKeys
      },

      /**
       * Operate in freehand mode for lines, polygons, and circles. This makes the interaction always operate in
       * freehand mode and takes precedence over any `freehandCondition` option.
       * @type {boolean}
       */
      freehand: {
        type: Boolean,
        default: false
      },

      /**
       * Condition that activates freehand drawing for lines and polygons. This function takes an `ol.MapBrowserEvent` and
       * returns a boolean to indicate whether that event should be handled. The default is `ol.events.condition.shiftKeyOnly`,
       * meaning that the Shift key activates freehand drawing.
       * @type {function|undefined}
       */
      freehandCondition: {
        type: Function,
        default: condition.shiftKeyOnly
      },

      /**
       * Wrap the world horizontally on the sketch overlay.
       * @type {boolean}
       */
      wrapX: {
        type: Boolean,
        default: false
      },

      /**
       * Delay in milliseconds after pointerdown before the current vertex can be dragged to its exact position.
       * @type {number}
       */
      dragVertexDelay: {
        type: Number,
        default: 500
      }
    },
    computed: {
      inputType: function inputType() {
        return transformType(this.type);
      }
    },
    watch: _objectSpread$C({}, /*#__PURE__*/makeChangeOrRecreateWatchers(['source', 'clickTolerance', 'snapTolerance', 'inputType', 'stopClick', 'maxPoints', 'minPoints', 'finishCondition', 'geometryFunction', 'geometryName', 'condition', 'freehand', 'freehandCondition', 'wrapX', 'dragVertexDelay'])),
    methods: {
      /**
       * @return {Promise<Draw>}
       * @protected
       */
      createInteraction: function createInteraction() {
        var _this = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          var source, features;
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return _this.getInstance(_this.source);

                case 2:
                  source = _this._source = _context.sent;
                  assert$1(!!source, "Source \"".concat(_this.source, "\" not found in identity map."));

                  if (!(source instanceof source$1.Vector)) {
                    if (isFunction$1(source.getFeaturesCollection)) {
                      features = source.getFeaturesCollection();
                    } else if (isFunction$1(source.getFeatures)) {
                      features = source.getFeatures();
                    }

                    instanceOf(features, ol.Collection, "Source \"".concat(_this.source, "\" doesn't provide features collection."));
                    source = null;
                  }

                  return _context.abrupt("return", new interaction$1.Draw({
                    source: source,
                    features: features,
                    clickTolerance: _this.clickTolerance,
                    snapTolerance: _this.snapTolerance,
                    type: _this.inputType,
                    stopClick: _this.stopClick,
                    maxPoints: _this.maxPoints,
                    minPoints: _this.minPoints,
                    finishCondition: _this.finishCondition,
                    geometryFunction: _this.geometryFunction,
                    geometryName: _this.geometryName,
                    condition: _this.condition,
                    freehand: _this.freehand,
                    freehandCondition: _this.freehandCondition,
                    wrapX: _this.wrapX,
                    dragVertexDelay: _this.dragVertexDelay,
                    style: _this.$style
                  }));

                case 6:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      },

      /**
       * @returns {Object}
       * @protected
       */
      getServices: function getServices() {
        return mergeDescriptors(interaction.methods.getServices.call(this), styleContainer.methods.getServices.call(this));
      },

      /**
       * @return {void}
       * @protected
       */
      subscribeAll: function subscribeAll() {
        interaction.methods.subscribeAll.call(this);
        subscribeToInteractionChanges$4.call(this);
      },

      /**
       * @return {StyleTarget}
       * @protected
       */
      getStyleTarget: function getStyleTarget() {
        var _this2 = this;

        return {
          getStyle: function getStyle() {
            return _this2._style;
          },
          setStyle: function setStyle() {

            _this2.scheduleRecreate();
          }
        };
      },
      getOverlay: function getOverlay() {
        var _this3 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.next = 2;
                  return _this3.resolveInteraction();

                case 2:
                  return _context2.abrupt("return", _context2.sent.getOverlay());

                case 3:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }))();
      },
      abortDrawing: function abortDrawing() {
        var _this4 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3() {
          return regenerator.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _context3.next = 2;
                  return _this4.resolveInteraction();

                case 2:
                  _context3.sent.abortDrawing();

                case 3:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }))();
      },
      finishDrawing: function finishDrawing() {
        var _this5 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4() {
          return regenerator.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  _context4.next = 2;
                  return _this5.resolveInteraction();

                case 2:
                  _context4.sent.finishDrawing();

                case 3:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4);
        }))();
      },
      appendCoordinates: function appendCoordinates(coordinates) {
        var _arguments = arguments,
            _this6 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee5() {
          var viewProj;
          return regenerator.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  viewProj = _arguments.length > 1 && _arguments[1] !== undefined ? _arguments[1] : false;
                  coordinates = viewProj ? roundLineCoords(coordinates) : _this6.lineToViewProj(coordinates);
                  _context5.next = 4;
                  return _this6.resolveInteraction();

                case 4:
                  _context5.sent.appendCoordinates(coordinates);

                case 5:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5);
        }))();
      },
      removeLastPoint: function removeLastPoint() {
        var _this7 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee6() {
          return regenerator.wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  _context6.next = 2;
                  return _this7.resolveInteraction();

                case 2:
                  _context6.sent.removeLastPoint();

                case 3:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6);
        }))();
      },
      getPointerCount: function getPointerCount() {
        var _this8 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee7() {
          return regenerator.wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  _context7.next = 2;
                  return _this8.resolveInteraction();

                case 2:
                  return _context7.abrupt("return", _context7.sent.getPointerCount());

                case 3:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee7);
        }))();
      }
    }
  };
  /**
   * @return {void}
   * @private
   */

  function subscribeToInteractionChanges$4() {
    var _this9 = this;

    var start = fromOlEvent(this.$interaction, 'drawstart').pipe(map(function (evt) {
      return _objectSpread$C(_objectSpread$C({}, evt), {}, {
        feature: initializeFeature(evt.feature)
      });
    }), tap(function () {
      return _this9.setInteracting(true);
    }));

    var sourceUpdObs = function sourceUpdObs() {
      var _this9$_source, _this9$_source$vm;

      if (!((_this9$_source = _this9._source) !== null && _this9$_source !== void 0 && (_this9$_source$vm = _this9$_source.vm) !== null && _this9$_source$vm !== void 0 && _this9$_source$vm.length)) {
        return of(true).pipe(delay(3 * FRAME_TIME));
      } // update:features on the source (which is feature-container)
      // will be always after drawend with delay ~= computed property update time + FRAME_TIME
      // so we can safely just wait first event


      return fromVueEvent(_this9._source.vm[0], 'update:features').pipe(first());
    };

    var end = fromOlEvent(this.$interaction, 'drawend').pipe(mergeMap(function (evt) {
      return sourceUpdObs().pipe(mapTo(evt));
    }), tap(function () {
      return _this9.setInteracting(false);
    }));
    var events = merge(start, end).pipe(map(function (_ref) {
      var type = _ref.type,
          feature = _ref.feature;
      var viewProj = _this9.resolvedViewProjection;
      var dataProj = _this9.resolvedDataProjection;
      return {
        type: type,
        feature: feature,

        get json() {
          if (!this._json) {
            this._json = writeGeoJsonFeature(this.feature, viewProj, dataProj, COORD_PRECISION);
          }

          return this._json;
        }

      };
    }));
    this.subscribeTo(events, function (evt) {
      return _this9.$emit(evt.type, evt);
    });
  }

  /* script */
  var __vue_script__$P = script$P;
  /* template */

  /* style */

  var __vue_inject_styles__$P = undefined;
  /* scoped */

  var __vue_scope_id__$P = undefined;
  /* module identifier */

  var __vue_module_identifier__$P = undefined;
  /* functional template */

  var __vue_is_functional_template__$P = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$P = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$P, __vue_script__$P, __vue_scope_id__$P, __vue_is_functional_template__$P, __vue_module_identifier__$P, false, undefined, undefined, undefined);

  function plugin$y(Vue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$y.installed) {
      return;
    }

    plugin$y.installed = true;
    options = pick(options, 'dataProjection');
    Object.assign(__vue_component__$P, options);
    Vue.component(__vue_component__$P.name, __vue_component__$P);
  }

  var DrawInteraction = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': plugin$y,
    install: plugin$y,
    Interaction: __vue_component__$P
  });

  function ownKeys$B(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$B(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$B(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$B(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var script$O = {
    name: 'VlGeomCircle',
    mixins: [simpleGeometry],
    props: {
      /* eslint-disable vue/require-prop-types */
      coordinates: _objectSpread$B(_objectSpread$B({}, simpleGeometry.props.coordinates), {}, {
        validator: isPointCoords
      }),

      /* eslint-enable vue/require-prop-types */

      /**
       * Circle radius always in meters.
       * @type {number}
       */
      radius: {
        type: Number,
        default: 0
      },

      /**
       * Projection in which radius provided.
       * Default: map data projection
       * @type {string}
       */
      radiusProjection: {
        type: String,
        validator: function validator(value) {
          return !!proj.get(value);
        }
      }
    },
    data: function data() {
      return {
        currentRadiusViewProj: this.radius
      };
    },
    computed: {
      type: /*#__PURE__*/constant(GeometryType.CIRCLE),
      resolvedRadiusProjection: function resolvedRadiusProjection() {
        return this.radiusProjection || this.resolvedDataProjection;
      },
      radiusDataProj: function radiusDataProj() {
        return round(this.radius);
      },
      radiusViewProj: function radiusViewProj() {
        return this.radiusToViewProj(this.radius, this.coordinatesDataProj);
      },
      currentRadiusDataProj: function currentRadiusDataProj() {
        return this.radiusToDataProj(this.currentRadiusViewProj);
      }
    },
    watch: {
      radiusViewProj: function radiusViewProj(value) {
        this.setRadius(value, true);
      },
      currentRadiusDataProj: function currentRadiusDataProj(value) {
        if (value === this.radiusDataProj) return;
        this.$emit('update:radius', value);
      }
    },
    created: function created() {
      this.currentRadiusViewProj = this.radiusViewProj;
    },
    methods: {
      /**
       * @return {Circle}
       * @protected
       */
      createGeometry: function createGeometry() {
        return new geom.Circle(this.currentCoordinatesViewProj, this.currentRadiusViewProj);
      },

      /**
       * @param {boolean} [viewProj=false]
       * @return {number[]}
       */
      getCoordinates: function getCoordinates() {
        var viewProj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        return this.getCenter(viewProj);
      },

      /**
       * @param {number[]} coordinate
       * @param {boolean} [viewProj=false]
       */
      setCoordinates: function setCoordinates(coordinate) {
        var viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        this.setCenter(coordinate, viewProj);
      },

      /**
       * @param {boolean} [viewProj=false]
       * @return {number[]}
       */
      getCenter: function getCenter() {
        var _this$$geometry;

        var viewProj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        var center = coalesce((_this$$geometry = this.$geometry) === null || _this$$geometry === void 0 ? void 0 : _this$$geometry.getCenter(), this.currentCoordinatesViewProj);
        return viewProj ? roundPointCoords(center) : this.pointToDataProj(center);
      },

      /**
       * @param {number[]} center
       * @param {boolean} [viewProj=false]
       */
      setCenter: function setCenter(center) {
        var viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        assert$1(isPointCoords(center), 'Invalid center');
        center = viewProj ? roundPointCoords(center) : this.pointToViewProj(center);

        if (!isEqual(center, this.currentCoordinatesViewProj)) {
          this.currentCoordinatesViewProj = center;
        }

        if (this.$geometry && !isEqual(center, this.$geometry.getCenter())) {
          this.$geometry.setCenter(center);
        }
      },

      /**
       * @param {boolean} [viewProj=false]
       * @return {number}
       */
      getRadius: function getRadius() {
        var _this$$geometry2;

        var viewProj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        var radius = coalesce((_this$$geometry2 = this.$geometry) === null || _this$$geometry2 === void 0 ? void 0 : _this$$geometry2.getRadius(), this.currentRadiusViewProj);
        return viewProj ? round(radius) : this.radiusToDataProj(radius);
      },

      /**
       * @param {number} radius
       * @param {boolean} [viewProj=false]
       */
      setRadius: function setRadius(radius) {
        var viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        assert$1(isNumber$1(radius), 'Invalid radius');
        radius = viewProj ? round(radius) : this.radiusToDataProj(radius);

        if (radius !== this.currentRadiusViewProj) {
          this.currentRadiusViewProj = radius;
        }

        if (this.$geometry && radius !== this.$geometry.getRadius()) {
          this.$geometry.setRadius(radius);
        }
      },

      /**
       * @param {number[]} center
       * @param {number} radius
       * @param {boolean} [viewProj=false]
       * @return {Promise<void>}
       */
      setCenterAndRadius: function setCenterAndRadius(center, radius) {
        var viewProj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        center = viewProj ? roundPointCoords(center) : this.pointToViewProj(center);
        radius = viewProj ? round(radius) : this.radiusToViewProj(radius);

        if (this.$geometry) {
          this.$geometry.setCenterAndRadius(center, radius);
        } else {
          this.setCenter(center, true);
          this.setRadius(radius, true);
        }
      },

      /**
       * @param {number} radius
       * @return {undefined|number}
       * @protected
       */
      radiusToViewProj: function radiusToViewProj(radius) {
        return transformDistance(radius, this.resolvedRadiusProjection, this.resolvedViewProjection);
      },

      /**
       * @param {number} radius
       * @return {undefined|number}
       * @protected
       */
      radiusToDataProj: function radiusToDataProj(radius) {
        return transformDistance(radius, this.resolvedViewProjection, this.resolvedRadiusProjection);
      }
    }
  };

  /* script */
  var __vue_script__$O = script$O;
  /* template */

  /* style */

  var __vue_inject_styles__$O = undefined;
  /* scoped */

  var __vue_scope_id__$O = undefined;
  /* module identifier */

  var __vue_module_identifier__$O = undefined;
  /* functional template */

  var __vue_is_functional_template__$O = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$O = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$O, __vue_script__$O, __vue_scope_id__$O, __vue_is_functional_template__$O, __vue_module_identifier__$O, false, undefined, undefined, undefined);

  function ownKeys$A(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$A(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$A(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$A(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var script$N = {
    name: 'VlGeomPoint',
    mixins: [simpleGeometry],
    props: {
      /* eslint-disable vue/require-prop-types */
      coordinates: _objectSpread$A(_objectSpread$A({}, simpleGeometry.props.coordinates), {}, {
        validator: isPointCoords
      })
      /* eslint-enable vue/require-prop-types */

    },
    computed: {
      type: /*#__PURE__*/constant(GeometryType.POINT)
    },
    methods: {
      /**
       * @return {Point}
       * @protected
       */
      createGeometry: function createGeometry() {
        return new geom.Point(this.currentCoordinatesViewProj);
      },

      /**
       * @param {number[]} coordinates
       * @param {boolean} [viewProj=false]
       */
      setCoordinates: function setCoordinates(coordinates) {
        var viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        assert$1(isPointCoords(coordinates), 'Invalid coordinates');
        simpleGeometry.methods.setCoordinates.call(this, coordinates, viewProj);
      }
    }
  };

  /* script */
  var __vue_script__$N = script$N;
  /* template */

  /* style */

  var __vue_inject_styles__$N = undefined;
  /* scoped */

  var __vue_scope_id__$N = undefined;
  /* module identifier */

  var __vue_module_identifier__$N = undefined;
  /* functional template */

  var __vue_is_functional_template__$N = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$N = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$N, __vue_script__$N, __vue_scope_id__$N, __vue_is_functional_template__$N, __vue_module_identifier__$N, false, undefined, undefined, undefined);

  //
  /**
   * A vector object for geographic features with a geometry and other attribute properties,
   * similar to the features in vector file formats like **GeoJSON**.
   */

  var script$M = {
    name: 'VlFeature',
    components: {
      PointGeom: __vue_component__$N
    },
    mixins: [feature]
  };

  /* script */
  var __vue_script__$M = script$M;
  /* template */

  var __vue_render__$9 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('i', {
      class: _vm.vmClass,
      staticStyle: {
        "display": "none !important"
      },
      attrs: {
        "id": _vm.vmId
      }
    }, [_vm._t("default", [_c('PointGeom', {
      attrs: {
        "id": 'vl-' + _vm.currentId + '-default-geom',
        "coordinates": [0, 0]
      }
    })], {
      "id": _vm.currentId,
      "properties": _vm.currentProperties
    })], 2);
  };

  var __vue_staticRenderFns__$9 = [];
  /* style */

  var __vue_inject_styles__$M = undefined;
  /* scoped */

  var __vue_scope_id__$M = undefined;
  /* module identifier */

  var __vue_module_identifier__$M = undefined;
  /* functional template */

  var __vue_is_functional_template__$M = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$M = /*#__PURE__*/normalizeComponent({
    render: __vue_render__$9,
    staticRenderFns: __vue_staticRenderFns__$9
  }, __vue_inject_styles__$M, __vue_script__$M, __vue_scope_id__$M, __vue_is_functional_template__$M, __vue_module_identifier__$M, false, undefined, undefined, undefined);

  function ownKeys$z(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$z(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$z(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$z(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var script$L = {
    name: 'VlGeomLineString',
    mixins: [simpleGeometry],
    props: {
      /* eslint-disable vue/require-prop-types */
      coordinates: _objectSpread$z(_objectSpread$z({}, simpleGeometry.props.coordinates), {}, {
        validator: isLineCoords
      })
      /* eslint-enable vue/require-prop-types */

    },
    computed: {
      type: /*#__PURE__*/constant(GeometryType.LINE_STRING)
    },
    methods: {
      /**
       * @returns {LineString}
       * @protected
       */
      createGeometry: function createGeometry() {
        return new geom.LineString(this.currentCoordinatesViewProj);
      },

      /**
       * @param {number[]} coordinates
       * @param {boolean} [viewProj=false]
       */
      setCoordinates: function setCoordinates(coordinates) {
        var viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        assert$1(isLineCoords(coordinates), 'Invalid coordinates');
        simpleGeometry.methods.setCoordinates.call(this, coordinates, viewProj);
      }
    }
  };

  /* script */
  var __vue_script__$L = script$L;
  /* template */

  /* style */

  var __vue_inject_styles__$L = undefined;
  /* scoped */

  var __vue_scope_id__$L = undefined;
  /* module identifier */

  var __vue_module_identifier__$L = undefined;
  /* functional template */

  var __vue_is_functional_template__$L = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$L = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$L, __vue_script__$L, __vue_scope_id__$L, __vue_is_functional_template__$L, __vue_module_identifier__$L, false, undefined, undefined, undefined);

  function ownKeys$y(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$y(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$y(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$y(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var script$K = {
    name: 'VlGeomMultiLineString',
    mixins: [simpleGeometry],
    props: {
      /* eslint-disable vue/require-prop-types */
      coordinates: _objectSpread$y(_objectSpread$y({}, simpleGeometry.props.coordinates), {}, {
        validator: isMultiLineCoords
      })
      /* eslint-enable vue/require-prop-types */

    },
    computed: {
      type: /*#__PURE__*/constant(GeometryType.MULTI_LINE_STRING)
    },
    methods: {
      /**
       * @returns {MultiLineString}
       * @protected
       */
      createGeometry: function createGeometry() {
        return new geom.MultiLineString(this.currentCoordinatesViewProj);
      },

      /**
       * @param {number[]} coordinates
       * @param {boolean} [viewProj=false]
       */
      setCoordinates: function setCoordinates(coordinates) {
        var viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        assert$1(isMultiLineCoords(coordinates), 'Invalid coordinates');
        simpleGeometry.methods.setCoordinates.call(this, coordinates, viewProj);
      }
    }
  };

  /* script */
  var __vue_script__$K = script$K;
  /* template */

  /* style */

  var __vue_inject_styles__$K = undefined;
  /* scoped */

  var __vue_scope_id__$K = undefined;
  /* module identifier */

  var __vue_module_identifier__$K = undefined;
  /* functional template */

  var __vue_is_functional_template__$K = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$K = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$K, __vue_script__$K, __vue_scope_id__$K, __vue_is_functional_template__$K, __vue_module_identifier__$K, false, undefined, undefined, undefined);

  function ownKeys$x(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$x(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$x(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$x(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var script$J = {
    name: 'VlGeomMultiPoint',
    mixins: [simpleGeometry],
    props: {
      /* eslint-disable vue/require-prop-types */
      coordinates: _objectSpread$x(_objectSpread$x({}, simpleGeometry.props.coordinates), {}, {
        validator: isMultiPointCoords
      })
      /* eslint-enable vue/require-prop-types */

    },
    computed: {
      type: /*#__PURE__*/constant(GeometryType.MULTI_POINT)
    },
    methods: {
      /**
       * @returns {MultiPoint}
       * @protected
       */
      createGeometry: function createGeometry() {
        return new geom.MultiPoint(this.currentCoordinatesViewProj);
      },

      /**
       * @param {number[]} coordinates
       * @param {boolean} [viewProj=false]
       */
      setCoordinates: function setCoordinates(coordinates) {
        var viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        assert$1(isMultiPointCoords(coordinates), 'Invalid coordinates');
        simpleGeometry.methods.setCoordinates.call(this, coordinates, viewProj);
      }
    }
  };

  /* script */
  var __vue_script__$J = script$J;
  /* template */

  /* style */

  var __vue_inject_styles__$J = undefined;
  /* scoped */

  var __vue_scope_id__$J = undefined;
  /* module identifier */

  var __vue_module_identifier__$J = undefined;
  /* functional template */

  var __vue_is_functional_template__$J = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$J = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$J, __vue_script__$J, __vue_scope_id__$J, __vue_is_functional_template__$J, __vue_module_identifier__$J, false, undefined, undefined, undefined);

  function ownKeys$w(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$w(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$w(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$w(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var script$I = {
    name: 'VlGeomMultiPolygon',
    mixins: [simpleGeometry],
    props: {
      /* eslint-disable vue/require-prop-types */
      coordinates: _objectSpread$w(_objectSpread$w({}, simpleGeometry.props.coordinates), {}, {
        validator: isMultiPolygonCoords
      })
      /* eslint-enable vue/require-prop-types */

    },
    computed: {
      type: /*#__PURE__*/constant(GeometryType.MULTI_POLYGON)
    },
    methods: {
      /**
       * @returns {MultiPolygon}
       * @protected
       */
      createGeometry: function createGeometry() {
        return new geom.MultiPolygon(this.currentCoordinatesViewProj);
      },

      /**
       * @param {number[]} coordinates
       * @param {boolean} [viewProj=false]
       */
      setCoordinates: function setCoordinates(coordinates) {
        var viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        assert$1(isMultiPolygonCoords(coordinates), 'Invalid coordinates');
        simpleGeometry.methods.setCoordinates.call(this, coordinates, viewProj);
      }
    }
  };

  /* script */
  var __vue_script__$I = script$I;
  /* template */

  /* style */

  var __vue_inject_styles__$I = undefined;
  /* scoped */

  var __vue_scope_id__$I = undefined;
  /* module identifier */

  var __vue_module_identifier__$I = undefined;
  /* functional template */

  var __vue_is_functional_template__$I = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$I = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$I, __vue_script__$I, __vue_scope_id__$I, __vue_is_functional_template__$I, __vue_module_identifier__$I, false, undefined, undefined, undefined);

  function ownKeys$v(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$v(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$v(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$v(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var script$H = {
    name: 'VlGeomPolygon',
    mixins: [simpleGeometry],
    props: {
      /* eslint-disable vue/require-prop-types */
      coordinates: _objectSpread$v(_objectSpread$v({}, simpleGeometry.props.coordinates), {}, {
        validator: isPolygonCoords
      })
      /* eslint-enable vue/require-prop-types */

    },
    computed: {
      type: /*#__PURE__*/constant(GeometryType.POLYGON)
    },
    methods: {
      /**
       * @returns {Polygon}
       * @protected
       */
      createGeometry: function createGeometry() {
        return new geom.Polygon(this.currentCoordinatesViewProj);
      },

      /**
       * @param {number[]} coordinates
       * @param {boolean} [viewProj=false]
       */
      setCoordinates: function setCoordinates(coordinates) {
        var viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        assert$1(isPolygonCoords(coordinates), 'Invalid coordinates');
        simpleGeometry.methods.setCoordinates.call(this, coordinates, viewProj);
      }
    }
  };

  /* script */
  var __vue_script__$H = script$H;
  /* template */

  /* style */

  var __vue_inject_styles__$H = undefined;
  /* scoped */

  var __vue_scope_id__$H = undefined;
  /* module identifier */

  var __vue_module_identifier__$H = undefined;
  /* functional template */

  var __vue_is_functional_template__$H = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$H = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$H, __vue_script__$H, __vue_scope_id__$H, __vue_is_functional_template__$H, __vue_module_identifier__$H, false, undefined, undefined, undefined);

  function plugin$x(Vue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$x.installed) {
      return;
    }

    plugin$x.installed = true;
    options = pick(options, 'dataProjection');
    Object.assign(__vue_component__$M, options);
    Object.assign(__vue_component__$O, options);
    Object.assign(__vue_component__$N, options);
    Object.assign(__vue_component__$L, options);
    Object.assign(__vue_component__$H, options);
    Object.assign(__vue_component__$J, options);
    Object.assign(__vue_component__$K, options);
    Object.assign(__vue_component__$I, options);
    Vue.component(__vue_component__$M.name, __vue_component__$M);
    Vue.component(__vue_component__$O.name, __vue_component__$O);
    Vue.component(__vue_component__$N.name, __vue_component__$N);
    Vue.component(__vue_component__$L.name, __vue_component__$L);
    Vue.component(__vue_component__$H.name, __vue_component__$H);
    Vue.component(__vue_component__$J.name, __vue_component__$J);
    Vue.component(__vue_component__$K.name, __vue_component__$K);
    Vue.component(__vue_component__$I.name, __vue_component__$I);
  }

  var Feature = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': plugin$x,
    install: plugin$x,
    Feature: __vue_component__$M,
    CircleGeom: __vue_component__$O,
    PointGeom: __vue_component__$N,
    LineStringGeom: __vue_component__$L,
    PolygonGeom: __vue_component__$H,
    MultiPointGeom: __vue_component__$J,
    MultiLineStringGeom: __vue_component__$K,
    MultiPolygonGeom: __vue_component__$I
  });

  function ownKeys$u(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$u(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$u(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$u(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var validateProjection = /*#__PURE__*/and(isString, function (value) {
    return proj.get(value) != null;
  });
  var script$G = {
    name: 'VlGeoloc',
    mixins: [projTransforms, olCmp, waitForMap],
    stubVNode: {
      empty: function empty() {
        return this.vmId;
      }
    },
    props: {
      tracking: {
        type: Boolean,
        default: true
      },
      trackingOptions: Object,
      projection: {
        type: String,
        validator: validateProjection
      }
    },
    data: function data() {
      return {
        viewProjection: EPSG_3857,
        dataProjection: EPSG_3857,
        currentTracking: this.tracking,
        currentTrackingOptions: this.trackingOptions && clonePlainObject(this.trackingOptions),
        currentProjection: this.projection
      };
    },
    computed: {
      resolvedDataProjection: function resolvedDataProjection() {
        var _this$$options;

        return coalesce(this.currentProjection, (_this$$options = this.$options) === null || _this$$options === void 0 ? void 0 : _this$$options.dataProjection, this.dataProjection, this.resolvedViewProjection);
      },
      accuracy: function accuracy() {
        return this.rev ? this.getAccuracy() : undefined;
      },
      accuracyGeometryDataProj: function accuracyGeometryDataProj() {
        return this.rev ? this.writeGeometryInDataProj(this.getAccuracyGeometry()) : undefined;
      },
      accuracyGeometryViewProj: function accuracyGeometryViewProj() {
        return this.rev ? this.writeGeometryInViewProj(this.getAccuracyGeometry()) : undefined;
      },
      altitude: function altitude() {
        return this.rev ? this.getAltitude() : undefined;
      },
      altitudeAccuracy: function altitudeAccuracy() {
        return this.rev ? this.getAltitudeAccuracy() : undefined;
      },
      heading: function heading() {
        return this.rev ? this.getHeading() : undefined;
      },
      speed: function speed() {
        return this.rev ? this.getSpeed() : undefined;
      },
      positionDataProj: function positionDataProj() {
        return this.rev ? this.getPosition() : undefined;
      },
      positionViewProj: function positionViewProj() {
        return this.rev ? this.pointToViewProj(this.getPosition()) : undefined;
      }
    },
    watch: {
      rev: function rev() {
        if (!this.$geolocation) return;

        if (this.currentTracking !== this.$geolocation.getTracking()) {
          this.currentTracking = this.$geolocation.getTracking();
        }

        if (!isEqual(this.currentTrackingOptions, this.$geolocation.getTrackingOptions())) {
          this.currentTrackingOptions = this.$geolocation.getTrackingOptions();
        }

        if (this.currentProjection !== this.$geolocation.getProjection().getCode()) {
          this.currentProjection = this.$geolocation.getProjection().getCode();
        }
      },
      tracking: function tracking(value) {
        this.setTracking(value);
      },
      currentTracking: function currentTracking(value) {
        if (value === this.tracking) return;
        this.$emit('update:tracking', value);
      },
      tracingOptions: {
        deep: true,
        handler: function handler(value) {
          this.setTrackingOptions(value);
        }
      },
      currentTrackingOptions: {
        deep: true,
        handler: function handler(value) {
          if (isEqual(value, this.trackingOptions)) return;
          this.$emit('update:tracingOptions', value && clonePlainObject(value));
        }
      },
      projection: function projection(value) {
        this.setProjection(value);
      },
      currentProjection: function currentProjection(value) {
        if (value === this.projection) return;
        this.$emit('update:projection', value);
      },
      accuracy: function accuracy(value, prev) {
        if (value === prev) return;
        this.$emit('update:accuracy', value);
      },
      accuracyGeometryDataProj: function accuracyGeometryDataProj(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit('update:accuracyGeometry', value);
      },
      currentAltitude: function currentAltitude(value, prev) {
        if (value === prev) return;
        this.$emit('update:altitude', value);
      },
      altitudeAccuracy: function altitudeAccuracy(value, prev) {
        if (value === prev) return;
        this.$emit('update:altitudeAccuracy', value);
      },
      heading: function heading(value, prev) {
        if (value === prev) return;
        this.$emit('update:heading', value);
      },
      speed: function speed(value, prev) {
        if (value === prev) return;
        this.$emit('update:speed', value);
      },
      positionDataProj: function positionDataProj(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit('update:position', value);
      }
    },
    created: function created() {
      defineServices$8.call(this);
    },
    methods: {
      /**
       * @return {Promise<void>}
       * @protected
       */
      beforeInit: function beforeInit() {
        var _this = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return Promise.all([olCmp.methods.beforeInit.call(_this), waitForMap.methods.beforeInit.call(_this)]);

                case 2:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      },

      /**
       * @return {module:ol/Geolocation~Geolocation}
       * @private
       */
      createOlObject: function createOlObject() {
        var geoloc = new ol.Geolocation({
          tracking: this.currentTracking,
          trackingOptions: this.currentTrackingOptions,
          projection: this.resolvedDataProjection
        });
        geoloc.set('id', this.currentId);
        return geoloc;
      },

      /**
       * @return {Promise<void>}
       * @protected
       */
      mount: function mount() {
        this.setTracking(this.tracking);
        return olCmp.methods.mount.call(this);
      },

      /**
       * @return {Promise<void>}
       * @protected
       */
      unmount: function unmount() {
        this.setTracking(false);
        return olCmp.methods.unmount.call(this);
      },

      /**
       * @protected
       */
      subscribeAll: function subscribeAll() {
        olCmp.methods.subscribeAll.call(this);
        subscribeToGeolocation.call(this);
      },
      resolveGeolocation: olCmp.methods.resolveOlObject,

      /**
       * @return {number|string}
       */
      getIdInternal: function getIdInternal() {
        return this.$geolocation.get('id');
      },

      /**
       * @param {string|number} id
       * @return {void}
       */
      setIdInternal: function setIdInternal(id) {
        if (id === this.getIdInternal()) return;
        this.$geolocation.set('id', id);
      },

      /**
       * @return {number|undefined}
       */
      getAccuracy: function getAccuracy() {
        var _this$$geolocation;

        return (_this$$geolocation = this.$geolocation) === null || _this$$geolocation === void 0 ? void 0 : _this$$geolocation.getAccuracy();
      },

      /**
       * @return {module:/ol/geom/Geometry~Geometry|undefined}
       */
      getAccuracyGeometry: function getAccuracyGeometry() {
        var _this$$geolocation2;

        return (_this$$geolocation2 = this.$geolocation) === null || _this$$geolocation2 === void 0 ? void 0 : _this$$geolocation2.getAccuracyGeometry();
      },

      /**
       * @return {number|undefined}
       */
      getAltitude: function getAltitude() {
        var _this$$geolocation3;

        return (_this$$geolocation3 = this.$geolocation) === null || _this$$geolocation3 === void 0 ? void 0 : _this$$geolocation3.getAltitude();
      },

      /**
       * @return {number|undefined}
       */
      getAltitudeAccuracy: function getAltitudeAccuracy() {
        var _this$$geolocation4;

        return (_this$$geolocation4 = this.$geolocation) === null || _this$$geolocation4 === void 0 ? void 0 : _this$$geolocation4.getAltitudeAccuracy();
      },

      /**
       * @return {number|undefined}
       */
      getHeading: function getHeading() {
        var _this$$geolocation5;

        return (_this$$geolocation5 = this.$geolocation) === null || _this$$geolocation5 === void 0 ? void 0 : _this$$geolocation5.getHeading();
      },

      /**
       * @return {number[]|undefined}
       */
      getPosition: function getPosition() {
        var _this$$geolocation6;

        return (_this$$geolocation6 = this.$geolocation) === null || _this$$geolocation6 === void 0 ? void 0 : _this$$geolocation6.getPosition();
      },

      /**
       * @return {module:ol/proj~ProjectionLike|undefined}
       */
      getProjection: function getProjection() {
        var _this$$geolocation7;

        return coalesce((_this$$geolocation7 = this.$geolocation) === null || _this$$geolocation7 === void 0 ? void 0 : _this$$geolocation7.getProjection(), this.currentProjection);
      },

      /**
       * @param {module:ol/proj~ProjectionLike} projection
       */
      setProjection: function setProjection(projection) {
        assert$1(validateProjection(projection), 'Invalid projection');
        projection = proj.get(projection);

        if (projection.getCode() !== this.currentProjection) {
          this.currentProjection = projection.getCode();
        }

        if (this.$geolocation && projection !== this.$geolocation.getProjection()) {
          this.$geolocation.setProjection(projection);
        }
      },

      /**
       * @return {number|undefined}
       */
      getSpeed: function getSpeed() {
        var _this$$geolocation8;

        return (_this$$geolocation8 = this.$geolocation) === null || _this$$geolocation8 === void 0 ? void 0 : _this$$geolocation8.getSpeed();
      },

      /**
       * @return {boolean}
       */
      getTracking: function getTracking() {
        var _this$$geolocation9;

        return coalesce((_this$$geolocation9 = this.$geolocation) === null || _this$$geolocation9 === void 0 ? void 0 : _this$$geolocation9.getTracking(), this.currentTracking);
      },

      /**
       * @param {boolean} tracking
       */
      setTracking: function setTracking(tracking) {
        if (tracking !== this.currentTracking) {
          this.currentTracking = tracking;
        }

        if (this.$geolocation && tracking !== this.$geolocation.getTracking()) {
          this.$geolocation.setTracking(tracking);
        }
      },

      /**
       * @return {Object|undefined}
       */
      getTrackingOptions: function getTrackingOptions() {
        var _this$$geolocation10;

        return coalesce((_this$$geolocation10 = this.$geolocation) === null || _this$$geolocation10 === void 0 ? void 0 : _this$$geolocation10.getTrackingOptions(), this.currentTrackingOptions);
      },

      /**
       * @param {Promise<Object|undefined>} options
       */
      setTrackingOptions: function setTrackingOptions(options) {
        if (!isEqual(options, this.currentTrackingOptions)) {
          this.currentTrackingOptions = options;
        }

        if (this.$geolocation && !isEqual(options, this.$geolocation.getTrackingOptions())) {
          this.$geolocation.setTrackingOptions(options);
        }
      }
    }
  };

  function defineServices$8() {
    var _this2 = this;

    Object.defineProperties(this, {
      $geolocation: {
        enumerable: true,
        get: function get() {
          return _this2.$olObject;
        }
      },
      $mapVm: {
        enumerable: true,
        get: function get() {
          var _this2$$services;

          return (_this2$$services = _this2.$services) === null || _this2$$services === void 0 ? void 0 : _this2$$services.mapVm;
        }
      },
      $viewVm: {
        enumerable: true,
        get: function get() {
          var _this2$$services2;

          return (_this2$$services2 = _this2.$services) === null || _this2$$services2 === void 0 ? void 0 : _this2$$services2.viewVm;
        }
      }
    });
  }
  /**
   * @return {void}
   * @private
   */


  function subscribeToGeolocation() {
    var _this3 = this;

    var setterKey = addPrefix('set');
    var setPropsChanges = merge(fromOlChangeEvent(this.$geolocation, 'projection', true, function (evt) {
      return _objectSpread$u(_objectSpread$u({}, evt), {}, {
        value: proj.get(evt.value).getCode()
      });
    }), fromOlChangeEvent(this.$geolocation, ['tracking', 'trackingOptions'], true)).pipe(map(function (evt) {
      return _objectSpread$u(_objectSpread$u({}, evt), {}, {
        setter: function setter(val) {
          _this3[setterKey(evt.prop)](val);

          _this3.scheduleRefresh();
        }
      });
    }));
    this.subscribeTo(setPropsChanges, function (_ref) {
      var setter = _ref.setter,
          value = _ref.value;
      return setter(value);
    });
    var otherChanged = fromOlChangeEvent(this.$geolocation, ['accuracy', 'accuracyGeometry', 'altitude', 'altitudeAccuracy', 'heading', 'speed', 'position'], true);
    this.subscribeTo(otherChanged, this.scheduleRefresh.bind(this));
  }

  /* script */
  var __vue_script__$G = script$G;
  /* template */

  var __vue_render__$8 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('i', {
      class: _vm.vmClass,
      staticStyle: {
        "display": "none !important"
      },
      attrs: {
        "id": _vm.vmId
      }
    }, [_vm._t("default", null, {
      "accuracy": _vm.accuracy,
      "accuracyGeometry": _vm.accuracyGeometryDataProj,
      "altitude": _vm.altitude,
      "altitudeAccuracy": _vm.altitudeAccuracy,
      "heading": _vm.heading,
      "position": _vm.positionDataProj,
      "speed": _vm.speed
    })], 2);
  };

  var __vue_staticRenderFns__$8 = [];
  /* style */

  var __vue_inject_styles__$G = undefined;
  /* scoped */

  var __vue_scope_id__$G = undefined;
  /* module identifier */

  var __vue_module_identifier__$G = undefined;
  /* functional template */

  var __vue_is_functional_template__$G = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$G = /*#__PURE__*/normalizeComponent({
    render: __vue_render__$8,
    staticRenderFns: __vue_staticRenderFns__$8
  }, __vue_inject_styles__$G, __vue_script__$G, __vue_scope_id__$G, __vue_is_functional_template__$G, __vue_module_identifier__$G, false, undefined, undefined, undefined);

  function plugin$w(Vue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$w.installed) {
      return;
    }

    plugin$w.installed = true;
    options = pick(options, 'dataProjection');
    Object.assign(__vue_component__$G, options);
    Vue.component(__vue_component__$G.name, __vue_component__$G);
  }

  var Geoloc = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': plugin$w,
    install: plugin$w,
    Geoloc: __vue_component__$G
  });

  var script$F = {
    name: 'VlStyleFill',
    mixins: [style],
    props: {
      color: {
        type: [String, Array],
        default: function _default() {
          return [255, 255, 255, 0.4];
        }
      }
    },
    data: function data() {
      return {
        currentColor: normalizeColor(this.color)
      };
    },
    computed: {
      inputColor: function inputColor() {
        return normalizeColor(this.color);
      }
    },
    watch: {
      rev: function rev() {
        if (!this.$style) return;
        this.setColor(this.getColor());
      },
      inputColor: {
        deep: true,
        handler: function handler(value) {
          this.setColor(value);
        }
      },
      currentColor: {
        deep: true,
        handler: function handler(value) {
          if (isEqual(value, this.inputColor)) return;
          this.$emit('update:color', value === null || value === void 0 ? void 0 : value.slice());
        }
      }
    },
    created: function created() {
      defineServices$7.call(this);
    },
    methods: {
      /**
       * @return {FillStyle}
       * @protected
       */
      createStyle: function createStyle() {
        return new style$1.Fill({
          color: this.currentColor
        });
      },

      /**
       * @return {Promise<void>}
       * @protected
       */
      mount: function mount() {
        var _this = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          var _this$$fillStyleConta;

          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  (_this$$fillStyleConta = _this.$fillStyleContainer) === null || _this$$fillStyleConta === void 0 ? void 0 : _this$$fillStyleConta.setFill(_this);
                  return _context.abrupt("return", style.methods.mount.call(_this));

                case 2:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      },

      /**
       * @return {Promise<void>}
       * @protected
       */
      unmount: function unmount() {
        var _this2 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
          var _this2$$fillStyleCont;

          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  if (((_this2$$fillStyleCont = _this2.$fillStyleContainer) === null || _this2$$fillStyleCont === void 0 ? void 0 : _this2$$fillStyleCont.getFillVm()) === _this2) {
                    _this2.$fillStyleContainer.setFill(null);
                  }

                  return _context2.abrupt("return", style.methods.unmount.call(_this2));

                case 2:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }))();
      },

      /**
       * @return {Promise<void>}
       */
      refresh: function refresh() {
        var _this3 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3() {
          var _this3$$fillStyleCont;

          return regenerator.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _context3.next = 2;
                  return Promise.all([style.methods.refresh.call(_this3), (_this3$$fillStyleCont = _this3.$fillStyleContainer) === null || _this3$$fillStyleCont === void 0 ? void 0 : _this3$$fillStyleCont.refresh()]);

                case 2:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }))();
      },

      /**
       * @protected
       */
      syncNonObservable: function syncNonObservable() {
        style.methods.syncNonObservable.call(this);
        this.setColor(this.getColor());
      },
      getColor: function getColor() {
        var _this$$style;

        return normalizeColor(coalesce((_this$$style = this.$style) === null || _this$$style === void 0 ? void 0 : _this$$style.getColor(), this.currentColor));
      },
      setColor: function setColor(color) {
        color = normalizeColor(color);

        if (!isEqual(color, this.currentColor)) {
          this.currentColor = color;
          this.scheduleRefresh();
        }

        if (this.$style && !isEqual(color, this.$style.getColor())) {
          this.$style.setColor(color);
          this.scheduleRefresh();
        }
      }
    }
  };

  function defineServices$7() {
    var _this4 = this;

    Object.defineProperties(this, {
      $fillStyleContainer: {
        enumerable: true,
        get: function get() {
          var _this4$$services;

          return (_this4$$services = _this4.$services) === null || _this4$$services === void 0 ? void 0 : _this4$$services.fillStyleContainer;
        }
      }
    });
  }

  /* script */
  var __vue_script__$F = script$F;
  /* template */

  /* style */

  var __vue_inject_styles__$F = undefined;
  /* scoped */

  var __vue_scope_id__$F = undefined;
  /* module identifier */

  var __vue_module_identifier__$F = undefined;
  /* functional template */

  var __vue_is_functional_template__$F = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$F = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$F, __vue_script__$F, __vue_scope_id__$F, __vue_is_functional_template__$F, __vue_module_identifier__$F, false, undefined, undefined, undefined);

  function ownKeys$t(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$t(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$t(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$t(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var script$E = {
    name: 'VlStyleStroke',
    mixins: [style],
    props: {
      color: {
        type: [Array, String],
        default: '#3399cc'
      },
      lineCap: {
        type: String,
        default: 'round' // round, butt, square

      },
      lineJoin: {
        type: String,
        default: 'round' // round, bevel, miter

      },
      lineDash: Array,
      lineDashOffset: {
        type: Number,
        default: 0
      },
      miterLimit: {
        type: Number,
        default: 10
      },
      width: {
        type: Number,
        default: 1.25
      }
    },
    data: function data() {
      var _this$lineDash;

      return {
        currentColor: normalizeColor(this.color),
        currentLineCap: this.lineCap,
        currentLineJoin: this.lineJoin,
        currentLineDash: (_this$lineDash = this.lineDash) === null || _this$lineDash === void 0 ? void 0 : _this$lineDash.slice(),
        currentLineDashOffset: this.lineDashOffset,
        currentMiterLimit: this.miterLimit,
        currentWidth: this.width
      };
    },
    computed: {
      inputColor: function inputColor() {
        return normalizeColor(this.color);
      },
      inputLineDash: function inputLineDash() {
        var _this$lineDash2;

        return (_this$lineDash2 = this.lineDash) === null || _this$lineDash2 === void 0 ? void 0 : _this$lineDash2.slice();
      }
    },
    watch: _objectSpread$t(_objectSpread$t(_objectSpread$t({
      rev: function rev() {
        if (!this.$style) return;
        this.setColor(this.getColor());
        this.setLineCap(this.getLineCap());
        this.setLineJoin(this.getLineJoin());
        this.setLineDash(this.getLineDash());
        this.setLineDashOffset(this.getLineDashOffset());
        this.setMiterLimit(this.getMiterLimit());
        this.setWidth(this.getWidth());
      }
    }, /*#__PURE__*/makeWatchers(['inputColor', 'lineCap', 'lineJoin', 'inputLineDash', 'lineDashOffset', 'miterLimit', 'width'], function (inProp) {
      var prop = inProp.slice(0, 5) === 'input' ? lowerFirst(inProp.slice(5)) : inProp;
      var setter = 'set' + upperFirst(prop);
      return {
        deep: ['inputColor', 'inputLineDash'].includes(inProp),
        handler: function handler(value) {
          this[setter](value);
        }
      };
    })), /*#__PURE__*/makeWatchers(['currentColor', 'currentLineCap', 'currentLineJoin', 'currentLineDash', 'currentLineDashOffset', 'currentMiterLimit', 'currentWidth'], function (curProp) {
      var prop = curProp.slice(0, 7) === 'current' ? lowerFirst(curProp.slice(7)) : curProp;
      var inProp = 'input' + upperFirst(prop);
      return {
        deep: ['currentColor', 'currentLineDash'].includes(curProp),
        handler: function handler(value) {
          if (isEqual(value, coalesce(this[inProp], this[prop]))) return;
          this.$emit("update:".concat(prop), isObjectLike(value) ? clonePlainObject(value) : value);
        }
      };
    })), {}, {
      inputColor: {
        deep: true,
        handler: function handler(value) {
          this.setColor(value);
        }
      },
      currentColor: {
        deep: true,
        handler: function handler(value) {
          if (isEqual(value, this.inputColor)) return;
          this.$emit('update:color', value === null || value === void 0 ? void 0 : value.slice());
        }
      },
      lineCap: function lineCap(value) {
        this.setLineCap(value);
      },
      currentLineCap: function currentLineCap(value) {
        if (value === this.lineCap) return;
        this.$emit('update:lineCap', value);
      },
      lineJoin: function lineJoin(value) {
        this.setLineJoin(value);
      },
      currentLineJoin: function currentLineJoin(value) {
        if (value === this.lineJoin) return;
        this.$emit('update:lineJoin', value);
      },
      inputLineDash: {
        deep: true,
        handler: function handler(value) {
          this.setLineDash(value);
        }
      },
      currentLineDash: {
        deep: true,
        handler: function handler(value) {
          if (isEqual(value, this.currentLineDash)) return;
          this.$emit('update:lineDash', value === null || value === void 0 ? void 0 : value.slice());
        }
      },
      lineDashOffset: function lineDashOffset(value) {
        this.setLineDashOffset(value);
      },
      currentLineDashOffset: function currentLineDashOffset(value) {
        if (value === this.lineDashOffset) return;
        this.$emit('update:lineDashOffset', value);
      },
      miterLimit: function miterLimit(value) {
        this.setMiterLimit(value);
      },
      currentMiterLimit: function currentMiterLimit(value) {
        if (value === this.miterLimit) return;
        this.$emit('update:miterLimit', value);
      },
      width: function width(value) {
        this.setWidth(value);
      },
      currentWidth: function currentWidth(value) {
        if (value === this.width) return;
        this.$emit('update:width', value);
      }
    }),
    created: function created() {
      defineServices$6.call(this);
    },
    methods: {
      /**
       * @return {StrokeStyle}
       * @protected
       */
      createStyle: function createStyle() {
        return new style$1.Stroke({
          color: this.currentColor,
          lineCap: this.currentLineCap,
          lineJoin: this.currentLineJoin,
          lineDash: this.currentLineDash,
          lineDashOffset: this.currentLineDashOffset,
          miterLimit: this.currentMiterLimit,
          width: this.currentWidth
        });
      },

      /**
       * @return {Promise<void>}
       * @protected
       */
      mount: function mount() {
        var _this = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          var _this$$strokeStyleCon;

          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  (_this$$strokeStyleCon = _this.$strokeStyleContainer) === null || _this$$strokeStyleCon === void 0 ? void 0 : _this$$strokeStyleCon.setStroke(_this);
                  return _context.abrupt("return", style.methods.mount.call(_this));

                case 2:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      },

      /**
       * @return {Promise<void>}
       * @protected
       */
      unmount: function unmount() {
        var _this2 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
          var _this2$$strokeStyleCo;

          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  if (((_this2$$strokeStyleCo = _this2.$strokeStyleContainer) === null || _this2$$strokeStyleCo === void 0 ? void 0 : _this2$$strokeStyleCo.getStrokeVm()) === _this2) {
                    _this2.$strokeStyleContainer.setStroke(null);
                  }

                  return _context2.abrupt("return", style.methods.unmount.call(_this2));

                case 2:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }))();
      },

      /**
       * @return {Promise}
       */
      refresh: function refresh() {
        var _this3 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3() {
          var _this3$$strokeStyleCo;

          return regenerator.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _context3.next = 2;
                  return Promise.all([style.methods.refresh.call(_this3), (_this3$$strokeStyleCo = _this3.$strokeStyleContainer) === null || _this3$$strokeStyleCo === void 0 ? void 0 : _this3$$strokeStyleCo.refresh()]);

                case 2:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }))();
      },

      /**
       * @protected
       */
      syncNonObservable: function syncNonObservable() {
        style.methods.syncNonObservable.call(this);
        this.setColor(this.getColor());
        this.setLineCap(this.getLineCap());
        this.setLineJoin(this.getLineJoin());
        this.setLineDash(this.getLineDash());
        this.setLineDashOffset(this.getLineDashOffset());
        this.setMiterLimit(this.getMiterLimit());
        this.setWidth(this.getWidth());
      },
      getColor: function getColor() {
        var _this$$style;

        return coalesce((_this$$style = this.$style) === null || _this$$style === void 0 ? void 0 : _this$$style.getColor(), this.currentColor);
      },
      setColor: function setColor(color) {
        color = normalizeColor(color);

        if (!isEqual(color, this.currentColor)) {
          this.currentColor = color;
          this.scheduleRefresh();
        }

        if (this.$style && !isEqual(color, this.$style.getColor())) {
          this.$style.setColor(color);
          this.scheduleRefresh();
        }
      },
      getLineCap: function getLineCap() {
        var _this$$style2;

        return coalesce((_this$$style2 = this.$style) === null || _this$$style2 === void 0 ? void 0 : _this$$style2.getLineCap(), this.currentLineCap);
      },
      setLineCap: function setLineCap(lineCap) {
        if (lineCap !== this.currentLineCap) {
          this.currentLineCap = lineCap;
          this.scheduleRefresh();
        }

        if (this.$style && lineCap !== this.$style.getLineCap()) {
          this.$style.setLineCap(lineCap);
          this.scheduleRefresh();
        }
      },
      getLineJoin: function getLineJoin() {
        var _this$$style3;

        return coalesce((_this$$style3 = this.$style) === null || _this$$style3 === void 0 ? void 0 : _this$$style3.getLineJoin(), this.currentLineJoin);
      },
      setLineJoin: function setLineJoin(lineJoin) {
        if (lineJoin !== this.currentLineJoin) {
          this.currentLineJoin = lineJoin;
        }

        if (this.$style && lineJoin !== this.$style.getLineJoin()) {
          this.$style.setLineJoin(lineJoin);
          this.scheduleRefresh();
        }
      },
      getLineDash: function getLineDash() {
        var _this$$style4;

        return coalesce((_this$$style4 = this.$style) === null || _this$$style4 === void 0 ? void 0 : _this$$style4.getLineDash(), this.currentLineDash);
      },
      setLineDash: function setLineDash(lineDash) {
        var _lineDash;

        lineDash = (_lineDash = lineDash) === null || _lineDash === void 0 ? void 0 : _lineDash.slice();

        if (!isEqual(lineDash, this.currentLineDash)) {
          this.currentLineDash = lineDash;
          this.scheduleRefresh();
        }

        if (this.$style && !isEqual(lineDash, this.$style.getLineDash())) {
          this.$style.setLineDash(lineDash);
          this.scheduleRefresh();
        }
      },
      getLineDashOffset: function getLineDashOffset() {
        var _this$$style5;

        return coalesce((_this$$style5 = this.$style) === null || _this$$style5 === void 0 ? void 0 : _this$$style5.getLineDashOffset(), this.currentLineDashOffset);
      },
      setLineDashOffset: function setLineDashOffset(lineDashOffset) {
        if (lineDashOffset !== this.currentLineDashOffset) {
          this.currentLineDashOffset = lineDashOffset;
          this.scheduleRefresh();
        }

        if (this.$style && lineDashOffset !== this.$style.getLineDashOffset()) {
          this.$style.setLineDashOffset(lineDashOffset);
          this.scheduleRefresh();
        }
      },
      getMiterLimit: function getMiterLimit() {
        var _this$$style6;

        return coalesce((_this$$style6 = this.$style) === null || _this$$style6 === void 0 ? void 0 : _this$$style6.getMiterLimit(), this.currentMiterLimit);
      },
      setMiterLimit: function setMiterLimit(miterLimit) {
        if (miterLimit !== this.currentMiterLimit) {
          this.currentMiterLimit = miterLimit;
          this.scheduleRefresh();
        }

        if (this.$style && miterLimit !== this.$style.getMiterLimit()) {
          this.$style.setMiterLimit(miterLimit);
          this.scheduleRefresh();
        }
      },
      getWidth: function getWidth() {
        var _this$$style7;

        return coalesce((_this$$style7 = this.$style) === null || _this$$style7 === void 0 ? void 0 : _this$$style7.getWidth(), this.currentWidth);
      },
      setWidth: function setWidth(width) {
        if (width !== this.currentWidth) {
          this.currentWidth = width;
          this.scheduleRefresh();
        }

        if (this.$style && width !== this.$style.getWidth()) {
          this.$style.setWidth(width);
          this.scheduleRefresh();
        }
      }
    }
  };

  function defineServices$6() {
    var _this4 = this;

    Object.defineProperties(this, {
      $strokeStyleContainer: {
        enumerable: true,
        get: function get() {
          var _this4$$services;

          return (_this4$$services = _this4.$services) === null || _this4$$services === void 0 ? void 0 : _this4$$services.strokeStyleContainer;
        }
      }
    });
  }

  /* script */
  var __vue_script__$E = script$E;
  /* template */

  /* style */

  var __vue_inject_styles__$E = undefined;
  /* scoped */

  var __vue_scope_id__$E = undefined;
  /* module identifier */

  var __vue_module_identifier__$E = undefined;
  /* functional template */

  var __vue_is_functional_template__$E = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$E = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$E, __vue_script__$E, __vue_scope_id__$E, __vue_is_functional_template__$E, __vue_module_identifier__$E, false, undefined, undefined, undefined);

  function ownKeys$s(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$s(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$s(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$s(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var script$D = {
    name: 'VlStyleCircle',
    components: {
      FillStyle: __vue_component__$F,
      StrokeStyle: __vue_component__$E
    },
    mixins: [regShapeStyle],
    props: {
      /* eslint-disable vue/require-prop-types */
      radius: _objectSpread$s(_objectSpread$s({}, regShapeStyle.props.radius), {}, {
        default: 5
      })
      /* eslint-enable vue/require-prop-types */

    },
    data: function data() {
      return {
        currentRadius: this.radius
      };
    },
    watch: {
      rev: function rev() {
        if (!this.$style) return;
        this.setRadius(this.getRadius());
      },
      currentRadius: function currentRadius(value) {
        if (value === this.radius) return;
        this.$emit('update:radius', value);
      }
    },
    methods: {
      /**
       * @return {CircleStyle}
       * @protected
       */
      createStyle: function createStyle() {
        return new style$1.Circle({
          // ol/style/Image
          displacement: this.inputDisplacement,
          // ol/style/RegularShape
          radius: this.currentRadius,
          fill: this.$fill,
          stroke: this.$stroke
        });
      },

      /**
       * @protected
       */
      syncNonObservable: function syncNonObservable() {
        regShapeStyle.methods.syncNonObservable.call(this);
        this.setRadius(this.getRadius());
      },
      getRadius: function getRadius() {
        var _this$$style;

        return coalesce((_this$$style = this.$style) === null || _this$$style === void 0 ? void 0 : _this$$style.getRadius(), this.currentRadius);
      },
      setRadius: function setRadius(radius) {
        if (radius !== this.currentRadius) {
          this.currentRadius = radius;
          this.scheduleRefresh();
        }

        if (this.$style && radius !== this.$style.getRadius()) {
          this.$style.setRadius(radius);
          this.scheduleRefresh();
        }
      },

      /**
       * @param {number} value
       * @protected
       */
      radiusChanged: function radiusChanged(value) {
        this.setRadius(value);
      },
      pointsChanged: noop$1,
      radius1Changed: noop$1,
      radius2Changed: noop$1,
      angleChanged: noop$1
    }
  };

  /* script */
  var __vue_script__$D = script$D;
  /* template */

  var __vue_render__$7 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('i', {
      class: _vm.vmClass,
      staticStyle: {
        "display": "none !important"
      },
      attrs: {
        "id": _vm.vmId
      }
    }, [_vm._t("default", [_c('FillStyle', {
      attrs: {
        "id": 'vl-' + _vm.currentId + '-default-fill-style'
      }
    }), _vm._v(" "), _c('StrokeStyle', {
      attrs: {
        "id": 'vl-' + _vm.currentId + '-default-stroke-style'
      }
    })])], 2);
  };

  var __vue_staticRenderFns__$7 = [];
  /* style */

  var __vue_inject_styles__$D = undefined;
  /* scoped */

  var __vue_scope_id__$D = undefined;
  /* module identifier */

  var __vue_module_identifier__$D = undefined;
  /* functional template */

  var __vue_is_functional_template__$D = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$D = /*#__PURE__*/normalizeComponent({
    render: __vue_render__$7,
    staticRenderFns: __vue_staticRenderFns__$7
  }, __vue_inject_styles__$D, __vue_script__$D, __vue_scope_id__$D, __vue_is_functional_template__$D, __vue_module_identifier__$D, false, undefined, undefined, undefined);

  /**
   * @module ol/style/IconAnchorUnits
   */
  /**
   * Icon anchor units. One of 'fraction', 'pixels'.
   * @enum {string}
   */
  var IconAnchorUnits = {
      /**
       * Anchor is a fraction
       * @api
       */
      FRACTION: 'fraction',
      /**
       * Anchor is in pixels
       * @api
       */
      PIXELS: 'pixels',
  };

  /**
   * @module ol/style/IconOrigin
   */
  /**
   * Icon origin. One of 'bottom-left', 'bottom-right', 'top-left', 'top-right'.
   * @enum {string}
   */
  var IconOrigin = {
      /**
       * Origin is at bottom left
       * @api
       */
      BOTTOM_LEFT: 'bottom-left',
      /**
       * Origin is at bottom right
       * @api
       */
      BOTTOM_RIGHT: 'bottom-right',
      /**
       * Origin is at top left
       * @api
       */
      TOP_LEFT: 'top-left',
      /**
       * Origin is at top right
       * @api
       */
      TOP_RIGHT: 'top-right',
  };

  function ownKeys$r(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$r(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$r(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$r(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var script$C = {
    name: 'VlStyleIcon',
    mixins: [imageStyle],
    props: {
      src: String,
      size: {
        type: Array,
        validator: function validator(val) {
          return val.length === 2;
        }
      },
      img: Image,
      imgSize: {
        type: Array,
        validator: function validator(val) {
          return val.length === 2;
        }
      },
      anchor: {
        type: Array,
        default: function _default() {
          return [0.5, 0.5];
        },
        validator: function validator(val) {
          return val.length === 2;
        }
      },
      anchorOrigin: {
        type: String,
        default: IconOrigin.TOP_LEFT // bottom-left, bottom-right, top-left or top-right

      },
      anchorXUnits: {
        type: String,
        default: IconAnchorUnits.FRACTION // pixels, fraction

      },
      anchorYUnits: {
        type: String,
        default: IconAnchorUnits.FRACTION // pixels, fraction

      },
      color: [Array, String],
      crossOrigin: String,
      offset: {
        type: Array,
        default: function _default() {
          return [0, 0];
        },
        validator: function validator(val) {
          return val.length === 2;
        }
      },
      offsetOrigin: {
        type: String,
        default: IconOrigin.TOP_LEFT // bottom-left, bottom-right, top-left or top-right

      }
    },
    data: function data() {
      var _this$anchor;

      return {
        currentAnchor: (_this$anchor = this.anchor) === null || _this$anchor === void 0 ? void 0 : _this$anchor.slice()
      };
    },
    computed: {
      inputSize: function inputSize() {
        var _this$size;

        return (_this$size = this.size) === null || _this$size === void 0 ? void 0 : _this$size.slice();
      },
      inputImgSize: function inputImgSize() {
        var _this$imgSize;

        return (_this$imgSize = this.imgSize) === null || _this$imgSize === void 0 ? void 0 : _this$imgSize.slice();
      },
      inputAnchor: function inputAnchor() {
        var _this$anchor2;

        return (_this$anchor2 = this.anchor) === null || _this$anchor2 === void 0 ? void 0 : _this$anchor2.slice();
      },
      inputColor: function inputColor() {
        return this.color ? normalizeColor(this.color) : undefined;
      },
      inputOffset: function inputOffset() {
        var _this$offset;

        return (_this$offset = this.offset) === null || _this$offset === void 0 ? void 0 : _this$offset.slice();
      }
    },
    watch: _objectSpread$r({
      rev: function rev() {
        if (!this.$style) return;
        this.setAnchor(this.getAnchor());
      },
      inputAnchor: {
        deep: true,
        handler: function handler(value) {
          this.setAnchor(value);
        }
      },
      currentAnchor: {
        deep: true,
        handler: function handler(value) {
          if (isEqual(value, this.inputAnchor)) return;
          this.$emit('update:anchor', value === null || value === void 0 ? void 0 : value.slice());
        }
      }
    }, /*#__PURE__*/makeChangeOrRecreateWatchers(['src', 'inputSize', 'img', 'inputImgSize', 'anchorOrigin', 'anchorXUnits', 'anchorYUnits', 'anchorYUnits', 'inputColor', 'crossOrigin', 'inputOffset', 'offsetOrigin'], ['inputSize', 'inputImgSize', 'inputColor', 'inputOffset'])),
    methods: {
      /**
       * @return {Icon}
       * @protected
       */
      createStyle: function createStyle() {
        assert$1(this.src && !this.img || !this.src && this.img, "vl-style-icon one of 'image' or 'src' prop must be provided.'");
        assert$1(!this.img || this.img && !isEmpty$2(this.imgSize), "vl-style-icon 'imgSize' must be set when image is provided.");
        return new style$1.Icon({
          // ol/style/Image
          opacity: this.currentOpacity,
          scale: this.currentScale,
          rotateWithView: this.currentRotateWithView,
          rotation: this.currentRotation,
          displacement: this.inputDisplacement,
          // ol/style/Icon
          anchor: this.currentAnchor,
          anchorOrigin: this.anchorOrigin,
          anchorXUnits: this.anchorXUnits,
          anchorYUnits: this.anchorYUnits,
          color: this.inputColor,
          crossOrigin: this.crossOrigin,
          offset: this.inputOffset,
          offsetOrigin: this.offsetOrigin,
          size: this.inputSize,
          src: this.src,
          img: this.img,
          imgSize: this.inputImgSize
        });
      },

      /**
       * @protected
       */
      syncNonObservable: function syncNonObservable() {
        imageStyle.methods.syncNonObservable.call(this);
        this.setAnchor(this.getAnchor());
      },
      getAnchor: function getAnchor() {
        var _this$$style, _this$$style$getAncho;

        var anchor = (_this$$style = this.$style) === null || _this$$style === void 0 ? void 0 : (_this$$style$getAncho = _this$$style.getAnchor()) === null || _this$$style$getAncho === void 0 ? void 0 : _this$$style$getAncho.slice();
        if (!anchor) return this.currentAnchor;
        var size = this.getSize();
        if (!size) return;

        if (this.anchorXUnits === IconAnchorUnits.FRACTION) {
          anchor[0] /= size[0];
        }

        if (this.anchorYUnits === IconAnchorUnits.FRACTION) {
          anchor[1] /= size[1];
        }

        if ([IconOrigin.TOP_RIGHT, IconOrigin.BOTTOM_RIGHT].includes(this.anchorOrigin)) {
          anchor[0] = 1 - anchor[0];
        }

        if ([IconOrigin.BOTTOM_LEFT, IconOrigin.BOTTOM_RIGHT].includes(this.anchorOrigin)) {
          anchor[1] = 1 - anchor[1];
        }

        anchor[0] = round(anchor[0], 3);
        anchor[1] = round(anchor[1], 3);
        return anchor;
      },
      setAnchor: function setAnchor(anchor) {
        var _anchor;

        anchor = (_anchor = anchor) === null || _anchor === void 0 ? void 0 : _anchor.slice();

        if (!isEqual(anchor, this.currentAnchor)) {
          this.currentAnchor = anchor;
          this.scheduleRefresh();
        }

        if (this.$style && !isEqual(anchor, this.$style.getAnchor())) {
          this.$style.setAnchor(anchor);
          this.scheduleRefresh();
        }
      },
      getColor: function getColor() {
        var _this$$style2;

        return coalesce((_this$$style2 = this.$style) === null || _this$$style2 === void 0 ? void 0 : _this$$style2.getColor(), this.inputColor);
      },
      getImage: function getImage(pixelRatio) {
        var _this$$style3;

        return (_this$$style3 = this.$style) === null || _this$$style3 === void 0 ? void 0 : _this$$style3.getImage(pixelRatio);
      },
      getPixelRatio: function getPixelRatio(pixelRatio) {
        var _this$$style4;

        return (_this$$style4 = this.$style) === null || _this$$style4 === void 0 ? void 0 : _this$$style4.getPixelRatio(pixelRatio);
      },
      getOrigin: function getOrigin() {
        var _this$$style5;

        return (_this$$style5 = this.$style) === null || _this$$style5 === void 0 ? void 0 : _this$$style5.getOrigin();
      },
      getSize: function getSize() {
        var _this$$style6;

        return coalesce((_this$$style6 = this.$style) === null || _this$$style6 === void 0 ? void 0 : _this$$style6.getSize(), this.inputSize);
      },
      getSrc: function getSrc() {
        var _this$$style7;

        return coalesce((_this$$style7 = this.$style) === null || _this$$style7 === void 0 ? void 0 : _this$$style7.getSrc(), this.src);
      },
      load: function load() {
        var _this = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return _this.resolveStyle();

                case 2:
                  _context.sent.load();

                case 3:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      }
    }
  };

  /* script */
  var __vue_script__$C = script$C;
  /* template */

  /* style */

  var __vue_inject_styles__$C = undefined;
  /* scoped */

  var __vue_scope_id__$C = undefined;
  /* module identifier */

  var __vue_module_identifier__$C = undefined;
  /* functional template */

  var __vue_is_functional_template__$C = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$C = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$C, __vue_script__$C, __vue_scope_id__$C, __vue_is_functional_template__$C, __vue_module_identifier__$C, false, undefined, undefined, undefined);

  var script$B = {
    name: 'VlStyleRegShape',
    mixins: [regShapeStyle],
    methods: {
      /**
       * @return {RegularShapeStyle}
       * @protected
       */
      createStyle: function createStyle() {
        return new style$1.RegularShape({
          // ol/style/Image
          rotation: this.currentRotation,
          rotateWithView: this.currentRotateWithView,
          displacement: this.inputDisplacement,
          // ol/style/RegularShape
          points: this.points,
          radius: this.radius,
          radius1: this.radius1,
          radius2: this.radius2,
          angle: this.angle,
          fill: this.$fill,
          stroke: this.$stroke
        });
      }
    }
  };

  /* script */
  var __vue_script__$B = script$B;
  /* template */

  /* style */

  var __vue_inject_styles__$B = undefined;
  /* scoped */

  var __vue_scope_id__$B = undefined;
  /* module identifier */

  var __vue_module_identifier__$B = undefined;
  /* functional template */

  var __vue_is_functional_template__$B = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$B = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$B, __vue_script__$B, __vue_scope_id__$B, __vue_is_functional_template__$B, __vue_module_identifier__$B, false, undefined, undefined, undefined);

  function ownKeys$q(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$q(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$q(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$q(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  /**
   * Style box component.
   * Wrapper for Style class. Can be inserted into component with setStyle/getStyle methods (vl-layer-vector, vl-feature & etc.)
   * and acts as a box for inner style components (vl-style-fill, vl-style-stroke, icon ...)
   */

  var script$A = {
    name: 'VlStyle',
    components: {
      CircleStyle: __vue_component__$D,
      FillStyle: __vue_component__$F,
      StrokeStyle: __vue_component__$E
    },
    mixins: [projTransforms, fillStyleContainer, strokeStyleContainer, textStyleContainer, imageStyleContainer, geometryContainer, style, waitForMap],
    stubVNode: {
      empty: false,
      attrs: function attrs() {
        return {
          id: this.vmId,
          class: this.vmClass
        };
      }
    },
    props: {
      /**
       * @type {number}
       */
      zIndex: {
        type: Number,
        default: 0
      },

      /**
       * @type {function}
       */
      renderer: Function,

      /**
       * @deprecated Use v-if directive.
       * @todo remove in v0.13.x
       */
      condition: [Boolean, Function]
    },
    data: function data() {
      return {
        viewProjection: EPSG_3857,
        dataProjection: EPSG_3857,
        currentZIndex: this.zIndex,
        currentRenderer: this.renderer
      };
    },
    computed: {
      stroke: function stroke() {
        if (!(this.rev && this.$stroke)) return;
        return dumpStrokeStyle(this.$stroke);
      },
      fill: function fill() {
        if (!(this.rev && this.$fill)) return;
        return dumpFillStyle(this.$fill);
      },
      text: function text() {
        if (!(this.rev && this.$text)) return;
        return dumpTextStyle(this.$text);
      },
      image: function image() {
        if (!(this.rev && this.$image)) return;
        return dumpImageStyle(this.$image);
      },
      geometryDataProj: function geometryDataProj() {
        if (!(this.rev && this.$geometry)) return;
        return this.writeGeometryInDataProj(this.$geometry);
      },
      geometryViewProj: function geometryViewProj() {
        if (!(this.rev && this.$geometry)) return;
        return this.writeGeometryInViewProj(this.$geometry);
      }
    },
    watch: _objectSpread$q(_objectSpread$q(_objectSpread$q({
      rev: function rev() {
        if (!this.$style) return;
        this.setZIndex(this.getZIndex());
        this.setRenderer(this.getRenderer());
      }
    }, /*#__PURE__*/makeWatchers(['zIndex', 'renderer'], function (inProp) {
      var prop = inProp.slice(0, 5) === 'input' ? lowerFirst(inProp.slice(5)) : inProp;
      var setter = 'set' + upperFirst(prop);
      return function (value) {
        this[setter](value);
      };
    })), /*#__PURE__*/makeWatchers(['currentZIndex', 'currentRenderer'], function (curProp) {
      var prop = curProp.slice(0, 7) === 'current' ? lowerFirst(curProp.slice(7)) : curProp;
      var inProp = 'input' + upperFirst(prop);
      return function (value) {
        if (isEqual(value, coalesce(this[inProp], this[prop]))) return;
        this.$emit("update:".concat(prop), isObjectLike(value) ? clonePlainObject(value) : value);
      };
    })), /*#__PURE__*/makeWatchers(['fill', 'stroke', 'text', 'image', 'geometryDataProj'], function (prop) {
      prop = prop.replace(/(DataProj|ViewProj)$/i, '');
      return {
        deep: true,
        handler: function handler(value, prev) {
          if (isEqual(value, prev)) return;
          this.$emit("update:".concat(prop), isObjectLike(value) ? clonePlainObject(value) : value);
        }
      };
    })),
    created: function created() {

      defineServices$5.call(this);
    },
    updated: function updated() {
    },
    methods: {
      /**
       * @return {Promise<void>}
       * @protected
       */
      beforeInit: function beforeInit() {
        var _this = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return Promise.all([style.methods.beforeInit.call(_this), waitForMap.methods.beforeInit.call(_this)]);

                case 2:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      },

      /**
       * @return {module:ol/style/Style~Style}
       * @protected
       */
      createStyle: function createStyle() {
        return new style$1.Style({
          zIndex: this.currentZIndex,
          renderer: this.currentRenderer,
          fill: this.$fill,
          stroke: this.$stroke,
          image: this.$image,
          text: this.$text,
          geometry: this.$geometry
        });
      },

      /**
       * @return {Promise<void>}
       * @protected
       */
      mount: function mount() {
        var _this2 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
          var _this2$$styleContaine;

          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  (_this2$$styleContaine = _this2.$styleContainer) === null || _this2$$styleContaine === void 0 ? void 0 : _this2$$styleContaine.addStyle(_this2);
                  return _context2.abrupt("return", style.methods.mount.call(_this2));

                case 2:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }))();
      },

      /**
       * @return {Promise<void>}
       * @protected
       */
      unmount: function unmount() {
        var _this3 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3() {
          var _this3$$styleContaine;

          return regenerator.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  (_this3$$styleContaine = _this3.$styleContainer) === null || _this3$$styleContaine === void 0 ? void 0 : _this3$$styleContaine.removeStyle(_this3);
                  return _context3.abrupt("return", style.methods.unmount.call(_this3));

                case 2:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }))();
      },

      /**
       * @return {Promise}
       */
      refresh: function refresh() {
        var _this4 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4() {
          var _this4$$styleContaine;

          return regenerator.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  _context4.next = 2;
                  return Promise.all([style.methods.refresh.call(_this4), (_this4$$styleContaine = _this4.$styleContainer) === null || _this4$$styleContaine === void 0 ? void 0 : _this4$$styleContaine.refresh()]);

                case 2:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4);
        }))();
      },

      /**
       * @returns {Object}
       * @protected
       */
      getServices: function getServices() {
        return mergeDescriptors(style.methods.getServices.call(this), fillStyleContainer.methods.getServices.call(this), strokeStyleContainer.methods.getServices.call(this), textStyleContainer.methods.getServices.call(this), imageStyleContainer.methods.getServices.call(this), geometryContainer.methods.getServices.call(this));
      },

      /**
       * @protected
       */
      syncNonObservable: function syncNonObservable() {
        style.methods.syncNonObservable.call(this);
        this.setZIndex(this.getZIndex());
        this.setRenderer(this.getRenderer());
      },
      getFillStyleTarget: function getFillStyleTarget() {
        return this.$style;
      },
      getStrokeStyleTarget: function getStrokeStyleTarget() {
        return this.$style;
      },
      getTextStyleTarget: function getTextStyleTarget() {
        return this.$style;
      },
      getImageStyleTarget: function getImageStyleTarget() {
        return this.$style;
      },
      getGeometryTarget: function getGeometryTarget() {
        return this.$style;
      },
      getZIndex: function getZIndex() {
        var _this$$style;

        return coalesce((_this$$style = this.$style) === null || _this$$style === void 0 ? void 0 : _this$$style.getZIndex(), this.currentZIndex);
      },
      setZIndex: function setZIndex(zIndex) {
        if (zIndex !== this.currentZIndex) {
          this.currentZIndex = zIndex;
          this.scheduleRefresh();
        }

        if (this.$style && zIndex !== this.$style.getZIndex()) {
          this.$style.setZIndex(zIndex);
          this.scheduleRefresh();
        }
      },
      getRenderer: function getRenderer() {
        var _this$$style2;

        return coalesce((_this$$style2 = this.$style) === null || _this$$style2 === void 0 ? void 0 : _this$$style2.getRenderer(), this.currentRenderer);
      },
      setRenderer: function setRenderer(renderer) {
        if (renderer !== this.currentRenderer) {
          this.currentRenderer = renderer;
          this.scheduleRefresh();
        }

        if (this.$style && renderer !== this.$style.getRenderer()) {
          this.$style.setRenderer(renderer);
          this.scheduleRefresh();
        }
      },
      // todo add support for geometry function
      getGeometryFunction: function getGeometryFunction() {
        var _this$$style3;

        return (_this$$style3 = this.$style) === null || _this$$style3 === void 0 ? void 0 : _this$$style3.getGeometryFunction();
      }
    }
  };

  function defineServices$5() {
    var _this5 = this;

    Object.defineProperties(this, {
      /**
       * @type {Object|undefined}
       */
      $mapVm: {
        enumerable: true,
        get: function get() {
          var _this5$$services;

          return (_this5$$services = _this5.$services) === null || _this5$$services === void 0 ? void 0 : _this5$$services.mapVm;
        }
      },

      /**
       * @type {Object|undefined}
       */
      $viewVm: {
        enumerable: true,
        get: function get() {
          var _this5$$services2;

          return (_this5$$services2 = _this5.$services) === null || _this5$$services2 === void 0 ? void 0 : _this5$$services2.viewVm;
        }
      }
    });
  }

  /* script */
  var __vue_script__$A = script$A;
  /* template */

  var __vue_render__$6 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('i', {
      class: _vm.vmClass,
      staticStyle: {
        "display": "none !important"
      },
      attrs: {
        "id": _vm.vmId
      }
    }, [_vm._t("default", [_c('CircleStyle', {
      attrs: {
        "id": 'vl-' + _vm.currentId + '-default-circle-style'
      }
    }), _vm._v(" "), _c('FillStyle', {
      attrs: {
        "id": 'vl-' + _vm.currentId + '-default-fill-style'
      }
    }), _vm._v(" "), _c('StrokeStyle', {
      attrs: {
        "id": 'vl-' + _vm.currentId + '-default-stroke-style'
      }
    })])], 2);
  };

  var __vue_staticRenderFns__$6 = [];
  /* style */

  var __vue_inject_styles__$A = undefined;
  /* scoped */

  var __vue_scope_id__$A = undefined;
  /* module identifier */

  var __vue_module_identifier__$A = undefined;
  /* functional template */

  var __vue_is_functional_template__$A = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$A = /*#__PURE__*/normalizeComponent({
    render: __vue_render__$6,
    staticRenderFns: __vue_staticRenderFns__$6
  }, __vue_inject_styles__$A, __vue_script__$A, __vue_scope_id__$A, __vue_is_functional_template__$A, __vue_module_identifier__$A, false, undefined, undefined, undefined);

  function ownKeys$p(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$p(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$p(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$p(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var script$z = {
    name: 'VlStyleBackgroundAdapter',
    mixins: [stubVNode, fillStyleContainer, strokeStyleContainer, olCmp],
    stubVNode: {
      empty: false,
      attrs: function attrs() {
        return {
          id: this.vmId,
          class: this.vmClass
        };
      }
    },
    computed: {
      stroke: function stroke() {
        if (!(this.rev && this.$strokeStyle)) return;
        return dumpStrokeStyle(this.$strokeStyle);
      },
      fill: function fill() {
        if (!(this.rev && this.$fill)) return;
        return dumpFillStyle(this.$fill);
      }
    },
    watch: _objectSpread$p({}, /*#__PURE__*/makeWatchers(['fill', 'stroke'], function (prop) {
      return function (value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit("update:".concat(prop), isObjectLike(value) ? clonePlainObject(value) : value);
      };
    })),
    created: function created() {
      var _this = this;

      Object.defineProperties(this, {
        $bgStyleContainer: {
          enumerable: true,
          get: function get() {
            var _this$$services;

            return (_this$$services = _this.$services) === null || _this$$services === void 0 ? void 0 : _this$$services.bgStyleContainer;
          }
        }
      });
    },
    methods: {
      createOlObject: function createOlObject() {
        var obj = stubObject();
        obj.id = this.currentId;
        return obj;
      },
      getServices: function getServices() {
        return mergeDescriptors(olCmp.methods.getServices.call(this), fillStyleContainer.methods.getServices.call(this), strokeStyleContainer.methods.getServices.call(this));
      },
      getFillStyleTarget: function getFillStyleTarget() {
        var _this2 = this;

        return {
          getFill: function getFill() {
            var _this2$$bgStyleContai;

            return (_this2$$bgStyleContai = _this2.$bgStyleContainer) === null || _this2$$bgStyleContai === void 0 ? void 0 : _this2$$bgStyleContai.getBackgroundFill();
          },
          setFill: function setFill(style) {
            var _this2$$bgStyleContai2;

            return (_this2$$bgStyleContai2 = _this2.$bgStyleContainer) === null || _this2$$bgStyleContai2 === void 0 ? void 0 : _this2$$bgStyleContai2.setBackgroundFill(style);
          }
        };
      },
      getStrokeStyleTarget: function getStrokeStyleTarget() {
        var _this3 = this;

        return {
          getStroke: function getStroke() {
            var _this3$$bgStyleContai;

            return (_this3$$bgStyleContai = _this3.$bgStyleContainer) === null || _this3$$bgStyleContai === void 0 ? void 0 : _this3$$bgStyleContai.getBackgroundStroke();
          },
          setStroke: function setStroke(style) {
            var _this3$$bgStyleContai2;

            return (_this3$$bgStyleContai2 = _this3.$bgStyleContainer) === null || _this3$$bgStyleContai2 === void 0 ? void 0 : _this3$$bgStyleContai2.setBackgroundStroke(style);
          }
        };
      }
    }
  };

  /* script */
  var __vue_script__$z = script$z;
  /* template */

  /* style */

  var __vue_inject_styles__$z = undefined;
  /* scoped */

  var __vue_scope_id__$z = undefined;
  /* module identifier */

  var __vue_module_identifier__$z = undefined;
  /* functional template */

  var __vue_is_functional_template__$z = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$z = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$z, __vue_script__$z, __vue_scope_id__$z, __vue_is_functional_template__$z, __vue_module_identifier__$z, false, undefined, undefined, undefined);

  function ownKeys$o(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$o(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$o(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$o(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var script$y = {
    name: 'VlStyleText',
    components: {
      BackgroundStyle: __vue_component__$z,
      FillStyle: __vue_component__$F,
      StrokeStyle: __vue_component__$E
    },
    mixins: [fillStyleContainer, strokeStyleContainer, style],
    stubVNode: {
      empty: false,
      attrs: function attrs() {
        return {
          id: this.vmId,
          class: this.vmClass
        };
      }
    },
    props: {
      font: {
        type: String,
        default: '10px sans-serif' // css font format https://developer.mozilla.org/en-US/docs/Web/CSS/font?v=control

      },
      maxAngle: Number,
      placement: String,
      offsetX: {
        type: Number,
        default: 0
      },
      offsetY: {
        type: Number,
        default: 0
      },
      overflow: Boolean,
      rotateWithView: {
        type: Boolean,
        default: false
      },
      rotation: {
        type: Number,
        default: 0
      },
      scale: {
        type: Number,
        default: 1
      },
      text: String,
      textAlign: String,
      // left, right, center, end, start
      textBaseline: String,
      // bottom, top, middle, alphabetic, hanging, ideographic
      padding: {
        type: Array,
        default: function _default() {
          return [0, 0, 0, 0];
        },
        validate: function validate(val) {
          return val.length && val.length === 4;
        }
      }
    },
    data: function data() {
      var _this$padding;

      return {
        currentFont: this.font,
        currentMaxAngle: this.maxAngle,
        currentPlacement: this.placement,
        currentOffsetX: this.offsetX,
        currentOffsetY: this.offsetY,
        currentOverflow: this.overflow,
        currentRotateWithView: this.rotateWithView,
        currentRotation: this.rotation,
        currentScale: this.scale,
        currentText: this.text,
        currentTextAlign: this.textAlign,
        currentTextBaseline: this.textBaseline,
        currentPadding: (_this$padding = this.padding) === null || _this$padding === void 0 ? void 0 : _this$padding.slice()
      };
    },
    computed: {
      inputPadding: function inputPadding() {
        var _this$padding2;

        return (_this$padding2 = this.padding) === null || _this$padding2 === void 0 ? void 0 : _this$padding2.slice();
      },
      stroke: function stroke() {
        if (!(this.rev && this.$stroke)) return;
        return dumpStrokeStyle(this.$stroke);
      },
      fill: function fill() {
        if (!(this.rev && this.$fill)) return;
        return dumpFillStyle(this.$fill);
      },
      backgroundFill: function backgroundFill() {
        if (!(this.rev && this.$bgFill)) return;
        return dumpFillStyle(this.$bgFill);
      },
      backgroundStroke: function backgroundStroke() {
        if (!(this.rev && this.$bgStroke)) return;
        return dumpStrokeStyle(this.$bgStroke);
      }
    },
    watch: _objectSpread$o(_objectSpread$o(_objectSpread$o({
      rev: function rev() {
        if (!this.$style) return;
        this.setFont(this.getFont());
        this.setMaxAngle(this.getMaxAngle());
        this.setPlacement(this.getPlacement());
        this.setOffsetX(this.getOffsetX());
        this.setOffsetY(this.getOffsetY());
        this.setOverflow(this.getOverflow());
        this.setRotateWithView(this.getRotateWithView());
        this.setRotation(this.getRotation());
        this.setScale(this.getScale());
        this.setText(this.getText());
        this.setTextAlign(this.getTextAlign());
        this.setTextBaseline(this.getTextBaseline());
        this.setPadding(this.getPadding());
      }
    }, /*#__PURE__*/makeWatchers(['font', 'maxAngle', 'placement', 'offsetX', 'offsetY', 'overflow', 'rotateWithView', 'rotation', 'scale', 'text', 'textAlign', 'textBaseline', 'inputPadding'], function (inProp) {
      var prop = inProp.slice(0, 5) === 'input' ? lowerFirst(inProp.slice(5)) : inProp;
      var setter = 'set' + upperFirst(prop);
      return {
        deep: ['inputPadding'].includes(inProp),
        handler: function handler(value) {
          this[setter](value);
        }
      };
    })), /*#__PURE__*/makeWatchers(['currentFont', 'currentMaxAngle', 'currentPlacement', 'currentOffsetX', 'currentOffsetY', 'currentOverflow', 'currentRotateWithView', 'currentRotation', 'currentScale', 'currentText', 'currentTextAlign', 'currentTextBaseline', 'currentPadding'], function (curProp) {
      var prop = curProp.slice(0, 7) === 'current' ? lowerFirst(curProp.slice(7)) : curProp;
      var inProp = 'input' + upperFirst(prop);
      return {
        deep: ['currentPadding'].includes(curProp),
        handler: function handler(value) {
          if (isEqual(value, coalesce(this[inProp], this[prop]))) return;
          this.$emit("update:".concat(prop), isObjectLike(value) ? clonePlainObject(value) : value);
        }
      };
    })), /*#__PURE__*/makeWatchers(['fill', 'stroke', 'backgroundFill', 'backgroundStroke'], function (prop) {
      return {
        deep: true,
        handler: function handler(value, prev) {
          if (isEqual(value, prev)) return;
          this.$emit("update:".concat(prop), isObjectLike(value) ? clonePlainObject(value) : value);
        }
      };
    })),
    created: function created() {
      this._bgFill = undefined;
      this._bgFillVm = undefined;
      this._bgStroke = undefined;
      this._bgStrokeVm = undefined;
      defineServices$4.call(this);
    },
    methods: {
      /**
       * @returns {Text}
       * @protected
       */
      createStyle: function createStyle() {
        return new style$1.Text({
          font: this.currentFont,
          maxAngle: this.currentMaxAngle,
          placement: this.currentPlacement,
          offsetX: this.currentOffsetX,
          offsetY: this.currentOffsetY,
          overflow: this.currentOverflow,
          rotateWithView: this.currentRotateWithView,
          rotation: this.currentRotation,
          scale: this.currentScale,
          text: this.currentText,
          textAlign: this.currentTextAlign,
          textBaseline: this.currentTextBaseline,
          padding: this.currentPadding,
          fill: this.$fill,
          stroke: this.$stroke,
          backgroundFill: this.$bgFill,
          backgroundStroke: this.$bgStroke
        });
      },

      /**
       * @return {Promise<void>}
       * @protected
       */
      mount: function mount() {
        var _this = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          var _this$$textStyleConta;

          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  (_this$$textStyleConta = _this.$textStyleContainer) === null || _this$$textStyleConta === void 0 ? void 0 : _this$$textStyleConta.setText(_this);
                  return _context.abrupt("return", style.methods.mount.call(_this));

                case 2:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      },

      /**
       * @return {Promise<void>}
       * @protected
       */
      unmount: function unmount() {
        var _this2 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
          var _this2$$textStyleCont;

          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  if (!(((_this2$$textStyleCont = _this2.$textStyleContainer) === null || _this2$$textStyleCont === void 0 ? void 0 : _this2$$textStyleCont.getTextVm()) === _this2)) {
                    _context2.next = 3;
                    break;
                  }

                  _context2.next = 3;
                  return _this2.$textStyleContainer.setText(null);

                case 3:
                  return _context2.abrupt("return", style.methods.unmount.call(_this2));

                case 4:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }))();
      },

      /**
       * @return {Promise<void>}
       */
      refresh: function refresh() {
        var _this3 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3() {
          var _this3$$textStyleCont;

          return regenerator.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _context3.next = 2;
                  return Promise.all([style.methods.refresh.call(_this3), (_this3$$textStyleCont = _this3.$textStyleContainer) === null || _this3$$textStyleCont === void 0 ? void 0 : _this3$$textStyleCont.refresh()]);

                case 2:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }))();
      },

      /**
       * @returns {Object}
       * @protected
       */
      getServices: function getServices() {
        var vm = this;
        return mergeDescriptors(style.methods.getServices.call(this), fillStyleContainer.methods.getServices.call(this), strokeStyleContainer.methods.getServices.call(this), {
          get bgStyleContainer() {
            return vm;
          }

        });
      },

      /**
       * @protected
       */
      syncNonObservable: function syncNonObservable() {
        style.methods.syncNonObservable.call(this);
        this.setFont(this.getFont());
        this.setMaxAngle(this.getMaxAngle());
        this.setPlacement(this.getPlacement());
        this.setOffsetX(this.getOffsetX());
        this.setOffsetY(this.getOffsetY());
        this.setOverflow(this.getOverflow());
        this.setRotateWithView(this.getRotateWithView());
        this.setRotation(this.getRotation());
        this.setScale(this.getScale());
        this.setText(this.getText());
        this.setTextAlign(this.getTextAlign());
        this.setTextBaseline(this.getTextBaseline());
        this.setPadding(this.getPadding());
      },
      getFont: function getFont() {
        var _this$$style;

        return coalesce((_this$$style = this.$style) === null || _this$$style === void 0 ? void 0 : _this$$style.getFont(), this.currentFont);
      },
      setFont: function setFont(font) {
        if (font !== this.currentFont) {
          this.currentFont = font;
          this.scheduleRefresh();
        }

        if (this.$style && font !== this.$style.getFont()) {
          this.$style.setFont(font);
          this.scheduleRefresh();
        }
      },
      getMaxAngle: function getMaxAngle() {
        var _this$$style2;

        return coalesce((_this$$style2 = this.$style) === null || _this$$style2 === void 0 ? void 0 : _this$$style2.getMaxAngle(), this.currentMaxAngle);
      },
      setMaxAngle: function setMaxAngle(maxAngle) {
        if (maxAngle !== this.currentMaxAngle) {
          this.currentMaxAngle = maxAngle;
          this.scheduleRefresh();
        }

        if (this.$style && maxAngle !== this.$style.getMaxAngle()) {
          this.$style.setMaxAngle(maxAngle);
          this.scheduleRefresh();
        }
      },
      getOffsetX: function getOffsetX() {
        var _this$$style3;

        return coalesce((_this$$style3 = this.$style) === null || _this$$style3 === void 0 ? void 0 : _this$$style3.getOffsetX(), this.currentOffsetX);
      },
      setOffsetX: function setOffsetX(offsetX) {
        if (offsetX !== this.currentOffsetX) {
          this.currentOffsetX = offsetX;
          this.scheduleRefresh();
        }

        if (this.$style && offsetX !== this.$style.getOffsetX()) {
          this.$style.setOffsetX(offsetX);
          this.scheduleRefresh();
        }
      },
      getOffsetY: function getOffsetY() {
        var _this$$style4;

        return coalesce((_this$$style4 = this.$style) === null || _this$$style4 === void 0 ? void 0 : _this$$style4.getOffsetY(), this.currentOffsetY);
      },
      setOffsetY: function setOffsetY(offsetY) {
        if (offsetY !== this.currentOffsetY) {
          this.currentOffsetY = offsetY;
          this.scheduleRefresh();
        }

        if (this.$style && offsetY !== this.$style.getOffsetY()) {
          this.$style.setOffsetY(offsetY);
          this.scheduleRefresh();
        }
      },
      getOverflow: function getOverflow() {
        var _this$$style5;

        return coalesce((_this$$style5 = this.$style) === null || _this$$style5 === void 0 ? void 0 : _this$$style5.getOverflow(), this.currentOverflow);
      },
      setOverflow: function setOverflow(overflow) {
        if (overflow !== this.currentOverflow) {
          this.currentOverflow = overflow;
          this.scheduleRefresh();
        }

        if (this.$style && overflow !== this.$style.getOverflow()) {
          this.$style.setOverflow(overflow);
          this.scheduleRefresh();
        }
      },
      getPadding: function getPadding() {
        var _this$$style6;

        return coalesce((_this$$style6 = this.$style) === null || _this$$style6 === void 0 ? void 0 : _this$$style6.getPadding(), this.currentPadding);
      },
      setPadding: function setPadding(padding) {
        var _padding;

        padding = (_padding = padding) === null || _padding === void 0 ? void 0 : _padding.slice();

        if (!isEqual(padding, this.currentPadding)) {
          this.currentPadding = padding;
          this.scheduleRefresh();
        }

        if (this.$style && !isEqual(padding, this.$style.getPadding())) {
          this.$style.setPadding(padding);
          this.scheduleRefresh();
        }
      },
      getPlacement: function getPlacement() {
        var _this$$source;

        return coalesce((_this$$source = this.$source) === null || _this$$source === void 0 ? void 0 : _this$$source.getPlacement(), this.currentPlacement);
      },
      setPlacement: function setPlacement(placement) {
        if (placement !== this.currentPlacement) {
          this.currentPlacement = placement;
          this.scheduleRefresh();
        }

        if (this.$style && placement !== this.$style.getPlacement()) {
          this.$style.setPlacement(placement);
          this.scheduleRefresh();
        }
      },
      getRotateWithView: function getRotateWithView() {
        var _this$$style7;

        return coalesce((_this$$style7 = this.$style) === null || _this$$style7 === void 0 ? void 0 : _this$$style7.getRotateWithView(), this.currentRotateWithView);
      },
      setRotateWithView: function setRotateWithView(rotateWithView) {
        if (rotateWithView !== this.currentRotateWithView) {
          this.currentRotateWithView = rotateWithView;
          this.scheduleRefresh();
        }

        if (this.$style && rotateWithView !== this.$style.getRotateWithView()) {
          this.$style.setRotateWithView(rotateWithView);
          this.scheduleRefresh();
        }
      },
      getRotation: function getRotation() {
        var _this$$style8;

        return coalesce((_this$$style8 = this.$style) === null || _this$$style8 === void 0 ? void 0 : _this$$style8.getRotation(), this.currentRotation);
      },
      setRotation: function setRotation(rotation) {
        if (rotation !== this.currentRotation) {
          this.currentRotation = rotation;
          this.scheduleRefresh();
        }

        if (this.$style && rotation !== this.$style.getRotation()) {
          this.$style.setRotation(rotation);
          this.scheduleRefresh();
        }
      },
      getScale: function getScale() {
        var _this$$style9;

        return coalesce((_this$$style9 = this.$style) === null || _this$$style9 === void 0 ? void 0 : _this$$style9.getScale(), this.currentScale);
      },
      setScale: function setScale(scale) {
        if (scale !== this.currentScale) {
          this.currentScale = scale;
          this.scheduleRefresh();
        }

        if (this.$style && scale !== this.$style.getScale()) {
          this.$style.setScale(scale);
          this.scheduleRefresh();
        }
      },
      getText: function getText() {
        var _this$$style10;

        return coalesce((_this$$style10 = this.$style) === null || _this$$style10 === void 0 ? void 0 : _this$$style10.getText(), this.currentText);
      },
      setText: function setText(text) {
        if (text !== this.currentText) {
          this.currentText = text;
          this.scheduleRefresh();
        }

        if (this.$style && text !== this.$style.getText()) {
          this.$style.setText(text);
          this.scheduleRefresh();
        }
      },
      getTextAlign: function getTextAlign() {
        var _this$$style11;

        return coalesce((_this$$style11 = this.$style) === null || _this$$style11 === void 0 ? void 0 : _this$$style11.getTextAlign(), this.currentTextAlign);
      },
      setTextAlign: function setTextAlign(textAlign) {
        if (textAlign !== this.currentTextAlign) {
          this.currentTextAlign = textAlign;
          this.scheduleRefresh();
        }

        if (this.$style && textAlign !== this.$style.getTextAlign()) {
          this.$style.setTextAlign(textAlign);
          this.scheduleRefresh();
        }
      },
      getTextBaseline: function getTextBaseline() {
        var _this$$style12;

        return coalesce((_this$$style12 = this.$style) === null || _this$$style12 === void 0 ? void 0 : _this$$style12.getTextBaseline(), this.currentTextBaseline);
      },
      setTextBaseline: function setTextBaseline(textBaseline) {
        if (textBaseline !== this.currentTextBaseline) {
          this.currentTextBaseline = textBaseline;
          this.scheduleRefresh();
        }

        if (this.$style && textBaseline !== this.$style.getTextBaseline()) {
          this.$style.setTextBaseline(textBaseline);
          this.scheduleRefresh();
        }
      },
      getFillStyleTarget: function getFillStyleTarget() {
        return this.$style;
      },
      getStrokeStyleTarget: function getStrokeStyleTarget() {
        return this.$style;
      },
      getBackgroundFill: function getBackgroundFill() {
        return this._bgFill;
      },
      setBackgroundFill: function setBackgroundFill(fill) {
        var _fill;

        fill = ((_fill = fill) === null || _fill === void 0 ? void 0 : _fill.$fill) || fill;
        fill || (fill = undefined);

        if (fill !== this._bgFill) {
          var _fill2;

          this._bgFill = fill;
          this._bgFillVm = ((_fill2 = fill) === null || _fill2 === void 0 ? void 0 : _fill2.vm) && fill.vm[0];
          this.scheduleRefresh();
        }

        if (this.$style && fill !== this.$style.getBackgroundFill()) {
          this.$style.setBackgroundFill(fill);
          this.scheduleRefresh();
        }
      },
      getBackgroundStroke: function getBackgroundStroke() {
        return this._bgStroke;
      },
      setBackgroundStroke: function setBackgroundStroke(stroke) {
        var _stroke;

        stroke = ((_stroke = stroke) === null || _stroke === void 0 ? void 0 : _stroke.$stroke) || stroke;
        stroke || (stroke = undefined);

        if (stroke !== this._bgStroke) {
          var _stroke2;

          this._bgStroke = stroke;
          this._bgStrokeVm = ((_stroke2 = stroke) === null || _stroke2 === void 0 ? void 0 : _stroke2.vm) && stroke.vm[0];
          this.scheduleRefresh();
        }

        if (this.$style && stroke !== this.$style.getBackgroundStroke()) {
          this.$style.setBackgroundStroke(stroke);
          this.scheduleRefresh();
        }
      }
    }
  };

  function defineServices$4() {
    var _this4 = this;

    Object.defineProperties(this, {
      $textStyleContainer: {
        enumerable: true,
        get: function get() {
          var _this4$$services;

          return (_this4$$services = _this4.$services) === null || _this4$$services === void 0 ? void 0 : _this4$$services.textStyleContainer;
        }
      },
      $bgFill: {
        enumerable: true,
        get: this.getBackgroundFill
      },
      $bgFillVm: {
        enumerable: true,
        get: function get() {
          return _this4._bgFillVm;
        }
      },
      $bgStroke: {
        enumerable: true,
        get: this.getBackgroundStroke
      },
      $bgStrokeVm: {
        enumerable: true,
        get: function get() {
          return _this4._bgStrokeVm;
        }
      }
    });
  }

  /* script */
  var __vue_script__$y = script$y;
  /* template */

  var __vue_render__$5 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('i', {
      class: _vm.vmClass,
      staticStyle: {
        "display": "none !important"
      },
      attrs: {
        "id": _vm.vmId
      }
    }, [_vm._t("default", [_c('FillStyle', {
      attrs: {
        "id": 'vl-' + _vm.currentId + '-default-fill-style',
        "color": "#333"
      }
    }), _vm._v(" "), _c('StrokeStyle', {
      attrs: {
        "id": 'vl-' + _vm.currentId + '-default-stroke-style',
        "color": "#eee"
      }
    })]), _vm._v(" "), _c('BackgroundStyle', {
      attrs: {
        "id": 'vl-' + _vm.currentId + '-background-style'
      }
    }, [_vm._t("background")], 2)], 2);
  };

  var __vue_staticRenderFns__$5 = [];
  /* style */

  var __vue_inject_styles__$y = undefined;
  /* scoped */

  var __vue_scope_id__$y = undefined;
  /* module identifier */

  var __vue_module_identifier__$y = undefined;
  /* functional template */

  var __vue_is_functional_template__$y = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$y = /*#__PURE__*/normalizeComponent({
    render: __vue_render__$5,
    staticRenderFns: __vue_staticRenderFns__$5
  }, __vue_inject_styles__$y, __vue_script__$y, __vue_scope_id__$y, __vue_is_functional_template__$y, __vue_module_identifier__$y, false, undefined, undefined, undefined);

  function plugin$v(Vue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$v.installed) {
      return;
    }

    plugin$v.installed = true;
    options = pick(options, 'dataProjection');
    Object.assign(__vue_component__$D, options);
    Object.assign(__vue_component__$F, options);
    Object.assign(__vue_component__$C, options);
    Object.assign(__vue_component__$B, options);
    Object.assign(__vue_component__$E, options);
    Object.assign(__vue_component__$A, options);
    Object.assign(__vue_component__$y, options);
    Vue.component(__vue_component__$D.name, __vue_component__$D);
    Vue.component(__vue_component__$F.name, __vue_component__$F);
    Vue.component(__vue_component__$C.name, __vue_component__$C);
    Vue.component(__vue_component__$B.name, __vue_component__$B);
    Vue.component(__vue_component__$E.name, __vue_component__$E);
    Vue.component(__vue_component__$A.name, __vue_component__$A);
    Vue.component(__vue_component__$y.name, __vue_component__$y); // todo remove in v0.13.x

    Vue.component('VlStyleBox', {
      name: 'VlStyleBox',
      extends: __vue_component__$A,
      created: function created() {
      }
    });
  }

  var Style = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': plugin$v,
    install: plugin$v,
    CircleStyle: __vue_component__$D,
    FillStyle: __vue_component__$F,
    IconStyle: __vue_component__$C,
    RegShapeStyle: __vue_component__$B,
    StrokeStyle: __vue_component__$E,
    Style: __vue_component__$A,
    TextStyle: __vue_component__$y
  });

  var script$x = {
    name: 'VlLayerGraticuleLatStyleAdapter',
    mixins: [stubVNode, textStyleContainer, olCmp],
    stubVNode: {
      empty: false,
      attrs: function attrs() {
        return {
          id: this.vmId,
          class: this.vmClass
        };
      }
    },
    computed: {
      text: function text() {
        if (!(this.rev && this.$text)) return;
        return dumpTextStyle(this.$text);
      }
    },
    watch: {
      text: {
        deep: true,
        handler: function handler(value, prev) {
          if (!isEqual(value, prev)) return;
          this.$emit('update:text', value && clonePlainObject(value));
        }
      }
    },
    created: function created() {
      var _this = this;

      Object.defineProperties(this, {
        $latStyleContainer: {
          enumerable: true,
          get: function get() {
            var _this$$services;

            return (_this$$services = _this.$services) === null || _this$$services === void 0 ? void 0 : _this$$services.latStyleContainer;
          }
        }
      });
    },
    methods: {
      createOlObject: function createOlObject() {
        var obj = stubObject();
        obj.id = this.currentId;
        return obj;
      },
      getServices: function getServices() {
        return mergeDescriptors(olCmp.methods.getServices.call(this), textStyleContainer.methods.getServices.call(this));
      },
      getTextStyleTarget: function getTextStyleTarget() {
        var _this2 = this;

        return {
          getText: function getText() {
            var _this2$$latStyleConta;

            return (_this2$$latStyleConta = _this2.$latStyleContainer) === null || _this2$$latStyleConta === void 0 ? void 0 : _this2$$latStyleConta.getLatLabelStyle();
          },
          setText: function setText(style) {
            var _this2$$latStyleConta2;

            return (_this2$$latStyleConta2 = _this2.$latStyleContainer) === null || _this2$$latStyleConta2 === void 0 ? void 0 : _this2$$latStyleConta2.setLatLabelStyle(style);
          }
        };
      }
    }
  };

  /* script */
  var __vue_script__$x = script$x;
  /* template */

  /* style */

  var __vue_inject_styles__$x = undefined;
  /* scoped */

  var __vue_scope_id__$x = undefined;
  /* module identifier */

  var __vue_module_identifier__$x = undefined;
  /* functional template */

  var __vue_is_functional_template__$x = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$x = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$x, __vue_script__$x, __vue_scope_id__$x, __vue_is_functional_template__$x, __vue_module_identifier__$x, false, undefined, undefined, undefined);

  var script$w = {
    name: 'VlLayerGraticuleLonStyleAdapter',
    mixins: [stubVNode, textStyleContainer, olCmp],
    stubVNode: {
      empty: false,
      attrs: function attrs() {
        return {
          id: this.vmId,
          class: this.vmClass
        };
      }
    },
    computed: {
      text: function text() {
        if (!(this.rev && this.$text)) return;
        return dumpTextStyle(this.$text);
      }
    },
    watch: {
      text: {
        deep: true,
        handler: function handler(value, prev) {
          if (!isEqual(value, prev)) return;
          this.$emit('update:text', value && clonePlainObject(value));
        }
      }
    },
    created: function created() {
      var _this = this;

      Object.defineProperties(this, {
        $lonStyleContainer: {
          enumerable: true,
          get: function get() {
            var _this$$services;

            return (_this$$services = _this.$services) === null || _this$$services === void 0 ? void 0 : _this$$services.lonStyleContainer;
          }
        }
      });
    },
    methods: {
      createOlObject: function createOlObject() {
        var obj = stubObject();
        obj.id = this.currentId;
        return obj;
      },
      getServices: function getServices() {
        return mergeDescriptors(olCmp.methods.getServices.call(this), textStyleContainer.methods.getServices.call(this));
      },
      getTextStyleTarget: function getTextStyleTarget() {
        var _this2 = this;

        return {
          getText: function getText() {
            var _this2$$lonStyleConta;

            return (_this2$$lonStyleConta = _this2.$lonStyleContainer) === null || _this2$$lonStyleConta === void 0 ? void 0 : _this2$$lonStyleConta.getLonLabelStyle();
          },
          setText: function setText(style) {
            var _this2$$lonStyleConta2;

            return (_this2$$lonStyleConta2 = _this2.$lonStyleContainer) === null || _this2$$lonStyleConta2 === void 0 ? void 0 : _this2$$lonStyleConta2.setLonLabelStyle(style);
          }
        };
      }
    }
  };

  /* script */
  var __vue_script__$w = script$w;
  /* template */

  /* style */

  var __vue_inject_styles__$w = undefined;
  /* scoped */

  var __vue_scope_id__$w = undefined;
  /* module identifier */

  var __vue_module_identifier__$w = undefined;
  /* functional template */

  var __vue_is_functional_template__$w = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$w = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$w, __vue_script__$w, __vue_scope_id__$w, __vue_is_functional_template__$w, __vue_module_identifier__$w, false, undefined, undefined, undefined);

  var script$v = {
    name: 'VlLayerGraticuleStrokeStyleAdapter',
    mixins: [stubVNode, strokeStyleContainer, olCmp],
    stubVNode: {
      empty: false,
      attrs: function attrs() {
        return {
          id: this.vmId,
          class: this.vmClass
        };
      }
    },
    computed: {
      stroke: function stroke() {
        if (!(this.rev && this.$stroke)) return;
        return dumpStrokeStyle(this.$stroke);
      }
    },
    watch: {
      stroke: {
        deep: true,
        handler: function handler(value, prev) {
          if (isEqual(value, prev)) return;
          this.$emit('update:stroke', value && clonePlainObject(value));
        }
      }
    },
    created: function created() {
      var _this = this;

      Object.defineProperties(this, {
        $strokeStyleContainer: {
          enumerable: true,
          get: function get() {
            var _this$$services;

            return (_this$$services = _this.$services) === null || _this$$services === void 0 ? void 0 : _this$$services.strokeStyleContainer;
          }
        }
      });
    },
    methods: {
      createOlObject: function createOlObject() {
        var obj = stubObject();
        obj.id = this.currentId;
        return obj;
      },
      getServices: function getServices() {
        return mergeDescriptors(olCmp.methods.getServices.call(this), strokeStyleContainer.methods.getServices.call(this));
      },
      getStrokeStyleTarget: function getStrokeStyleTarget() {
        var _this2 = this;

        return {
          setStroke: function setStroke(style) {
            return _this2.$strokeStyleContainer.setStrokeStyle(style);
          },
          getStroke: function getStroke() {
            return _this2.$strokeStyleContainer.getStrokeStyle();
          }
        };
      }
    }
  };

  /* script */
  var __vue_script__$v = script$v;
  /* template */

  /* style */

  var __vue_inject_styles__$v = undefined;
  /* scoped */

  var __vue_scope_id__$v = undefined;
  /* module identifier */

  var __vue_module_identifier__$v = undefined;
  /* functional template */

  var __vue_is_functional_template__$v = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$v = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$v, __vue_script__$v, __vue_scope_id__$v, __vue_is_functional_template__$v, __vue_module_identifier__$v, false, undefined, undefined, undefined);

  function ownKeys$n(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$n(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$n(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$n(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var script$u = {
    name: 'VlLayerGraticule',
    components: {
      LonStyle: __vue_component__$w,
      LatStyle: __vue_component__$x,
      GStrokeStyle: __vue_component__$v,
      TextStyle: __vue_component__$y,
      FillStyle: __vue_component__$F,
      StrokeStyle: __vue_component__$E
    },
    mixins: [vectorLayer],
    props: {
      // ol/layer/Graticule
      maxLines: {
        type: Number,
        default: 100
      },
      targetSize: {
        type: Number,
        default: 100
      },
      showLabels: {
        type: Boolean,
        default: false
      },
      lonLabelFormatter: Function,
      latLabelFormatter: Function,
      lonLabelPosition: {
        type: Number,
        default: 0
      },
      latLabelPosition: {
        type: Number,
        default: 1
      },
      intervals: {
        type: Array,
        default: function _default() {
          return [90, 45, 30, 20, 10, 5, 2, 1, 0.5, 0.2, 0.1, 0.05, 0.01, 0.005, 0.002, 0.001];
        }
      },
      wrapX: {
        type: Boolean,
        default: true
      }
    },
    computed: {
      inputIntervals: function inputIntervals() {
        var _this$intervals;

        return (_this$intervals = this.intervals) === null || _this$intervals === void 0 ? void 0 : _this$intervals.slice();
      },
      meridians: function meridians() {
        var _this = this;

        if (!this.rev) return [];
        return map$1(this.getMeridians(), function (geom) {
          return _this.writeGeometryInDataProj(geom);
        });
      },
      parallels: function parallels() {
        var _this2 = this;

        if (!this.rev) return [];
        return map$1(this.getParallels(), function (geom) {
          return _this2.writeGeometryInDataProj(geom);
        });
      },
      lonLabelStyle: function lonLabelStyle() {
        if (!(this.rev && this.$lonLabelStyle)) return;
        return dumpTextStyle(this.$lonLabelStyle);
      },
      latLabelStyle: function latLabelStyle() {
        if (!(this.rev && this.$latLabelStyle)) return;
        return dumpTextStyle(this.$latLabelStyle);
      },
      strokeStyle: function strokeStyle() {
        if (!(this.rev && this.$strokeStyle)) return;
        return dumpStrokeStyle(this.$strokeStyle);
      }
    },
    watch: _objectSpread$n({
      meridians: {
        deep: true,
        handler: function handler(value, prev) {
          if (isEqual(value, prev)) return;
          this.$emit('update:meridians', clonePlainObject(value));
        }
      },
      parallels: {
        deep: true,
        handler: function handler(value, prev) {
          if (isEqual(value, prev)) return;
          this.$emit('update:parallels', clonePlainObject(value));
        }
      },
      lonLabelStyle: {
        deep: true,
        handler: function handler(value, prev) {
          if (isEqual(value, prev)) return;
          this.$emit('update:lonLabelStyle', value && clonePlainObject(value));
        }
      },
      latLabelStyle: {
        deep: true,
        handler: function handler(value, prev) {
          if (isEqual(value, prev)) return;
          this.$emit('update:latLabelStyle', value && clonePlainObject(value));
        }
      },
      strokeStyle: {
        deep: true,
        handler: function handler(value, prev) {
          if (isEqual(value, prev)) return;
          this.$emit('update:strokeStyle', value && clonePlainObject(value));
        }
      }
    }, /*#__PURE__*/makeChangeOrRecreateWatchers(['maxLines', 'targetSize', 'showLabels', 'lonLabelFormatter', 'latLabelFormatter', 'lonLabelPosition', 'latLabelPosition', 'inputIntervals', 'wrapX'], ['inputIntervals'])),
    created: function created() {
      this._lonLabelStyle = undefined;
      this._lonLabelStyleVm = undefined;
      this._latLabelStyle = undefined;
      this._latLabelStyleVm = undefined;
      this._strokeStyle = undefined;
      this._strokeStyleVm = undefined;
      Object.defineProperties(this, {
        $lonLabelStyle: {
          enumerable: true,
          get: this.getLonLabelStyle
        },
        $lonLabelStyleVm: {
          enumerable: true,
          get: this.getLonLabelStyleVm
        },
        $latLabelStyle: {
          enumerable: true,
          get: this.getLatLabelStyle
        },
        $latLabelStyleVm: {
          enumerable: true,
          get: this.getLatLabelStyleVm
        },
        $strokeStyle: {
          enumerable: true,
          get: this.getStrokeStyle
        },
        $strokeStyleVm: {
          enumerable: true,
          get: this.getStrokeStyleVm
        }
      });
    },
    methods: {
      createLayer: function createLayer() {
        return new GraticuleLayer__default['default']({
          // ol/layer/Base
          className: this.className,
          opacity: this.currentOpacity,
          visible: this.currentVisible,
          extent: this.currentExtentViewProj,
          zIndex: this.currentZIndex,
          minResolution: this.currentMinResolution,
          maxResolution: this.currentMaxResolution,
          minZoom: this.currentMinZoom,
          maxZoom: this.currentMaxZoom,
          // ol/layer/Layer
          render: this.render,
          // ol/layer/Vector
          renderOrder: this.renderOrder,
          renderBuffer: this.renderBuffer,
          declutter: this.declutter,
          updateWhileAnimating: this.updateWhileAnimating,
          updateWhileInteracting: this.updateWhileInteracting,
          style: this.$style,
          // ol/layer/Graticule
          maxLines: this.maxLines,
          strokeStyle: this.$strokeStyle,
          targetSize: this.targetSize,
          showLabels: this.showLabels,
          lonLabelFormatter: this.lonLabelFormatter,
          latLabelFormatter: this.latLabelFormatter,
          lonLabelPosition: this.lonLabelPosition,
          latLabelPosition: this.latLabelPosition,
          lonLabelStyle: this.$lonLabelStyle,
          latLabelStyle: this.$latLabelStyle,
          intervals: this.inputIntervals,
          wrapX: this.wrapX
        });
      },
      getServices: function getServices() {
        var vm = this;
        return mergeDescriptors(vectorLayer.methods.getServices.call(this), {
          get lonStyleContainer() {
            return vm;
          },

          get latStyleContainer() {
            return vm;
          },

          get strokeStyleContainer() {
            return vm;
          }

        });
      },
      getMeridians: function getMeridians() {
        var _this$$layer;

        return coalesce((_this$$layer = this.$layer) === null || _this$$layer === void 0 ? void 0 : _this$$layer.getMeridians(), []);
      },
      getParallels: function getParallels() {
        var _this$$layer2;

        return coalesce((_this$$layer2 = this.$layer) === null || _this$$layer2 === void 0 ? void 0 : _this$$layer2.getParallels(), []);
      },
      getLonLabelStyle: function getLonLabelStyle() {
        return this._lonLabelStyle;
      },
      getLonLabelStyleVm: function getLonLabelStyleVm() {
        return this._lonLabelStyleVm;
      },
      setLonLabelStyle: function setLonLabelStyle(style) {
        var _style, _style2, _style3;

        style = ((_style = style) === null || _style === void 0 ? void 0 : _style.$style) || style;
        style || (style = undefined);
        assert$1(!style || style instanceof style$1.Text, 'Invalid lon label style');
        if (style === this._lonLabelStyle) return;
        this._lonLabelStyle = style;
        this._lonLabelStyleVm = ((_style2 = style) === null || _style2 === void 0 ? void 0 : _style2.vm) && ((_style3 = style) === null || _style3 === void 0 ? void 0 : _style3.vm[0]);

        this.scheduleRecreate();
      },
      getLatLabelStyle: function getLatLabelStyle() {
        return this._latLabelStyle;
      },
      getLatLabelStyleVm: function getLatLabelStyleVm() {
        return this._latLabelStyleVm;
      },
      setLatLabelStyle: function setLatLabelStyle(style) {
        var _style4, _style5, _style6;

        style = ((_style4 = style) === null || _style4 === void 0 ? void 0 : _style4.$style) || style;
        style || (style = undefined);
        assert$1(!style || style instanceof style$1.Text, 'Invalid lat label style');
        if (style === this._latLabelStyle) return;
        this._latLabelStyle = style;
        this._latLabelStyleVm = ((_style5 = style) === null || _style5 === void 0 ? void 0 : _style5.vm) && ((_style6 = style) === null || _style6 === void 0 ? void 0 : _style6.vm[0]);

        this.scheduleRecreate();
      },
      getStrokeStyle: function getStrokeStyle() {
        return this._strokeStyle;
      },
      getStrokeStyleVm: function getStrokeStyleVm() {
        return this._strokeStyleVm;
      },
      setStrokeStyle: function setStrokeStyle(style) {
        var _style7, _style8, _style9;

        style = (_style7 = style) === null || _style7 === void 0 ? void 0 : _style7.$style;
        style || (style = undefined);
        assert$1(!style || style instanceof style$1.Stroke, 'Invalid stroke style');
        if (style === this._strokeStyle) return;
        this._strokeStyle = style;
        this._strokeStyleVm = ((_style8 = style) === null || _style8 === void 0 ? void 0 : _style8.vm) && ((_style9 = style) === null || _style9 === void 0 ? void 0 : _style9.vm[0]);

        this.scheduleRecreate();
      }
    }
  };

  /* script */
  var __vue_script__$u = script$u;
  /* template */

  var __vue_render__$4 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('i', {
      class: _vm.vmClass,
      staticStyle: {
        "display": "none !important"
      },
      attrs: {
        "id": _vm.vmId
      }
    }, [_c('LonStyle', {
      attrs: {
        "id": 'vl-' + _vm.currentId + '-lon-style'
      }
    }, [_vm._t("lon", [_c('TextStyle', {
      attrs: {
        "id": 'vl-' + _vm.currentId + '-default-text-style',
        "font": "'12px sans-serif'",
        "text-baseline": "bottom"
      }
    }, [_c('FillStyle', {
      attrs: {
        "id": 'vl-' + _vm.currentId + '-default-fill-style',
        "color": "rgba(0,0,0,1)"
      }
    }), _vm._v(" "), _c('StrokeStyle', {
      attrs: {
        "id": 'vl-' + _vm.currentId + '-default-stroke-style',
        "color": "rgba(255,255,255,1)",
        "width": 3
      }
    })], 1)])], 2), _vm._v(" "), _c('LatStyle', {
      attrs: {
        "id": 'vl-' + _vm.currentId + '-lat-style'
      }
    }, [_vm._t("lat", [_c('TextStyle', {
      attrs: {
        "id": 'vl-' + _vm.currentId + '-default-text-style',
        "font": "'12px Calibri,sans-serif'",
        "text-baseline": "bottom"
      }
    }, [_c('FillStyle', {
      attrs: {
        "id": 'vl-' + _vm.currentId + '-default-fill-style',
        "color": "rgba(0,0,0,1)"
      }
    }), _vm._v(" "), _c('StrokeStyle', {
      attrs: {
        "id": 'vl-' + _vm.currentId + '-default-stroke-style',
        "color": "rgba(255,255,255,1)",
        "width": 3
      }
    })], 1)])], 2), _vm._v(" "), _c('GStrokeStyle', {
      attrs: {
        "id": 'vl-' + _vm.currentId + '-graticule-style'
      }
    }, [_vm._t("stroke", [_c('StrokeStyle', {
      attrs: {
        "id": 'vl-' + _vm.currentId + '-default-graticule-stroke-style',
        "color": "rgba(0,0,0,0.2)"
      }
    })])], 2)], 1);
  };

  var __vue_staticRenderFns__$4 = [];
  /* style */

  var __vue_inject_styles__$u = undefined;
  /* scoped */

  var __vue_scope_id__$u = undefined;
  /* module identifier */

  var __vue_module_identifier__$u = undefined;
  /* functional template */

  var __vue_is_functional_template__$u = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$u = /*#__PURE__*/normalizeComponent({
    render: __vue_render__$4,
    staticRenderFns: __vue_staticRenderFns__$4
  }, __vue_inject_styles__$u, __vue_script__$u, __vue_scope_id__$u, __vue_is_functional_template__$u, __vue_module_identifier__$u, false, undefined, undefined, undefined);

  function plugin$u(Vue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$u.installed) {
      return;
    }

    plugin$u.installed = true;
    options = pick(options, 'dataProjection');
    Object.assign(__vue_component__$u, options);
    Vue.component(__vue_component__$u.name, __vue_component__$u); // todo remove in v0.13.x

    Vue.component('VlGraticule', {
      name: 'VlGraticule',
      extends: __vue_component__$u,
      created: function created() {
      }
    });
  }

  var GraticuleLayer = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': plugin$u,
    install: plugin$u,
    Layer: __vue_component__$u
  });

  var script$t = {
    name: 'VlLayerGroup',
    mixins: [layersContainer, baseLayer],
    computed: {
      layers: function layers() {
        if (!this.rev) return [];
        return map$1(this.getLayers(), function (layer) {
          return {
            id: getLayerId(layer),
            type: layer.constructor.name
          };
        });
      }
    },
    watch: {
      layers: {
        deep: true,
        handler: function handler(value, prev) {
          if (isEqual(value, prev)) return;
          this.$emit('update:layers', value.slice());
        }
      }
    },
    methods: {
      createLayer: function createLayer() {
        return new layer$1.Group({
          // ol/layer/Base
          className: this.className,
          opacity: this.currentOpacity,
          visible: this.currentVisible,
          extent: this.currentExtentViewProj,
          zIndex: this.currentZIndex,
          minResolution: this.currentMinResolution,
          maxResolution: this.currentMaxResolution,
          minZoom: this.currentMinZoom,
          maxZoom: this.currentMaxZoom,
          // ol/layer/Group
          layers: this.$layersCollection
        });
      },
      getServices: function getServices() {
        return mergeDescriptors(baseLayer.methods.getServices.call(this), layersContainer.methods.getServices.call(this));
      },
      subscribeAll: function subscribeAll() {
        layersContainer.methods.subscribeAll.call(this);
        baseLayer.methods.subscribeAll.call(this);
      }
    }
  };

  /* script */
  var __vue_script__$t = script$t;
  /* template */

  /* style */

  var __vue_inject_styles__$t = undefined;
  /* scoped */

  var __vue_scope_id__$t = undefined;
  /* module identifier */

  var __vue_module_identifier__$t = undefined;
  /* functional template */

  var __vue_is_functional_template__$t = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$t = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$t, __vue_script__$t, __vue_scope_id__$t, __vue_is_functional_template__$t, __vue_module_identifier__$t, false, undefined, undefined, undefined);

  function plugin$t(Vue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$t.installed) {
      return;
    }

    plugin$t.installed = true;
    options = pick(options, 'dataProjection');
    Object.assign(__vue_component__$t, options);
    Vue.component(__vue_component__$t.name, __vue_component__$t);
  }

  var GroupLayer = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': plugin$t,
    install: plugin$t,
    Layer: __vue_component__$t
  });

  function ownKeys$m(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$m(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$m(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$m(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var script$s = {
    name: 'VlLayerHeatmap',
    mixins: [vectorLayer],
    props: {
      /**
       * @type {string[]}
       */
      gradient: {
        type: Array,
        default: function _default() {
          return ['#0000ff', '#00ffff', '#00ff00', '#ffff00', '#ff0000'];
        }
      },

      /**
       * @type {number}
       */
      radius: {
        type: Number,
        default: 8
      },

      /**
       * @type {number}
       */
      blur: {
        type: Number,
        default: 15
      },

      /**
       * @type {string}
       */
      weight: {
        type: [String, Function],
        default: 'weight'
      }
    },
    data: function data() {
      return {
        currentGradient: this.gradient.slice(),
        currentRadius: this.radius,
        currentBlur: this.blur
      };
    },
    computed: {
      inputGradient: function inputGradient() {
        return this.gradient.slice();
      }
    },
    watch: _objectSpread$m({
      rev: function rev() {
        if (!this.$layer) return;

        if (!isEqual(this.currentGradient, this.$layer.getGradient())) {
          this.currentGradient = this.$layer.getGradient();
        }

        if (this.currentRadius !== this.$layer.getRadius()) {
          this.currentRadius = this.$layer.getRadius();
        }

        if (this.currentBlur !== this.$layer.getBlur()) {
          this.currentBlur = this.$layer.getBlur();
        }
      },
      inputGradient: function inputGradient(value) {
        this.setGradient(value);
      },
      currentGradient: {
        deep: true,
        handler: function handler(value) {
          if (isEqual(value, this.inputGradient)) return;
          this.$emit('update:gradient', value.slice());
        }
      },
      radius: function radius(value) {
        this.setRadius(value);
      },
      currentRadius: function currentRadius(value) {
        if (value === this.radius) return;
        this.$emit('update:radius', value);
      },
      blur: function blur(value) {
        this.setBlur(value);
      },
      currentBlur: function currentBlur(value) {
        if (value === this.blur) return;
        this.$emit('update:blur', value);
      }
    }, /*#__PURE__*/makeChangeOrRecreateWatchers(['weight'])),
    methods: {
      /**
       * @returns {HeatmapLayer}
       */
      createLayer: function createLayer() {
        return new layer$1.Heatmap({
          // ol/layer/Base
          className: this.className,
          opacity: this.currentOpacity,
          visible: this.currentVisible,
          extent: this.currentExtentViewProj,
          zIndex: this.currentZIndex,
          minResolution: this.currentMinResolution,
          maxResolution: this.currentMaxResolution,
          minZoom: this.currentMinZoom,
          maxZoom: this.currentMaxZoom,
          // ol/layer/Layer
          render: this.render,
          source: this.$source,
          // ol/layer/BaseVector
          renderOrder: this.renderOrder,
          renderBuffer: this.renderBuffer,
          declutter: this.declutter,
          updateWhileAnimating: this.updateWhileAnimating,
          updateWhileInteracting: this.updateWhileInteracting,
          style: this.$style,
          // ol/layer/Heatmap
          blur: this.currentBlur,
          gradient: this.currentGradient,
          radius: this.currentRadius,
          weight: this.weight
        });
      },
      subscribeAll: function subscribeAll() {
        vectorLayer.methods.subscribeAll.call(this);
        subscribeToLayerEvents.call(this);
      },
      getBlur: function getBlur() {
        var _this$$layer;

        return coalesce((_this$$layer = this.$layer) === null || _this$$layer === void 0 ? void 0 : _this$$layer.getBlur(), this.currentBlur);
      },
      setBlur: function setBlur(blur) {
        blur = Number(blur);
        assert$1(isNumber$1(blur), 'Invalid blur');

        if (blur !== this.currentBlur) {
          this.currentBlur = blur;
        }

        if (this.$layer && blur !== this.$layer.getBlur()) {
          this.$layer.setBlur(blur);
        }
      },
      getGradient: function getGradient() {
        var _this$$layer2;

        return coalesce((_this$$layer2 = this.$layer) === null || _this$$layer2 === void 0 ? void 0 : _this$$layer2.getGradient(), this.currentGradient);
      },
      setGradient: function setGradient(gradient) {
        assert$1(isArray$2(gradient), 'Invalid gradient');
        gradient = gradient.slice();

        if (!isEqual(gradient, this.currentGradient)) {
          this.currentGradient = gradient;
        }

        if (this.$layer && !isEqual(gradient, this.$layer.getGradient())) {
          this.$layer.setGradient(gradient);
        }
      },
      getRadius: function getRadius() {
        var _this$$layer3;

        return coalesce((_this$$layer3 = this.$layer) === null || _this$$layer3 === void 0 ? void 0 : _this$$layer3.getRadius(), this.currentRadius);
      },
      setRadius: function setRadius(radius) {
        radius = Number(radius);
        assert$1(isNumber$1(radius), 'Invalid radius');

        if (radius !== this.currentRadius) {
          this.currentRadius = radius;
        }

        if (this.$layer && radius !== this.$layer.getRadius()) {
          this.$layer.setRadius(radius);
        }
      }
    }
  };

  function subscribeToLayerEvents() {
    var _this = this;

    var setterKey = addPrefix('set');
    var propChanges = fromOlChangeEvent(this.$layer, ['blur', 'gradient', 'radius'], true, function (evt) {
      return _objectSpread$m(_objectSpread$m({}, evt), {}, {
        setter: _this[setterKey(evt.prop)]
      });
    });
    this.subscribeTo(propChanges, function (_ref) {
      var setter = _ref.setter,
          value = _ref.value;
      return setter(value);
    });
  }

  /* script */
  var __vue_script__$s = script$s;
  /* template */

  /* style */

  var __vue_inject_styles__$s = undefined;
  /* scoped */

  var __vue_scope_id__$s = undefined;
  /* module identifier */

  var __vue_module_identifier__$s = undefined;
  /* functional template */

  var __vue_is_functional_template__$s = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$s = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$s, __vue_script__$s, __vue_scope_id__$s, __vue_is_functional_template__$s, __vue_module_identifier__$s, false, undefined, undefined, undefined);

  function plugin$s(Vue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$s.installed) {
      return;
    }

    plugin$s.installed = true;
    options = pick(options, 'dataProjection');
    Object.assign(__vue_component__$s, options);
    Vue.component(__vue_component__$s.name, __vue_component__$s);
  }

  var HeatmapLayer = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': plugin$s,
    install: plugin$s,
    Layer: __vue_component__$s
  });

  function ownKeys$l(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$l(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$l(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$l(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var validateUrl$1 = /*#__PURE__*/and(isString, negate(isEmpty$2));
  var script$r = {
    name: 'VlSourceImageArcgisRest',
    mixins: [arcgisSource, imageSource],
    props: {
      // ol/source/ImageArcGISRest
      crossOrigin: String,
      imageLoadFunction: Function,

      /**
       * @deprecated
       * @todo remove later
       */
      imageLoadFunc: Function,
      imageSmoothing: {
        type: Boolean,
        default: true
      },
      ratio: {
        type: Number,
        default: 1.5
      },
      url: {
        type: String,
        required: true,
        validator: validateUrl$1
      }
    },
    data: function data() {
      return {
        currentImageLoadFunction: this.imageLoadFunction,
        currentUrl: this.url
      };
    },
    computed: {
      inputImageLoadFunction: function inputImageLoadFunction() {
        return this.imageLoadFunction || this.imageLoadFunc;
      }
    },
    watch: _objectSpread$l({
      rev: function rev() {
        if (!this.$source) return;

        if (this.currentImageLoadFunction !== this.$source.getImageLoadFunction()) {
          this.currentImageLoadFunction = this.$source.getImageLoadFunction();
        }

        if (this.currentUrl !== this.$source.getUrl()) {
          this.currentUrl = this.$source.getUrl();
        }
      },
      url: function url(value) {
        this.setUrl(value);
      },
      currentUrl: function currentUrl(value) {
        if (value === this.url) return;
        this.$emit('update:url', value);
      },
      inputImageLoadFunction: function inputImageLoadFunction(value) {
        this.setImageLoadFunction(value);
      },
      currentImageLoadFunction: function currentImageLoadFunction(value) {
        if (value === this.imageLoadFunction) return;
        this.$emit('update:imageLoadFunction', value);
      }
    }, /*#__PURE__*/makeChangeOrRecreateWatchers(['crossOrigin', 'imageSmoothing', 'ratio'])),
    created: function created() {

      this.currentImageLoadFunction = this.inputImageLoadFunction;
    },
    updated: function updated() {
    },
    methods: {
      createSource: function createSource() {
        return new source$1.ImageArcGISRest({
          // ol/source/Source
          attributions: this.currentAttributions,
          projection: this.resolvedDataProjection,
          // ol/source/Image
          resolutions: this.inputResolutions,
          // ol/source/ImageArcGISRest
          crossOrigin: this.crossOrigin,
          hidpi: this.hidpi,
          imageLoadFunction: this.currentImageLoadFunction,
          imageSmoothing: this.imageSmoothing,
          params: this.currentParams,
          ratio: this.ratio,
          url: this.currentUrl
        });
      },
      getUrl: function getUrl() {
        var _this$$source;

        return coalesce((_this$$source = this.$source) === null || _this$$source === void 0 ? void 0 : _this$$source.getUrl(), this.currentUrl);
      },
      setUrl: function setUrl(url) {
        assert$1(validateUrl$1(url), 'Invalid url');

        if (url !== this.currentUrl) {
          this.currentUrl = url;
        }

        if (this.$source && url !== this.$source.getUrl()) {
          this.$source.setUrl(url);
        }
      },
      getImageLoadFunction: function getImageLoadFunction() {
        var _this$$source2;

        return coalesce((_this$$source2 = this.$source) === null || _this$$source2 === void 0 ? void 0 : _this$$source2.getImageLoadFunction(), this.currentImageLoadFunction);
      },
      setImageLoadFunction: function setImageLoadFunction(func) {
        assert$1(isFunction$1(func), 'Invalid image load function');

        if (func !== this.currentImageLoadFunction) {
          this.currentImageLoadFunction = func;
        }

        if (this.$source && func !== this.$source.getImageLoadFunction()) {
          this.$source.setImageLoadFunction(func);
        }
      },
      stateChanged: noop$1
    }
  };

  /* script */
  var __vue_script__$r = script$r;
  /* template */

  /* style */

  var __vue_inject_styles__$r = undefined;
  /* scoped */

  var __vue_scope_id__$r = undefined;
  /* module identifier */

  var __vue_module_identifier__$r = undefined;
  /* functional template */

  var __vue_is_functional_template__$r = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$r = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$r, __vue_script__$r, __vue_scope_id__$r, __vue_is_functional_template__$r, __vue_module_identifier__$r, false, undefined, undefined, undefined);

  function plugin$r(Vue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$r.installed) {
      return;
    }

    plugin$r.installed = true;
    options = pick(options, 'dataProjection');
    Object.assign(__vue_component__$r, options);
    Vue.component(__vue_component__$r.name, __vue_component__$r);
  }

  var ImageArcgisRestSource = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': plugin$r,
    install: plugin$r,
    Source: __vue_component__$r
  });

  /**
   * Layer for server-rendered images that are available for arbitrary extents and resolutions.
   */

  var script$q = {
    name: 'VlLayerImage',
    mixins: [imageLayer],
    methods: {
      /**
       * @return {Image}
       * @protected
       */
      createLayer: function createLayer() {
        return new layer$1.Image({
          // ol/layer/Base
          className: this.className,
          opacity: this.currentOpacity,
          visible: this.currentVisible,
          extent: this.currentExtentViewProj,
          zIndex: this.currentZIndex,
          minResolution: this.currentMinResolution,
          maxResolution: this.currentMaxResolution,
          minZoom: this.currentMinZoom,
          maxZoom: this.currentMaxZoom,
          // ol/layer/Layer
          render: this.render,
          source: this.$source
        });
      }
    }
  };

  /* script */
  var __vue_script__$q = script$q;
  /* template */

  /* style */

  var __vue_inject_styles__$q = undefined;
  /* scoped */

  var __vue_scope_id__$q = undefined;
  /* module identifier */

  var __vue_module_identifier__$q = undefined;
  /* functional template */

  var __vue_is_functional_template__$q = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$q = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$q, __vue_script__$q, __vue_scope_id__$q, __vue_is_functional_template__$q, __vue_module_identifier__$q, false, undefined, undefined, undefined);

  function plugin$q(Vue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$q.installed) {
      return;
    }

    plugin$q.installed = true;
    options = pick(options, 'dataProjection');
    Object.assign(__vue_component__$q, options);
    Vue.component(__vue_component__$q.name, __vue_component__$q);
  }

  var ImageLayer = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': plugin$q,
    install: plugin$q,
    Layer: __vue_component__$q
  });

  function ownKeys$k(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$k(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$k(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$k(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  /**
   * A layer source for displaying a single, static image.
   */

  var script$p = {
    name: 'VlSourceImageStatic',
    mixins: [imageSource],
    props: {
      // ol/source/ImageStatic
      crossOrigin: String,

      /**
       * Image extent in the source projection.
       * @type {number[]}
       */
      imageExtent: {
        type: Array,
        // required: true,
        validator: function validator(value) {
          return value.length === 4;
        }
      },

      /**
       * @deprecated
       * @todo remove later
       */
      imgExtent: {
        type: Array,
        validator: function validator(value) {
          return value.length === 4;
        }
      },

      /**
       * @deprecated Use `imgExtent` instead.
       * @todo remove in v0.13.x
       */
      extent: {
        type: Array,
        validator: function validator(value) {
          return value.length === 4;
        }
      },

      /**
       * Optional function to load an image given a URL.
       * @type {function|undefined}
       */
      imageLoadFunction: Function,

      /**
       * @deprecated
       * @todo remove later
       */
      imgLoadFunc: Function,

      /**
       * @deprecated Use `imgLoadFunc` instead.
       * @todo remove in v0.13.x
       */
      loadFunc: Function,

      /**
       * Image size in pixels.
       * @type {number[]}
       */
      imageSize: {
        type: Array,
        validator: function validator(value) {
          return value.length === 2;
        }
      },

      /**
       * @deprecated
       * @todo remove later
       */
      imgSize: {
        type: Array,
        validator: function validator(value) {
          return value.length === 2;
        }
      },

      /**
       * @deprecated Use `imgSize` instead.
       * @todo remove in v0.13.x
       */
      size: {
        type: Array,
        validator: function validator(value) {
          return value.length === 2;
        }
      },

      /**
       * @type {boolean}
       */
      imageSmoothing: {
        type: Boolean,
        default: true
      },

      /**
       * Image URL.
       * @type {string}
       */
      url: {
        type: String,
        required: true,
        validator: /*#__PURE__*/negate(isEmpty$2)
      }
    },
    computed: {
      inputImageExtent: function inputImageExtent() {
        var _coalesce;

        return (_coalesce = coalesce(this.imageExtent, this.imgExtent, this.extent)) === null || _coalesce === void 0 ? void 0 : _coalesce.slice();
      },
      inputImageLoadFunction: function inputImageLoadFunction() {
        return coalesce(this.imageLoadFunction, this.imgLoadFunc, this.loadFunc);
      },
      inputImageSize: function inputImageSize() {
        var _coalesce2;

        return (_coalesce2 = coalesce(this.imageSize, this.imgSize, this.size)) === null || _coalesce2 === void 0 ? void 0 : _coalesce2.slice();
      }
    },
    watch: _objectSpread$k({}, /*#__PURE__*/makeChangeOrRecreateWatchers(['crossOrigin', 'inputImageExtent', 'inputImageLoadFunction', 'inputImageSize', 'imageSmoothing', 'url'], ['inputImageExtent', 'inputImageSize'])),
    created: function created() {
    },
    updated: function updated() {
    },
    methods: {
      /**
       * @return {ImageStatic}
       * @protected
       */
      createSource: function createSource() {
        return new source$1.ImageStatic({
          // ol/source/Source
          attributions: this.currentAttributions,
          projection: this.resolvedDataProjection,
          // ol/source/ImageStatic
          crossOrigin: this.crossOrigin,
          imageExtent: this.inputImageExtent,
          imageLoadFunction: this.inputImageLoadFunction,
          imageSize: this.inputImageSize,
          imageSmoothing: this.imageSmoothing,
          url: this.url
        });
      },
      getUrl: function getUrl() {
        var _this$$source;

        return coalesce((_this$$source = this.$source) === null || _this$$source === void 0 ? void 0 : _this$$source.getUrl(), this.url);
      },
      getImageExtent: function getImageExtent() {
        var _this$$source2;

        return coalesce((_this$$source2 = this.$source) === null || _this$$source2 === void 0 ? void 0 : _this$$source2.getImageExtent(), this.inputImageExtent);
      },
      stateChanged: noop$1
    }
  };

  /* script */
  var __vue_script__$p = script$p;
  /* template */

  /* style */

  var __vue_inject_styles__$p = undefined;
  /* scoped */

  var __vue_scope_id__$p = undefined;
  /* module identifier */

  var __vue_module_identifier__$p = undefined;
  /* functional template */

  var __vue_is_functional_template__$p = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$p = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$p, __vue_script__$p, __vue_scope_id__$p, __vue_is_functional_template__$p, __vue_module_identifier__$p, false, undefined, undefined, undefined);

  function plugin$p(Vue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$p.installed) {
      return;
    }

    plugin$p.installed = true;
    options = pick(options, 'dataProjection');
    Object.assign(__vue_component__$p, options);
    Vue.component(__vue_component__$p.name, __vue_component__$p);
  }

  var ImageStaticSource = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': plugin$p,
    install: plugin$p,
    Source: __vue_component__$p
  });

  function ownKeys$j(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$j(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$j(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$j(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var validateUrl = /*#__PURE__*/and(isString, negate(isEmpty$2));
  var script$o = {
    name: 'VlSourceImageWms',
    mixins: [wmsSource, imageSource],
    props: {
      // ol/source/ImageArcGISRest
      crossOrigin: String,
      imageLoadFunction: Function,

      /**
       * @deprecated
       * @todo remove later
       */
      imageLoadFunc: Function,
      imageSmoothing: {
        type: Boolean,
        default: true
      },
      ratio: {
        type: Number,
        default: 1.5
      },
      url: {
        type: String,
        required: true,
        validator: validateUrl
      }
    },
    data: function data() {
      return {
        currentImageLoadFunction: this.imageLoadFunction,
        currentUrl: this.url
      };
    },
    computed: {
      inputImageLoadFunction: function inputImageLoadFunction() {
        return this.imageLoadFunction || this.imageLoadFunc;
      }
    },
    watch: _objectSpread$j({
      rev: function rev() {
        if (!this.$source) return;

        if (this.currentUrl !== this.$source.getUrl()) {
          this.currentUrl = this.$source.getUrl();
        }

        if (this.currentImageLoadFunction !== this.$source.getImageLoadFunction()) {
          this.currentImageLoadFunction = this.$source.getImageLoadFunction();
        }
      },
      url: function url(value) {
        this.setUrl(value);
      },
      currentUrl: function currentUrl(value) {
        if (value === this.url) return;
        this.$emit('update:url', value);
      },
      inputImageLoadFunction: function inputImageLoadFunction(value) {
        this.setImageLoadFunction(value);
      },
      currentImageLoadFunc: function currentImageLoadFunc(value) {
        if (value === this.imageLoadFunction) return;
        this.$emit('update:imageLoadFunction', value);
      }
    }, /*#__PURE__*/makeChangeOrRecreateWatchers(['crossOrigin', 'imageSmoothing', 'ratio'])),
    created: function created() {

      this.currentImageLoadFunction = this.inputImageLoadFunction;
    },
    updated: function updated() {
    },
    methods: {
      createSource: function createSource() {
        return new source$1.ImageWMS({
          // ol/source/Source
          attributions: this.currentAttributions,
          projection: this.resolvedDataProjection,
          // ol/source/Image
          resolutions: this.inputResolutions,
          // ol/source/ImageWMS
          crossOrigin: this.crossOrigin,
          hidpi: this.hidpi,
          serverType: this.serverType,
          imageLoadFunction: this.currentImageLoadFunction,
          imageSmoothing: this.imageSmoothing,
          params: this.currentParams,
          ratio: this.ratio,
          url: this.currentUrl
        });
      },
      getUrl: function getUrl() {
        var _this$$source;

        return coalesce((_this$$source = this.$source) === null || _this$$source === void 0 ? void 0 : _this$$source.getUrl(), this.currentUrl);
      },
      setUrl: function setUrl(url) {
        assert$1(validateUrl(url), 'Invalid url');

        if (url !== this.currentUrl) {
          this.currentUrl = url;
        }

        if (this.$source && url !== this.$source.getUrl()) {
          this.$source.setUrls(url);
        }
      },
      getImageLoadFunction: function getImageLoadFunction() {
        var _this$$source2;

        return coalesce((_this$$source2 = this.$source) === null || _this$$source2 === void 0 ? void 0 : _this$$source2.getImageLoadFunction(), this.currentImageLoadFunction);
      },
      setImageLoadFunction: function setImageLoadFunction(func) {
        assert$1(isFunction$1(func), 'Invalid image load function');

        if (func !== this.currentImageLoadFunction) {
          this.currentImageLoadFunction = func;
        }

        if (this.$source && func !== this.$source.getImageLoadFunction()) {
          this.$source.setImageLoadFunction(func);
        }
      },
      stateChanged: noop$1
    }
  };

  /* script */
  var __vue_script__$o = script$o;
  /* template */

  /* style */

  var __vue_inject_styles__$o = undefined;
  /* scoped */

  var __vue_scope_id__$o = undefined;
  /* module identifier */

  var __vue_module_identifier__$o = undefined;
  /* functional template */

  var __vue_is_functional_template__$o = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$o = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$o, __vue_script__$o, __vue_scope_id__$o, __vue_is_functional_template__$o, __vue_module_identifier__$o, false, undefined, undefined, undefined);

  function plugin$o(Vue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$o.installed) {
      return;
    }

    plugin$o.installed = true;
    options = pick(options, 'dataProjection');
    Object.assign(__vue_component__$o, options);
    Vue.component(__vue_component__$o.name, __vue_component__$o);
  }

  var ImageWmsSource = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': plugin$o,
    install: plugin$o,
    Source: __vue_component__$o
  });

  /**
   * @module ol/MapBrowserEventType
   */
  /**
   * Constants for event names.
   * @enum {string}
   */
  var MapBrowserEventType = {
      /**
       * A true single click with no dragging and no double click. Note that this
       * event is delayed by 250 ms to ensure that it is not a double click.
       * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
       * @api
       */
      SINGLECLICK: 'singleclick',
      /**
       * A click with no dragging. A double click will fire two of this.
       * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
       * @api
       */
      CLICK: EventType.CLICK,
      /**
       * A true double click, with no dragging.
       * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
       * @api
       */
      DBLCLICK: EventType.DBLCLICK,
      /**
       * Triggered when a pointer is dragged.
       * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
       * @api
       */
      POINTERDRAG: 'pointerdrag',
      /**
       * Triggered when a pointer is moved. Note that on touch devices this is
       * triggered when the map is panned, so is not the same as mousemove.
       * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
       * @api
       */
      POINTERMOVE: 'pointermove',
      POINTERDOWN: 'pointerdown',
      POINTERUP: 'pointerup',
      POINTEROVER: 'pointerover',
      POINTEROUT: 'pointerout',
      POINTERENTER: 'pointerenter',
      POINTERLEAVE: 'pointerleave',
      POINTERCANCEL: 'pointercancel',
  };

  /**
   * @module ol/MapEventType
   */
  /**
   * @enum {string}
   */
  var MapEventType = {
      /**
       * Triggered after a map frame is rendered.
       * @event module:ol/MapEvent~MapEvent#postrender
       * @api
       */
      POSTRENDER: 'postrender',
      /**
       * Triggered when the map starts moving.
       * @event module:ol/MapEvent~MapEvent#movestart
       * @api
       */
      MOVESTART: 'movestart',
      /**
       * Triggered after the map is moved.
       * @event module:ol/MapEvent~MapEvent#moveend
       * @api
       */
      MOVEEND: 'moveend',
  };

  /**
   * Layer for data that is rendered client-side.
   */

  var script$n = {
    name: 'VlLayerVector',
    mixins: [vectorLayer],
    props: {
      /**
       * @deprecated Use `vl-layer-vector-image` to render vector layer as image
       * @todo remove in v0.13.x
       */
      renderMode: String
    },
    created: function created() {
    },
    updated: function updated() {
    },
    methods: {
      /**
       * @return {module:ol/layer/Vector~VectorLayer}
       * @protected
       */
      createLayer: function createLayer() {
        return new layer$1.Vector({
          // ol/layer/Base
          className: this.className,
          opacity: this.currentOpacity,
          visible: this.currentVisible,
          extent: this.currentExtentViewProj,
          zIndex: this.currentZIndex,
          minResolution: this.currentMinResolution,
          maxResolution: this.currentMaxResolution,
          minZoom: this.currentMinZoom,
          maxZoom: this.currentMaxZoom,
          // ol/layer/Layer
          render: this.render,
          source: this.$source,
          // ol/layer/BaseVector
          renderOrder: this.renderOrder,
          renderBuffer: this.renderBuffer,
          declutter: this.declutter,
          updateWhileAnimating: this.updateWhileAnimating,
          updateWhileInteracting: this.updateWhileInteracting,
          style: this.$style
        });
      }
    }
  };

  /* script */
  var __vue_script__$n = script$n;
  /* template */

  /* style */

  var __vue_inject_styles__$n = undefined;
  /* scoped */

  var __vue_scope_id__$n = undefined;
  /* module identifier */

  var __vue_module_identifier__$n = undefined;
  /* functional template */

  var __vue_is_functional_template__$n = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$n = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$n, __vue_script__$n, __vue_scope_id__$n, __vue_is_functional_template__$n, __vue_module_identifier__$n, false, undefined, undefined, undefined);

  function plugin$n(Vue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$n.installed) {
      return;
    }

    plugin$n.installed = true;
    options = pick(options, 'dataProjection');
    Object.assign(__vue_component__$n, options);
    Vue.component(__vue_component__$n.name, __vue_component__$n);
  }

  var VectorLayer = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': plugin$n,
    install: plugin$n,
    Layer: __vue_component__$n
  });

  var script$m = {
    name: 'VlSourceVector',
    mixins: [vectorSource]
  };

  /* script */
  var __vue_script__$m = script$m;
  /* template */

  /* style */

  var __vue_inject_styles__$m = undefined;
  /* scoped */

  var __vue_scope_id__$m = undefined;
  /* module identifier */

  var __vue_module_identifier__$m = undefined;
  /* functional template */

  var __vue_is_functional_template__$m = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$m = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$m, __vue_script__$m, __vue_scope_id__$m, __vue_is_functional_template__$m, __vue_module_identifier__$m, false, undefined, undefined, undefined);

  function plugin$m(Vue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$m.installed) {
      return;
    }

    plugin$m.installed = true;
    options = pick(options, 'dataProjection');
    Object.assign(__vue_component__$m, options);
    Vue.component(__vue_component__$m.name, __vue_component__$m);
  }

  var VectorSource = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': plugin$m,
    install: plugin$m,
    Source: __vue_component__$m
  });

  function ownKeys$i(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$i(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$i(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$i(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  /**
   * Represents a simple **2D view** of the map. This is the component to act upon to change the **center**,
   * **resolution**, and **rotation** of the map.
   */

  var script$l = {
    name: 'VlView',
    mixins: [projTransforms, olCmp, waitForMap],
    stubVNode: {
      empty: function empty() {
        return this.vmId;
      }
    },
    props: {
      /**
       * @type {number[]}
       */
      center: {
        type: Array,
        default: function _default() {
          return [0, 0];
        },
        validator: function validator(value) {
          return value.length === 2 && value.every(isNumber$1);
        }
      },

      /**
       * @type {boolean}
       */
      constrainOnlyCenter: Boolean,

      /**
       * @type {number[]|undefined}
       */
      extent: {
        type: Array,
        validator: function validator(value) {
          return value.length === 4 && value.every(isNumber$1);
        }
      },

      /**
       * @type {boolean}
       */
      smoothExtentConstraint: {
        type: Boolean,
        default: true
      },

      /**
       * @type {number}
       */
      rotation: {
        type: Number,
        default: 0
      },

      /**
       * @type {boolean}
       */
      enableRotation: {
        type: Boolean,
        default: true
      },

      /**
       * @type {boolean|number}
       */
      constrainRotation: {
        type: [Boolean, Number],
        default: true
      },

      /**
       * @type {number|undefined}
       */
      resolution: Number,

      /**
       * @type {number[]|undefined}
       */
      resolutions: {
        type: Array,
        validator: function validator(value) {
          return value.every(isNumber$1);
        }
      },

      /**
       * @type {number|undefined}
       */
      maxResolution: Number,

      /**
       * @type {number|undefined}
       */
      minResolution: Number,

      /**
       * @type {boolean}
       */
      constrainResolution: Boolean,

      /**
       * @type {boolean}
       */
      smoothResolutionConstraint: {
        type: Boolean,
        default: true
      },

      /**
       * @type {number}
       */
      zoom: {
        type: Number,
        default: 0
      },

      /**
       * @type {number}
       */
      zoomFactor: {
        type: Number,
        default: 2
      },

      /**
       * @type {number}
       */
      maxZoom: {
        type: Number,
        default: 28
      },

      /**
       * @type {number}
       */
      minZoom: {
        type: Number,
        default: 0
      },

      /**
       * @type {boolean}
       */
      multiWorld: Boolean,

      /**
       * @type {string}
       */
      projection: {
        type: String,
        default: EPSG_3857,
        validator: function validator(value) {
          return proj.get(value) != null;
        }
      },
      showFullExtent: Boolean
    },
    data: function data() {
      var _this$resolutions;

      return {
        dataProjection: this.projection,
        currentProjection: this.projection,
        currentCenterViewProj: roundPointCoords(this.center),
        currentZoom: this.zoom,
        currentRotation: this.rotation,
        currentResolution: this.resolution,
        currentMinZoom: this.minZoom,
        currentMaxZoom: this.maxZoom,
        currentResolutions: (_this$resolutions = this.resolutions) === null || _this$resolutions === void 0 ? void 0 : _this$resolutions.slice(),
        currentMaxResolution: this.maxResolution,
        currentMinResolution: this.minResolution
      };
    },
    computed: {
      centerDataProj: function centerDataProj() {
        return roundPointCoords(this.center);
      },
      centerViewProj: function centerViewProj() {
        return this.pointToViewProj(this.center);
      },
      currentCenterDataProj: function currentCenterDataProj() {
        return this.pointToDataProj(this.currentCenterViewProj);
      },
      extentDataProj: function extentDataProj() {
        return roundExtent(this.extent);
      },
      extentViewProj: function extentViewProj() {
        return this.extentToViewProj(this.extent);
      },
      inputResolutions: function inputResolutions() {
        var _this$resolutions2;

        return (_this$resolutions2 = this.resolutions) === null || _this$resolutions2 === void 0 ? void 0 : _this$resolutions2.slice();
      },
      visibleExtentDataProj: function visibleExtentDataProj() {
        var _this$getExtent;

        if (!this.rev) return;
        return (_this$getExtent = this.getExtent()) === null || _this$getExtent === void 0 ? void 0 : _this$getExtent.slice();
      },
      visibleExtentViewProj: function visibleExtentViewProj() {
        var _this$getExtent2;

        if (!this.rev) return;
        return (_this$getExtent2 = this.getExtent(true)) === null || _this$getExtent2 === void 0 ? void 0 : _this$getExtent2.slice();
      },
      animating: function animating() {
        return !!(this.rev && this.getAnimating());
      },
      interacting: function interacting() {
        return !!(this.rev && this.getInteracting());
      },
      resolvedViewProjection: function resolvedViewProjection() {
        return this.currentProjection;
      }
    },
    watch: _objectSpread$i({
      rev: function rev() {
        if (!this.$view) return;

        if (this.currentProjection !== this.$view.getProjection().getCode()) {
          this.currentProjection = this.$view.getProjection().getCode();
        }

        if (!isEqual(this.currentCenterViewProj, this.$view.getCenter())) {
          this.currentCenterViewProj = this.$view.getCenter();
        }

        if (this.currentZoom !== this.$view.getZoom()) {
          this.currentZoom = this.$view.getZoom();
        }

        if (this.currentRotation !== this.$view.getRotation()) {
          this.currentRotation = this.$view.getRotation();
        }

        if (this.currentResolution !== this.$view.getResolution()) {
          this.currentResolution = this.$view.getResolution();
        }

        if (this.currentMinZoom !== this.$view.getMinZoom()) {
          this.currentMinZoom = this.$view.getMinZoom();
        }

        if (this.currentMaxZoom !== this.$view.getMaxZoom()) {
          this.currentMaxZoom = this.$view.getMaxZoom();
        }

        if (!isEqual(this.currentResolutions, this.$view.getResolutions())) {
          this.currentResolutions = this.$view.getResolutions();
        }

        if (this.currentMaxResolution !== this.$view.getMaxResolution()) {
          this.currentMaxResolution = this.$view.getMaxResolution();
        }

        if (this.currentMinResolution !== this.$view.getMinResolution()) {
          this.currentMinResolution = this.$view.getMinResolution();
        }
      },
      centerViewProj: {
        deep: true,
        handler: function handler(value, prev) {
          if (this.getAnimating()) return;
          this.setCenter(value, true);
        }
      },
      currentCenterDataProj: {
        deep: true,
        handler: function handler(value, prev) {
          if (isEqual(value, this.centerDataProj)) return;
          this.$emit('update:center', value.slice());
        }
      },
      rotation: function rotation(value) {
        if (this.getAnimating()) return;
        this.setRotation(value);
      },
      currentRotation: function currentRotation(value) {
        if (value === this.rotation) return;
        this.$emit('update:rotation', value);
      },
      resolution: function resolution(value) {
        if (this.getAnimating()) return;
        this.setResolution(value);
      },
      currentResolution: function currentResolution(value) {
        if (value === this.resolution) return;
        this.$emit('update:resolution', value);
      },
      constrainResolution: function constrainResolution(value) {
        this.setConstrainResolution(value);
      },
      zoom: function zoom(value) {
        if (this.getAnimating()) return;
        this.setZoom(value);
      },
      currentZoom: function currentZoom(value) {
        if (value === this.zoom) return;
        this.$emit('update:zoom', value);
      },
      minZoom: function minZoom(value) {
        this.setMinZoom(value);
      },
      currentMinZoom: function currentMinZoom(value) {
        if (value === this.minZoom) return;
        this.$emit('update:minZoom', value);
      },
      maxZoom: function maxZoom(value) {
        this.setMaxZoom(value);
      },
      currentMaxZoom: function currentMaxZoom(value) {
        if (value === this.maxZoom) return;
        this.$emit('update:maxZoom', value);
      },
      inputResolutions: {
        deep: true,
        handler: function handler(value) {
          if (value === this.currentResolutions) return;

          this.currentResolutions = value === null || value === void 0 ? void 0 : value.slice();
          return this.scheduleRecreate();
        }
      },
      currentResolutions: {
        deep: true,
        handler: function handler(value) {
          if (isEqual(value, this.inputResolutions)) return;
          this.$emit('update:resolutions', value === null || value === void 0 ? void 0 : value.slice());
        }
      },
      maxResolution: function maxResolution(value) {
        if (value === this.currentMaxResolution) return;

        this.currentMaxResolution = value;
        return this.scheduleRecreate();
      },
      currentMaxResolution: function currentMaxResolution(value) {
        if (value === this.maxResolution) return;
        this.$emit('update:maxResolution', value);
      },
      minResolution: function minResolution(value) {
        if (value === this.currentMinResolution) return;

        this.currentMinResolution = value;
        return this.scheduleRecreate();
      },
      currentMinResolution: function currentMinResolution(value) {
        if (value === this.minResolution) return;
        this.$emit('update:minResolution', value);
      },
      projection: function projection(value) {
        var _this$inputResolution;

        if (value === this.currentProjection) return;

        this.currentProjection = this.dataProjection = value; // reset current resolution fields to inputs
        // so zoom fields will take precedence

        this.currentResolution = this.resolution;
        this.currentResolutions = (_this$inputResolution = this.inputResolutions) === null || _this$inputResolution === void 0 ? void 0 : _this$inputResolution.slice();
        this.currentMaxResolution = this.maxResolution;
        this.currentMinResolution = this.minResolution;
        return this.scheduleRecreate();
      },
      currentProjection: function currentProjection(value) {
        if (value === this.projection) return;
        this.$emit('update:projection', value);
      },
      animating: function animating(value, prev) {
        if (value === prev) return;
        this.$emit('update:animating', value);
      },
      interacting: function interacting(value, prev) {
        if (value === prev) return;
        this.$emit('update:interacting', value);
      },
      visibleExtentDataProj: {
        deep: true,
        handler: function handler(value, prev) {
          if (isEqual(value, prev)) return;
          this.$emit('update:visibleExtent', value === null || value === void 0 ? void 0 : value.slice());
        }
      }
    }, /*#__PURE__*/makeChangeOrRecreateWatchers(['constrainOnlyCenter', 'smoothExtentConstraint', 'enableRotation', 'constrainRotation', 'constrainResolution', 'smoothResolutionConstraint', 'zoomFactor', 'multiWorld', 'extentViewProj'], ['extentViewProj'])),
    created: function created() {
      defineServices$3.call(this);
      this.currentCenterViewProj = this.centerViewProj.slice();
    },
    methods: {
      /**
       * @return {Promise<void>}
       * @protected
       */
      beforeInit: function beforeInit() {
        var _this = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return Promise.all([olCmp.methods.beforeInit.call(_this), waitForMap.methods.beforeInit.call(_this)]);

                case 2:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      },

      /**
       * @return {module:ol/View~View}
       * @protected
       */
      createOlObject: function createOlObject() {
        var view = new ol.View({
          center: this.currentCenterViewProj,
          constrainOnlyCenter: this.constrainOnlyCenter,
          extent: this.extentViewProj,
          smoothExtentConstraint: this.smoothExtentConstraint,
          rotation: this.currentRotation,
          enableRotation: this.enableRotation,
          constrainRotation: this.constrainRotation,
          resolution: this.currentResolution,
          resolutions: this.currentResolutions,
          maxResolution: this.currentMaxResolution,
          minResolution: this.currentMinResolution,
          constrainResolution: this.constrainResolution,
          smoothResolutionConstraint: this.smoothResolutionConstraint,
          zoom: this.currentZoom,
          zoomFactor: this.zoomFactor,
          maxZoom: this.currentMaxZoom,
          minZoom: this.currentMinZoom,
          multiWorld: this.multiWorld,
          projection: this.currentProjection,
          showFullExtent: this.showFullExtent
        });
        initializeView(view, this.currentId);
        return view;
      },

      /**
       * @return {Promise<void>}
       * @protected
       */
      mount: function mount() {
        var _this2 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
          var _this2$$viewContainer;

          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  (_this2$$viewContainer = _this2.$viewContainer) === null || _this2$$viewContainer === void 0 ? void 0 : _this2$$viewContainer.setView(_this2);
                  return _context2.abrupt("return", olCmp.methods.mount.call(_this2));

                case 2:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }))();
      },

      /**
       * @return {void}
       * @protected
       */
      unmount: function unmount() {
        var _this3 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3() {
          var _this3$$viewContainer;

          return regenerator.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  if (((_this3$$viewContainer = _this3.$viewContainer) === null || _this3$$viewContainer === void 0 ? void 0 : _this3$$viewContainer.getViewVm()) === _this3) {
                    _this3.$viewContainer.setView(null);
                  }

                  return _context3.abrupt("return", olCmp.methods.unmount.call(_this3));

                case 2:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }))();
      },

      /**
       * @return {void}
       * @protected
       */
      subscribeAll: function subscribeAll() {
        olCmp.methods.subscribeAll.call(this);
        subscribeToEvents$1.call(this);
      },

      /**
       * @return {*}
       * @protected
       */
      getIdInternal: function getIdInternal() {
        return getViewId(this.$view);
      },

      /**
       * @param {*} id
       * @protected
       */
      setIdInternal: function setIdInternal(id) {
        if (id === this.getIdInternal()) return;
        setViewId(this.$view, id);
      },

      /**
       * @return {Promise<module:ol/View~View>}
       */
      resolveView: olCmp.methods.resolveOlObject,

      /**
       * @see {@link https://openlayers.org/en/latest/apidoc/module-ol_View-View.html#animate}
       * @param {...(module:ol/View~AnimationOptions|function(boolean))} args
       * @return {Promise<boolean>} Resolves when animation completes
       */
      animate: function animate() {
        var _arguments = arguments,
            _this4 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4() {
          var _len, args, _key, cb, view;

          return regenerator.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  for (_len = _arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                    args[_key] = _arguments[_key];
                  }

                  cb = noop$1;

                  if (isFunction$1(args[args.length - 1])) {
                    cb = args[args.length - 1];
                    args = args.slice(0, args.length - 1);
                  }

                  args.forEach(function (opts) {
                    if (!isArray$2(opts.center)) return;

                    if (!opts.viewProj) {
                      opts.center = _this4.pointToViewProj(opts.center);
                    }
                  });
                  _context4.next = 6;
                  return _this4.resolveView();

                case 6:
                  view = _context4.sent;
                  return _context4.abrupt("return", new Promise(function (resolve) {
                    view.animate.apply(view, _toConsumableArray(args).concat([function (complete) {
                      cb(complete);
                      resolve(complete);
                    }]));
                  }));

                case 8:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4);
        }))();
      },

      /**
       * @see {@link https://openlayers.org/en/latest/apidoc/module-ol_View-View.html#fit}
       * @param {Object|module:ol/geom/SimpleGeometry~SimpleGeometry|module:ol/extent~Extent} geometryOrExtent
       * @param {module:ol/View~FitOptions} [options]
       * @return {Promise<boolean>} Resolves when view changes
       */
      fit: function fit(geometryOrExtent) {
        var _arguments2 = arguments,
            _this5 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee5() {
          var options, cb, view;
          return regenerator.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  options = _arguments2.length > 1 && _arguments2[1] !== undefined ? _arguments2[1] : {};

                  if (!isGeoJSONGeometry(geometryOrExtent)) {
                    _context5.next = 5;
                    break;
                  }

                  if (options.viewProj) {
                    geometryOrExtent = _this5.readGeometryInViewProj(geometryOrExtent);
                  } else {
                    geometryOrExtent = _this5.readGeometryInDataProj(geometryOrExtent);
                  }

                  _context5.next = 9;
                  break;

                case 5:
                  if (!isFunction$1(geometryOrExtent.resolveOlObject)) {
                    _context5.next = 9;
                    break;
                  }

                  _context5.next = 8;
                  return geometryOrExtent.resolveOlObject();

                case 8:
                  geometryOrExtent = _context5.sent;

                case 9:
                  cb = options.callback || noop$1;
                  _context5.next = 12;
                  return _this5.resolveView();

                case 12:
                  view = _context5.sent;
                  return _context5.abrupt("return", new Promise(function (resolve) {
                    view.fit(geometryOrExtent, _objectSpread$i(_objectSpread$i({}, options), {}, {
                      callback: function callback(complete) {
                        cb(complete);
                        resolve(complete);
                      }
                    }));
                  }));

                case 14:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5);
        }))();
      },

      /**
       * @return {Promise<void>}
       */
      cancelAnimations: function cancelAnimations() {
        var _this6 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee6() {
          return regenerator.wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  _context6.next = 2;
                  return _this6.resolveView();

                case 2:
                  _context6.sent.cancelAnimations();

                case 3:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6);
        }))();
      },

      /**
       * @return {boolean}
       */
      getAnimating: function getAnimating() {
        var _this$$view;

        return coalesce((_this$$view = this.$view) === null || _this$$view === void 0 ? void 0 : _this$$view.getAnimating(), false);
      },

      /**
       * @return {Promise<void>}
       */
      beginInteraction: function beginInteraction() {
        var _this7 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee7() {
          return regenerator.wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  _context7.next = 2;
                  return _this7.resolveView();

                case 2:
                  _context7.sent.beginInteraction();

                case 3:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee7);
        }))();
      },

      /**
       * @param {number} [duration]
       * @param {number} [resolutionDirection]
       * @param {number[]} [anchor]
       * @param {boolean} [viewProj=false]
       * @return {Promise<void>}
       */
      endInteraction: function endInteraction(duration, resolutionDirection, anchor) {
        var _arguments3 = arguments,
            _this8 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee8() {
          var viewProj;
          return regenerator.wrap(function _callee8$(_context8) {
            while (1) {
              switch (_context8.prev = _context8.next) {
                case 0:
                  viewProj = _arguments3.length > 3 && _arguments3[3] !== undefined ? _arguments3[3] : false;

                  if (!viewProj) {
                    anchor = _this8.pointToViewProj(anchor);
                  }

                  _context8.next = 4;
                  return _this8.resolveView();

                case 4:
                  _context8.sent.endInteraction(duration, resolutionDirection, anchor);

                case 5:
                case "end":
                  return _context8.stop();
              }
            }
          }, _callee8);
        }))();
      },

      /**
       * @return {boolean}
       */
      getInteracting: function getInteracting() {
        var _this$$view2;

        return coalesce((_this$$view2 = this.$view) === null || _this$$view2 === void 0 ? void 0 : _this$$view2.getInteracting(), false);
      },

      /**
       * @param {number[]|undefined} [size]
       * @param {boolean} [viewProj=false]
       * @return {Promise<number[]>}
       */
      calculateExtent: function calculateExtent(size) {
        var _arguments4 = arguments,
            _this9 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee9() {
          var viewProj, extent;
          return regenerator.wrap(function _callee9$(_context9) {
            while (1) {
              switch (_context9.prev = _context9.next) {
                case 0:
                  viewProj = _arguments4.length > 1 && _arguments4[1] !== undefined ? _arguments4[1] : false;
                  _context9.next = 3;
                  return _this9.resolveView();

                case 3:
                  extent = _context9.sent.calculateExtent(size);

                  if (!viewProj) {
                    _context9.next = 6;
                    break;
                  }

                  return _context9.abrupt("return", roundExtent(extent));

                case 6:
                  return _context9.abrupt("return", _this9.extentToDataProj(extent));

                case 7:
                case "end":
                  return _context9.stop();
              }
            }
          }, _callee9);
        }))();
      },

      /**
       * @param {boolean} [viewProj=false]
       * @return {number[]|undefined}
       */
      getExtent: function getExtent() {
        var viewProj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        if (!this.$view) return;
        var extent = this.$view.calculateExtent();
        if (viewProj) return roundExtent(extent);
        return this.extentToDataProj(extent);
      },

      /**
       * @param {number[]} coordinate
       * @param {number[]} size
       * @param {number[]} position
       * @param {boolean} [viewProj=false]
       * @return {Promise<void>}
       */
      centerOn: function centerOn(coordinate, size, position) {
        var _arguments5 = arguments,
            _this10 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee10() {
          var viewProj;
          return regenerator.wrap(function _callee10$(_context10) {
            while (1) {
              switch (_context10.prev = _context10.next) {
                case 0:
                  viewProj = _arguments5.length > 3 && _arguments5[3] !== undefined ? _arguments5[3] : false;

                  if (!viewProj) {
                    coordinate = _this10.pointToViewProj(coordinate);
                  }

                  _context10.next = 4;
                  return _this10.resolveView();

                case 4:
                  _context10.sent.centerOn(coordinate, size, position);

                case 5:
                case "end":
                  return _context10.stop();
              }
            }
          }, _callee10);
        }))();
      },

      /**
       * @param {boolean} [viewProj=false]
       * @return {number[]}
       */
      getCenter: function getCenter() {
        var viewProj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

        if (!this.$view) {
          return viewProj ? this.currentCenterViewProj : this.currentCenterDataProj;
        }

        var center = this.$view.getCenter();
        if (viewProj) return center;
        return this.pointToDataProj(center);
      },

      /**
       * @param {number[]} center
       * @param {boolean} [viewProj=false]
       */
      setCenter: function setCenter(center) {
        var viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        assert$1(isArray$2(center) && center.length === 2, 'Invalid center');

        if (viewProj) {
          center = roundPointCoords(center);
        } else {
          center = this.pointToViewProj(center);
        }

        if (!isEqual(center, this.currentCenterViewProj)) {
          this.currentCenterViewProj = center;
        }

        if (this.$view && !isEqual(center, this.$view.getCenter())) {
          this.$view.setCenter(center);
        }
      },

      /**
       * @return {number}
       */
      getResolution: function getResolution() {
        var _this$$view3;

        return coalesce((_this$$view3 = this.$view) === null || _this$$view3 === void 0 ? void 0 : _this$$view3.getResolution(), this.currentResolution);
      },

      /**
       * @param {number} resolution
       */
      setResolution: function setResolution(resolution) {
        resolution = Number(resolution);
        assert$1(isNumber$1(resolution), 'Invalid resolution');

        if (resolution !== this.currentResolution) {
          this.currentResolution = resolution;
        }

        if (this.$view && resolution !== this.$view.getResolution()) {
          this.$view.setResolution(resolution);
        }
      },

      /**
       * @param {number[]} extent
       * @param {number[]} size
       * @param {boolean} [viewProj=false]
       * @return {Promise<number>}
       */
      getResolutionForExtent: function getResolutionForExtent(extent, size) {
        var _arguments6 = arguments,
            _this11 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee11() {
          var viewProj;
          return regenerator.wrap(function _callee11$(_context11) {
            while (1) {
              switch (_context11.prev = _context11.next) {
                case 0:
                  viewProj = _arguments6.length > 2 && _arguments6[2] !== undefined ? _arguments6[2] : false;

                  if (!viewProj) {
                    extent = _this11.extentToViewProj(extent);
                  }

                  _context11.next = 4;
                  return _this11.resolveView();

                case 4:
                  return _context11.abrupt("return", _context11.sent.getResolutionForExtent(extent, size));

                case 5:
                case "end":
                  return _context11.stop();
              }
            }
          }, _callee11);
        }))();
      },

      /**
       * @param {number} zoom
       * @return {Promise<number>}
       */
      getResolutionForZoom: function getResolutionForZoom(zoom) {
        var _this12 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee12() {
          return regenerator.wrap(function _callee12$(_context12) {
            while (1) {
              switch (_context12.prev = _context12.next) {
                case 0:
                  _context12.next = 2;
                  return _this12.resolveView();

                case 2:
                  return _context12.abrupt("return", _context12.sent.getResolutionForZoom(zoom));

                case 3:
                case "end":
                  return _context12.stop();
              }
            }
          }, _callee12);
        }))();
      },

      /**
       * @return {number[]|undefined}
       */
      getResolutions: function getResolutions() {
        var _this$$view4;

        return coalesce((_this$$view4 = this.$view) === null || _this$$view4 === void 0 ? void 0 : _this$$view4.getResolutions(), this.currentResolutions);
      },

      /**
       * @return {number|undefined}
       */
      getMaxResolution: function getMaxResolution() {
        var _this$$view5;

        return coalesce((_this$$view5 = this.$view) === null || _this$$view5 === void 0 ? void 0 : _this$$view5.getMaxResolution(), this.currentMaxResolution);
      },

      /**
       * @return {number|undefined}
       */
      getMinResolution: function getMinResolution() {
        var _this$$view6;

        return coalesce((_this$$view6 = this.$view) === null || _this$$view6 === void 0 ? void 0 : _this$$view6.getMinResolution(), this.currentMinResolution);
      },

      /**
       * @return {number|undefined}
       */
      getZoom: function getZoom() {
        var _this$$view7;

        return coalesce((_this$$view7 = this.$view) === null || _this$$view7 === void 0 ? void 0 : _this$$view7.getZoom(), this.currentZoom);
      },

      /**
       * @param {number} zoom
       */
      setZoom: function setZoom(zoom) {
        zoom = Number(zoom);
        assert$1(isNumber$1(zoom), 'Invalid zoom');

        if (zoom !== this.currentZoom) {
          this.currentZoom = zoom;
        }

        if (this.$view && zoom !== this.$view.getZoom()) {
          this.$view.setZoom(zoom);
        }
      },

      /**
       * @param {number} resolution
       * @return {Promise<number|undefined>}
       */
      getZoomForResolution: function getZoomForResolution(resolution) {
        var _this13 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee13() {
          return regenerator.wrap(function _callee13$(_context13) {
            while (1) {
              switch (_context13.prev = _context13.next) {
                case 0:
                  _context13.next = 2;
                  return _this13.resolveView();

                case 2:
                  return _context13.abrupt("return", _context13.sent.getZoomForResolution(resolution));

                case 3:
                case "end":
                  return _context13.stop();
              }
            }
          }, _callee13);
        }))();
      },

      /**
       * @return {number|undefined}
       */
      getMaxZoom: function getMaxZoom() {
        var _this$$view8;

        return coalesce((_this$$view8 = this.$view) === null || _this$$view8 === void 0 ? void 0 : _this$$view8.getMaxZoom(), this.currentMaxZoom);
      },

      /**
       * @param {number} zoom
       */
      setMaxZoom: function setMaxZoom(zoom) {
        zoom = Number(zoom);
        assert$1(isNumber$1(zoom), 'Invalid maxZoom');

        if (zoom !== this.currentMaxZoom) {
          this.currentMaxZoom = zoom;
        }

        if (this.$view && zoom !== this.$view.getMaxZoom()) {
          this.$view.setMaxZoom(zoom);
        }
      },

      /**
       * @return {number|undefined}
       */
      getMinZoom: function getMinZoom() {
        var _this$$view9;

        return coalesce((_this$$view9 = this.$view) === null || _this$$view9 === void 0 ? void 0 : _this$$view9.getMinZoom(), this.currentMinZoom);
      },

      /**
       * @param {number} zoom
       */
      setMinZoom: function setMinZoom(zoom) {
        zoom = Number(zoom);
        assert$1(isNumber$1(zoom), 'Invalid minZoom');

        if (zoom !== this.currentMinZoom) {
          this.currentMinZoom = zoom;
        }

        if (this.$view && zoom !== this.$view.getMinZoom()) {
          this.$view.setMinZoom(zoom);
        }
      },

      /**
       * @return {module:ol/proj/ProjectionLike}
       */
      getProjection: function getProjection() {
        var _this$$view10;

        return coalesce((_this$$view10 = this.$view) === null || _this$$view10 === void 0 ? void 0 : _this$$view10.getProjection(), proj.get(this.currentProjection));
      },

      /**
       * @return {number|undefined}
       */
      getRotation: function getRotation() {
        var _this$$view11;

        return coalesce((_this$$view11 = this.$view) === null || _this$$view11 === void 0 ? void 0 : _this$$view11.getRotation(), this.currentRotation);
      },

      /**
       * @param {number} rotation
       */
      setRotation: function setRotation(rotation) {
        rotation = Number(rotation);
        assert$1(isNumber$1(rotation), 'Invalid rotation');

        if (rotation !== this.currentRotation) {
          this.currentRotation = rotation;
        }

        if (this.$view && rotation !== this.$view.getRotation()) {
          this.$view.setRotation(rotation);
        }
      }
    }
  };

  function defineServices$3() {
    var _this14 = this;

    Object.defineProperties(this, {
      /**
       * @type {module:ol/View~View|undefined}
       */
      $view: {
        enumerable: true,
        get: function get() {
          return _this14.$olObject;
        }
      },

      /**
       * @type {Object|undefined}
       */
      $viewContainer: {
        enumerable: true,
        get: function get() {
          var _this14$$services;

          return (_this14$$services = _this14.$services) === null || _this14$$services === void 0 ? void 0 : _this14$$services.viewContainer;
        }
      },

      /**
       * @type {Object|undefined}
       */
      $mapVm: {
        enumerable: true,
        get: function get() {
          var _this14$$services2;

          return (_this14$$services2 = _this14.$services) === null || _this14$$services2 === void 0 ? void 0 : _this14$$services2.mapVm;
        }
      }
    });
  }
  /**
   * Subscribe to OpenLayers significant events
   * @return {void}
   * @private
   */


  function subscribeToEvents$1() {
    return _subscribeToEvents$1.apply(this, arguments);
  }

  function _subscribeToEvents$1() {
    _subscribeToEvents$1 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee14() {
      var _this15 = this;

      var setterKey, resolutionChanges, zoomChanges, propChanges;
      return regenerator.wrap(function _callee14$(_context14) {
        while (1) {
          switch (_context14.prev = _context14.next) {
            case 0:
              setterKey = addPrefix('set');
              resolutionChanges = fromOlChangeEvent(this.$view, 'resolution', true);
              zoomChanges = resolutionChanges.pipe(map(function () {
                return {
                  prop: 'zoom',
                  value: _this15.getZoom()
                };
              }), distinctUntilKeyChanged('value'));
              propChanges = merge(fromOlChangeEvent(this.$view, ['id', 'rotation', 'center'], true), resolutionChanges, zoomChanges).pipe(map(function (evt) {
                return _objectSpread$i(_objectSpread$i({}, evt), {}, {
                  setter: function setter(val) {
                    var args = [val];

                    if (evt.prop === 'center') {
                      args.push(true);
                    }

                    _this15[setterKey(evt.prop)].apply(_this15, args);
                  }
                });
              }));
              this.subscribeTo(propChanges, function (_ref) {
                var setter = _ref.setter,
                    value = _ref.value;
                return setter(value);
              });

            case 5:
            case "end":
              return _context14.stop();
          }
        }
      }, _callee14, this);
    }));
    return _subscribeToEvents$1.apply(this, arguments);
  }

  /* script */
  var __vue_script__$l = script$l;
  /* template */

  var __vue_render__$3 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('i', {
      class: _vm.vmClass,
      staticStyle: {
        "display": "none !important"
      },
      attrs: {
        "id": _vm.vmId
      }
    }, [_vm._t("default", null, {
      "center": _vm.currentCenterDataProj,
      "zoom": _vm.currentZoom,
      "resolution": _vm.currentResolution,
      "rotation": _vm.currentRotation,
      "extent": _vm.visibleExtentDataProj
    })], 2);
  };

  var __vue_staticRenderFns__$3 = [];
  /* style */

  var __vue_inject_styles__$l = undefined;
  /* scoped */

  var __vue_scope_id__$l = undefined;
  /* module identifier */

  var __vue_module_identifier__$l = undefined;
  /* functional template */

  var __vue_is_functional_template__$l = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$l = /*#__PURE__*/normalizeComponent({
    render: __vue_render__$3,
    staticRenderFns: __vue_staticRenderFns__$3
  }, __vue_inject_styles__$l, __vue_script__$l, __vue_scope_id__$l, __vue_is_functional_template__$l, __vue_module_identifier__$l, false, undefined, undefined, undefined);

  function ownKeys$h(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$h(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$h(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$h(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  /**
   * Container for **layers**, **interactions**, **controls** and **overlays**. It responsible for viewport
   * rendering and low level interaction events.
   *
   * todo make render function that injects VlView if it is not provided by the user,
   *      then it can be provided to lower components
   */

  var script$k = {
    name: 'VlMap',
    components: {
      ViewCmp: __vue_component__$l,
      VectorLayerCmp: __vue_component__$n,
      VectorSourceCmp: __vue_component__$m
    },
    mixins: [projTransforms, layersContainer, controlsContainer, interactionsContainer, overlaysContainer, featuresContainer, olCmp],
    props: {
      /**
       * Options for default controls added to the map by default. Set to `false` to disable all map controls. Object
       * value is used to configure controls.
       * @type {Object|boolean}
       * @todo remove when vl-control-* components will be ready
       */
      defaultControls: {
        type: [Object, Boolean],
        default: true
      },

      /**
       * Options for default interactions added to the map by default. Object
       * value is used to configure default interactions.
       * @type {Object|boolean}
       */
      defaultInteractions: {
        type: [Object, Boolean],
        default: true
      },

      /**
       * The element to listen to keyboard events on. For example, if this option is set to `document` the keyboard
       * interactions will always trigger. If this option is not specified, the element the library listens to keyboard
       * events on is the component root element.
       * @type {string|Element|Document|undefined}
       */
      keyboardEventTarget: [String, Element, Document],

      /**
       * The minimum distance in pixels the cursor must move to be detected as a map move event instead of a click.
       * Increasing this value can make it easier to click on the map.
       * @type {number}
       */
      moveTolerance: {
        type: Number,
        default: 1
      },

      /**
       * The ratio between physical pixels and device-independent pixels (dips) on the device.
       * @type {number}
       */
      pixelRatio: {
        type: Number,
        default: function _default() {
          return window.devicePixelRatio || 1;
        }
      },

      /**
       * Maximum number tiles to load simultaneously.
       * @type {number}
       */
      maxTilesLoading: {
        type: Number,
        default: 16
      },

      /**
       * Root element `tabindex` attribute value. Value should be provided to allow keyboard events on map.
       * @type {number|string}
       */
      tabindex: [String, Number],

      /**
       * Projection for input/output coordinates in plain data.
       * @type {string|undefined}
       */
      dataProjection: {
        type: String,
        validator: function validator(value) {
          return proj.get(value) != null;
        }
      },

      /**
       * @type {boolean}
       */
      wrapX: {
        type: Boolean,
        default: true
      },

      /**
       * @type {boolean}
       */
      updateWhileAnimating: {
        type: Boolean,
        default: false
      },

      /**
       * @type {boolean}
       */
      updateWhileInteracting: {
        type: Boolean,
        default: false
      }
    },
    data: function data() {
      return {
        viewProjection: EPSG_3857,
        withCustomView: false,
        size: undefined,
        currentDataProjection: this.dataProjection
      };
    },
    computed: {
      resolvedDataProjection: function resolvedDataProjection() {
        var _this$$options;

        return coalesce(this.currentDataProjection, this.dataProjection, (_this$$options = this.$options) === null || _this$$options === void 0 ? void 0 : _this$$options.dataProjection, this.viewProjection);
      },
      view: function view() {
        if (!(this.rev && this.$view)) return;
        return {
          id: getViewId(this.$view),
          type: this.$view.constructor.name
        };
      },

      /**
       * @returns {string[]}
       */
      layers: function layers() {
        if (!this.rev) return [];
        return map$1(this.getLayers(), function (layer) {
          return {
            id: getLayerId(layer),
            type: layer.constructor.name
          };
        });
      },

      /**
       * @returns {string[]}
       */
      controls: function controls() {
        if (!this.rev) return [];
        return map$1(this.getControls(), function (control) {
          return {
            id: getControlId(control),
            type: control.constructor.name
          };
        });
      },

      /**
       * @returns {string[]}
       */
      interactions: function interactions() {
        if (!this.rev) return [];
        return map$1(this.getInteractions(), function (interaction) {
          return {
            id: getInteractionId(interaction),
            type: interaction.constructor.name
          };
        });
      },

      /**
       * @returns {string[]}
       */
      overlays: function overlays() {
        if (!this.rev) return [];
        return map$1(this.getOverlays(), function (overlay) {
          return {
            id: getOverlayId(overlay),
            type: overlay.constructor.name
          };
        });
      },

      /**
       * @type {Object[]}
       */
      featuresDataProj: function featuresDataProj() {
        var _this = this;

        if (!this.rev) return [];
        return map$1(this.getFeatures(), function (feature) {
          return _this.writeFeatureInDataProj(feature);
        });
      },

      /**
       * @type {Object[]}
       */
      featuresViewProj: function featuresViewProj() {
        var _this2 = this;

        if (!this.rev) return [];
        return map$1(this.getFeatures(), function (feature) {
          return _this2.writeFeatureInViewProj(feature);
        });
      }
    },
    watch: _objectSpread$h({
      rev: function rev() {
        if (!this.$map) return;

        if (!isEqual(this.size, this.$map.getSize())) {
          this.size = this.$map.getSize();
        }
      },
      size: {
        deep: true,
        handler: function handler(value, prev) {
          if (isEqual(value, prev)) return;
          this.$emit('update:size', value === null || value === void 0 ? void 0 : value.slice());
        }
      },
      defaultControls: {
        deep: true,
        handler: function handler(value) {
          this.initDefaultControls(value);
        }
      },
      defaultInteractions: {
        deep: true,
        handler: function handler(value) {
          this.initDefaultInteractions(value);
        }
      },
      dataProjection: function dataProjection(value) {
        this.setDataProjection(value);
      },
      view: {
        deep: true,
        handler: function handler(value, prev) {
          if (value === prev) return;
          this.$emit('update:view', value);
        }
      },
      layers: {
        deep: true,
        handler: function handler(value, prev) {
          if (isEqual(value, prev)) return;
          this.$emit('update:layers', value.slice());
        }
      },
      controls: {
        deep: true,
        handler: function handler(value, prev) {
          if (isEqual(value, prev)) return;
          this.$emit('update:controls', value.slice());
        }
      },
      interactions: {
        deep: true,
        handler: function handler(value, prev) {
          if (isEqual(value, prev)) return;
          this.$emit('update:interactions', value.slice());
        }
      },
      overlays: {
        deep: true,
        handler: function handler(value, prev) {
          if (isEqual(value, prev)) return;
          this.$emit('update:overlays', value.slice());
        }
      },
      featuresDataProj: {
        deep: true,
        handler: function handler(value, prev) {
          if (isEqual(value, prev)) return;
          this.$emit('update:features', clonePlainObject(value));
        }
      }
    }, /*#__PURE__*/makeChangeOrRecreateWatchers(['keyboardEventTarget', 'moveTolerance', 'pixelRatio', 'maxTilesLoading'])),
    created: function created() {
      /**
       * @type {module:ol/View~View}
       * @private
       */
      this._view = new ol.View({
        center: [0, 0],
        zoom: 2
      });
      /**
       * @type {Object|undefined}
       */

      this._viewVm = undefined;
      defineServices$2.call(this); // todo wrap controls into components and provide vl-control-default

      this.initDefaultControls(this.defaultControls); // todo initialize without interactions and provide vl-interaction-default component

      this.initDefaultInteractions(this.defaultInteractions);
    },
    methods: {
      /**
       * @return {module:ol/Map~Map}
       * @protected
       */
      createOlObject: function createOlObject() {
        var _this3 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          var map;
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  map = new ol.Map({
                    pixelRatio: _this3.pixelRatio,
                    moveTolerance: _this3.moveTolerance,
                    keyboardEventTarget: _this3.keyboardEventTarget,
                    maxTilesLoading: _this3.maxTilesLoading,
                    controls: _this3.$controlsCollection,
                    interactions: _this3.$interactionsCollection,
                    layers: _this3.$layersCollection,
                    overlays: _this3.$overlaysCollection,
                    view: _this3.$view
                  });
                  setMapId(map, _this3.currentId);
                  setMapDataProjection(map, _this3.resolvedDataProjection);
                  _this3.size && map.setSize(_this3.size);
                  return _context.abrupt("return", map);

                case 5:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      },

      /**
       * @return {Promise<void>}
       * @protected
       */
      mount: function mount() {
        var _this4 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _this4.setTarget(_this4.$el);

                  return _context2.abrupt("return", olCmp.methods.mount.call(_this4));

                case 2:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }))();
      },

      /**
       * @return {Promise<void>}
       * @protected
       */
      unmount: function unmount() {
        var _this5 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3() {
          return regenerator.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _this5.setTarget(null);

                  return _context3.abrupt("return", olCmp.methods.unmount.call(_this5));

                case 2:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }))();
      },

      /**
       * @protected
       */
      subscribeAll: function subscribeAll() {
        var _this6 = this;

        olCmp.methods.subscribeAll.call(this);
        layersContainer.methods.subscribeAll.call(this);
        controlsContainer.methods.subscribeAll.call(this);
        interactionsContainer.methods.subscribeAll.call(this);
        overlaysContainer.methods.subscribeAll.call(this);
        featuresContainer.methods.subscribeAll.call(this);
        subscribeToEvents.call(this); // view projection can be changed in runtime only through vl-view vm

        this.subscribeTo(fromVueWatcher(this, function () {
          var _this6$$viewVm;

          return (_this6$$viewVm = _this6.$viewVm) === null || _this6$$viewVm === void 0 ? void 0 : _this6$$viewVm.resolvedViewProjection;
        }), function (_ref) {
          var value = _ref.value;
          _this6.viewProjection = value || EPSG_3857;
        });
      },

      /**
       * @returns {Object}
       * @protected
       */
      getServices: function getServices() {
        var vm = this;
        return mergeDescriptors(olCmp.methods.getServices.call(this), layersContainer.methods.getServices.call(this), controlsContainer.methods.getServices.call(this), interactionsContainer.methods.getServices.call(this), overlaysContainer.methods.getServices.call(this), featuresContainer.methods.getServices.call(this), {
          get mapVm() {
            return vm;
          },

          get viewVm() {
            return vm.$viewVm;
          },

          get viewContainer() {
            return vm;
          }

        });
      },

      /**
       * @return {string|number}
       * @protected
       */
      getIdInternal: function getIdInternal() {
        return getMapId(this.$map);
      },

      /**
       * @param {string|number} id
       * @protected
       */
      setIdInternal: function setIdInternal(id) {
        if (id === this.getIdInternal()) return;
        setMapId(this.$map, id);
      },

      /**
       * @return {Promise<module:ol/Map~Map>}
       */
      resolveMap: olCmp.methods.resolveOlObject,

      /**
       * @param {number[]} pixel
       * @param {function} callback
       * @param {Object} [opts]
       * @return {Promise}
       */
      forEachFeatureAtPixel: function forEachFeatureAtPixel(pixel, callback) {
        var _arguments = arguments,
            _this7 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4() {
          var opts;
          return regenerator.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  opts = _arguments.length > 2 && _arguments[2] !== undefined ? _arguments[2] : {};
                  _context4.next = 3;
                  return _this7.resolveMap();

                case 3:
                  return _context4.abrupt("return", _context4.sent.forEachFeatureAtPixel(pixel, callback, opts));

                case 4:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4);
        }))();
      },

      /**
       * @param {number[]} pixel
       * @param {function} callback
       * @param {Object} [opts]
       * @return {Promise}
       */
      forEachLayerAtPixel: function forEachLayerAtPixel(pixel, callback) {
        var _arguments2 = arguments,
            _this8 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee5() {
          var opts;
          return regenerator.wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  opts = _arguments2.length > 2 && _arguments2[2] !== undefined ? _arguments2[2] : {};
                  _context5.next = 3;
                  return _this8.resolveMap();

                case 3:
                  return _context5.abrupt("return", _context5.sent.forEachLayerAtPixel(pixel, callback, opts));

                case 4:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5);
        }))();
      },

      /**
       * @param {number[]} pixel
       * @param {boolean} [viewProj=false]
       * @return {Promise<number[]>} Coordinates in the map view projection.
       */
      getCoordinateFromPixel: function getCoordinateFromPixel(pixel) {
        var _arguments3 = arguments,
            _this9 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee6() {
          var viewProj, coordinate;
          return regenerator.wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  viewProj = _arguments3.length > 1 && _arguments3[1] !== undefined ? _arguments3[1] : false;
                  _context6.next = 3;
                  return _this9.resolveMap();

                case 3:
                  coordinate = _context6.sent.getCoordinateFromPixel(pixel);

                  if (!viewProj) {
                    _context6.next = 6;
                    break;
                  }

                  return _context6.abrupt("return", roundPointCoords(coordinate));

                case 6:
                  return _context6.abrupt("return", _this9.pointToDataProj(coordinate));

                case 7:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6);
        }))();
      },

      /**
       * @param {Event} event
       * @param {boolean} [viewProj=false]
       * @return {Promise<number[]>}
       */
      getEventCoordinate: function getEventCoordinate(event) {
        var _arguments4 = arguments,
            _this10 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee7() {
          var viewProj, coordinate;
          return regenerator.wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  viewProj = _arguments4.length > 1 && _arguments4[1] !== undefined ? _arguments4[1] : false;
                  _context7.next = 3;
                  return _this10.resolveMap();

                case 3:
                  coordinate = _context7.sent.getEventCoordinate(event);

                  if (!viewProj) {
                    _context7.next = 6;
                    break;
                  }

                  return _context7.abrupt("return", roundPointCoords(coordinate));

                case 6:
                  return _context7.abrupt("return", _this10.pointToDataProj(coordinate));

                case 7:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee7);
        }))();
      },

      /**
       * @param {Event} event
       * @return {Promise<number[]>}
       */
      getEventPixel: function getEventPixel(event) {
        var _this11 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee8() {
          return regenerator.wrap(function _callee8$(_context8) {
            while (1) {
              switch (_context8.prev = _context8.next) {
                case 0:
                  _context8.next = 2;
                  return _this11.resolveMap();

                case 2:
                  return _context8.abrupt("return", _context8.sent.getEventPixel(event));

                case 3:
                case "end":
                  return _context8.stop();
              }
            }
          }, _callee8);
        }))();
      },

      /**
       * @param {number[]} pixel
       * @param {Object} [opts]
       * @return {Promise}
       */
      getFeaturesAtPixel: function getFeaturesAtPixel(pixel) {
        var _arguments5 = arguments,
            _this12 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee9() {
          var opts;
          return regenerator.wrap(function _callee9$(_context9) {
            while (1) {
              switch (_context9.prev = _context9.next) {
                case 0:
                  opts = _arguments5.length > 1 && _arguments5[1] !== undefined ? _arguments5[1] : {};
                  _context9.next = 3;
                  return _this12.resolveMap();

                case 3:
                  return _context9.abrupt("return", _context9.sent.getFeaturesAtPixel(pixel, opts));

                case 4:
                case "end":
                  return _context9.stop();
              }
            }
          }, _callee9);
        }))();
      },

      /**
       * @param {number[]} pixel
       * @param {Object} [options]
       * @return {Promise<boolean>}
       */
      hasFeatureAtPixel: function hasFeatureAtPixel(pixel) {
        var _arguments6 = arguments,
            _this13 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee10() {
          var options;
          return regenerator.wrap(function _callee10$(_context10) {
            while (1) {
              switch (_context10.prev = _context10.next) {
                case 0:
                  options = _arguments6.length > 1 && _arguments6[1] !== undefined ? _arguments6[1] : {};
                  _context10.next = 3;
                  return _this13.resolveMap();

                case 3:
                  return _context10.abrupt("return", _context10.sent.hasFeatureAtPixel(pixel, options));

                case 4:
                case "end":
                  return _context10.stop();
              }
            }
          }, _callee10);
        }))();
      },

      /**
       * @param {number[]} coordinate Coordinates in map view projection
       * @param {boolean} [viewProj=false]
       * @return {Promise<number[]>}
       */
      getPixelFromCoordinate: function getPixelFromCoordinate(coordinate) {
        var _arguments7 = arguments,
            _this14 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee11() {
          var viewProj;
          return regenerator.wrap(function _callee11$(_context11) {
            while (1) {
              switch (_context11.prev = _context11.next) {
                case 0:
                  viewProj = _arguments7.length > 1 && _arguments7[1] !== undefined ? _arguments7[1] : false;

                  if (!viewProj) {
                    coordinate = _this14.pointToViewProj(coordinate);
                  }

                  _context11.next = 4;
                  return _this14.resolveMap();

                case 4:
                  return _context11.abrupt("return", _context11.sent.getPixelFromCoordinate(coordinate));

                case 5:
                case "end":
                  return _context11.stop();
              }
            }
          }, _callee11);
        }))();
      },

      /**
       * @return {number[]|undefined}
       */
      getSize: function getSize() {
        var _this$$map;

        return coalesce((_this$$map = this.$map) === null || _this$$map === void 0 ? void 0 : _this$$map.getSize(), this.size);
      },

      /**
       * @param {number[]} size
       */
      setSize: function setSize(size) {
        assert$1(isArray$2(size) && size.length === 2, 'Invalid size');
        size = size.slice();

        if (!isEqual(size, this.size)) {
          this.size = size;
        }

        if (this.$map && !isEqual(size, this.$map.getSize())) {
          this.$map.setSize(size);
        }
      },

      /**
       * Updates map size.
       * @return {Promise<void>}
       */
      updateSize: function updateSize() {
        var _this15 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee12() {
          return regenerator.wrap(function _callee12$(_context12) {
            while (1) {
              switch (_context12.prev = _context12.next) {
                case 0:
                  _context12.next = 2;
                  return _this15.resolveMap();

                case 2:
                  _context12.sent.updateSize();

                case 3:
                case "end":
                  return _context12.stop();
              }
            }
          }, _callee12);
        }))();
      },

      /**
       * @return {Promise<void>}
       */
      render: function render() {
        var _this16 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee13() {
          var map;
          return regenerator.wrap(function _callee13$(_context13) {
            while (1) {
              switch (_context13.prev = _context13.next) {
                case 0:
                  _context13.next = 2;
                  return _this16.resolveMap();

                case 2:
                  map = _context13.sent;
                  return _context13.abrupt("return", new Promise(function (resolve) {
                    map.once('postrender', function () {
                      return resolve();
                    });
                    map.render();
                  }));

                case 4:
                case "end":
                  return _context13.stop();
              }
            }
          }, _callee13);
        }))();
      },

      /**
       * @return {HTMLElement|undefined}
       */
      getTarget: function getTarget() {
        var _this$$map2;

        return coalesce((_this$$map2 = this.$map) === null || _this$$map2 === void 0 ? void 0 : _this$$map2.getTarget(), this.$el);
      },

      /**
       * @param {HTMLElement} target
       */
      setTarget: function setTarget(target) {
        if (this.$map && target !== this.$map.getTarget()) {
          this.$map.setTarget(target);
          this.$emit('update:target', target);
        }
      },

      /**
       * @return {HTMLElement|undefined}
       */
      getViewport: function getViewport() {
        var _this$$map3;

        return (_this$$map3 = this.$map) === null || _this$$map3 === void 0 ? void 0 : _this$$map3.getViewport();
      },

      /**
       * @return {module:ol/View~View|undefined}
       */
      getView: function getView() {
        var _this$$map4;

        return coalesce((_this$$map4 = this.$map) === null || _this$$map4 === void 0 ? void 0 : _this$$map4.getView(), this._view);
      },

      /**
       * @return {Object}
       */
      getViewVm: function getViewVm() {
        return this._viewVm;
      },

      /**
       * @param {module:ol/View~View|Vue|undefined} view
       */
      setView: function setView(view) {
        var _view;

        view = ((_view = view) === null || _view === void 0 ? void 0 : _view.$view) || view;
        assert$1(!view || view instanceof ol.View, 'Invalid view');

        if (view !== this._view) {
          var _view2, _view3;

          this._view = view;
          this._viewVm = ((_view2 = view) === null || _view2 === void 0 ? void 0 : _view2.vm) && ((_view3 = view) === null || _view3 === void 0 ? void 0 : _view3.vm[0]);
        }

        if (this.$map && view !== this.$map.getView()) {
          this.$map.setView(view);
        }

        this.scheduleRefresh();
      },

      /**
       * @return {module:ol/proj~ProjectionLike|undefined}
       */
      getDataProjection: function getDataProjection() {
        return coalesce(this.$map && getMapDataProjection(this.$map), this.resolvedDataProjection);
      },

      /**
       * @param {module:ol/proj~ProjectionLike} projection
       */
      setDataProjection: function setDataProjection(projection) {
        projection = proj.get(projection);
        assert$1(projection != null, 'Invalid projection');

        if (projection.getCode() !== this.currentDataProjection) {
          this.currentDataProjection = projection.getCode();
        }

        if (this.$map && projection.getCode() !== getMapDataProjection(this.$map)) {
          setMapDataProjection(this.$map, projection.getCode());
        }
      },

      /**
       * Triggers focus on map container.
       */
      focus: function focus() {
        this.$el.focus();
      },

      /**
       * Updates map size and re-renders map.
       * @return {Promise}
       */
      refresh: function refresh() {
        var _this17 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee14() {
          return regenerator.wrap(function _callee14$(_context14) {
            while (1) {
              switch (_context14.prev = _context14.next) {
                case 0:
                  _context14.next = 2;
                  return _this17.updateSize();

                case 2:
                  _context14.next = 4;
                  return _this17.render();

                case 4:
                  return _context14.abrupt("return", olCmp.methods.refresh.call(_this17));

                case 5:
                case "end":
                  return _context14.stop();
              }
            }
          }, _callee14);
        }))();
      },
      isInteracting: function isInteracting() {
        if (!this.$map) return false;
        return this.getInteractions().some(function (interaction) {
          return !!interaction.get('interacting');
        });
      },

      /**
       * @param {Object} sourceVm
       * @protected
       */
      featuresOverlaySourceCreated: function featuresOverlaySourceCreated(sourceVm) {
        sourceVm.addFeatures(this.getFeatures());
        var adds = fromVueEvent(this, 'addfeature').pipe(map(function (_ref2) {
          var feature = _ref2.feature;
          return feature;
        }), bufferDebounceTime(FRAME_TIME));
        this.subscribeTo(adds, function (features) {
          return sourceVm.addFeatures(features);
        });
        var removes = fromVueEvent(this, 'removefeature').pipe(map(function (_ref3) {
          var feature = _ref3.feature;
          return feature;
        }), bufferDebounceTime(FRAME_TIME));
        this.subscribeTo(removes, function (features) {
          return sourceVm.removeFeatures(features);
        });
      },

      /**
       * @protected {string} value
       * @protected
       */
      resolvedDataProjectionChanged: function resolvedDataProjectionChanged(value) {
        if (value === this.dataProjection) return;
        this.$emit('update:dataProjection', value);
      }
    }
  };

  function defineServices$2() {
    var _this18 = this;

    Object.defineProperties(this, {
      /**
       * OpenLayers map instance.
       * @type {module:ol/Map~Map|undefined}
       */
      $map: {
        enumerable: true,
        get: function get() {
          return _this18.$olObject;
        }
      },

      /**
       * @type {module:ol/View~View|undefined}
       */
      $view: {
        enumerable: true,
        get: this.getView
      },

      /**
       * @type {Object|undefined}
       */
      $viewVm: {
        enumerable: true,
        get: this.getViewVm
      },
      $featuresOverlayVm: {
        enumerable: true,
        get: function get() {
          var _this18$$refs;

          return (_this18$$refs = _this18.$refs) === null || _this18$$refs === void 0 ? void 0 : _this18$$refs.featuresOverlay;
        }
      },
      $featuresOverlaySourceVm: {
        enumerable: true,
        get: function get() {
          var _this18$$refs2;

          return (_this18$$refs2 = _this18.$refs) === null || _this18$$refs2 === void 0 ? void 0 : _this18$$refs2.featuresOverlaySource;
        }
      }
    });
  }
  /**
   * Subscribe to OL map events.
   *
   * @return {void}
   * @private
   */


  function subscribeToEvents() {
    return _subscribeToEvents.apply(this, arguments);
  }

  function _subscribeToEvents() {
    _subscribeToEvents = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee15() {
      var _this19 = this;

      var setterKey, viewChanges, propChanges, pointerEvents, otherEvents;
      return regenerator.wrap(function _callee15$(_context15) {
        while (1) {
          switch (_context15.prev = _context15.next) {
            case 0:
              setterKey = addPrefix('set');
              viewChanges = fromOlChangeEvent(this.$map, 'view', true).pipe(tap(function (_ref4) {
                var view = _ref4.value;

                if (_this19._viewSubs) {
                  _this19.unsubscribe(_this19._viewSubs);
                }

                if (view) {
                  _this19._viewSubs = _this19.subscribeTo(fromOlChangeEvent(view, 'id', true), _this19.scheduleRefresh.bind(_this19));
                }

                _this19.viewProjection = (view === null || view === void 0 ? void 0 : view.getProjection().getCode()) || EPSG_3857;
                _this19.withCustomView = view && (!view.vm || view.vm.some(function (vm) {
                  return vm !== _this19.$refs.view;
                }));
              }));
              propChanges = merge(viewChanges, fromOlChangeEvent(this.$map, ['dataProjection', 'size', 'target' // 'layerGroup', FIXME not ready
              ], true)).pipe(map(function (evt) {
                return _objectSpread$h(_objectSpread$h({}, evt), {}, {
                  setter: _this19[setterKey(evt.prop)]
                });
              }));
              this.subscribeTo(propChanges, function (_ref5) {
                var setter = _ref5.setter,
                    value = _ref5.value;
                return setter(value);
              }); // pointer

              pointerEvents = merge(fromOlEvent(this.$map, [MapBrowserEventType.CLICK, MapBrowserEventType.DBLCLICK, MapBrowserEventType.SINGLECLICK]), fromOlEvent(this.$map, [MapBrowserEventType.POINTERDRAG, MapBrowserEventType.POINTERMOVE], null, [distinctUntilChanged(function (a, b) {
                return isEqual({
                  t: a.type,
                  c: a.coordinate
                }, {
                  t: b.type,
                  c: b.coordinate
                });
              })])).pipe(map(function (evt) {
                return omit(_objectSpread$h(_objectSpread$h({}, evt), {}, {
                  pixel: evt.pixel,
                  coordinate: _this19.pointToDataProj(evt.coordinate)
                }), ['pixel_', 'coordinate_']);
              })); // other

              otherEvents = fromOlEvent(this.$map, [MapEventType.MOVESTART, MapEventType.MOVEEND, MapEventType.POSTRENDER, RenderEventType.PRECOMPOSE, RenderEventType.POSTCOMPOSE, RenderEventType.RENDERCOMPLETE]);
              this.subscribeTo(merge(pointerEvents, otherEvents), function (evt) {
                return _this19.$emit(evt.type, evt);
              });

            case 7:
            case "end":
              return _context15.stop();
          }
        }
      }, _callee15, this);
    }));
    return _subscribeToEvents.apply(this, arguments);
  }

  /* script */
  var __vue_script__$k = script$k;
  /* template */

  var __vue_render__$2 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      class: _vm.vmClass,
      attrs: {
        "id": _vm.vmId,
        "tabindex": _vm.tabindex
      }
    }, [_vm._t("default"), _vm._v(" "), !_vm.withCustomView ? _c('ViewCmp', {
      ref: "view",
      attrs: {
        "id": 'vl-' + _vm.currentId + '-default-view'
      }
    }) : _vm._e(), _vm._v(" "), _c('VectorLayerCmp', {
      ref: "featuresOverlay",
      attrs: {
        "id": 'vl-' + _vm.currentId + '-default-layer',
        "overlay": true,
        "update-while-animating": _vm.updateWhileAnimating,
        "update-while-interacting": _vm.updateWhileInteracting
      }
    }, [_c('VectorSourceCmp', {
      ref: "featuresOverlaySource",
      attrs: {
        "id": 'vl-' + _vm.currentId + '-default-source',
        "wrap-x": _vm.wrapX,
        "projection": _vm.currentDataProjection
      },
      on: {
        "created": _vm.featuresOverlaySourceCreated
      }
    }, [_vm._t("overlay")], 2)], 1)], 2);
  };

  var __vue_staticRenderFns__$2 = [];
  /* style */

  var __vue_inject_styles__$k = undefined;
  /* scoped */

  var __vue_scope_id__$k = undefined;
  /* module identifier */

  var __vue_module_identifier__$k = undefined;
  /* functional template */

  var __vue_is_functional_template__$k = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$k = /*#__PURE__*/normalizeComponent({
    render: __vue_render__$2,
    staticRenderFns: __vue_staticRenderFns__$2
  }, __vue_inject_styles__$k, __vue_script__$k, __vue_scope_id__$k, __vue_is_functional_template__$k, __vue_module_identifier__$k, false, undefined, undefined, undefined);

  function plugin$l(Vue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$l.installed) {
      return;
    }

    plugin$l.installed = true;
    options = pick(options, 'dataProjection');
    Object.assign(__vue_component__$k, options);
    Object.assign(__vue_component__$l, options);
    Vue.component(__vue_component__$k.name, __vue_component__$k);
    Vue.component(__vue_component__$l.name, __vue_component__$l);
  }

  var Map$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': plugin$l,
    install: plugin$l,
    Map: __vue_component__$k,
    View: __vue_component__$l
  });

  function ownKeys$g(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$g(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$g(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$g(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var MAPBOX_URL_TEMPLATE = 'https://{a-c}.tiles.mapbox.com/v4/{mapId}/{z}/{x}/{y}{tileNameSuffix}.{tileFormat}?access_token={accessToken}';
  var MAPBOX_ATTRIBUTIONS = '&copy; <a href="https://www.mapbox.com/" target="_blank">MapBox</a>.';
  var script$j = {
    name: 'VlSourceMapbox',
    mixins: [xyzSource],
    props: {
      /* eslint-disable vue/require-prop-types */
      // ol/source/Source
      attributions: _objectSpread$g(_objectSpread$g({}, source.props.attributions), {}, {
        default: MAPBOX_ATTRIBUTIONS
      }),
      // ol/source/UrlTile
      url: _objectSpread$g(_objectSpread$g({}, urlTileSource.props.url), {}, {
        default: MAPBOX_URL_TEMPLATE
      }),

      /* eslint-enable vue/require-prop-types */
      // custom
      accessToken: {
        type: String,
        required: true
      },
      mapId: {
        type: String,
        required: true
      },
      tileFormat: {
        type: String,
        default: 'png'
      }
    },
    computed: {
      /**
       * @type {string}
       */
      tileNameSuffix: function tileNameSuffix() {
        return _tileNameSuffix(this.tilePixelRatio);
      },

      /**
       * @type {string[]}
       */
      urlTokens: function urlTokens() {
        return ['mapId', 'accessToken', 'tileNameSuffix', 'tileFormat'];
      }
    }
  };
  /**
   * @param {number} [ratio]
   * @returns {number}
   * @private
   */

  function tileRatio(ratio) {
    ratio = coalesce(ratio, 1);
    return ratio > 1 ? 2 : 1;
  }
  /**
   * @param {number} [ratio]
   * @returns {string}
   * @private
   */


  function _tileNameSuffix(ratio) {
    ratio = tileRatio(ratio);
    return ratio > 1 ? ['@', ratio, 'x'].join('') : '';
  }

  /* script */
  var __vue_script__$j = script$j;
  /* template */

  /* style */

  var __vue_inject_styles__$j = undefined;
  /* scoped */

  var __vue_scope_id__$j = undefined;
  /* module identifier */

  var __vue_module_identifier__$j = undefined;
  /* functional template */

  var __vue_is_functional_template__$j = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$j = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$j, __vue_script__$j, __vue_scope_id__$j, __vue_is_functional_template__$j, __vue_module_identifier__$j, false, undefined, undefined, undefined);

  function plugin$k(Vue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$k.installed) {
      return;
    }

    plugin$k.installed = true;
    options = pick(options, 'dataProjection');
    Object.assign(__vue_component__$j, options);
    Vue.component(__vue_component__$j.name, __vue_component__$j);
  }

  var MapboxSource = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': plugin$k,
    install: plugin$k,
    Source: __vue_component__$j
  });

  /**
   * @module ol/layer/VectorTileRenderType
   */
  /**
   * @enum {string}
   * Render mode for vector tiles:
   *  * `'image'`: Vector tiles are rendered as images. Great performance, but
   *    point symbols and texts are always rotated with the view and pixels are
   *    scaled during zoom animations.
   *  * `'hybrid'`: Polygon and line elements are rendered as images, so pixels
   *    are scaled during zoom animations. Point symbols and texts are accurately
   *    rendered as vectors and can stay upright on rotated views.
   *  * `'vector'`: Everything is rendered as vectors. Use this mode for improved
   *    performance on vector tile layers with only a few rendered features (e.g.
   *    for highlighting a subset of features of another layer with the same
   *    source).
   * @api
   */
  var RenderType = {
      IMAGE: 'image',
      HYBRID: 'hybrid',
      VECTOR: 'vector',
  };

  function ownKeys$f(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$f(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$f(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$f(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var script$i = {
    name: 'VlLayerVectorTile',
    mixins: [tileLayer, vectorLayer],
    props: {
      renderMode: {
        type: String,
        default: RenderType.HYBRID,
        validator: function validator(val) {
          return Object.values(RenderType).includes(val);
        }
      }
    },
    watch: _objectSpread$f({}, /*#__PURE__*/makeChangeOrRecreateWatchers(['renderMode'])),
    methods: {
      /**
       * @return {VectorTileLayer}
       * @protected
       */
      createLayer: function createLayer() {
        return new layer$1.VectorTile({
          // ol/layer/Base
          className: this.className,
          opacity: this.currentOpacity,
          visible: this.currentVisible,
          extent: this.currentExtentViewProj,
          zIndex: this.currentZIndex,
          minResolution: this.currentMinResolution,
          maxResolution: this.currentMaxResolution,
          minZoom: this.currentMinZoom,
          maxZoom: this.currentMaxZoom,
          // ol/layer/Layer
          render: this.render,
          source: this.$source,
          // ol/layer/BaseVector
          renderOrder: this.renderOrder,
          renderBuffer: this.renderBuffer,
          declutter: this.declutter,
          updateWhileAnimating: this.updateWhileAnimating,
          updateWhileInteracting: this.updateWhileInteracting,
          style: this.$style,
          // ol/layer/VectorTile
          // tile layer props
          preload: this.currentPreload,
          useInterimTilesOnError: this.currentUseInterimTilesOnError,
          // vector tile props
          renderMode: this.renderMode
        });
      }
    }
  };

  /* script */
  var __vue_script__$i = script$i;
  /* template */

  /* style */

  var __vue_inject_styles__$i = undefined;
  /* scoped */

  var __vue_scope_id__$i = undefined;
  /* module identifier */

  var __vue_module_identifier__$i = undefined;
  /* functional template */

  var __vue_is_functional_template__$i = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$i = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$i, __vue_script__$i, __vue_scope_id__$i, __vue_is_functional_template__$i, __vue_module_identifier__$i, false, undefined, undefined, undefined);

  function plugin$j(Vue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$j.installed) {
      return;
    }

    plugin$j.installed = true;
    options = pick(options, 'dataProjection');
    Object.assign(__vue_component__$i, options);
    Vue.component(__vue_component__$i.name, __vue_component__$i);
  }

  var VectorTileLayer = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': plugin$j,
    install: plugin$j,
    Layer: __vue_component__$i
  });

  function ownKeys$e(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$e(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$e(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$e(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var script$h = {
    name: 'VlLayerMapboxVector',
    extends: __vue_component__$i,
    props: {
      styleUrl: {
        type: String,
        required: true
      },
      accessToken: {
        type: String,
        required: true
      },
      sourceId: String,
      layerIds: {
        type: Array,
        validate: function validate(val) {
          return isArray$2(val) && val.every(isString);
        }
      },
      // eslint-disable-next-line vue/require-prop-types
      declutter: _objectSpread$e(_objectSpread$e({}, vectorLayer.props.declutter), {}, {
        default: true
      })
    },
    watch: _objectSpread$e({}, makeChangeOrRecreateWatchers(['styleUrl', 'accessToken', 'sourceId', 'layerIds'], ['layerIds'])),
    methods: {
      /**
       * @returns {HeatmapLayer}
       */
      createLayer: function createLayer() {
        return new layer$1.MapboxVector({
          // ol/layer/Base
          className: this.className,
          opacity: this.currentOpacity,
          visible: this.currentVisible,
          extent: this.currentExtentViewProj,
          zIndex: this.currentZIndex,
          minResolution: this.currentMinResolution,
          maxResolution: this.currentMaxResolution,
          minZoom: this.currentMinZoom,
          maxZoom: this.currentMaxZoom,
          // ol/layer/BaseVector
          renderOrder: this.renderOrder,
          renderBuffer: this.renderBuffer,
          declutter: this.declutter,
          updateWhileAnimating: this.updateWhileAnimating,
          updateWhileInteracting: this.updateWhileInteracting,
          // ol/layer/Tile
          preload: this.currentPreload,
          useInterimTilesOnError: this.currentUseInterimTilesOnError,
          // ol/layer/MapboxVector
          styleUrl: this.styleUrl,
          accessToken: this.accessToken,
          source: this.sourceId,
          layers: this.layerIds
        });
      }
    }
  };

  /* script */
  var __vue_script__$h = script$h;
  /* template */

  /* style */

  var __vue_inject_styles__$h = undefined;
  /* scoped */

  var __vue_scope_id__$h = undefined;
  /* module identifier */

  var __vue_module_identifier__$h = undefined;
  /* functional template */

  var __vue_is_functional_template__$h = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$h = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$h, __vue_script__$h, __vue_scope_id__$h, __vue_is_functional_template__$h, __vue_module_identifier__$h, false, undefined, undefined, undefined);

  function plugin$i(Vue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$i.installed) {
      return;
    }

    plugin$i.installed = true;
    options = pick(options, 'dataProjection');
    Object.assign(__vue_component__$h, options);
    Vue.component(__vue_component__$h.name, __vue_component__$h);
  }

  var MapboxVectorLayer = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': plugin$i,
    install: plugin$i,
    Layer: __vue_component__$h
  });

  function ownKeys$d(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$d(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$d(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$d(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var script$g = {
    name: 'VlInteractionModify',
    mixins: [interaction, styleContainer],
    stubVNode: {
      empty: false,
      attrs: function attrs() {
        return {
          id: this.vmId,
          class: this.vmClass
        };
      }
    },
    props: {
      /**
       * Source or collection identifier from IdentityMap.
       * @type {String}
       */
      source: {
        type: String,
        required: true
      },

      /**
       * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event will be
       * considered to add or move a vertex to the sketch. Default is `ol.events.condition.primaryAction`.
       * @type {function|undefined}
       */
      condition: {
        type: Function,
        default: condition.primaryAction
      },

      /**
       * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.
       * By default, `ol.events.condition.singleClick` with `ol.events.condition.altKeyOnly` results in a vertex deletion.
       * @type {function|undefined}
       */
      deleteCondition: {
        type: Function,
        default: condition.altKeyOnly
      },

      /**
       * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether a new vertex can be added
       * to the sketch features. Default is `ol.events.condition.always`.
       * @type {function|undefined}
       */
      insertVertexCondition: {
        type: Function,
        default: condition.always
      },

      /**
       * Pixel tolerance for considering the pointer close enough to a segment or vertex for editing.
       * @type {number}
       */
      pixelTolerance: {
        type: Number,
        default: 10
      },

      /**
       * Wrap the world horizontally on the sketch overlay.
       * @type {boolean}
       */
      wrapX: {
        type: Boolean,
        default: false
      }
    },
    watch: _objectSpread$d({}, /*#__PURE__*/makeChangeOrRecreateWatchers(['source', 'condition', 'deleteCondition', 'insertVertexCondition', 'pixelTolerance', 'wrapX'])),
    methods: {
      /**
       * @return {Promise<Modify>}
       * @protected
       */
      createInteraction: function createInteraction() {
        var _this = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          var source, features;
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return _this.getInstance(_this.source);

                case 2:
                  source = _this._source = _context.sent;
                  assert$1(!!source, "Source \"".concat(_this.source, "\" not found in identity map."));

                  if (source instanceof source$1.Vector) {
                    features = source.getFeaturesCollection();

                    if (features) {
                      instanceOf(features, ol.Collection, "Source \"".concat(_this.source, "\" doesn't provide features collection."));
                      source = null;
                    }
                  } else {
                    if (isFunction$1(source.getFeaturesCollection)) {
                      features = source.getFeaturesCollection();
                    } else if (isFunction$1(source.getFeatures)) {
                      features = source.getFeatures();
                    }

                    instanceOf(features, ol.Collection, "Source \"".concat(_this.source, "\" doesn't provide features collection."));
                    source = null;
                  }

                  return _context.abrupt("return", new interaction$1.Modify({
                    source: source,
                    features: features,
                    condition: _this.condition,
                    deleteCondition: _this.deleteCondition,
                    insertVertexCondition: _this.insertVertexCondition,
                    pixelTolerance: _this.pixelTolerance,
                    wrapX: _this.wrapX,
                    style: _this.$style
                  }));

                case 6:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      },

      /**
       * @returns {Object}
       * @protected
       */
      getServices: function getServices() {
        return mergeDescriptors(interaction.methods.getServices.call(this), styleContainer.methods.getServices.call(this));
      },

      /**
       * @return {void}
       * @protected
       */
      subscribeAll: function subscribeAll() {
        interaction.methods.subscribeAll.call(this);
        subscribeToInteractionChanges$3.call(this);
      },

      /**
       * @return {StyleTarget}
       * @protected
       */
      getStyleTarget: function getStyleTarget() {
        var _this2 = this;

        return {
          getStyle: function getStyle() {
            return _this2._style;
          },
          setStyle: function setStyle() {

            _this2.scheduleRecreate();
          }
        };
      },
      getOverlay: function getOverlay() {
        var _this3 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.next = 2;
                  return _this3.resolveInteraction();

                case 2:
                  return _context2.abrupt("return", _context2.sent.getOverlay());

                case 3:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }))();
      },
      getPointerCount: function getPointerCount() {
        var _this4 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3() {
          return regenerator.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  _context3.next = 2;
                  return _this4.resolveInteraction();

                case 2:
                  return _context3.abrupt("return", _context3.sent.getPointerCount());

                case 3:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }))();
      },
      removePoint: function removePoint() {
        var _this5 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4() {
          return regenerator.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  _context4.next = 2;
                  return _this5.resolveInteraction();

                case 2:
                  return _context4.abrupt("return", _context4.sent.removePoint());

                case 3:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4);
        }))();
      }
    }
  };
  /**
   * @private
   */

  function subscribeToInteractionChanges$3() {
    var _this6 = this;

    var modifying;
    var start = fromOlEvent(this.$interaction, 'modifystart').pipe(tap(function (evt) {
      _this6.setInteracting(true);

      modifying = [];
      evt.features.forEach(function (feature) {
        modifying[feature.getId()] = feature.getRevision();
      });
    }));
    var end = fromOlEvent(this.$interaction, 'modifyend').pipe(map(function (evt) {
      return _objectSpread$d(_objectSpread$d({}, evt), {}, {
        modified: evt.features.getArray().reduce(function (modified, feature, idx) {
          if (modifying[feature.getId()] !== feature.getRevision()) {
            modified[idx] = feature.getId();
          }

          return modified;
        }, {})
      });
    }), tap(function () {
      return _this6.setInteracting(false);
    }));
    var events = merge(start, end).pipe(map(function (_ref) {
      var type = _ref.type,
          features = _ref.features,
          modified = _ref.modified;
      var viewProj = _this6.resolvedViewProjection;
      var dataProj = _this6.resolvedDataProjection;
      return {
        type: type,
        features: features instanceof ol.Collection ? features.getArray() : features,
        modified: modified || {},

        get json() {
          if (!this._json) {
            this._json = map$1(this.features, function (feature) {
              return writeGeoJsonFeature(feature, viewProj, dataProj, COORD_PRECISION);
            });
          }

          return this._json;
        }

      };
    }));
    this.subscribeTo(events, function (evt) {
      return _this6.$emit(evt.type, evt);
    });
  }

  /* script */
  var __vue_script__$g = script$g;
  /* template */

  /* style */

  var __vue_inject_styles__$g = undefined;
  /* scoped */

  var __vue_scope_id__$g = undefined;
  /* module identifier */

  var __vue_module_identifier__$g = undefined;
  /* functional template */

  var __vue_is_functional_template__$g = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$g = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$g, __vue_script__$g, __vue_scope_id__$g, __vue_is_functional_template__$g, __vue_module_identifier__$g, false, undefined, undefined, undefined);

  function plugin$h(Vue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$h.installed) {
      return;
    }

    plugin$h.installed = true;
    options = pick(options, 'dataProjection');
    Object.assign(__vue_component__$g, options);
    Vue.component(__vue_component__$g.name, __vue_component__$g);
  }

  var ModifyInteraction = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': plugin$h,
    install: plugin$h,
    Interaction: __vue_component__$g
  });

  function ownKeys$c(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$c(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$c(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$c(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var OSM_ATTRIBUTIONS = '&copy; <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors.';
  var OSM_URL_TEMPLATE = 'https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png';
  var OSM_MAX_ZOOM = 19;
  var script$f = {
    name: 'VlSourceOsm',
    mixins: [xyzSource],
    props: {
      /* eslint-disable vue/require-prop-types */
      // ol/source/Source
      attributions: _objectSpread$c(_objectSpread$c({}, source.props.attributions), {}, {
        default: OSM_ATTRIBUTIONS
      }),
      // ol/source/UrlTile
      url: _objectSpread$c(_objectSpread$c({}, urlTileSource.props.url), {}, {
        default: OSM_URL_TEMPLATE
      }),
      // ol/source/XYZ
      maxZoom: _objectSpread$c(_objectSpread$c({}, xyzSource.props.maxZoom), {}, {
        default: OSM_MAX_ZOOM
      })
      /* eslint-enable vue/require-prop-types */

    },
    computed: {
      tileGridIdent: noop$1,
      inputTileGridFactory: noop$1,
      inputTileUrlFunction: noop$1
    },
    watch: _objectSpread$c({}, /*#__PURE__*/makeChangeOrRecreateWatchers(['inputUrl', 'maxZoom'])),
    methods: {
      createSource: function createSource() {
        // always EPSG:3857, size: 256x256, format png
        return new source$1.OSM({
          // ol/source/Source
          attributions: this.currentAttributions,
          wrapX: this.wrapX,
          // ol/source/Tile
          cacheSize: this.cacheSize,
          opaque: this.opaque,
          // ol/source/UrlTile
          tileLoadFunction: this.currentTileLoadFunction,
          url: this.currentUrls[0],
          // ol/source/TileImage
          crossOrigin: this.crossOrigin,
          reprojectionErrorThreshold: this.reprojectionErrorThreshold,
          imageSmoothing: this.imageSmoothing,
          // ol/source/XYZ
          maxZoom: this.maxZoom
        });
      },
      inputUrlChanged: function inputUrlChanged(value) {
        this.setUrl(value);
      },
      // skip all other handlers
      tileClassChanged: noop$1,
      inputTileUrlFunctionChanged: noop$1,
      inputTileGridFactoryChanged: noop$1,
      tileGridChanged: noop$1,
      tilePixelRatioChanged: noop$1,
      transitionChanged: noop$1,
      zDirectionChanged: noop$1,
      attributionsCollapsibleChanged: noop$1,
      projectionChanged: noop$1
    }
  };

  /* script */
  var __vue_script__$f = script$f;
  /* template */

  /* style */

  var __vue_inject_styles__$f = undefined;
  /* scoped */

  var __vue_scope_id__$f = undefined;
  /* module identifier */

  var __vue_module_identifier__$f = undefined;
  /* functional template */

  var __vue_is_functional_template__$f = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$f = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$f, __vue_script__$f, __vue_scope_id__$f, __vue_is_functional_template__$f, __vue_module_identifier__$f, false, undefined, undefined, undefined);

  function plugin$g(Vue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$g.installed) {
      return;
    }

    plugin$g.installed = true;
    options = pick(options, 'dataProjection');
    Object.assign(__vue_component__$f, options);
    Vue.component(__vue_component__$f.name, __vue_component__$f);
  }

  var OsmSource = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': plugin$g,
    install: plugin$g,
    Source: __vue_component__$f
  });

  /**
   * @module ol/OverlayPositioning
   */
  /**
   * Overlay position: `'bottom-left'`, `'bottom-center'`,  `'bottom-right'`,
   * `'center-left'`, `'center-center'`, `'center-right'`, `'top-left'`,
   * `'top-center'`, `'top-right'`
   * @enum {string}
   */
  var OverlayPositioning = {
      BOTTOM_LEFT: 'bottom-left',
      BOTTOM_CENTER: 'bottom-center',
      BOTTOM_RIGHT: 'bottom-right',
      CENTER_LEFT: 'center-left',
      CENTER_CENTER: 'center-center',
      CENTER_RIGHT: 'center-right',
      TOP_LEFT: 'top-left',
      TOP_CENTER: 'top-center',
      TOP_RIGHT: 'top-right',
  };

  function ownKeys$b(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$b(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$b(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$b(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var script$e = {
    name: 'VlOverlay',
    mixins: [projTransforms, olCmp, waitForMap],
    props: {
      offset: {
        type: Array,
        default: function _default() {
          return [0, 0];
        },
        validator: function validator(value) {
          return value.length === 2;
        }
      },
      position: {
        type: Array,
        validator: function validator(value) {
          return value.length === 2;
        } // required: true,

      },
      positioning: {
        type: String,
        default: OverlayPositioning.TOP_LEFT,
        validator: function validator(value) {
          return Object.values(OverlayPositioning).includes(value);
        }
      },
      stopEvent: {
        type: Boolean,
        default: true
      },
      insertFirst: {
        type: Boolean,
        default: true
      },
      autoPan: [Boolean, Object],
      autoPanMargin: Number,
      autoPanAnimation: Object,
      autoPanOptions: Object,
      className: String
    },
    data: function data() {
      return {
        visible: false,
        viewProjection: EPSG_3857,
        dataProjection: EPSG_3857,
        currentOffset: this.offset.slice(),
        currentPositionViewProj: roundPointCoords(this.position),
        currentPositioning: this.positioning
      };
    },
    computed: {
      positionDataProj: function positionDataProj() {
        return roundPointCoords(this.position);
      },
      positionViewProj: function positionViewProj() {
        return this.pointToViewProj(this.position);
      },
      currentPositionDataProj: function currentPositionDataProj() {
        return this.pointToDataProj(this.currentPositionViewProj);
      },
      inputOffset: function inputOffset() {
        return this.offset.slice();
      },
      inputAutoPan: function inputAutoPan() {
        return isPlainObject(this.autoPan) ? clonePlainObject(this.autoPan) : this.autoPan;
      },
      inputAutoPanAnimation: function inputAutoPanAnimation() {
        return isPlainObject(this.autoPanAnimation) ? clonePlainObject(this.autoPanAnimation) : this.autoPanAnimation;
      },
      inputAutoPanOptions: function inputAutoPanOptions() {
        return isPlainObject(this.autoPanOptions) ? clonePlainObject(this.autoPanOptions) : this.autoPanOptions;
      },
      classes: function classes() {
        return [this.vmClass, this.visible ? 'visible' : undefined].filter(identity$2);
      }
    },
    watch: _objectSpread$b({
      rev: function rev() {
        if (!this.$overlay) return;

        if (!isEqual(this.currentOffset, this.$overlay.getOffset())) {
          this.currentOffset = this.$overlay.getOffset();
        }

        if (!isEqual(this.currentPositionViewProj, this.$overlay.getPosition())) {
          this.currentPositionViewProj = this.$overlay.getPosition();
        }

        if (this.currentPositioning !== this.$overlay.getPositioning()) {
          this.currentPositioning = this.$overlay.getPositioning();
        }
      },
      inputOffset: {
        deep: true,
        handler: function handler(value) {
          this.setOffset(value);
        }
      },
      currentOffset: {
        deep: true,
        handler: function handler(value) {
          if (isEqual(value, this.inputOffset)) return;
          this.$emit('update:offset', value.slice());
        }
      },
      positionViewProj: {
        deep: true,
        handler: function handler(value) {
          this.setPosition(value, true);
        }
      },
      currentPositionDataProj: {
        deep: true,
        handler: function handler(value) {
          if (isEqual(value, this.positionDataProj)) return;
          this.$emit('update:position', value === null || value === void 0 ? void 0 : value.slice());
        }
      },
      positioning: function positioning(value) {
        this.setPositioning(value);
      },
      currentPositioning: function currentPositioning(value) {
        if (value === this.positioning) return;
        this.$emit('update:positioning', value);
      }
    }, /*#__PURE__*/makeChangeOrRecreateWatchers(['stopEvent', 'insertFirst', 'autoPanMargin', 'className', 'inputAutoPan', 'inputAutoPanAnimation', 'inputAutoPanOptions'], ['inputAutoPan', 'inputAutoPanAnimation', 'inputAutoPanOptions'])),
    methods: {
      /**
       * @return {Promise<void>}
       * @protected
       */
      beforeInit: function beforeInit() {
        var _this = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  defineServices$1.call(_this);
                  _context.next = 3;
                  return Promise.all([olCmp.methods.beforeInit.call(_this), waitForMap.methods.beforeInit.call(_this)]);

                case 3:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      },

      /**
       * @return {module:ol/Overlay~Overlay}
       * @protected
       */
      createOlObject: function createOlObject() {
        var overlay = new ol.Overlay({
          id: this.currentId,
          element: this.$el,
          offset: this.currentOffset,
          position: this.currentPositionViewProj,
          positioning: this.currentPositioning,
          stopEvent: this.stopEvent,
          insertFirst: this.insertFirst,
          autoPan: this.inputAutoPan,
          autoPanMargin: this.autoPanMargin,
          autoPanAnimation: this.inputAutoPanAnimation,
          autoPanOptions: this.inputAutoPanOptions,
          className: this.className
        });
        initializeOverlay(overlay, this.currentId);
        return overlay;
      },

      /**
       * @return {Promise<void>}
       * @protected
       */
      mount: function mount() {
        var _this2 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
          var _this2$$overlaysConta;

          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _this2.visible = true;
                  (_this2$$overlaysConta = _this2.$overlaysContainer) === null || _this2$$overlaysConta === void 0 ? void 0 : _this2$$overlaysConta.addOverlay(_this2.$overlay);
                  return _context2.abrupt("return", olCmp.methods.mount.call(_this2));

                case 3:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }))();
      },

      /**
       * @return {Promise<void>}
       * @protected
       */
      unmount: function unmount() {
        var _this3 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3() {
          var _this3$$overlaysConta;

          return regenerator.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  (_this3$$overlaysConta = _this3.$overlaysContainer) === null || _this3$$overlaysConta === void 0 ? void 0 : _this3$$overlaysConta.removeOverlay(_this3.$overlay);
                  _this3.visible = false;
                  return _context3.abrupt("return", olCmp.methods.unmount.call(_this3));

                case 3:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }))();
      },

      /**
       * @return {void}
       * @protected
       */
      subscribeAll: function subscribeAll() {
        olCmp.methods.subscribeAll.call(this);
        subscribeToOverlayChanges.call(this);
      },

      /**
       * @return {*}
       * @protected
       */
      getIdInternal: function getIdInternal() {
        return getOverlayId(this.$overlay);
      },

      /**
       * @param {*} id
       * @protected
       */
      setIdInternal: function setIdInternal(id) {
        if (id === this.getIdInternal()) return;
        setOverlayId(this.$overlay, id);
      },

      /**
       * @return {Promise<module:ol/Overlay~Overlay>}
       */
      resolveOverlay: olCmp.methods.resolveOlObject,
      getOffset: function getOffset() {
        var _this$$overlay;

        return coalesce((_this$$overlay = this.$overlay) === null || _this$$overlay === void 0 ? void 0 : _this$$overlay.getOffset(), this.currentOffset);
      },
      setOffset: function setOffset(offset) {
        assert$1(isArray$2(offset) && offset.length === 2, 'Invalid offset');
        offset = offset.slice();

        if (!isEqual(offset, this.currentOffset)) {
          this.currentOffset = offset;
        }

        if (this.$overlay && !isEqual(offset, this.$overlay.getOffset())) {
          this.$overlay.setOffset(offset);
        }
      },
      getPosition: function getPosition() {
        var viewProj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

        if (!this.$overlay) {
          return viewProj ? this.currentPositionViewProj : this.currentPositionDataProj;
        }

        var position = this.$overlay.getPosition();
        if (viewProj) return roundPointCoords(position);
        return this.pointToDataProj(position);
      },
      setPosition: function setPosition(position) {
        var _position;

        var viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        assert$1(position == null || isArray$2(position) && position.length === 2, 'Invalid position');
        position = (_position = position) === null || _position === void 0 ? void 0 : _position.slice();

        if (!viewProj) {
          position = this.pointToViewProj(position);
        }

        if (!isEqual(position, this.currentPositionViewProj)) {
          this.currentPositionViewProj = position;
        }

        if (this.$overlay && !isEqual(position, this.$overlay.getPosition())) {
          this.$overlay.setPosition(position);
        }
      },
      getPositioning: function getPositioning() {
        var _this$$overlay2;

        return ((_this$$overlay2 = this.$overlay) === null || _this$$overlay2 === void 0 ? void 0 : _this$$overlay2.getPositioning()) || this.currentPositioning;
      },
      setPositioning: function setPositioning(positioning) {
        if (positioning !== this.currentPositioning) {
          this.currentPositioning = positioning;
        }

        if (this.$overlay && positioning !== this.$overlay.getPositioning()) {
          this.$overlay.setPositioning(positioning);
        }
      },
      panIntoView: function panIntoView() {
        var _arguments = arguments,
            _this4 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4() {
          var options;
          return regenerator.wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  options = _arguments.length > 0 && _arguments[0] !== undefined ? _arguments[0] : {};
                  _context4.next = 3;
                  return _this4.resolveOverlay();

                case 3:
                  _context4.sent.panIntoView(options);

                case 4:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4);
        }))();
      }
    }
  };

  function defineServices$1() {
    var _this5 = this;

    Object.defineProperties(this, {
      $overlay: {
        enumerable: true,
        get: function get() {
          return _this5.$olObject;
        }
      },
      $mapVm: {
        enumerable: true,
        get: function get() {
          var _this5$$services;

          return (_this5$$services = _this5.$services) === null || _this5$$services === void 0 ? void 0 : _this5$$services.mapVm;
        }
      },
      $viewVm: {
        enumerable: true,
        get: function get() {
          var _this5$$services2;

          return (_this5$$services2 = _this5.$services) === null || _this5$$services2 === void 0 ? void 0 : _this5$$services2.viewVm;
        }
      },
      $overlaysContainer: {
        enumerable: true,
        get: function get() {
          var _this5$$services3;

          return (_this5$$services3 = _this5.$services) === null || _this5$$services3 === void 0 ? void 0 : _this5$$services3.overlaysContainer;
        }
      }
    });
  }
  /**
   * @return {void}
   * @private
   */


  function subscribeToOverlayChanges() {
    var _this6 = this;

    var setterKey = addPrefix('set');
    var propChanges = fromOlChangeEvent(this.$overlay, ['offset', 'position', 'positioning'], true, function (evt) {
      return _objectSpread$b(_objectSpread$b({}, evt), {}, {
        setter: function setter(val) {
          var args = [val];

          if (evt.prop === 'position') {
            args.push(true);
          }

          _this6[setterKey(evt.prop)].apply(_this6, args);
        }
      });
    });
    this.subscribeTo(propChanges, function (_ref) {
      var setter = _ref.setter,
          value = _ref.value;
      return setter(value);
    });
  }

  /* script */
  var __vue_script__$e = script$e;
  /* template */

  var __vue_render__$1 = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('div', {
      class: _vm.classes,
      attrs: {
        "id": _vm.vmId
      }
    }, [_vm._t("default", null, {
      "id": _vm.currentId,
      "position": _vm.currentPositionDataProj,
      "offset": _vm.currentOffset,
      "positioning": _vm.currentPositioning
    })], 2);
  };

  var __vue_staticRenderFns__$1 = [];
  /* style */

  var __vue_inject_styles__$e = undefined;
  /* scoped */

  var __vue_scope_id__$e = undefined;
  /* module identifier */

  var __vue_module_identifier__$e = undefined;
  /* functional template */

  var __vue_is_functional_template__$e = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$e = /*#__PURE__*/normalizeComponent({
    render: __vue_render__$1,
    staticRenderFns: __vue_staticRenderFns__$1
  }, __vue_inject_styles__$e, __vue_script__$e, __vue_scope_id__$e, __vue_is_functional_template__$e, __vue_module_identifier__$e, false, undefined, undefined, undefined);

  function plugin$f(Vue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$f.installed) {
      return;
    }

    plugin$f.installed = true;
    options = pick(options, 'dataProjection');
    Object.assign(__vue_component__$e, options);
    Vue.component(__vue_component__$e.name, __vue_component__$e);
  }

  var Overlay = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': plugin$f,
    install: plugin$f,
    Overlay: __vue_component__$e
  });

  var defineProperty = createCommonjsModule(function (module) {
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  module.exports = _defineProperty;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  });

  var _defineProperty = /*@__PURE__*/getDefaultExportFromCjs(defineProperty);

  var classCallCheck = createCommonjsModule(function (module) {
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  module.exports = _classCallCheck;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  });

  var _classCallCheck = /*@__PURE__*/getDefaultExportFromCjs(classCallCheck);

  var createClass = createCommonjsModule(function (module) {
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  module.exports = _createClass;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  });

  var _createClass = /*@__PURE__*/getDefaultExportFromCjs(createClass);

  var getPrototypeOf = createCommonjsModule(function (module) {
  function _getPrototypeOf(o) {
    module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    module.exports["default"] = module.exports, module.exports.__esModule = true;
    return _getPrototypeOf(o);
  }

  module.exports = _getPrototypeOf;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  });

  var _getPrototypeOf = /*@__PURE__*/getDefaultExportFromCjs(getPrototypeOf);

  var superPropBase = createCommonjsModule(function (module) {
  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  module.exports = _superPropBase;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  });

  var get = createCommonjsModule(function (module) {
  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      module.exports = _get = Reflect.get;
      module.exports["default"] = module.exports, module.exports.__esModule = true;
    } else {
      module.exports = _get = function _get(target, property, receiver) {
        var base = superPropBase(target, property);
        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };

      module.exports["default"] = module.exports, module.exports.__esModule = true;
    }

    return _get(target, property, receiver || target);
  }

  module.exports = _get;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  });

  var _get = /*@__PURE__*/getDefaultExportFromCjs(get);

  var setPrototypeOf = createCommonjsModule(function (module) {
  function _setPrototypeOf(o, p) {
    module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    module.exports["default"] = module.exports, module.exports.__esModule = true;
    return _setPrototypeOf(o, p);
  }

  module.exports = _setPrototypeOf;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  });

  var inherits = createCommonjsModule(function (module) {
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) setPrototypeOf(subClass, superClass);
  }

  module.exports = _inherits;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  });

  var _inherits = /*@__PURE__*/getDefaultExportFromCjs(inherits);

  var assertThisInitialized = createCommonjsModule(function (module) {
  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  module.exports = _assertThisInitialized;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  });

  var possibleConstructorReturn = createCommonjsModule(function (module) {
  var _typeof = _typeof_1["default"];



  function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
      return call;
    }

    return assertThisInitialized(self);
  }

  module.exports = _possibleConstructorReturn;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  });

  var _possibleConstructorReturn = /*@__PURE__*/getDefaultExportFromCjs(possibleConstructorReturn);

  /*!
  Rotate vector features interaction for OpenLayers

  @package ol-rotate-feature
  @author Vladimir Vershinin <ghettovoice@gmail.com>
  @version 3.0.1
  @licence MIT
  @copyright (c) 2016-2020, Vladimir Vershinin <ghettovoice@gmail.com>
  */

  /**
   * This file is part of ol-rotate-feature package.
   * @module ol-rotate-feature
   * @license MIT
   * @author Vladimir Vershinin
   */

  /**
   * @param {boolean} condition
   * @param {string} message
   * @throws Error
   */
  function assert(condition) {
    var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    message = ['Assertion failed', message].join(': ');

    if (!condition) {
      throw new Error(message);
    }
  }
  /**
   * @param {*} arg
   * @returns {*}
   */

  function identity(arg) {
    return arg;
  }
  function includes(arr, value) {
    return arr.indexOf(value) !== -1;
  }
  function isArray(val) {
    return Object.prototype.toString.call(val) === '[object Array]';
  }

  /**
   * This file is part of ol-rotate-feature package.
   * @module ol-rotate-feature
   * @license MIT
   * @author Vladimir Vershinin
   */

  /**
   * @enum {string}
   */
  var RotateFeatureEventType = {
    /**
     * Triggered upon feature rotate start.
     * @event RotateFeatureEvent#rotatestart
     */
    START: 'rotatestart',

    /**
     * Triggered upon feature rotation.
     * @event RotateFeatureEvent#rotating
     */
    ROTATING: 'rotating',

    /**
     * Triggered upon feature rotation end.
     * @event RotateFeatureEvent#rotateend
     */
    END: 'rotateend'
  };
  /**
   * Events emitted by RotateFeatureInteraction instances are instances of this type.
   *
   * @class
   * @author Vladimir Vershinin
   */

  var RotateFeatureEvent = /*#__PURE__*/function () {
    /**
     * @param {string} type Type.
     * @param {ol.Collection<ol.Feature>} features Rotated features.
     * @param {number} angle Angle in radians.
     * @param {ol.Coordinate} anchor Anchor position.
     */
    function RotateFeatureEvent(type, features, angle, anchor) {
      _classCallCheck(this, RotateFeatureEvent);

      /**
       * @type {boolean}
       * @private
       */
      this.propagationStopped_ = false;
      /**
       * The event type.
       * @type {string}
       * @private
       */

      this.type_ = type;
      /**
       * The features being rotated.
       * @type {ol.Collection<ol.Feature>}
       * @private
       */

      this.features_ = features;
      /**
       * Current angle in radians.
       * @type {number}
       * @private
       */

      this.angle_ = angle;
      /**
       * Current rotation anchor.
       * @type {ol.Coordinate}
       * @private
       */

      this.anchor_ = anchor;
    }
    /**
     * @type {boolean}
     */


    _createClass(RotateFeatureEvent, [{
      key: "preventDefault",

      /**
       * Prevent event propagation.
       */
      value: function preventDefault() {
        this.propagationStopped_ = true;
      }
      /**
       * Stop event propagation.
       */

    }, {
      key: "stopPropagation",
      value: function stopPropagation() {
        this.propagationStopped_ = true;
      }
    }, {
      key: "propagationStopped",
      get: function get() {
        return this.propagationStopped_;
      }
      /**
       * @type {string}
       */

    }, {
      key: "type",
      get: function get() {
        return this.type_;
      }
      /**
       * @type {ol.Collection<ol.Feature>}
       */

    }, {
      key: "features",
      get: function get() {
        return this.features_;
      }
      /**
       * @type {number}
       */

    }, {
      key: "angle",
      get: function get() {
        return this.angle_;
      }
      /**
       * @type {ol.Coordinate}
       */

    }, {
      key: "anchor",
      get: function get() {
        return this.anchor_;
      }
    }]);

    return RotateFeatureEvent;
  }();

  var ua = typeof navigator !== 'undefined' ? navigator.userAgent.toLowerCase() : '';
  var MAC = ua.indexOf('macintosh') !== -1;
  var WEBKIT = ua.indexOf('webkit') !== -1 && ua.indexOf('edge') == -1;
  var mouseActionButton = function mouseActionButton(mapBrowserEvent) {
    var originalEvent =
    /** @type {MouseEvent} */
    mapBrowserEvent.originalEvent;
    return originalEvent.button == 0 && !(WEBKIT && MAC && originalEvent.ctrlKey);
  };

  function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

  function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
  var ANCHOR_KEY = 'rotate-anchor';
  var ARROW_KEY = 'rotate-arrow';
  var ANGLE_PROP = 'angle';
  var ANCHOR_PROP = 'anchor';
  /**
   * @todo todo добавить опцию condition - для возможности переопределения клавиш
   */

  var RotateFeatureInteraction = /*#__PURE__*/function (_PointerInteraction) {
    _inherits(RotateFeatureInteraction, _PointerInteraction);

    var _super = _createSuper(RotateFeatureInteraction);

    /**
     * @param {InteractionOptions} options
     */
    function RotateFeatureInteraction() {
      var _context;

      var _this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      _classCallCheck(this, RotateFeatureInteraction);

      _this = _super.call(this, {
        // handleEvent: handleEvent,
        handleDownEvent: handleDownEvent,
        handleUpEvent: handleUpEvent,
        handleDragEvent: handleDragEvent,
        handleMoveEvent: handleMoveEvent
      });
      /**
       * @type {string}
       * @private
       */

      _this.previousCursor_ = undefined;
      /**
       * @type {Feature}
       * @private
       */

      _this.anchorFeature_ = undefined;
      /**
       * @type {Feature}
       * @private
       */

      _this.arrowFeature_ = undefined;
      /**
       * @type {Coordinate}
       * @private
       */

      _this.lastCoordinate_ = undefined;
      /**
       * @type {boolean}
       * @private
       */

      _this.anchorMoving_ = false;
      /**
       * @type {Vector}
       * @private
       */

      _this.overlay_ = new layer$1.Vector({
        style: options.style || getDefaultStyle(),
        source: new source$1.Vector({
          features: new ol.Collection()
        })
      });
      /**
       * @private
       * @type {module:ol/events/condition~Condition}
       */

      _this.condition_ = options.condition ? options.condition : condition.always;
      /**
       * @type {Collection<Feature>}
       * @private
       */

      _this.features_ = undefined;

      if (options.features) {
        if (isArray(options.features)) {
          _this.features_ = new ol.Collection(options.features);
        } else if (options.features instanceof ol.Collection) {
          _this.features_ = options.features;
        } else {
          throw new Error('Features option should be an array or collection of features, ' + 'got ' + _typeof$1(options.features));
        }
      } else {
        _this.features_ = new ol.Collection();
      }
      /**
       * @type {boolean}
       * @public
       */


      _this.allowAnchorMovement = options.allowAnchorMovement === undefined ? true : options.allowAnchorMovement;

      _this.setAnchor(options.anchor || getFeaturesCentroid(_this.features_));

      _this.setAngle(options.angle || 0);

      _this.features_.on('add', (_context = _this).onFeatureAdd_.bind(_context));

      _this.features_.on('remove', (_context = _this).onFeatureRemove_.bind(_context));

      _this.on('change:' + ANGLE_PROP, (_context = _this).onAngleChange_.bind(_context));

      _this.on('change:' + ANCHOR_PROP, (_context = _this).onAnchorChange_.bind(_context));

      _this.createOrUpdateAnchorFeature_();

      _this.createOrUpdateArrowFeature_();

      return _this;
    }
    /**
     * @type {Collection<Feature>}
     */


    _createClass(RotateFeatureInteraction, [{
      key: "setMap",

      /**
       * @param {ol.Map} map
       */
      value: function setMap(map) {
        this.overlay_.setMap(map);

        _get(_getPrototypeOf(RotateFeatureInteraction.prototype), "setMap", this).call(this, map);
      }
      /**
       * @param {boolean} active
       */

    }, {
      key: "setActive",
      value: function setActive(active) {
        if (this.overlay_) {
          this.overlay_.setMap(active ? this.map : undefined);
        }

        _get(_getPrototypeOf(RotateFeatureInteraction.prototype), "setActive", this).call(this, active);
      }
      /**
       * Set current angle of interaction features.
       *
       * @param {number} angle
       */

    }, {
      key: "setAngle",
      value: function setAngle(angle) {
        assert(!isNaN(parseFloat(angle)), 'Numeric value passed');
        this.set(ANGLE_PROP, parseFloat(angle));
      }
      /**
       * Returns current angle of interaction features.
       *
       * @return {number}
       */

    }, {
      key: "getAngle",
      value: function getAngle() {
        return this.get(ANGLE_PROP);
      }
      /**
       * Set current anchor position.
       *
       * @param {Coordinate | undefined} anchor
       */

    }, {
      key: "setAnchor",
      value: function setAnchor(anchor) {
        assert(anchor == null || isArray(anchor) && anchor.length === 2, 'Array of two elements passed');
        this.set(ANCHOR_PROP, anchor != null ? anchor.map(parseFloat) : getFeaturesCentroid(this.features_));
      }
      /**
       * Returns current anchor position.
       *
       * @return {Coordinate | undefined}
       */

    }, {
      key: "getAnchor",
      value: function getAnchor() {
        return this.get(ANCHOR_PROP);
      }
      /**
       * @private
       */

    }, {
      key: "createOrUpdateAnchorFeature_",
      value: function createOrUpdateAnchorFeature_() {
        var angle = this.getAngle();
        var anchor = this.getAnchor();
        if (!anchor) return;

        if (this.anchorFeature_) {
          this.anchorFeature_.getGeometry().setCoordinates(anchor);
          this.anchorFeature_.set(ANGLE_PROP, angle);
        } else {
          var _Feature;

          this.anchorFeature_ = new ol.Feature((_Feature = {
            geometry: new geom.Point(anchor)
          }, _defineProperty(_Feature, ANGLE_PROP, angle), _defineProperty(_Feature, ANCHOR_KEY, true), _Feature));
          this.overlay_.getSource().addFeature(this.anchorFeature_);
        }
      }
      /**
       * @private
       */

    }, {
      key: "createOrUpdateArrowFeature_",
      value: function createOrUpdateArrowFeature_() {
        var angle = this.getAngle();
        var anchor = this.getAnchor();
        if (!anchor) return;

        if (this.arrowFeature_) {
          this.arrowFeature_.getGeometry().setCoordinates(anchor);
          this.arrowFeature_.set(ANGLE_PROP, angle);
        } else {
          var _Feature2;

          this.arrowFeature_ = new ol.Feature((_Feature2 = {
            geometry: new geom.Point(anchor)
          }, _defineProperty(_Feature2, ANGLE_PROP, angle), _defineProperty(_Feature2, ARROW_KEY, true), _Feature2));
          this.overlay_.getSource().addFeature(this.arrowFeature_);
        }
      }
      /**
       * @private
       */

    }, {
      key: "resetAngleAndAnchor_",
      value: function resetAngleAndAnchor_() {
        this.resetAngle_();
        this.resetAnchor_();
      }
      /**
       * @private
       */

    }, {
      key: "resetAngle_",
      value: function resetAngle_() {
        this.set(ANGLE_PROP, 0, true);
        this.arrowFeature_ && this.arrowFeature_.set(ANGLE_PROP, this.getAngle());
        this.anchorFeature_ && this.anchorFeature_.set(ANGLE_PROP, this.getAngle());
      }
      /**
       * @private
       */

    }, {
      key: "resetAnchor_",
      value: function resetAnchor_() {
        this.set(ANCHOR_PROP, getFeaturesCentroid(this.features_), true);

        if (this.getAnchor()) {
          this.arrowFeature_ && this.arrowFeature_.getGeometry().setCoordinates(this.getAnchor());
          this.anchorFeature_ && this.anchorFeature_.getGeometry().setCoordinates(this.getAnchor());
        }
      }
      /**
       * @private
       */

    }, {
      key: "onFeatureAdd_",
      value: function onFeatureAdd_() {
        this.resetAngleAndAnchor_();
        this.createOrUpdateAnchorFeature_();
        this.createOrUpdateArrowFeature_();
      }
      /**
       * @private
       */

    }, {
      key: "onFeatureRemove_",
      value: function onFeatureRemove_() {
        this.resetAngleAndAnchor_();

        if (this.features_.getLength()) {
          this.createOrUpdateAnchorFeature_();
          this.createOrUpdateArrowFeature_();
        } else {
          this.overlay_.getSource().clear();
          this.anchorFeature_ = this.arrowFeature_ = undefined;
        }
      }
      /**
       * @private
       */

    }, {
      key: "onAngleChange_",
      value: function onAngleChange_(_ref) {
        var _this2 = this;

        var oldValue = _ref.oldValue;
        this.features_.forEach(function (feature) {
          return feature.getGeometry().rotate(_this2.getAngle() - oldValue, _this2.getAnchor());
        });
        this.arrowFeature_ && this.arrowFeature_.set(ANGLE_PROP, this.getAngle());
        this.anchorFeature_ && this.anchorFeature_.set(ANGLE_PROP, this.getAngle());
      }
      /**
       * @private
       */

    }, {
      key: "onAnchorChange_",
      value: function onAnchorChange_() {
        var anchor = this.getAnchor();

        if (anchor) {
          this.anchorFeature_ && this.anchorFeature_.getGeometry().setCoordinates(anchor);
          this.arrowFeature_ && this.arrowFeature_.getGeometry().setCoordinates(anchor);
        }
      }
      /**
       * @param {Collection<Feature>} features
       * @private
       */

    }, {
      key: "dispatchRotateStartEvent_",
      value: function dispatchRotateStartEvent_(features) {
        this.dispatchEvent(new RotateFeatureEvent(RotateFeatureEventType.START, features, this.getAngle(), this.getAnchor()));
      }
      /**
       * @param {Collection<Feature>} features
       * @private
       */

    }, {
      key: "dispatchRotatingEvent_",
      value: function dispatchRotatingEvent_(features) {
        this.dispatchEvent(new RotateFeatureEvent(RotateFeatureEventType.ROTATING, features, this.getAngle(), this.getAnchor()));
      }
      /**
       * @param {Collection<Feature>} features
       * @private
       */

    }, {
      key: "dispatchRotateEndEvent_",
      value: function dispatchRotateEndEvent_(features) {
        this.dispatchEvent(new RotateFeatureEvent(RotateFeatureEventType.END, features, this.getAngle(), this.getAnchor()));
      }
    }, {
      key: "features",
      get: function get() {
        return this.features_;
      }
      /**
       * @type {number}
       */

    }, {
      key: "angle",
      get: function get() {
        return this.getAngle();
      }
      /**
       * @param {number} angle
       */
      ,
      set: function set(angle) {
        this.setAngle(angle);
      }
      /**
       * @type {Coordinate|number[]|undefined}
       */

    }, {
      key: "anchor",
      get: function get() {
        return this.getAnchor();
      }
      /**
       * @param {Coordinate|undefined} anchor
       */
      ,
      set: function set(anchor) {
        this.setAnchor(anchor);
      }
      /**
       * @param {PluggableMap} map
       */

    }, {
      key: "map",
      set: function set(map) {
        this.setMap(map);
      }
      /**
       * @type {PluggableMap}
       */
      ,
      get: function get() {
        return this.getMap();
      }
      /**
       * @param {boolean} active
       */

    }, {
      key: "active",
      set: function set(active) {
        this.setActive(active);
      }
      /**
       * @type {boolean}
       */
      ,
      get: function get() {
        return this.getActive();
      }
    }]);

    return RotateFeatureInteraction;
  }(interaction$1.Pointer);

  function handleDownEvent(evt) {
    if (!condition.mouseOnly(evt)) {
      return false;
    }

    if (mouseActionButton(evt) && this.condition_(evt)) {
      // disable selection of inner features
      var foundFeature = evt.map.forEachFeatureAtPixel(evt.pixel, identity);

      if (includes(['click', 'singleclick', 'dblclick'], evt.type) && includes([this.anchorFeature_, this.arrowFeature_], foundFeature)) {
        return false;
      } // handle click & drag on features for rotation


      if (foundFeature && !this.lastCoordinate_ && (includes(this.features_.getArray(), foundFeature) || foundFeature === this.arrowFeature_)) {
        this.lastCoordinate_ = evt.coordinate;
        handleMoveEvent.call(this, evt);
        this.dispatchRotateStartEvent_(this.features_);
        return true;
      } // handle click & drag on rotation anchor feature
      else if (foundFeature && foundFeature === this.anchorFeature_ && this.allowAnchorMovement) {
          this.anchorMoving_ = true;
          handleMoveEvent.call(this, evt);
          return true;
        }
    }

    return false;
  }
  /**
   * @param {MapBrowserEvent} evt Event.
   * @return {boolean}
   * @this {RotateFeatureInteraction}
   * @private
   */


  function handleUpEvent(evt) {
    // stop drag sequence of features
    if (this.lastCoordinate_) {
      this.lastCoordinate_ = undefined;
      handleMoveEvent.call(this, evt);
      this.dispatchRotateEndEvent_(this.features_);
      return true;
    } // stop drag sequence of the anchors
    else if (this.anchorMoving_) {
        this.anchorMoving_ = false;
        handleMoveEvent.call(this, evt);
        return true;
      }

    return false;
  }
  /**
   * @param {MapBrowserEvent} evt Event.
   * @return {boolean}
   * @this {RotateFeatureInteraction}
   * @private
   */


  function handleDragEvent(_ref2) {
    var coordinate = _ref2.coordinate;
    var anchorCoordinate = this.anchorFeature_.getGeometry().getCoordinates(); // handle drag of features by angle

    if (this.lastCoordinate_) {
      // calculate vectors of last and current pointer positions
      var lastVector = [this.lastCoordinate_[0] - anchorCoordinate[0], this.lastCoordinate_[1] - anchorCoordinate[1]];
      var newVector = [coordinate[0] - anchorCoordinate[0], coordinate[1] - anchorCoordinate[1]]; // calculate angle between last and current vectors (positive angle counter-clockwise)

      var angle = Math.atan2(lastVector[0] * newVector[1] - newVector[0] * lastVector[1], lastVector[0] * newVector[0] + lastVector[1] * newVector[1]);
      this.setAngle(this.getAngle() + angle);
      this.dispatchRotatingEvent_(this.features_);
      this.lastCoordinate_ = coordinate;
    } // handle drag of the anchor
    else if (this.anchorMoving_) {
        this.setAnchor(coordinate);
      }
  }
  /**
   * @param {MapBrowserEvent} evt Event.
   * @return {boolean}
   * @this {RotateFeatureInteraction}
   * @private
   */


  function handleMoveEvent(_ref3) {
    var map = _ref3.map,
        pixel = _ref3.pixel;
    var elem = map.getTargetElement();
    var foundFeature = map.forEachFeatureAtPixel(pixel, identity);

    var setCursor = function setCursor(cursor) {
      var vendor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (vendor) {
        elem.style.cursor = '-webkit-' + cursor;
        elem.style.cursor = '-moz-' + cursor;
      }

      elem.style.cursor = cursor;
    };

    if (this.lastCoordinate_) {
      this.previousCursor_ = elem.style.cursor;
      setCursor('grabbing', true);
    } else if (foundFeature && (includes(this.features_.getArray(), foundFeature) || foundFeature === this.arrowFeature_)) {
      this.previousCursor_ = elem.style.cursor;
      setCursor('grab', true);
    } else if (foundFeature && foundFeature === this.anchorFeature_ && this.allowAnchorMovement || this.anchorMoving_) {
      this.previousCursor_ = elem.style.cursor;
      setCursor('crosshair');
    } else {
      setCursor(this.previousCursor_ || '');
      this.previousCursor_ = undefined;
    }
  }
  /**
   * @returns {StyleFunction}
   * @private
   */


  function getDefaultStyle() {
    var _styles;

    var white = [255, 255, 255, 0.8];
    var blue = [0, 153, 255, 0.8];
    var transparent = [255, 255, 255, 0.01];
    var width = 2;
    var styles = (_styles = {}, _defineProperty(_styles, ANCHOR_KEY, [new style$1.Style({
      image: new style$1.RegularShape({
        fill: new style$1.Fill({
          color: [0, 153, 255, 0.8]
        }),
        stroke: new style$1.Stroke({
          color: blue,
          width: 1
        }),
        radius: 4,
        points: 6
      }),
      zIndex: Infinity
    })]), _defineProperty(_styles, ARROW_KEY, [new style$1.Style({
      fill: new style$1.Fill({
        color: transparent
      }),
      stroke: new style$1.Stroke({
        color: white,
        width: width + 2
      }),
      text: new style$1.Text({
        font: '12px sans-serif',
        offsetX: 20,
        offsetY: -20,
        fill: new style$1.Fill({
          color: 'blue'
        }),
        stroke: new style$1.Stroke({
          color: white,
          width: width + 1
        })
      }),
      zIndex: Infinity
    }), new style$1.Style({
      fill: new style$1.Fill({
        color: transparent
      }),
      stroke: new style$1.Stroke({
        color: blue,
        width: width
      }),
      zIndex: Infinity
    })]), _styles);
    return function (feature, resolution) {
      var style;
      var angle = feature.get(ANGLE_PROP) || 0;

      switch (true) {
        case feature.get(ANCHOR_KEY):
          style = styles[ANCHOR_KEY];
          style[0].getImage().setRotation(-angle);
          return style;

        case feature.get(ARROW_KEY):
          style = styles[ARROW_KEY];
          var coordinates = feature.getGeometry().getCoordinates(); // generate arrow polygon

          var geom$1 = new geom.Polygon([[[coordinates[0], coordinates[1] - 6 * resolution], [coordinates[0] + 8 * resolution, coordinates[1] - 12 * resolution], [coordinates[0], coordinates[1] + 30 * resolution], [coordinates[0] - 8 * resolution, coordinates[1] - 12 * resolution], [coordinates[0], coordinates[1] - 6 * resolution]]]); // and rotate it according to current angle

          geom$1.rotate(angle, coordinates);
          style[0].setGeometry(geom$1);
          style[1].setGeometry(geom$1);
          style[0].getText().setText(Math.round(-angle * 180 / Math.PI) + '°');
          return style;
      }
    };
  }
  /**
   * @param {Collection<Feature>|Array<Feature>} features
   * @returns {Extent | number[] | undefined}
   * @private
   */


  function getFeaturesExtent(features) {
    features = features instanceof ol.Collection ? features.getArray() : features;
    if (!features.length) return;
    return new geom.GeometryCollection(features.map(function (feature) {
      return feature.getGeometry();
    })).getExtent();
  }
  /**
   * @param {Collection<ol.Feature> | Array<Feature>} features
   * @return {Coordinate | number[] | undefined}
   */


  function getFeaturesCentroid(features) {
    features = features instanceof ol.Collection ? features.getArray() : features;
    if (!features.length) return;
    return extent.getCenter(getFeaturesExtent(features));
  }

  /**
   * This file is part of ol-rotate-feature package.
   * @module ol-rotate-feature
   * @license MIT
   * @author Vladimir Vershinin
   */

  if (typeof window !== 'undefined' && window.ol && window.ol.interaction) {
    window.ol.interaction.RotateFeature = RotateFeatureInteraction;
  }

  /**
   * @module ol/source/VectorEventType
   */
  /**
   * @enum {string}
   */
  var VectorEventType = {
      /**
       * Triggered when a feature is added to the source.
       * @event module:ol/source/Vector.VectorSourceEvent#addfeature
       * @api
       */
      ADDFEATURE: 'addfeature',
      /**
       * Triggered when a feature is updated.
       * @event module:ol/source/Vector.VectorSourceEvent#changefeature
       * @api
       */
      CHANGEFEATURE: 'changefeature',
      /**
       * Triggered when the clear method is called on the source.
       * @event module:ol/source/Vector.VectorSourceEvent#clear
       * @api
       */
      CLEAR: 'clear',
      /**
       * Triggered when a feature is removed from the source.
       * See {@link module:ol/source/Vector#clear source.clear()} for exceptions.
       * @event module:ol/source/Vector.VectorSourceEvent#removefeature
       * @api
       */
      REMOVEFEATURE: 'removefeature',
      /**
       * Triggered when features starts loading.
       * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart
       * @api
       */
      FEATURESLOADSTART: 'featuresloadstart',
      /**
       * Triggered when features finishes loading.
       * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend
       * @api
       */
      FEATURESLOADEND: 'featuresloadend',
      /**
       * Triggered if feature loading results in an error.
       * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror
       * @api
       */
      FEATURESLOADERROR: 'featuresloaderror',
  };

  function ownKeys$a(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$a(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$a(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$a(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var script$d = {
    name: 'VlInteractionRotate',
    mixins: [interaction, styleContainer],
    stubVNode: {
      empty: false,
      attrs: function attrs() {
        return {
          id: this.vmId,
          class: this.vmClass
        };
      }
    },
    props: {
      /**
       * Source or collection identifier from IdentityMap.
       * @type {String}
       */
      source: {
        type: String,
        required: true
      },
      angle: {
        type: Number,
        default: 0
      },
      anchor: {
        type: Array,
        validator: function validator(val) {
          return val.length >= 2;
        }
      },
      condition: {
        type: Function,
        default: condition.always
      },
      allowAnchorMovement: {
        type: Boolean,
        default: true
      }
    },
    data: function data() {
      return {
        currentAnchorViewProj: roundPointCoords(this.anchor),
        currentAngle: this.angle
      };
    },
    computed: {
      anchorDataProj: function anchorDataProj() {
        return roundPointCoords(this.anchor);
      },
      anchorViewProj: function anchorViewProj() {
        return this.pointToViewProj(this.anchor);
      },
      currentAnchorDataProj: function currentAnchorDataProj() {
        return this.pointToDataProj(this.currentAnchorViewProj);
      }
    },
    watch: _objectSpread$a({
      rev: function rev() {
        if (!this.$interaction) return;

        if (!isEqual(this.currentAnchorViewProj, this.$interaction.getAnchor())) {
          this.currentAnchorViewProj = this.$interaction.getAnchor();
        }

        if (this.currentAngle !== this.$interaction.getAngle()) {
          this.currentAngle = this.$interaction.getAngle();
        }
      },
      anchorViewProj: {
        deep: true,
        handler: function handler(value) {
          if (!value) return;
          this.setAnchor(value, true);
        }
      },
      currentAnchorDataProj: {
        deep: true,
        handler: function handler(value) {
          if (isEqual(value, this.anchorDataProj)) return;
          this.$emit('update:anchor', value === null || value === void 0 ? void 0 : value.slice());
        }
      },
      angle: function angle(value) {
        this.setAngle(value);
      },
      currentAngle: function currentAngle(value) {
        if (value === this.angle) return;
        this.$emit('update:angle', value);
      }
    }, /*#__PURE__*/makeChangeOrRecreateWatchers(['source', 'condition', 'allowAnchorMovement'])),
    created: function created() {
      var _this$anchorViewProj;

      this.currentAnchorViewProj = (_this$anchorViewProj = this.anchorViewProj) === null || _this$anchorViewProj === void 0 ? void 0 : _this$anchorViewProj.slice();
    },
    methods: {
      /**
       * @return {Promise<Modify>}
       * @protected
       */
      createInteraction: function createInteraction() {
        var _this = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          var source, features;
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return _this.getInstance(_this.source);

                case 2:
                  source = _this._source = _context.sent;
                  assert$1(!!source, "Source \"".concat(_this.source, "\" not found in identity map."));

                  if (source instanceof source$1.Vector) {
                    features = source.getFeaturesCollection();

                    if (!features) {
                      features = new ol.Collection(source.getFeatures());

                      _this.subscribeTo(fromOlEvent(source, VectorEventType.ADDFEATURE), function (_ref) {
                        var feature = _ref.feature;
                        return feature && features.push(feature);
                      });

                      _this.subscribeTo(fromOlEvent(source, VectorEventType.REMOVEFEATURE), function (_ref2) {
                        var feature = _ref2.feature;
                        return feature && features.remove(feature);
                      });
                    }

                    instanceOf(features, ol.Collection, "Source \"".concat(_this.source, "\" doesn't provide features collection."));
                  } else {
                    if (isFunction$1(source.getFeaturesCollection)) {
                      features = source.getFeaturesCollection();
                    } else if (isFunction$1(source.getFeatures)) {
                      features = source.getFeatures();
                    }

                    instanceOf(features, ol.Collection, "Source \"".concat(_this.source, "\" doesn't provide features collection."));
                  }

                  return _context.abrupt("return", new RotateFeatureInteraction({
                    features: features,
                    angle: _this.currentAngle,
                    anchor: _this.currentAnchorViewProj,
                    allowAnchorMovement: _this.allowAnchorMovement,
                    condition: _this.condition,
                    style: _this.$style
                  }));

                case 6:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      },

      /**
       * @returns {Object}
       * @protected
       */
      getServices: function getServices() {
        return mergeDescriptors(interaction.methods.getServices.call(this), styleContainer.methods.getServices.call(this));
      },

      /**
       * @protected
       */
      subscribeAll: function subscribeAll() {
        interaction.methods.subscribeAll.call(this);
        subscribeToInteractionChanges$2.call(this);
      },

      /**
       * @return {StyleTarget}
       * @protected
       */
      getStyleTarget: function getStyleTarget() {
        var _this2 = this;

        return {
          getStyle: function getStyle() {
            return _this2._style;
          },
          setStyle: function setStyle() {

            _this2.scheduleRecreate();
          }
        };
      },
      getAngle: function getAngle() {
        var _this$$interaction;

        return coalesce((_this$$interaction = this.$interaction) === null || _this$$interaction === void 0 ? void 0 : _this$$interaction.getAngle(), this.currentAngle);
      },
      setAngle: function setAngle(angle) {
        assert$1(isNumber$1(angle), 'Invalid angle');

        if (angle !== this.currentAngle) {
          this.currentAngle = angle;
        }

        if (this.$interaction && angle !== this.$interaction.getAngle()) {
          this.$interaction.setAngle(angle);
        }
      },
      getAnchor: function getAnchor() {
        var _this$$interaction2;

        var viewProj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        var anchor = coalesce((_this$$interaction2 = this.$interaction) === null || _this$$interaction2 === void 0 ? void 0 : _this$$interaction2.getAnchor(), this.currentAnchorViewProj);
        return viewProj ? roundPointCoords(anchor) : this.pointToDataProj(anchor);
      },
      setAnchor: function setAnchor(anchor) {
        var viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        assert$1(isPointCoords(anchor), 'Invalid anchor');
        anchor = viewProj ? roundPointCoords(anchor) : this.pointToViewProj(anchor);

        if (!isEqual(anchor, this.currentAnchorViewProj)) {
          this.currentAnchorViewProj = anchor;
        }

        if (this.$interaction && !isEqual(anchor, this.$interaction.getAnchor())) {
          this.$interaction.setAnchor(anchor);
        }
      }
    }
  };
  /**
   * @private
   */

  function subscribeToInteractionChanges$2() {
    var _this3 = this;

    var setterKey = addPrefix('set');
    var propChanges = fromOlChangeEvent(this.$interaction, ['angle', 'anchor'], true, function (evt) {
      return _objectSpread$a(_objectSpread$a({}, evt), {}, {
        setter: function setter(val) {
          var args = [val];

          if (evt.prop === 'anchor') {
            args.push(true);
          }

          _this3[setterKey(evt.prop)].apply(_this3, args);
        }
      });
    });
    this.subscribeTo(propChanges, function (_ref3) {
      var setter = _ref3.setter,
          value = _ref3.value;
      return setter(value);
    });
    var start = fromOlEvent(this.$interaction, 'rotatestart').pipe(tap(function () {
      return _this3.setInteracting(true);
    }));
    var end = fromOlEvent(this.$interaction, 'rotateend').pipe(tap(function () {
      return _this3.setInteracting(false);
    }));
    var progress = fromOlEvent(this.$interaction, 'rotating');
    var events = merge(start, end, progress).pipe(map(function (_ref4) {
      var type = _ref4.type,
          features = _ref4.features,
          angle = _ref4.angle,
          anchor = _ref4.anchor;
      var viewProj = _this3.resolvedViewProjection;
      var dataProj = _this3.resolvedDataProjection;
      return {
        type: type,
        features: features instanceof ol.Collection ? features.getArray() : features,
        angle: angle,
        anchor: _this3.pointToDataProj(anchor),

        get json() {
          if (!this._json) {
            this._json = map$1(this.features, function (feature) {
              return writeGeoJsonFeature(feature, viewProj, dataProj, COORD_PRECISION);
            });
          }

          return this._json;
        }

      };
    }));
    this.subscribeTo(events, function (evt) {
      return _this3.$emit(evt.type, evt);
    });
  }

  /* script */
  var __vue_script__$d = script$d;
  /* template */

  /* style */

  var __vue_inject_styles__$d = undefined;
  /* scoped */

  var __vue_scope_id__$d = undefined;
  /* module identifier */

  var __vue_module_identifier__$d = undefined;
  /* functional template */

  var __vue_is_functional_template__$d = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$d = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$d, __vue_script__$d, __vue_scope_id__$d, __vue_is_functional_template__$d, __vue_module_identifier__$d, false, undefined, undefined, undefined);

  function plugin$e(Vue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$e.installed) {
      return;
    }

    plugin$e.installed = true;
    options = pick(options, 'dataProjection');
    Object.assign(__vue_component__$d, options);
    Vue.component(__vue_component__$d.name, __vue_component__$d);
  }

  var RotateInteraction = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': plugin$e,
    install: plugin$e,
    Interaction: __vue_component__$d
  });

  function ownKeys$9(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$9(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$9(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$9(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var script$c = {
    name: 'VlInteractionSelect',
    mixins: [featuresContainer, styleContainer, interaction],
    props: {
      /**
       * A function that takes an `ol.Feature` and an `ol.layer.Layer` and returns `true` if the feature may be selected or `false` otherwise.
       * @type {function|undefined}
       */
      filter: {
        type: Function,
        default: /*#__PURE__*/constant(true)
      },

      /**
       * A list of layers from which features should be selected. Alternatively, a filter function can be provided.
       * @type {string[]|function|undefined}
       */
      layers: {
        type: [Array, Function],
        default: undefined
      },

      /**
       * Hit-detection tolerance. Pixels inside the radius around the given position will be checked for features.
       * This only works for the canvas renderer and not for WebGL.
       * @type {number}
       */
      hitTolerance: {
        type: Number,
        default: 0
      },

      /**
       * A boolean that determines if the default behaviour should select only single features or all (overlapping)
       * features at the clicked map position.
       * @type {boolean}
       */
      multi: {
        type: Boolean,
        default: false
      },

      /**
       * Selected features as array of GeoJSON features with coordinates in the map view projection.
       * @type {string[]|number[]|Object[]}
       */
      features: {
        type: Array,
        default: stubArray,
        validator: function validator(value) {
          return value.every(or(isString, isNumber$1, isGeoJSONFeature));
        }
      },

      /**
       * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should
       * be handled. By default, this is `ol.events.condition.never`. Use this if you want to use different events
       * for `add` and `remove` instead of `toggle`.
       * @type {function|undefined}
       */
      addCondition: {
        type: Function,
        default: condition.never
      },

      /**
       * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.
       * This is the event for the selected features as a whole. By default, this is `ol.events.condition.singleClick`.
       * Clicking on a feature selects that feature and removes any that were in the selection. Clicking outside any feature
       * removes all from the selection.
       * @type {function|undefined}
       */
      condition: {
        type: Function,
        default: condition.singleClick
      },

      /**
       * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.
       * By default, this is `ol.events.condition.never`. Use this if you want to use different events for `add` and `remove`
       * instead of `toggle`.
       * @type {function|undefined}
       */
      removeCondition: {
        type: Function,
        default: condition.never
      },

      /**
       * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.
       * This is in addition to the `condition` event. By default, `ol.events.condition.shiftKeyOnly`, i.e. pressing `shift`
       * as well as the `condition` event, adds that feature to the current selection if it is not currently selected,
       * and removes it if it is.
       * @type {function|undefined}
       */
      toggleCondition: {
        type: Function,
        default: condition.shiftKeyOnly
      }
    },
    data: function data() {
      return {
        currentHitTolerance: this.hitTolerance
      };
    },
    computed: {
      featuresDataProj: function featuresDataProj() {
        return map$1(this.features, function (feature) {
          if (isGeoJSONFeature(feature)) {
            feature = initializeFeature(clonePlainObject(feature));
          }

          return feature;
        });
      },
      featuresViewProj: function featuresViewProj() {
        var _this = this;

        return map$1(this.features, function (feature) {
          if (isGeoJSONFeature(feature)) {
            feature = _this.writeFeatureInViewProj(_this.readFeatureInDataProj(feature));
          }

          return feature;
        });
      },
      currentFeaturesDataProj: function currentFeaturesDataProj() {
        var _this2 = this;

        if (!this.rev) return [];
        return map$1(this.getFeatures(), function (feature) {
          return _this2.writeFeatureInDataProj(feature);
        });
      },
      currentFeaturesViewProj: function currentFeaturesViewProj() {
        var _this3 = this;

        if (!this.rev) return [];
        return map$1(this.getFeatures(), function (feature) {
          return _this3.writeFeatureInViewProj(feature);
        });
      },
      currentFeatureIds: function currentFeatureIds() {
        return map$1(this.currentFeaturesDataProj, function (feature) {
          return getFeatureId(feature);
        });
      },
      layerFilter: function layerFilter() {
        var _this4 = this;

        return Array.isArray(this.layers) ? function (layer) {
          return _this4.layers.includes(getLayerId(layer));
        } : this.layers;
      },
      style: function style() {
        var _this5 = this;

        if (!(this.rev && this.$style)) return;
        var style = this.$style;
        if (isFunction$1(style)) return style;
        if (!style) return;
        isArray$2(style) || (style = [style]);
        return style.map(function (style) {
          return dumpStyle(style, function (geom) {
            return _this5.writeGeometryInDataProj(geom);
          });
        });
      }
    },
    watch: _objectSpread$9({
      rev: function rev() {
        if (!this.$interaction) return;

        if (this.currentHitTolerance !== this.$interaction.getHitTolerance()) {
          this.currentHitTolerance = this.$interaction.getHitTolerance();
        }
      },
      featuresViewProj: {
        deep: true,
        handler: function handler(features) {
          var ids = map$1(features, function (feature) {
            return isObjectLike(feature) ? getFeatureId(feature) : feature;
          });
          if (isEqual(ids, this.currentFeatureIds)) return;
          this.unselectAll();
          forEach(features, this.select.bind(this));
        }
      },
      currentFeaturesDataProj: {
        deep: true,
        handler: function handler(value) {
          if (isEqual(value, this.featuresDataProj)) return;
          this.$emit('update:features', value && clonePlainObject(value));
        }
      },
      hitTolerance: function hitTolerance(value) {
        this.setHitTolerance(value);
      },
      currentHitTolerance: function currentHitTolerance(value) {
        if (value === this.hitTolerance) return;
        this.$emit('update:hitTolerance', value);
      },
      style: {
        deep: true,
        handler: function handler(value, prev) {
          if (isEqual(value, prev)) return;

          if (isPlainObject(value) || isArray$2(value)) {
            value = clonePlainObject(value);
          }

          this.$emit('update:style', value);
        }
      }
    }, /*#__PURE__*/makeChangeOrRecreateWatchers(['filter', 'multi', 'wrapX', 'addCondition', 'condition', 'removeCondition', 'toggleCondition'])),
    methods: {
      /**
       * @return {Select}
       * @protected
       */
      createInteraction: function createInteraction() {
        return new interaction$1.Select({
          multi: this.multi,
          filter: this.filter,
          layers: this.layerFilter,
          hitTolerance: this.currentHitTolerance,
          addCondition: this.addCondition,
          condition: this.condition,
          removeCondition: this.removeCondition,
          toggleCondition: this.toggleCondition,
          style: this.$style,
          features: this.$featuresCollection
        });
      },

      /**
       * @returns {Object}
       * @protected
       */
      getServices: function getServices() {
        return mergeDescriptors(interaction.methods.getServices.call(this), featuresContainer.methods.getServices.call(this), styleContainer.methods.getServices.call(this));
      },

      /**
       * @return {void}
       * @protected
       */
      subscribeAll: function subscribeAll() {
        interaction.methods.subscribeAll.call(this);
        featuresContainer.methods.subscribeAll.call(this);
        subscribeToInteractionChanges$1.call(this);
      },

      /**
       * @return {StyleTarget}
       * @protected
       */
      getStyleTarget: function getStyleTarget() {
        var _this6 = this;

        return {
          getStyle: function getStyle() {
            return _this6._style;
          },
          setStyle: function setStyle() {

            _this6.scheduleRecreate();
          }
        };
      },

      /**
       * @param {FeatureLike} feature
       */
      select: function select(feature) {
        feature = this.resolveFeature(feature);
        if (!feature) return;
        this.addFeature(feature);
      },

      /**
       * @param {FeatureLike} feature
       */
      unselect: function unselect(feature) {
        feature = this.resolveFeature(feature);
        if (!feature) return;
        this.removeFeature(feature);
      },

      /**
       * @return {void}
       */
      unselectAll: function unselectAll() {
        this.clearFeatures();
      },

      /**
       * @param {Object|Vue|Feature|string|number} feature
       * @return {Feature|undefined}
       * @protected
       */
      resolveFeature: function resolveFeature(feature) {
        var _feature,
            _this7 = this;

        if (!feature) return;
        feature = ((_feature = feature) === null || _feature === void 0 ? void 0 : _feature.$feature) || feature;
        if (feature instanceof ol.Feature) return feature;
        var featureId = isString(feature) || isNumber$1(feature) ? feature : getFeatureId(feature);

        if (!featureId) {
          throw new Error("".concat(this.vmName, " undefined feature id"));
        }

        feature = null;
        forEach(this.$mapVm.getLayers(), function (layer) {
          if (_this7.layerFilter && !_this7.layerFilter(layer)) {
            return;
          }

          var source = layer.getSource();

          if (isFunction$1(source === null || source === void 0 ? void 0 : source.getFeatureById)) {
            feature = source.getFeatureById(featureId);
          }

          return !feature;
        });
        return feature;
      },
      updateFeature: function updateFeature(feature) {
        /* disable update here, because wil always work with origin feature */
      },
      getHitTolerance: function getHitTolerance() {
        var _this$$interaction;

        return coalesce((_this$$interaction = this.$interaction) === null || _this$$interaction === void 0 ? void 0 : _this$$interaction.getHitTolerance(), this.currentHitTolerance);
      },
      setHitTolerance: function setHitTolerance(tolerance) {
        assert$1(isNumber$1(tolerance), 'Invalid tolerance');

        if (tolerance !== this.currentHitTolerance) {
          this.currentHitTolerance = tolerance;
        }

        if (this.$interaction && tolerance !== this.$interaction.getHitTolerance()) {
          this.$interaction.setHitTolerance(tolerance);
        }
      },
      getLayer: function getLayer(feature) {
        var _this8 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  feature = _this8.resolveFeature(feature);
                  _context.next = 3;
                  return _this8.resolveInteraction();

                case 3:
                  return _context.abrupt("return", _context.sent.getLayer(feature));

                case 4:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      }
    }
  };
  /**
   * @return {void}
   * @private
   */

  function subscribeToInteractionChanges$1() {
    var _this9 = this;

    var select = fromVueEvent(this, 'addfeature', function (evt) {
      return {
        type: 'select',
        feature: evt.feature,

        get json() {
          return evt.json;
        }

      };
    });
    var unselect = fromVueEvent(this, 'removefeature', function (evt) {
      return {
        type: 'unselect',
        feature: evt.feature,

        get json() {
          return evt.json;
        }

      };
    });
    var events = merge(select, unselect);
    this.subscribeTo(events, function (evt) {
      return _this9.$emit(evt.type, evt);
    });
  }

  /* script */
  var __vue_script__$c = script$c;
  /* template */

  var __vue_render__ = function __vue_render__() {
    var _vm = this;

    var _h = _vm.$createElement;

    var _c = _vm._self._c || _h;

    return _c('i', {
      class: _vm.vmClass,
      staticStyle: {
        "display": "none !important"
      },
      attrs: {
        "id": _vm.vmId
      }
    }, [_vm._t("default", null, {
      "features": _vm.currentFeaturesDataProj
    })], 2);
  };

  var __vue_staticRenderFns__ = [];
  /* style */

  var __vue_inject_styles__$c = undefined;
  /* scoped */

  var __vue_scope_id__$c = undefined;
  /* module identifier */

  var __vue_module_identifier__$c = undefined;
  /* functional template */

  var __vue_is_functional_template__$c = false;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$c = /*#__PURE__*/normalizeComponent({
    render: __vue_render__,
    staticRenderFns: __vue_staticRenderFns__
  }, __vue_inject_styles__$c, __vue_script__$c, __vue_scope_id__$c, __vue_is_functional_template__$c, __vue_module_identifier__$c, false, undefined, undefined, undefined);

  function plugin$d(Vue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$d.installed) {
      return;
    }

    plugin$d.installed = true;
    options = pick(options, 'dataProjection');
    Object.assign(__vue_component__$c, options);
    Vue.component(__vue_component__$c.name, __vue_component__$c);
  }

  var SelectInteraction = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': plugin$d,
    install: plugin$d,
    Interaction: __vue_component__$c
  });

  function ownKeys$8(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$8(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$8(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$8(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var script$b = {
    name: 'VlInteractionSnap',
    mixins: [interaction],
    props: {
      /**
       * Target source identifier from IdentityMap.
       * @type {string}
       */
      source: {
        type: String,
        required: true
      },

      /**
       * Snap to edges
       * @type {boolean}
       */
      edge: {
        type: Boolean,
        default: true
      },

      /**
       * Snap to vertices.
       * @type {boolean}
       */
      vertex: {
        type: Boolean,
        default: true
      },

      /**
       * Pixel tolerance for considering the pointer close enough to a segment or vertex for snapping.
       * @type {number}
       */
      pixelTolerance: {
        type: Number,
        default: 10
      }
    },
    watch: _objectSpread$8({}, /*#__PURE__*/makeChangeOrRecreateWatchers(['source', 'edge', 'vertex', 'pixelTolerance'])),
    methods: {
      /**
       * @return {Promise<Snap>}
       * @protected
       */
      createInteraction: function createInteraction() {
        var _this = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          var source, features;
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return _this.getInstance(_this.source);

                case 2:
                  source = _context.sent;
                  assert$1(!!source, "Source \"".concat(_this.source, "\" not found in identity map."));

                  if (!(source instanceof source$1.Vector)) {
                    if (isFunction$1(source.getFeaturesCollection)) {
                      features = source.getFeaturesCollection();
                    } else if (isFunction$1(source.getFeatures)) {
                      features = source.getFeatures();
                    }

                    instanceOf(features, ol.Collection, "Source \"".concat(_this.source, "\" doesn't provide features collection."));
                    source = null;
                  }

                  return _context.abrupt("return", new interaction$1.Snap({
                    source: source,
                    features: features,
                    edge: _this.edge,
                    vertex: _this.vertex,
                    pixelTolerance: _this.pixelTolerance
                  }));

                case 6:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      }
    }
  };

  /* script */
  var __vue_script__$b = script$b;
  /* template */

  /* style */

  var __vue_inject_styles__$b = undefined;
  /* scoped */

  var __vue_scope_id__$b = undefined;
  /* module identifier */

  var __vue_module_identifier__$b = undefined;
  /* functional template */

  var __vue_is_functional_template__$b = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$b = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$b, __vue_script__$b, __vue_scope_id__$b, __vue_is_functional_template__$b, __vue_module_identifier__$b, false, undefined, undefined, undefined);

  function plugin$c(Vue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$c.installed) {
      return;
    }

    plugin$c.installed = true;
    options = pick(options, 'dataProjection');
    Object.assign(__vue_component__$b, options);
    Vue.component(__vue_component__$b.name, __vue_component__$b);
  }

  var SnapInteraction = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': plugin$c,
    install: plugin$c,
    Interaction: __vue_component__$b
  });

  function ownKeys$7(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$7(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$7(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$7(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var SPUTNIK_URL_TEMPLATE = 'http://tiles.maps.sputnik.ru/{z}/{x}/{y}.png?apikey={apikey}';
  var SPUTNIK_ATTRIBUTIONS = '&copy; <a href="http://rt.ru/" target="_blank">Ростелеком</a>. ';
  var script$a = {
    name: 'VlSourceSputnik',
    mixins: [xyzSource],
    props: {
      /* eslint-disable vue/require-prop-types */
      // ol/source/Source
      attributions: _objectSpread$7(_objectSpread$7({}, source.props.attributions), {}, {
        default: SPUTNIK_ATTRIBUTIONS
      }),
      // ol/source/UrlTile
      url: _objectSpread$7(_objectSpread$7({}, urlTileSource.props.url), {}, {
        default: SPUTNIK_URL_TEMPLATE
      }),

      /* eslint-enable vue/require-prop-types */
      // custom
      apiKey: {
        type: String
      }
    },
    computed: {
      /**
       * @type {string[]}
       */
      urlTokens: function urlTokens() {
        return ['apiKey'];
      }
    }
  };

  /* script */
  var __vue_script__$a = script$a;
  /* template */

  /* style */

  var __vue_inject_styles__$a = undefined;
  /* scoped */

  var __vue_scope_id__$a = undefined;
  /* module identifier */

  var __vue_module_identifier__$a = undefined;
  /* functional template */

  var __vue_is_functional_template__$a = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$a = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$a, __vue_script__$a, __vue_scope_id__$a, __vue_is_functional_template__$a, __vue_module_identifier__$a, false, undefined, undefined, undefined);

  function plugin$b(Vue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$b.installed) {
      return;
    }

    plugin$b.installed = true;
    options = pick(options, 'dataProjection');
    Object.assign(__vue_component__$a, options);
    Vue.component(__vue_component__$a.name, __vue_component__$a);
  }

  var SputnikSource = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': plugin$b,
    install: plugin$b,
    Source: __vue_component__$a
  });

  var script$9 = {
    name: 'VlSourceStamen',
    mixins: [xyzSource],
    props: {
      // ol/source/Stamen

      /**
       * Stamen layer name
       *
       * @type {string}
       */
      layer: {
        type: String,
        required: true
      }
    },
    computed: {
      tileGridIdent: noop$1,
      inputTileGridFactory: noop$1,
      inputTileUrlFunction: noop$1
    },
    methods: {
      createSource: function createSource() {
        return new source$1.Stamen({
          // ol/source/Source
          wrapX: this.wrapX,
          // ol/source/Tile
          cacheSize: this.cacheSize,
          opaque: this.opaque,
          transition: this.transition,
          // ol/source/UrlTile
          tileLoadFunction: this.currentTileLoadFunction,
          url: this.currentUrls[0],
          // ol/source/TileImage
          reprojectionErrorThreshold: this.reprojectionErrorThreshold,
          imageSmoothing: this.imageSmoothing,
          // ol/source/XYZ
          minZoom: this.minZoom,
          maxZoom: this.maxZoom,
          // ol/source/Stamen
          layer: this.layer
        });
      },
      inputUrlChanged: function inputUrlChanged(value) {
        this.setUrl(value);
      },
      attributionsCollapsibleChanged: noop$1,
      projectionChanged: noop$1,
      inputTileGridFactoryChanged: noop$1,
      tileGridChanged: noop$1,
      zDirectionChanged: noop$1,
      inputTileUrlFunctionChanged: noop$1,
      crossOriginChanged: noop$1,
      tileClassChanged: noop$1
    }
  };

  /* script */
  var __vue_script__$9 = script$9;
  /* template */

  /* style */

  var __vue_inject_styles__$9 = undefined;
  /* scoped */

  var __vue_scope_id__$9 = undefined;
  /* module identifier */

  var __vue_module_identifier__$9 = undefined;
  /* functional template */

  var __vue_is_functional_template__$9 = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$9 = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$9, __vue_script__$9, __vue_scope_id__$9, __vue_is_functional_template__$9, __vue_module_identifier__$9, false, undefined, undefined, undefined);

  function plugin$a(Vue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$a.installed) {
      return;
    }

    plugin$a.installed = true;
    options = pick(options, 'dataProjection');
    Object.assign(__vue_component__$9, options);
    Vue.component(__vue_component__$9.name, __vue_component__$9);
  }

  var StamenSource = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': plugin$a,
    install: plugin$a,
    Source: __vue_component__$9
  });

  function ownKeys$6(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$6(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$6(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$6(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  /**
   * Style function component for advanced styling.
   * Plays the role of both a style that mounts itself to style target component (vl-layer-vector, vl-feature & etc.)
   * and style target for inner style containers (vl-style-box) as fallback style.
   */

  var script$8 = {
    name: 'VlStyleFunc',
    mixins: [stubVNode, projTransforms, styleContainer, olCmp, waitForMap],
    stubVNode: {
      empty: false,
      attrs: function attrs() {
        return {
          id: this.vmId,
          class: this.vmClass
        };
      }
    },
    props: {
      /**
       * @type {function(): function(feature: Feature): Style}
       */
      function: {
        type: Function // required: true,

      },

      /**
       * @deprecated
       * @todo remove later
       */
      func: Function,

      /**
       * @deprecated Use `func` prop instead.
       * @todo remove in v0.13.x
       */
      factory: Function
    },
    data: function data() {
      return {
        viewProjection: EPSG_3857,
        dataProjection: EPSG_3857
      };
    },
    computed: {
      inputFunction: function inputFunction() {
        var func = this.function || this.func;

        if (!func && this.factory) {
          func = this.factory();
        }

        return func;
      }
    },
    watch: _objectSpread$6({}, /*#__PURE__*/makeChangeOrRecreateWatchers(['inputFunction'])),
    created: function created() {

      defineServices.call(this);
    },
    updated: function updated() {
    },
    methods: {
      /**
       * @return {Promise<void>}
       * @protected
       */
      beforeInit: function beforeInit() {
        var _this = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return Promise.all([olCmp.methods.beforeInit.call(_this), waitForMap.methods.beforeInit.call(_this)]);

                case 2:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      },

      /**
       * @return {function(feature: Feature): Style}
       * @protected
       */
      createOlObject: function createOlObject() {
        // user provided style function
        var providedStyleFunc = this.inputFunction; // fallback style function made from inner style containers

        var fallbackStyleFunc = this.createStyleFunc(this.$style, this.getDefaultStyle());

        var func = function __styleFunc(feature, resolution) {
          var style = providedStyleFunc(feature, resolution); // not empty or null style

          if (style == null || Array.isArray(style) && style.length || style instanceof style$1.Style) {
            return style;
          }

          return fallbackStyleFunc(feature, resolution);
        };

        func.id = this.currentId;
        return func;
      },

      /**
       * @returns {Object}
       * @protected
       */
      getServices: function getServices() {
        return mergeDescriptors(olCmp.methods.getServices.call(this), styleContainer.methods.getServices.call(this));
      },

      /**
       * @return {Promise<void>}
       * @protected
       */
      mount: function mount() {
        var _this2 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
          var _this2$$styleContaine;

          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  (_this2$$styleContaine = _this2.$styleContainer) === null || _this2$$styleContaine === void 0 ? void 0 : _this2$$styleContaine.setStyle(_this2);
                  return _context2.abrupt("return", olCmp.methods.mount.call(_this2));

                case 2:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }))();
      },

      /**
       * @return {Promise<void>}
       * @protected
       */
      unmount: function unmount() {
        var _this3 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee3() {
          var _this3$$styleContaine;

          return regenerator.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  if (((_this3$$styleContaine = _this3.$styleContainer) === null || _this3$$styleContaine === void 0 ? void 0 : _this3$$styleContaine.getStyle()) === _this3.$styleFunction) {
                    _this3.$styleContainer.setStyle(null);
                  }

                  return _context3.abrupt("return", olCmp.methods.unmount.call(_this3));

                case 2:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3);
        }))();
      },

      /**
       * @protected
       */
      getStyleTarget: function getStyleTarget() {
        var _this4 = this;

        return {
          getStyle: function getStyle() {
            return _this4._style;
          },
          setStyle: function () {
            var _setStyle = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee4() {
              return regenerator.wrap(function _callee4$(_context4) {
                while (1) {
                  switch (_context4.prev = _context4.next) {
                    case 0:

                      _context4.next = 3;
                      return _this4.scheduleRecreate();

                    case 3:
                    case "end":
                      return _context4.stop();
                  }
                }
              }, _callee4);
            }));

            function setStyle() {
              return _setStyle.apply(this, arguments);
            }

            return setStyle;
          }()
        };
      }
    }
  };

  function defineServices() {
    var _this5 = this;

    Object.defineProperties(this, {
      $styleFunction: {
        enumerable: true,
        get: function get() {
          return _this5.$olObject;
        }
      },

      /**
       * @type {Object|undefined}
       */
      $mapVm: {
        enumerable: true,
        get: function get() {
          var _this5$$services;

          return (_this5$$services = _this5.$services) === null || _this5$$services === void 0 ? void 0 : _this5$$services.mapVm;
        }
      },

      /**
       * @type {Object|undefined}
       */
      $viewVm: {
        enumerable: true,
        get: function get() {
          var _this5$$services2;

          return (_this5$$services2 = _this5.$services) === null || _this5$$services2 === void 0 ? void 0 : _this5$$services2.viewVm;
        }
      },

      /**
       * @type {Object|undefined}
       */
      $styleContainer: {
        enumerable: true,
        get: function get() {
          var _this5$$services3;

          return (_this5$$services3 = _this5.$services) === null || _this5$$services3 === void 0 ? void 0 : _this5$$services3.styleContainer;
        }
      }
    });
  }

  /* script */
  var __vue_script__$8 = script$8;
  /* template */

  /* style */

  var __vue_inject_styles__$8 = undefined;
  /* scoped */

  var __vue_scope_id__$8 = undefined;
  /* module identifier */

  var __vue_module_identifier__$8 = undefined;
  /* functional template */

  var __vue_is_functional_template__$8 = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$8 = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$8, __vue_script__$8, __vue_scope_id__$8, __vue_is_functional_template__$8, __vue_module_identifier__$8, false, undefined, undefined, undefined);

  function plugin$9(Vue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$9.installed) {
      return;
    }

    plugin$9.installed = true;
    options = pick(options, 'dataProjection');
    Object.assign(__vue_component__$8, options);
    Vue.component(__vue_component__$8.name, __vue_component__$8);
  }

  var StyleFunc = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': plugin$9,
    install: plugin$9,
    Style: __vue_component__$8
  });

  var script$7 = {
    name: 'VlSourceTileArcgisRest',
    mixins: [arcgisSource, tileImageSource],
    computed: {
      inputTileUrlFunction: noop$1
    },
    methods: {
      createSource: function createSource() {
        return new source$1.TileArcGISRest({
          // ol/source/Source
          attributions: this.currentAttributions,
          projection: this.resolvedDataProjection,
          wrapX: this.wrapX,
          // ol/source/Tile
          cacheSize: this.cacheSize,
          tileGrid: this.tileGrid,
          transition: this.transition,
          // ol/source/UrlTile
          tileLoadFunction: this.currentTileLoadFunction,
          urls: this.currentUrls,
          // ol/source/TileImage
          crossOrigin: this.crossOrigin,
          reprojectionErrorThreshold: this.reprojectionErrorThreshold,
          imageSmoothing: this.imageSmoothing,
          // ol/source/TileArcGISRest
          hidpi: this.hidpi,
          params: this.currentParams
        });
      },
      stateChanged: noop$1,
      attributionsCollapsibleChanged: noop$1,
      tileKeyChanged: noop$1,
      opaqueChanged: noop$1,
      tilePixelRatioChanged: noop$1,
      zDirectionChanged: noop$1,
      inputTileUrlFunctionChanged: noop$1,
      tileClassChanged: noop$1
    }
  };

  /* script */
  var __vue_script__$7 = script$7;
  /* template */

  /* style */

  var __vue_inject_styles__$7 = undefined;
  /* scoped */

  var __vue_scope_id__$7 = undefined;
  /* module identifier */

  var __vue_module_identifier__$7 = undefined;
  /* functional template */

  var __vue_is_functional_template__$7 = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$7 = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$7, __vue_script__$7, __vue_scope_id__$7, __vue_is_functional_template__$7, __vue_module_identifier__$7, false, undefined, undefined, undefined);

  function plugin$8(Vue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$8.installed) {
      return;
    }

    plugin$8.installed = true;
    options = pick(options, 'dataProjection');
    Object.assign(__vue_component__$7, options);
    Vue.component(__vue_component__$7.name, __vue_component__$7);
    Vue.component('VlSourceArcgisRest', {
      name: 'VlSourceArcgisRest',
      extends: __vue_component__$7,
      created: function created() {
      }
    });
  }

  var TileArcgisRestSource = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': plugin$8,
    install: plugin$8,
    Source: __vue_component__$7
  });

  /**
   * Layer that provide pre-rendered, tiled images in grid that are organized by zoom levels for
   * specific resolutions. `vl-tile-layer` component implements a **source container** interface, so it should be
   * used together with tile-like `vl-source-*` components.
   */

  var script$6 = {
    name: 'VlLayerTile',
    mixins: [tileLayer],
    methods: {
      /**
       * @return {Tile}
       * @protected
       */
      createLayer: function createLayer() {
        return new layer$1.Tile({
          // ol/layer/Base
          className: this.className,
          opacity: this.currentOpacity,
          visible: this.currentVisible,
          extent: this.currentExtentViewProj,
          zIndex: this.currentZIndex,
          minResolution: this.currentMinResolution,
          maxResolution: this.currentMaxResolution,
          minZoom: this.currentMinZoom,
          maxZoom: this.currentMaxZoom,
          // ol/layer/Layer
          render: this.render,
          source: this.$source,
          // ol/layer/BaseTile
          preload: this.currentPreload,
          useInterimTilesOnError: this.currentUseInterimTilesOnError
        });
      }
    }
  };

  /* script */
  var __vue_script__$6 = script$6;
  /* template */

  /* style */

  var __vue_inject_styles__$6 = undefined;
  /* scoped */

  var __vue_scope_id__$6 = undefined;
  /* module identifier */

  var __vue_module_identifier__$6 = undefined;
  /* functional template */

  var __vue_is_functional_template__$6 = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$6 = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$6, __vue_script__$6, __vue_scope_id__$6, __vue_is_functional_template__$6, __vue_module_identifier__$6, false, undefined, undefined, undefined);

  function plugin$7(Vue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$7.installed) {
      return;
    }

    plugin$7.installed = true;
    options = pick(options, 'dataProjection');
    Object.assign(__vue_component__$6, options);
    Vue.component(__vue_component__$6.name, __vue_component__$6);
  }

  var TileLayer = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': plugin$7,
    install: plugin$7,
    Layer: __vue_component__$6
  });

  function ownKeys$5(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$5(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$5(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var script$5 = {
    name: 'VlSourceTileWms',
    mixins: [wmsSource, tileImageSource],
    props: {
      gutter: {
        type: Number,
        default: 0
      }
    },
    computed: {
      inputTileUrlFunction: noop$1
    },
    watch: _objectSpread$5({}, /*#__PURE__*/makeChangeOrRecreateWatchers(['gutter'])),
    methods: {
      createSource: function createSource() {
        return new source$1.TileWMS({
          // ol/source/Source
          attributions: this.currentAttributions,
          projection: this.resolvedDataProjection,
          wrapX: this.wrapX,
          // ol/source/Tile
          cacheSize: this.cacheSize,
          tileGrid: this.tileGrid,
          transition: this.transition,
          // ol/source/UrlTile
          tileLoadFunction: this.currentTileLoadFunction,
          urls: this.currentUrls,
          // ol/source/TileImage
          crossOrigin: this.crossOrigin,
          reprojectionErrorThreshold: this.reprojectionErrorThreshold,
          tileClass: this.tileClass,
          imageSmoothing: this.imageSmoothing,
          // ol/source/TileWMS
          gutter: this.gutter,
          hidpi: this.hidpi,
          serverType: this.serverType,
          params: this.currentParams
        });
      },
      stateChanged: noop$1,
      attributionsCollapsibleChanged: noop$1,
      tileKeyChanged: noop$1,
      opaqueChanged: noop$1,
      tilePixelRatioChanged: noop$1,
      zDirectionChanged: noop$1,
      inputTileUrlFunctionChanged: noop$1
    }
  };

  /* script */
  var __vue_script__$5 = script$5;
  /* template */

  /* style */

  var __vue_inject_styles__$5 = undefined;
  /* scoped */

  var __vue_scope_id__$5 = undefined;
  /* module identifier */

  var __vue_module_identifier__$5 = undefined;
  /* functional template */

  var __vue_is_functional_template__$5 = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$5 = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$5, __vue_script__$5, __vue_scope_id__$5, __vue_is_functional_template__$5, __vue_module_identifier__$5, false, undefined, undefined, undefined);

  function plugin$6(Vue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$6.installed) {
      return;
    }

    plugin$6.installed = true;
    options = pick(options, 'dataProjection');
    Object.assign(__vue_component__$5, options);
    Vue.component(__vue_component__$5.name, __vue_component__$5); // todo remove in v0.13.x

    Vue.component('VlSourceWms', {
      name: 'VlSourceWms',
      extends: __vue_component__$5,
      created: function created() {
      }
    });
  }

  var TileWmsSource = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': plugin$6,
    install: plugin$6,
    Source: __vue_component__$5
  });

  function ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$4(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var script$4 = {
    name: 'VlInteractionTranslate',
    mixins: [interaction],
    stubVNode: {
      empty: false,
      attrs: function attrs() {
        return {
          id: this.vmId,
          class: this.vmClass
        };
      }
    },
    props: {
      source: {
        type: String,
        required: true
      },
      layers: [String, Array],
      filter: Function,
      hitTolerance: {
        type: Number,
        default: 0
      }
    },
    data: function data() {
      return {
        currentHitTolerance: this.hitTolerance
      };
    },
    computed: {
      inputFilter: function inputFilter() {
        if (isFunction$1(this.filter)) return this.filter;
        var layers = this.layers;
        if (!layers) return;
        if (isString(layers)) layers = [layers];
        return function (feature, layer) {
          return layers.includes(getLayerId(layer));
        };
      }
    },
    watch: _objectSpread$4({
      rev: function rev() {
        if (!this.$interaction) return;

        if (this.currentHitTolerance !== this.$interaction.getHitTolerance()) {
          this.currentHitTolerance = this.$interaction.getHitTolerance();
        }
      },
      hitTolerance: function hitTolerance(value) {
        this.setHitTolerance(value);
      },
      currentHitTolerance: function currentHitTolerance(value) {
        if (value === this.hitTolerance) return;
        this.$emit('update:hitTolerance', value);
      }
    }, /*#__PURE__*/makeChangeOrRecreateWatchers(['source', 'inputFilter'])),
    methods: {
      /**
       * @return {Promise<Modify>}
       * @protected
       */
      createInteraction: function createInteraction() {
        var _this = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          var source, features;
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return _this.getInstance(_this.source);

                case 2:
                  source = _this._source = _context.sent;
                  assert$1(!!source, "Source \"".concat(_this.source, "\" not found in identity map."));

                  if (source instanceof source$1.Vector) {
                    features = source.getFeaturesCollection();

                    if (!features) {
                      features = new ol.Collection(source.getFeatures());

                      _this.subscribeTo(fromOlEvent(source, VectorEventType.ADDFEATURE), function (_ref) {
                        var feature = _ref.feature;
                        return feature && features.push(feature);
                      });

                      _this.subscribeTo(fromOlEvent(source, VectorEventType.REMOVEFEATURE), function (_ref2) {
                        var feature = _ref2.feature;
                        return feature && features.remove(feature);
                      });
                    }

                    instanceOf(features, ol.Collection, "Source \"".concat(_this.source, "\" doesn't provide features collection."));
                  } else {
                    if (isFunction$1(source.getFeaturesCollection)) {
                      features = source.getFeaturesCollection();
                    } else if (isFunction$1(source.getFeatures)) {
                      features = source.getFeatures();
                    }

                    instanceOf(features, ol.Collection, "Source \"".concat(_this.source, "\" doesn't provide features collection."));
                  }

                  return _context.abrupt("return", new interaction$1.Translate({
                    features: features,
                    filter: _this.inputFilter,
                    hitTolerance: _this.currentHitTolerance
                  }));

                case 6:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      },

      /**
       * @return {void}
       * @protected
       */
      subscribeAll: function subscribeAll() {
        interaction.methods.subscribeAll.call(this);
        subscribeToInteractionChanges.call(this);
      },
      getHitTolerance: function getHitTolerance() {
        var _this$$interaction;

        return coalesce((_this$$interaction = this.$interaction) === null || _this$$interaction === void 0 ? void 0 : _this$$interaction.getHitTolerance(), this.currentHitTolerance);
      },
      setHitTolerance: function setHitTolerance(tolerance) {
        assert$1(isNumber$1(tolerance), 'Invalid hit tolerance');

        if (tolerance !== this.currentHitTolerance) {
          this.currentHitTolerance = tolerance;
        }

        if (this.$interaction && tolerance !== this.$interaction.getHitTolerance()) {
          this.$interaction.setHitTolerance(tolerance);
        }
      }
    }
  };
  /**
   * @private
   */

  function subscribeToInteractionChanges() {
    var _this2 = this;

    var start = fromOlEvent(this.$interaction, 'translatestart').pipe(tap(function () {
      return _this2.setInteracting(true);
    }));
    var end = fromOlEvent(this.$interaction, 'translateend').pipe(tap(function () {
      return _this2.setInteracting(false);
    }));
    var progress = fromOlEvent(this.$interaction, 'translating');
    var events = merge(start, end, progress).pipe(map(function (_ref3) {
      var type = _ref3.type,
          features = _ref3.features,
          coordinate = _ref3.coordinate,
          startCoordinate = _ref3.startCoordinate;
      var viewProj = _this2.resolvedViewProjection;
      var dataProj = _this2.resolvedDataProjection;
      return {
        type: type,
        features: features instanceof ol.Collection ? features.getArray() : features,
        coordinate: _this2.pointToDataProj(coordinate),
        startCoordinate: _this2.pointToDataProj(startCoordinate),

        get json() {
          if (!this._json) {
            this._json = map$1(this.features, function (feature) {
              return writeGeoJsonFeature(feature, viewProj, dataProj, COORD_PRECISION);
            });
          }

          return this._json;
        }

      };
    }));
    this.subscribeTo(events, function (evt) {
      return _this2.$emit(evt.type, evt);
    });
  }

  /* script */
  var __vue_script__$4 = script$4;
  /* template */

  /* style */

  var __vue_inject_styles__$4 = undefined;
  /* scoped */

  var __vue_scope_id__$4 = undefined;
  /* module identifier */

  var __vue_module_identifier__$4 = undefined;
  /* functional template */

  var __vue_is_functional_template__$4 = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$4 = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$4, __vue_script__$4, __vue_scope_id__$4, __vue_is_functional_template__$4, __vue_module_identifier__$4, false, undefined, undefined, undefined);

  function plugin$5(Vue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$5.installed) {
      return;
    }

    plugin$5.installed = true;
    options = pick(options, 'dataProjection');
    Object.assign(__vue_component__$4, options);
    Vue.component(__vue_component__$4.name, __vue_component__$4);
  }

  var TranslateInteraction = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': plugin$5,
    install: plugin$5,
    Interaction: __vue_component__$4
  });

  function ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  /**
   * Layer for data that is rendered client-side.
   */

  var script$3 = {
    name: 'VlLayerVectorImage',
    mixins: [vectorLayer],
    props: {
      // ol/layer/VectorImage

      /**
       * @type {number}
       */
      imageRatio: {
        type: Number,
        default: 1
      }
    },
    watch: _objectSpread$3({}, /*#__PURE__*/makeChangeOrRecreateWatchers(['imageRatio'])),
    methods: {
      /**
       * @return {VectorImageLayer}
       * @protected
       */
      createLayer: function createLayer() {
        return new layer$1.VectorImage({
          // ol/layer/Base
          className: this.className,
          opacity: this.currentOpacity,
          visible: this.currentVisible,
          extent: this.currentExtentViewProj,
          zIndex: this.currentZIndex,
          minResolution: this.currentMinResolution,
          maxResolution: this.currentMaxResolution,
          minZoom: this.currentMinZoom,
          maxZoom: this.currentMaxZoom,
          // ol/layer/Layer
          render: this.render,
          source: this.$source,
          // ol/layer/BaseVector
          renderOrder: this.renderOrder,
          renderBuffer: this.renderBuffer,
          declutter: this.declutter,
          updateWhileAnimating: this.updateWhileAnimating,
          updateWhileInteracting: this.updateWhileInteracting,
          style: this.$style,
          // ol/layer/VectorImage
          imageRatio: this.imageRatio
        });
      }
    }
  };

  /* script */
  var __vue_script__$3 = script$3;
  /* template */

  /* style */

  var __vue_inject_styles__$3 = undefined;
  /* scoped */

  var __vue_scope_id__$3 = undefined;
  /* module identifier */

  var __vue_module_identifier__$3 = undefined;
  /* functional template */

  var __vue_is_functional_template__$3 = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$3 = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$3, __vue_script__$3, __vue_scope_id__$3, __vue_is_functional_template__$3, __vue_module_identifier__$3, false, undefined, undefined, undefined);

  function plugin$4(Vue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$4.installed) {
      return;
    }

    plugin$4.installed = true;
    options = pick(options, 'dataProjection');
    Object.assign(__vue_component__$3, options);
    Vue.component(__vue_component__$3.name, __vue_component__$3);
  }

  var VectorImageLayer = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': plugin$4,
    install: plugin$4,
    Layer: __vue_component__$3
  });

  function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var validateTileSize = /*#__PURE__*/or(isNumber$1, and(isArray$2, function (value) {
    return value.length === 2 && value.every(isNumber$1);
  }));
  var script$2 = {
    name: 'VlSourceVectorTile',
    mixins: [urlTileSource, featureHelper],
    props: {
      /* eslint-disable vue/require-prop-types */
      // ol/source/Tile
      cacheSize: _objectSpread$2(_objectSpread$2({}, tileSource.props.cacheSize), {}, {
        default: 128
      }),
      zDirection: _objectSpread$2(_objectSpread$2({}, tileSource.props.zDirection), {}, {
        default: 1
      }),

      /* eslint-enable vue/require-prop-types */
      // ol/source/VectorTile
      extent: {
        type: Array,
        validator: function validator(value) {
          return value.length === 4 && value.every(isNumber$1);
        }
      },
      formatFactory: {
        type: Function,
        default: createMvtFmt
      },
      overlaps: {
        type: Boolean,
        default: true
      },
      tileClass: Function,
      maxZoom: {
        type: Number,
        default: 22
      },
      minZoom: {
        type: Number,
        default: 0,
        validator: function validator(value) {
          return value >= 0;
        }
      },
      maxResolution: Number,
      tileSize: {
        type: [Number, Array],
        default: function _default() {
          return [512, 512];
        },
        validator: validateTileSize
      }
    },
    data: function data() {
      return {
        format: undefined
      };
    },
    computed: {
      inputTileSize: function inputTileSize() {
        return isArray$2(this.tileSize) ? this.tileSize : [this.tileSize, this.tileSize];
      },
      derivedTileGridFactory: function derivedTileGridFactory() {
        if (isFunction$1(this.tileGridFactory)) {
          return this.tileGridFactory;
        }

        var extent = this.extentDataProj || extentFromProjection(this.resolvedDataProjection);
        var maxZoom = this.maxZoom;
        var minZoom = this.minZoom;
        var maxResolution = this.maxResolution;
        var tileSize = this.inputTileSize;
        return function () {
          return tilegrid.createXYZ({
            extent: extent,
            maxZoom: maxZoom,
            minZoom: minZoom,
            maxResolution: maxResolution,
            tileSize: tileSize
          });
        };
      },
      extentDataProj: function extentDataProj() {
        return roundExtent(this.extent);
      },
      extentViewProj: function extentViewProj() {
        return this.extentToViewProj(this.extent);
      },
      formatIdent: function formatIdent() {
        if (!this.olObjIdent) return;
        return this.makeIdent(this.olObjIdent, 'format');
      },
      inputFormatFactory: function inputFormatFactory() {
        return sealFactory(this.formatFactory.bind(this));
      },
      inputTileUrlFunction: function inputTileUrlFunction() {
        var urlFunc = coalesce(this.tileUrlFunction, this.tileUrlFunc);
        if (isFunction$1(urlFunc)) return urlFunc;
        if (this.currentUrls.length === 0) return;
        return createTileUrlFunctionFromTemplates(this.currentUrls, this.tileGrid);
      }
    },
    watch: _objectSpread$2({
      formatIdent: function formatIdent(value, prevValue) {
        if (value && prevValue) {
          this.moveInstance(value, prevValue);
        } else if (value && !prevValue && this.format) {
          this.setInstance(value, this.format);
        } else if (!value && prevValue) {
          this.unsetInstance(prevValue);
        }
      },
      inputFormatFactory: function inputFormatFactory(value) {
        while (this.hasInstance(this.formatIdent)) {
          this.unsetInstance(this.formatIdent);
        }

        if (isFunction$1(value)) {
          this.format = this.instanceFactoryCall(this.formatIdent, value.bind(this));
        } else {
          this.format = undefined;
        }
      }
    }, /*#__PURE__*/makeChangeOrRecreateWatchers(['extentViewProj', 'overlaps', 'tileClass'], ['extentViewProj'])),
    created: function created() {
      if (isFunction$1(this.inputFormatFactory)) {
        this.format = this.instanceFactoryCall(this.formatIdent, this.inputFormatFactory.bind(this));
      }
    },
    methods: {
      /**
       * @return {VectorTileSource}
       */
      createSource: function createSource() {
        return new source$1.VectorTile({
          // ol/source/Source
          attributions: this.currentAttributions,
          attributionsCollapsible: this.attributionsCollapsible,
          projection: this.resolvedDataProjection,
          state: this.currentState,
          wrapX: this.wrapX,
          // ol/source/Tile
          cacheSize: this.cacheSize,
          tileGrid: this.tileGrid,
          transition: this.transition,
          zDirection: this.zDirection,
          // ol/source/UrlTile
          tileLoadFunction: this.currentTileLoadFunction,
          tileUrlFunction: this.currentTileUrlFunction,
          // ol/source/VectorTile
          format: this.format,
          extent: this.extentViewProj,
          overlaps: this.overlaps,
          tileClass: this.tileClass
        });
      },

      /**
       * @returns {void}
       */
      subscribeAll: function subscribeAll() {
        urlTileSource.methods.subscribeAll.call(this);
        subscribeToSourceEvents.call(this);
      },
      getFeaturesInExtent: function getFeaturesInExtent(extent) {
        var _arguments = arguments,
            _this = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          var viewProj;
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  viewProj = _arguments.length > 1 && _arguments[1] !== undefined ? _arguments[1] : false;
                  extent = viewProj ? roundExtent(extent) : _this.extentToViewProj(extent);
                  _context.next = 4;
                  return _this.resolveSource();

                case 4:
                  return _context.abrupt("return", _context.sent.getFeaturesInExtent(extent));

                case 5:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }))();
      },
      clear: function clear() {
        var _this2 = this;

        return _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee2() {
          return regenerator.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  _context2.next = 2;
                  return _this2.resolveSource();

                case 2:
                  _context2.sent.clear();

                case 3:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2);
        }))();
      },
      tileKeyChanged: noop$1,
      opaqueChanged: noop$1,
      tilePixelRatioChanged: noop$1
    }
  };

  function subscribeToSourceEvents() {
    var _this3 = this;

    this.subscribeTo(fromOlEvent(this.$source, TileEventType.TILELOADEND), function (evt) {
      if (!evt.tile) return;
      forEach(evt.tile.getFeatures(), function (feature) {
        if (!(feature instanceof ol.Feature)) return;

        _this3.initializeFeature(feature);
      });
    });
  }

  /* script */
  var __vue_script__$2 = script$2;
  /* template */

  /* style */

  var __vue_inject_styles__$2 = undefined;
  /* scoped */

  var __vue_scope_id__$2 = undefined;
  /* module identifier */

  var __vue_module_identifier__$2 = undefined;
  /* functional template */

  var __vue_is_functional_template__$2 = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$2 = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$2, __vue_script__$2, __vue_scope_id__$2, __vue_is_functional_template__$2, __vue_module_identifier__$2, false, undefined, undefined, undefined);

  function plugin$3(Vue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$3.installed) {
      return;
    }

    plugin$3.installed = true;
    options = pick(options, 'dataProjection');
    Object.assign(__vue_component__$2, options);
    Vue.component(__vue_component__$2.name, __vue_component__$2);
  }

  var VectorTileSource = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': plugin$3,
    install: plugin$3,
    Source: __vue_component__$2
  });

  /**
   * @module ol/tilegrid/common
   */
  /**
   * Default maximum zoom for default tile grids.
   * @type {number}
   */
  var DEFAULT_MAX_ZOOM = 42;
  /**
   * Default tile size.
   * @type {number}
   */
  var DEFAULT_TILE_SIZE = 256;

  function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var script$1 = {
    name: 'VlSourceWmts',
    mixins: [tileImageSource],
    props: {
      // ol/source/WMTS
      layerName: {
        type: String,
        required: true
      },
      styleName: {
        type: String,
        required: true
      },
      matrixSet: {
        type: String,
        required: true
      },
      dimensions: Object,
      format: {
        type: String,
        default: 'image/jpeg'
      },
      requestEncoding: {
        type: String,
        default: 'KVP'
      },
      version: {
        type: String,
        default: '1.0.0'
      },
      // custom
      extent: {
        type: Array,
        validator: function validator(value) {
          return value.length === 4 && value.every(isNumber$1);
        }
      },
      resolutions: {
        type: Array,
        validator: function validator(value) {
          return value.every(isNumber$1);
        }
      },
      origin: {
        type: Array,
        validator: function validator(value) {
          return value.length === 2 && value.every(isNumber$1);
        }
      },
      matrixIds: {
        type: Array,
        validator: function validator(value) {
          return value.every(isNumber$1);
        }
      },
      maxZoom: {
        type: Number,
        default: DEFAULT_MAX_ZOOM
      },
      minZoom: {
        type: Number,
        default: 0
      },
      tileSize: {
        type: [Number, Array],
        default: function _default() {
          return [DEFAULT_TILE_SIZE, DEFAULT_TILE_SIZE];
        }
      }
    },
    computed: {
      extentDataProj: function extentDataProj() {
        return roundExtent(this.extent);
      },
      extentViewProj: function extentViewProj() {
        return this.extentToViewProj(this.extent);
      },
      originDataProj: function originDataProj() {
        return roundPointCoords(this.origin);
      },
      originViewProj: function originViewProj() {
        return this.pointToViewProj(this.origin);
      },
      inputTileSize: function inputTileSize() {
        return isArray$2(this.tileSize) ? this.tileSize : [this.tileSize, this.tileSize];
      },
      derivedTileGridFactory: function derivedTileGridFactory() {
        if (isFunction$1(this.tileGridFactory)) {
          return this.tileGridFactory;
        }

        var extent = this.extentDataProj || extentFromProjection(this.resolvedDataProjection);
        var resolutions = this.resolutions || resolutionsFromExtent(extent, this.maxZoom, this.inputTileSize);
        var origin = this.originDataProj || getCorner(extent, ExtentCorner.TOP_LEFT);
        var matrixIds = this.matrixIds || range(this.minZoom, resolutions.length);
        var tileSize = this.inputTileSize;
        var minZoom = this.minZoom;
        return function () {
          return new WMTSTileGrid__default['default']({
            extent: extent,
            origin: origin,
            resolutions: resolutions,
            minZoom: minZoom,
            matrixIds: matrixIds,
            tileSize: tileSize
          });
        };
      },
      inputTileUrlFunction: noop$1
    },
    watch: _objectSpread$1({}, /*#__PURE__*/makeChangeOrRecreateWatchers(['dimensions', 'format', 'layerName', 'styleName', 'matrixSet', 'requestEncoding', 'version'], ['dimensions'])),
    methods: {
      /**
       * @returns {WMTS}
       * @protected
       */
      createSource: function createSource() {
        return new source$1.WMTS({
          // ol/source/Source
          attributions: this.currentAttributions,
          projection: this.resolvedDataProjection,
          wrapX: this.wrapX,
          // ol/source/Tile
          cacheSize: this.cacheSize,
          tileGrid: this.tileGrid,
          tilePixelRatio: this.tilePixelRatio,
          transition: this.transition,
          // ol/source/UrlTile
          urls: this.currentUrls,
          tileLoadFunction: this.currentTileLoadFunction,
          // ol/source/TileImage
          crossOrigin: this.crossOrigin,
          reprojectionErrorThreshold: this.reprojectionErrorThreshold,
          tileClass: this.tileClass,
          imageSmoothing: this.imageSmoothing,
          // ol/source/WMTS
          dimensions: this.dimensions,
          format: this.format,
          layer: this.layerName,
          style: this.styleName,
          matrixSet: this.matrixSet,
          requestEncoding: this.requestEncoding,
          version: this.version
        });
      },
      getDimensions: function getDimensions() {
        var _this$$source;

        return coalesce((_this$$source = this.$source) === null || _this$$source === void 0 ? void 0 : _this$$source.getDimensions(), this.dimensions);
      },
      getFormat: function getFormat() {
        var _this$$source2;

        return coalesce((_this$$source2 = this.$source) === null || _this$$source2 === void 0 ? void 0 : _this$$source2.getFormat(), this.format);
      },
      getLayer: function getLayer() {
        var _this$$source3;

        return coalesce((_this$$source3 = this.$source) === null || _this$$source3 === void 0 ? void 0 : _this$$source3.getLayer(), this.layerName);
      },
      getMatrixSet: function getMatrixSet() {
        var _this$$source4;

        return coalesce((_this$$source4 = this.$source) === null || _this$$source4 === void 0 ? void 0 : _this$$source4.getMatrixSet(), this.matrixSet);
      },
      getRequestEncoding: function getRequestEncoding() {
        var _this$$source5;

        return coalesce((_this$$source5 = this.$source) === null || _this$$source5 === void 0 ? void 0 : _this$$source5.getRequestEncoding(), this.requestEncoding);
      },
      getStyle: function getStyle() {
        var _this$$source6;

        return coalesce((_this$$source6 = this.$source) === null || _this$$source6 === void 0 ? void 0 : _this$$source6.getStyle(), this.styleName);
      },
      getVersion: function getVersion() {
        var _this$$source7;

        return coalesce((_this$$source7 = this.$source) === null || _this$$source7 === void 0 ? void 0 : _this$$source7.getVersion(), this.version);
      },
      attributionsCollapsibleChanged: noop$1,
      stateChanged: noop$1,
      tileKeyChanged: noop$1,
      opaqueChanged: noop$1,
      zDirectionChanged: noop$1,
      inputTileUrlFunctionChanged: noop$1
    }
  };

  function resolutionsFromExtent(extent$1, maxZoom, tileSize, maxResolution) {
    maxZoom = maxZoom !== undefined ? maxZoom : DEFAULT_MAX_ZOOM;
    var height = extent.getHeight(extent$1);
    var width = extent.getWidth(extent$1);
    tileSize = size.toSize(tileSize !== undefined ? tileSize : DEFAULT_TILE_SIZE);
    maxResolution = maxResolution > 0 ? maxResolution : Math.max(width / tileSize[0], height / tileSize[1]);
    var length = maxZoom + 1;
    var resolutions = new Array(length);

    for (var z = 0; z < length; ++z) {
      resolutions[z] = maxResolution / Math.pow(2, z);
    }

    return resolutions;
  }

  /* script */
  var __vue_script__$1 = script$1;
  /* template */

  /* style */

  var __vue_inject_styles__$1 = undefined;
  /* scoped */

  var __vue_scope_id__$1 = undefined;
  /* module identifier */

  var __vue_module_identifier__$1 = undefined;
  /* functional template */

  var __vue_is_functional_template__$1 = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__$1 = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$1, __vue_script__$1, __vue_scope_id__$1, __vue_is_functional_template__$1, __vue_module_identifier__$1, false, undefined, undefined, undefined);

  function plugin$2(Vue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$2.installed) {
      return;
    }

    plugin$2.installed = true;
    options = pick(options, 'dataProjection');
    Object.assign(__vue_component__$1, options);
    Vue.component(__vue_component__$1.name, __vue_component__$1);
  }

  var WmtsSource = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': plugin$2,
    install: plugin$2,
    Source: __vue_component__$1
  });

  var script = {
    name: 'VlSourceXyz',
    mixins: [xyzSource]
  };

  /* script */
  var __vue_script__ = script;
  /* template */

  /* style */

  var __vue_inject_styles__ = undefined;
  /* scoped */

  var __vue_scope_id__ = undefined;
  /* module identifier */

  var __vue_module_identifier__ = undefined;
  /* functional template */

  var __vue_is_functional_template__ = undefined;
  /* style inject */

  /* style inject SSR */

  /* style inject shadow dom */

  var __vue_component__ = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, false, undefined, undefined, undefined);

  function plugin$1(Vue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin$1.installed) {
      return;
    }

    plugin$1.installed = true;
    options = pick(options, 'dataProjection');
    Object.assign(__vue_component__, options);
    Vue.component(__vue_component__.name, __vue_component__);
  }

  var XyzSource = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': plugin$1,
    install: plugin$1,
    Source: __vue_component__
  });

  /**
   * @const {string} VueLayers version.
   */

  var VERSION = '0.12.0-rc.26';
  /**
   * @typedef {Object} VueLayersOptions
   * @property {string} [dataProjection] Projection for all properties, events and other plain values.
   */

  /**
   * Registers all VueLayers components.
   * @param {Vue|VueConstructor} Vue
   * @param {VueLayersOptions} [options]
   */

  function plugin(Vue) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    if (plugin.installed) {
      return;
    }

    plugin.installed = true; // install components

    Vue.use(BingmapsSource, options);
    Vue.use(ClusterSource, options);
    Vue.use(DrawInteraction, options);
    Vue.use(Feature, options);
    Vue.use(Geoloc, options);
    Vue.use(GraticuleLayer, options);
    Vue.use(GroupLayer, options);
    Vue.use(HeatmapLayer, options);
    Vue.use(ImageArcgisRestSource, options);
    Vue.use(ImageLayer, options);
    Vue.use(ImageStaticSource, options);
    Vue.use(ImageWmsSource, options);
    Vue.use(Map$1, options);
    Vue.use(MapboxSource, options);
    Vue.use(MapboxVectorLayer, options);
    Vue.use(ModifyInteraction, options);
    Vue.use(OsmSource, options);
    Vue.use(Overlay, options);
    Vue.use(RotateInteraction, options);
    Vue.use(SelectInteraction, options);
    Vue.use(SnapInteraction, options);
    Vue.use(SputnikSource, options);
    Vue.use(StamenSource, options);
    Vue.use(Style, options);
    Vue.use(StyleFunc, options);
    Vue.use(TileArcgisRestSource, options);
    Vue.use(TileLayer, options);
    Vue.use(TileWmsSource, options);
    Vue.use(TranslateInteraction, options);
    Vue.use(VectorImageLayer, options);
    Vue.use(VectorLayer, options);
    Vue.use(VectorSource, options);
    Vue.use(VectorTileLayer, options);
    Vue.use(VectorTileSource, options);
    Vue.use(WmtsSource, options);
    Vue.use(XyzSource, options);
  }

  var VueLayers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    VERSION: VERSION,
    'default': plugin,
    install: plugin,
    BingmapsSource: BingmapsSource,
    ClusterSource: ClusterSource,
    DrawInteraction: DrawInteraction,
    Feature: Feature,
    Geoloc: Geoloc,
    GraticuleLayer: GraticuleLayer,
    GroupLayer: GroupLayer,
    HeatmapLayer: HeatmapLayer,
    ImageArcgisRestSource: ImageArcgisRestSource,
    ImageLayer: ImageLayer,
    ImageStaticSource: ImageStaticSource,
    ImageWmsSource: ImageWmsSource,
    Map: Map$1,
    MapboxSource: MapboxSource,
    MapboxVectorLayer: MapboxVectorLayer,
    ModifyInteraction: ModifyInteraction,
    OsmSource: OsmSource,
    Overlay: Overlay,
    RotateInteraction: RotateInteraction,
    SelectInteraction: SelectInteraction,
    SnapInteraction: SnapInteraction,
    SputnikSource: SputnikSource,
    StamenSource: StamenSource,
    Style: Style,
    StyleFunc: StyleFunc,
    TileArcgisRestSource: TileArcgisRestSource,
    TileLayer: TileLayer,
    TileWmsSource: TileWmsSource,
    TranslateInteraction: TranslateInteraction,
    VectorImageLayer: VectorImageLayer,
    VectorLayer: VectorLayer,
    VectorSource: VectorSource,
    VectorTileLayer: VectorTileLayer,
    VectorTileSource: VectorTileSource,
    WmtsSource: WmtsSource,
    XyzSource: XyzSource
  });

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  var index_umd = _objectSpread(_objectSpread({}, VueLayers), {}, {
    mixins: mixins,
    olExt: olExt,
    rxExt: rxExt,
    utils: utils
  });

  if (typeof window.Vue !== 'undefined') {
    window.Vue.use(VueLayers);
  }

  return index_umd;

})));
//# sourceMappingURL=vuelayers.umd.js.map
