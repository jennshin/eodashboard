/**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.12.0-rc.26
 * @license MIT
 * @copyright (c) 2017-2021, Vladimir Vershinin <ghettovoice@gmail.com>
 */
import _classCallCheck from '@babel/runtime/helpers/esm/classCallCheck';
import _assertThisInitialized from '@babel/runtime/helpers/esm/assertThisInitialized';
import _inherits from '@babel/runtime/helpers/esm/inherits';
import _possibleConstructorReturn from '@babel/runtime/helpers/esm/possibleConstructorReturn';
import _getPrototypeOf from '@babel/runtime/helpers/esm/getPrototypeOf';
import _wrapNativeSuper from '@babel/runtime/helpers/esm/wrapNativeSuper';
import _typeof from '@babel/runtime/helpers/esm/typeof';
import _regeneratorRuntime from '@babel/runtime/regenerator';
import { Collection } from 'ol';
import _createClass from '@babel/runtime/helpers/esm/createClass';
import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';
import _toConsumableArray from '@babel/runtime/helpers/esm/toConsumableArray';
import _asyncToGenerator from '@babel/runtime/helpers/esm/asyncToGenerator';
import baseMergeDescriptors from 'merge-descriptors';
import { interval, throwError, race, NEVER } from 'rxjs';
import { skipWhile, skipUntil, first, switchMap, timeout, catchError } from 'rxjs/operators';

var _context;

var _marked = /*#__PURE__*/_regeneratorRuntime.mark(rangeIterator);
/**
 * Mini Lodash.
 */

var glob = typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : {};
var globIsFinite = glob.isFinite || noop;
var objectProto = Object.prototype;
var funcProto = Object.prototype;
var objectToString = objectProto.toString;
var objectHasOwnProp = objectProto.hasOwnProperty;
var funcToString = funcProto.toString;
var objectTag = /*#__PURE__*/(_context = {}, objectToString).call(_context);
var numberTag = /*#__PURE__*/(_context = 0, objectToString).call(_context);
var stringTag = /*#__PURE__*/(_context = '', objectToString).call(_context);
var booleanTag = /*#__PURE__*/(_context = true, objectToString).call(_context);
var objectCtorString = /*#__PURE__*/funcToString.call(Object);
function noop() {// do nothing
}
function constant(value) {
  return function () {
    return value;
  };
}
function stubArray() {
  return [];
}
function stubObject() {
  return Object.create(null);
}
function stubCollection() {
  return new Collection();
}
function stubTrue() {
  return true;
}
function stubFalse() {
  return false;
}
function identity(value) {
  return value;
}
function negate(func) {
  return function () {
    return !func.apply(void 0, arguments);
  };
}
function or() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  return function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return reduce(funcs, function (result, fn) {
      return result || fn.apply(void 0, args);
    }, false);
  };
}
function and() {
  for (var _len3 = arguments.length, funcs = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    funcs[_key3] = arguments[_key3];
  }

  return function () {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }

    return reduce(funcs, function (result, fn) {
      return result && fn.apply(void 0, args);
    }, true);
  };
}
function toArray(value) {
  return Array.from(value);
}
function isBoolean(value) {
  return objectToString.call(value) === booleanTag;
}
function isNumber(value) {
  return objectToString.call(value) === numberTag;
}
function isString(value) {
  return objectToString.call(value) === stringTag;
}
function isArray(value) {
  return Array.isArray(value);
}
function isArrayLike(value) {
  return isObjectLike(value) && objectHasOwnProp.call(value, 'length');
}
function isCollection(value) {
  return value instanceof Collection;
}
function isFinite(value) {
  return typeof value === 'number' && globIsFinite(value);
}
function isFunction(value) {
  return typeof value === 'function';
}
/**
 * @param {*} value
 * @return {boolean} True if value is number or numeric string.
 */

function isNumeric(value) {
  return !isNaN(parseFloat(value)) && globIsFinite(value);
}
function isObjectLike(value) {
  return value != null && _typeof(value) === 'object';
}
function isPlainObject(value) {
  if (!isObjectLike(value) || objectToString.call(value) !== objectTag) {
    return false;
  }

  var proto = Object.getPrototypeOf(value);

  if (proto == null) {
    return true;
  }

  var Ctor = proto.constructor;
  return typeof Ctor === 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) === objectCtorString;
}
function round(number) {
  var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  if (!globIsFinite(number)) return number;
  if (precision < 0) return Number(number);
  return Number(Number(number).toFixed(precision));
}
/**
 * @param {...*} [args]
 *
 * @return {*}
 */

function coalesce() {
  for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
    args[_key5] = arguments[_key5];
  }

  return args.find(function (val) {
    return val != null;
  });
}
/**
 * @param {Object} object
 * @return {Object} Returns object only with plain properties.
 */

function plainProps(object) {
  var newObject = {};

  var isPlain = function isPlain(x) {
    return isNumeric(x) || isString(x) || isArray(x) || isBoolean(x) || isPlainObject(x);
  };

  Object.keys(object).forEach(function (key) {
    if (isPlain(object[key])) {
      newObject[key] = object[key];
    }
  });
  return newObject;
}
/**
 * Replaces `tokens` in the `string` by values from the `replaces`.
 *
 * @param {string} string
 * @param {Object} replaces
 *
 * @returns {string}
 */

function replaceTokens(string, replaces) {
  var regExp = new RegExp(Object.keys(replaces).map(function (field) {
    return '(\\{' + field + '\\})';
  }).join('|'), 'ig');
  return string.replace(regExp, function (match) {
    return replaces[match.substr(1, match.length - 2)] || '';
  });
}
function isEqual(value, other) {
  if (value === other) {
    return true;
  }

  if (value == null || other == null || !(isObjectLike(value) && isObjectLike(other))) {
    // eslint-disable-next-line no-self-compare
    return value !== value && other !== other;
  }

  var valueProps = Object.keys(value);
  var otherProps = Object.keys(other);

  if (valueProps.length !== otherProps.length) {
    return false;
  } // if (serialize(value) === serialize(other)) return


  var checked = [];

  var traverse = function traverse(valueProps, otherProps) {
    for (var i = 0, l = valueProps.length; i < l; i++) {
      var valueProp = valueProps[i];

      if (checked.includes(valueProp)) {
        continue;
      }

      if (objectHasOwnProp.call(other, valueProp) === false) {
        return false;
      }

      var otherProp = otherProps[i];

      if (!isEqual(value[valueProp], other[otherProp])) {
        return false;
      }

      checked.push(otherProp);
    }

    return true;
  };

  if (traverse(valueProps, otherProps) === false) {
    return false;
  }

  return traverse(otherProps, valueProps);
}
function getLength(value) {
  if (isCollection(value)) {
    value = value.getArray();
  }

  if (isArrayLike(value)) {
    return value.length;
  }

  return 0;
}
function isEmpty(value) {
  if (isCollection(value)) {
    value = value.getArray();
  }

  if (isObjectLike(value)) {
    value = Object.values(value).filter(negate(isEmpty));
  }

  return !value || isArrayLike(value) && getLength(value) === 0;
}
function keys(object) {
  return Object.keys(object);
}
function values(object) {
  return Object.values(object);
}
function seal(object) {
  return Object.seal(object);
}
function freeze(object) {
  return Object.freeze(object);
}
function sealFactory(factory) {
  var fn = factory;

  if (!fn.sealed) {
    fn = function fn() {
      return seal(factory.apply(void 0, arguments));
    };

    fn.sealed = true;
  }

  return fn;
}
function freezeFactory(factory) {
  var fn = factory;

  if (!fn.freezed) {
    fn = function fn() {
      return freeze(factory.apply(void 0, arguments));
    };

    fn.freezed = true;
  }

  return fn;
}
function forEach(collection, iteratee) {
  if (isCollection(collection)) {
    collection = collection.getArray();
  }

  var keys = Object.keys(collection);

  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    var value = collection[key];

    if (iteratee(value, key) === false) {
      return;
    }
  }
}
function reduce(collection, iteratee, initial) {
  var result = initial;
  forEach(collection, function (value, key) {
    result = iteratee(result, value, key);
  });
  return result;
}
function filter(collection) {
  var iteratee = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : negate(isEmpty);
  return reduce(collection, function (newCollection, value, key) {
    if (iteratee(value, key)) {
      if (isArray(newCollection)) {
        newCollection.push(value);
      } else {
        newCollection[key] = value;
      }
    }

    return newCollection;
  }, isArrayLike(collection) || isCollection(collection) ? [] : {});
}
function find(collection) {
  var iteratee = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;
  var res = filter(collection, iteratee);
  if (isArray(res)) return res[0];
  return res[keys(res)[0]];
}
function map(collection) {
  var iteratee = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;
  return reduce(collection, function (newCollection, value, key) {
    newCollection[key] = iteratee(value, key);
    return newCollection;
  }, isArrayLike(collection) || isCollection(collection) ? [] : {});
}
function mapValues(object) {
  var iteratee = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;
  return map(object, iteratee);
}
function mapKeys(object) {
  var iteratee = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;
  return reduce(object, function (newObject, value, key) {
    newObject[iteratee(value, key)] = value;
    return newObject;
  }, isArrayLike(object) || isCollection(object) ? [] : {});
}
function every(collection) {
  var iteratee = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;
  return reduce(collection, function (result, value, key) {
    return result && iteratee(value, key);
  }, true);
}
function some(collection) {
  var iteratee = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;
  return reduce(collection, function (result, value, key) {
    return result || iteratee(value, key);
  }, false);
}
function firstEl(object) {
  if (isCollection(object)) {
    object = object.getArray();
  }

  if (!isArrayLike(object)) return;
  return object[0];
}
function lastEl(object) {
  if (isCollection(object)) {
    object = object.getArray();
  }

  if (!isArrayLike(object)) return;
  return object[object.length - 1];
}
function pick(object, key) {
  for (var _len6 = arguments.length, keys = new Array(_len6 > 2 ? _len6 - 2 : 0), _key6 = 2; _key6 < _len6; _key6++) {
    keys[_key6 - 2] = arguments[_key6];
  }

  if (Array.isArray(key)) {
    keys = key;
  } else {
    keys = [key].concat(keys);
  }

  return reduce(keys, function (picked, key) {
    picked[key] = object[key];
    return picked;
  }, {});
}
function omit(object, key) {
  for (var _len7 = arguments.length, keys = new Array(_len7 > 2 ? _len7 - 2 : 0), _key7 = 2; _key7 < _len7; _key7++) {
    keys[_key7 - 2] = arguments[_key7];
  }

  if (Array.isArray(key)) {
    keys = key;
  } else {
    keys = [key].concat(keys);
  }

  return filter(object, function (value, key) {
    return !keys.includes(key);
  });
}
function upperFirst(string) {
  string = String(string);

  if (string.length === 0) {
    return '';
  }

  return string[0].toUpperCase() + string.slice(1);
}
function lowerFirst(string) {
  string = String(string);

  if (string.length === 0) {
    return '';
  }

  return string[0].toLowerCase() + string.slice(1);
}
function rangeIterator(start, end) {
  var step,
      i,
      _args = arguments;
  return _regeneratorRuntime.wrap(function rangeIterator$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          step = _args.length > 2 && _args[2] !== undefined ? _args[2] : 1;
          i = start;

        case 2:
          if (!(i < end)) {
            _context2.next = 8;
            break;
          }

          _context2.next = 5;
          return i;

        case 5:
          i += step;
          _context2.next = 2;
          break;

        case 8:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked);
}
function range(start, end) {
  var step = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  return Array.from(rangeIterator(start, end, step));
}
/**
 * https://github.com/you-dont-need/You-Dont-Need-Lodash-Underscore#_get
 *
 * @param obj
 * @param path
 * @param defaultValue
 * @return {*}
 */

function get(obj, path, defaultValue) {
  var travel = function travel(regexp) {
    return String.prototype.split.call(path, regexp).filter(Boolean).reduce(function (res, key) {
      return res !== null && res !== undefined ? res[key] : res;
    }, obj);
  };

  var result = travel(/[,[\]]+?/) || travel(/[,[\].]+?/);
  return result === undefined || result === obj ? defaultValue : result;
}
function hasOwnProp(object, prop) {
  return isObjectLike(object) && objectHasOwnProp.call(object, prop);
}
function hasProp(object, prop) {
  return isObjectLike(object) && prop in object;
}
function includes(array, value) {
  var comparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : isEqual;
  var elems = filter(array, function (elem) {
    return comparator(elem, value);
  });
  return elems.shift();
}
function difference(array1, array2) {
  var comparator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : isEqual;
  return filter(array1, function (value) {
    return !includes(array2, value, comparator);
  });
}
/**
 * @param {string} str
 * @return {string}
 */

function camelCase(str) {
  var regExp = /([-_]\w)/g;
  return str.replace(regExp, function (matches) {
    return matches[1].toUpperCase();
  });
}
/**
 * @param {string} str
 * @returns {string}
 */

function kebabCase(str) {
  return str.match(/[A-Z]{2,}(?=[A-Z][a-z0-9]*|\b)|[A-Z]?[a-z0-9]*|[A-Z]|[0-9]+/g).filter(Boolean).map(function (x) {
    return x.toLowerCase();
  }).join('-');
}
function serialize(value) {
  return JSON.stringify(value);
}
function unserialize(value) {
  if (!isString(value)) return;
  return JSON.parse(value);
}
function clonePlainObject(obj) {
  return unserialize(serialize(obj));
}
function addPrefix(prefix) {
  return function (str) {
    return prefix + (prefix ? upperFirst(str) : str);
  };
}

function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var AssertionError = /*#__PURE__*/function (_Error) {
  _inherits(AssertionError, _Error);

  var _super = _createSuper$1(AssertionError);

  function AssertionError(message) {
    var _this;

    _classCallCheck(this, AssertionError);

    _this = _super.call(this, message);
    _this.name = _this.constructor.name;

    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(_assertThisInitialized(_this), _this.constructor);
    } else {
      _this.stack = new Error(message).stack;
    }

    return _this;
  }

  return AssertionError;
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * @param {*} value
 * @param {string} message
 * @throws AssertionError
 */

function assert(value, message) {
  if (!value) {
    throw new AssertionError(message || 'Assertion failed');
  }
}
/**
 * @param {*} value
 * @param {string|undefined} [msg]
 * @throws {AssertionError}
 */

function numeric(value, msg) {
  assert(isNumeric(value), msg || 'value is a number');
}
/**
 * @param {*} value
 * @param {Function} Ctor
 * @param {string|undefined} [msg]
 * @throws {AssertionError}
 */

function instanceOf(value, Ctor, msg) {
  assert(value instanceof Ctor, msg || "value is an instance of ".concat(Ctor.name));
}

/**
 * Simple Identity map with refs count
 */
var IdentityMap = /*#__PURE__*/function () {
  function IdentityMap() {
    _classCallCheck(this, IdentityMap);

    _defineProperty(this, "_pools", Object.create(null));
  }

  _createClass(IdentityMap, [{
    key: "_preparePool",
    value:
    /**
     * @param {string} pool
     * @private
     */
    function _preparePool(pool) {
      this._pools[pool] || (this._pools[pool] = Object.create(null));
    }
    /**
     * @param {string} id
     * @param {*} value
     * @param {string} pool
     */

  }, {
    key: "set",
    value: function set(id, value) {
      var pool = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'default';
      if (value == null) return;

      this._preparePool(pool);

      this._pools[pool][id] = {
        value: value,
        refs: 1
      };
    }
    /**
     * @param {string} id
     * @param {string} pool
     */

  }, {
    key: "get",
    value: function get(id) {
      var pool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';

      this._preparePool(pool);

      var rec = this._pools[pool][id];
      if (!rec || rec.value == null) return;
      rec.refs++;
      this._pools[pool][id] = rec;
      return rec.value;
    }
    /**
     * @param {string} id
     * @param {string} pool
     */

  }, {
    key: "unset",
    value: function unset(id) {
      var pool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';

      this._preparePool(pool);

      var rec = this._pools[pool][id];
      if (!rec || rec.value == null) return;
      rec.refs--;

      if (rec.refs === 0) {
        delete this._pools[pool][id];
      }
    }
    /**
     * @param {string} id
     * @param {string} pool
     * @return {boolean}
     */

  }, {
    key: "has",
    value: function has(id) {
      var pool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';

      this._preparePool(pool);

      return !!this._pools[pool][id];
    }
    /**
     * @param {string} fromId
     * @param {string} toId
     * @param {string} [pool]
     * @returns {boolean}
     */

  }, {
    key: "move",
    value: function move(fromId, toId) {
      var pool = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'default';
      if (!this.has(fromId, pool) || !toId) return false;
      this._pools[pool][toId] = this._pools[pool][fromId];
      delete this._pools[pool][fromId];
      return true;
    }
    /**
     * @param {string} pool
     * @return {string[]}
     */

  }, {
    key: "ids",
    value: function ids() {
      var pool = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'default';

      this._preparePool(pool);

      return Object.keys(this._pools[pool]);
    }
    /**
     * @param {string} id
     * @param {string} pool
     * @return {*}
     */

  }, {
    key: "refs",
    value: function refs(id) {
      var pool = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';

      this._preparePool(pool);

      return this.has(id, pool) ? this._pools[pool][id].refs : undefined;
    }
  }]);

  return IdentityMap;
}();

/* eslint-disable no-console */

var log = makeLog('[VueLayers]');
var warn = makeWarn('[VueLayers] WARN');
var error = makeError('[VueLayers] ERR');
/* eslint-enable no-console */

function encode(val) {
  return JSON.stringify(val);
}
function newLogger() {
  var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return {
    log: makeLog("[VueLayers] ".concat(prefix)),
    warn: makeWarn("[VueLayers] WARN ".concat(prefix)),
    error: makeError("[VueLayers] ERR ".concat(prefix))
  };
}
function makeLog() {
  var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return function () {
    var _console;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (prefix) {
      if (isString(args[0])) {
        args[0] = prefix.trim() + ' ' + args[0];
      } else {
        args = [prefix.trim()].concat(_toConsumableArray(args));
      }
    }

    (_console = console).log.apply(_console, _toConsumableArray(args));
  };
}
function makeWarn() {
  var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return function () {
    var _console2;

    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    if (prefix) {
      if (isString(args[0])) {
        args[0] = prefix.trim() + ' ' + args[0];
      } else {
        args = [prefix.trim()].concat(_toConsumableArray(args));
      }
    }

    (_console2 = console).warn.apply(_console2, _toConsumableArray(args));
  };
}
function makeError() {
  var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return function () {
    var _console3;

    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }

    if (prefix) {
      if (isString(args[0])) {
        args[0] = prefix.trim() + ' ' + args[0];
      } else {
        args = [prefix.trim()].concat(_toConsumableArray(args));
      }
    }

    (_console3 = console).error.apply(_console3, _toConsumableArray(args));
  };
}

function sequential (fn) {
  return /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
    var res,
        _args = arguments;
    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!fn._execPromise) {
              _context.next = 3;
              break;
            }

            _context.next = 3;
            return fn._execPromise;

          case 3:
            fn._execPromise = Promise.resolve(fn.call.apply(fn, [this].concat(Array.prototype.slice.call(_args))));
            _context.next = 6;
            return fn._execPromise;

          case 6:
            res = _context.sent;
            delete fn._execPromise;
            return _context.abrupt("return", res);

          case 9:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));
}

/**
 * @param {...Object} args
 * @returns {Object}
 */

function mergeDescriptors() {
  var redefine;

  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  if (_typeof(args[args.length - 1]) !== 'object') {
    redefine = args.pop();
  }

  return args.slice(1).reduce(function (dest, src, i) {
    return baseMergeDescriptors(dest, src, redefine);
  }, args[0]);
}

/**
 * Constructs watch hash for multiple properties.
 * @param {string[]} props
 * @param {function|Object} watcherFactory
 */
function makeWatchers(props, watcherFactory) {
  return props.reduce(function (hash, prop) {
    hash[prop] = watcherFactory(prop);
    return hash;
  }, {});
}
function extractChildren(slots) {
  var slotNames = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  return Object.keys(slots).reduce(function (all, name) {
    if (!slotNames.length || slotNames.includes(name)) {
      all = all.concat(slots[name]);
    }

    return all;
  }, []);
}

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
var WaitCancelError = /*#__PURE__*/function (_Error) {
  _inherits(WaitCancelError, _Error);

  var _super = _createSuper(WaitCancelError);

  function WaitCancelError(message) {
    var _this;

    _classCallCheck(this, WaitCancelError);

    _this = _super.call(this, message);

    _defineProperty(_assertThisInitialized(_this), "name", 'WaitCancelError');

    if (isFunction(Error.captureStackTrace)) {
      Error.captureStackTrace(_assertThisInitialized(_this), _this.constructor);
    } else {
      _this.stack = new Error(message).stack;
    }

    return _this;
  }

  return WaitCancelError;
}( /*#__PURE__*/_wrapNativeSuper(Error));
var WaitTimeoutError = /*#__PURE__*/function (_Error2) {
  _inherits(WaitTimeoutError, _Error2);

  var _super2 = _createSuper(WaitTimeoutError);

  function WaitTimeoutError(message) {
    var _this2;

    _classCallCheck(this, WaitTimeoutError);

    _this2 = _super2.call(this, message);

    _defineProperty(_assertThisInitialized(_this2), "name", 'WaitTimeoutError');

    if (isFunction(Error.captureStackTrace)) {
      Error.captureStackTrace(_assertThisInitialized(_this2), _this2.constructor);
    } else {
      _this2.stack = new Error(message).stack;
    }

    return _this2;
  }

  return WaitTimeoutError;
}( /*#__PURE__*/_wrapNativeSuper(Error));
/**
 * @param {function|Observable} condition
 * @param {function|Observable} [breakOn]
 * @param {number} [timeout]
 * @returns {Promise<boolean>}
 */

function waitFor(condition, breakOn, timeout$1) {
  var defCond = function defCond(x) {
    return !x;
  };

  var success = interval(1000 / 60).pipe(isFunction(condition) ? skipWhile(negate(condition)) : skipUntil(condition.pipe(skipWhile(defCond))), first());
  var failed = NEVER;

  if (breakOn) {
    failed = interval(1000 / 60).pipe(isFunction(breakOn) ? skipWhile(negate(breakOn)) : skipUntil(breakOn.pipe(skipWhile(defCond))), first(), switchMap(function () {
      return throwError(new WaitCancelError('wait canceled'));
    }));
  }

  var obs = race(success, failed);

  if (timeout$1 > 0) {
    obs = obs.pipe(timeout(timeout$1));
  }

  return obs.pipe(catchError(function (err) {
    if (err.name === 'TimeoutError') {
      err = new WaitTimeoutError('wait timed out');
    }

    throw err;
  })).toPromise();
}

export { AssertionError, IdentityMap, WaitCancelError, WaitTimeoutError, addPrefix, and, assert, camelCase, clonePlainObject, coalesce, constant, difference, encode, error, every, extractChildren, filter, find, firstEl, forEach, freeze, freezeFactory, get, getLength, hasOwnProp, hasProp, identity, includes, instanceOf, isArray, isArrayLike, isBoolean, isCollection, isEmpty, isEqual, isFinite, isFunction, isNumber, isNumeric, isObjectLike, isPlainObject, isString, kebabCase, keys, lastEl, log, lowerFirst, makeError, makeLog, makeWarn, makeWatchers, map, mapKeys, mapValues, mergeDescriptors, negate, newLogger, noop, numeric, omit, or, pick, plainProps, range, rangeIterator, reduce, replaceTokens, round, seal, sealFactory, sequential, serialize, some, stubArray, stubCollection, stubFalse, stubObject, stubTrue, toArray, unserialize, upperFirst, values, waitFor, warn };
//# sourceMappingURL=utils.js.map
