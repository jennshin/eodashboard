/**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.12.0-rc.26
 * @license MIT
 * @copyright (c) 2017-2021, Vladimir Vershinin <ghettovoice@gmail.com>
 */
import { noop, coalesce, pick, isEqual, clonePlainObject, stubObject, mergeDescriptors, assert, isNumber, upperFirst, camelCase, isFunction, instanceOf, constant, round, addPrefix, and, isString, makeWatchers, lowerFirst, isObjectLike, isEmpty, map as map$1, isArray, negate, omit, isPlainObject, identity, stubArray, or, forEach, sealFactory, range } from './utils';
import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';
import { BingMaps, Cluster, Source, Vector, ImageArcGISRest, ImageStatic, ImageWMS, OSM, Stamen, TileArcGISRest, TileWMS, VectorTile as VectorTile$1, WMTS } from 'ol/source';
import { tileImageSource, makeChangeOrRecreateWatchers, stubVNode, sourceContainer, olCmp, vectorSource, interaction, styleContainer, FRAME_TIME, simpleGeometry, feature, projTransforms, waitForMap, style, regShapeStyle, imageStyle, fillStyleContainer, strokeStyleContainer, textStyleContainer, imageStyleContainer, geometryContainer, vectorLayer, layersContainer, baseLayer, arcgisSource, imageSource, imageLayer, wmsSource, controlsContainer, interactionsContainer, overlaysContainer, featuresContainer, xyzSource, source, urlTileSource, tileLayer, featureHelper, tileSource } from './mixins';
import { getSourceId, findPointOnSurface, createPointGeom, roundLineCoords, initializeFeature, writeGeoJsonFeature, COORD_PRECISION, roundPointCoords, isPointCoords, transformDistance, isLineCoords, isMultiLineCoords, isMultiPointCoords, isMultiPolygonCoords, isPolygonCoords, EPSG_3857, normalizeColor, dumpStrokeStyle, dumpFillStyle, dumpTextStyle, dumpImageStyle, getLayerId, roundExtent, initializeView, getViewId, setViewId, isGeoJSONGeometry, getControlId, getInteractionId, getOverlayId, setMapId, setMapDataProjection, getMapId, getMapDataProjection, initializeOverlay, setOverlayId, isGeoJSONFeature, getFeatureId, dumpStyle, createMvtFmt, extentFromProjection, getCorner } from './ol-ext';
import _asyncToGenerator from '@babel/runtime/helpers/esm/asyncToGenerator';
import _regeneratorRuntime from '@babel/runtime/regenerator';
import { Collection, Geolocation, View, Map as Map$1, Overlay as Overlay$1, Feature as Feature$1 } from 'ol';
import { noModifierKeys, shiftKeyOnly, primaryAction, altKeyOnly, always, never, singleClick } from 'ol/events/condition';
import GeometryType from 'ol/geom/GeometryType';
import { Draw, Modify, Select, Snap, Translate } from 'ol/interaction';
import { merge, of } from 'rxjs';
import { map, tap, mergeMap, mapTo, delay, first, distinctUntilKeyChanged, distinctUntilChanged } from 'rxjs/operators';
import { fromOlEvent, fromVueEvent, fromOlChangeEvent, fromVueWatcher, bufferDebounceTime } from './rx-ext';
import { Circle, Point, LineString, MultiLineString, MultiPoint, MultiPolygon, Polygon } from 'ol/geom';
import { get } from 'ol/proj';
import GraticuleLayer$1 from 'ol/layer/Graticule';
import { Fill, Stroke, Circle as Circle$1, Icon, RegularShape, Style as Style$1, Text } from 'ol/style';
import IconAnchorUnits from 'ol/style/IconAnchorUnits';
import IconOrigin from 'ol/style/IconOrigin';
import { Group, Heatmap, Image as Image$1, Vector as Vector$1, VectorTile, MapboxVector, Tile, VectorImage } from 'ol/layer';
import MapBrowserEventType from 'ol/MapBrowserEventType';
import MapEventType from 'ol/MapEventType';
import RenderEventType from 'ol/render/EventType';
import _toConsumableArray from '@babel/runtime/helpers/esm/toConsumableArray';
import RenderType from 'ol/layer/VectorTileRenderType';
import OverlayPositioning from 'ol/OverlayPositioning';
import RotateInteraction$1 from 'ol-rotate-feature';
import VectorEventType from 'ol/source/VectorEventType';
import { createTileUrlFunctionFromTemplates } from 'ol-tilecache';
import TileEventType from 'ol/source/TileEventType';
import { createXYZ } from 'ol/tilegrid';
import { getHeight, getWidth } from 'ol/extent';
import ExtentCorner from 'ol/extent/Corner';
import { toSize } from 'ol/size';
import { DEFAULT_MAX_ZOOM, DEFAULT_TILE_SIZE } from 'ol/tilegrid/common';
import WMTSTileGrid from 'ol/tilegrid/WMTS';

function ownKeys$D(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$D(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$D(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$D(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var script$S = {
  name: 'VlSourceBingmaps',
  mixins: [tileImageSource],
  props: {
    // ol/source/BingMaps

    /**
     * Enables hidpi tiles.
     * @type {boolean}
     */
    hidpi: {
      type: Boolean,
      default: false
    },

    /**
     * Culture code.
     * @type {string}
     */
    culture: {
      type: String,
      default: 'en-us'
    },

    /**
     * Bing Maps API key.
     * @type {string}
     */
    apiKey: {
      type: String,
      required: true
    },

    /**
     * Type of imagery.
     * @type {string}
     */
    imagerySet: {
      type: String,
      required: true
    },

    /**
     * @type {number}
     */
    maxZoom: {
      type: Number,
      default: 21
    }
  },
  computed: {
    tileGridIdent: noop,
    inputTileGridFactory: noop,
    inputUrl: noop,
    inputUrls: noop,
    inputTileUrlFunction: noop,
    inputAttributions: noop
  },
  watch: _objectSpread$D({}, /*#__PURE__*/makeChangeOrRecreateWatchers(['hidpi', 'culture', 'apiKey', 'imagerySet', 'maxZoom'])),
  methods: {
    /**
     * @return {module:ol/source/BingMaps}
     * @protected
     */
    createSource: function createSource() {
      return new BingMaps({
        // ol/source/Source
        wrapX: this.wrapX,
        // ol/source/Tile
        cacheSize: this.cacheSize,
        opaque: this.opaque,
        transition: this.transition,
        // ol/source/UrlTile
        tileLoadFunction: this.currentTileLoadFunction,
        // ol/source/TileImage
        reprojectionErrorThreshold: this.reprojectionErrorThreshold,
        imageSmoothing: this.imageSmoothing,
        // ol/source/BingMaps
        hidpi: this.hidpi,
        culture: this.culture,
        key: this.apiKey,
        imagerySet: this.imagerySet,
        maxZoom: this.maxZoom
      });
    },
    getApiKey: function getApiKey() {
      var _this$$source;

      return coalesce((_this$$source = this.$source) === null || _this$$source === void 0 ? void 0 : _this$$source.getApiKey(), this.apiKey);
    },
    getImagerySet: function getImagerySet() {
      var _this$$source2;

      return coalesce((_this$$source2 = this.$source) === null || _this$$source2 === void 0 ? void 0 : _this$$source2.getImagerySet(), this.imagerySet);
    },
    stateChanged: noop,
    attributionsCollapsibleChanged: noop,
    projectionChanged: noop,
    tileGridIdentChanged: noop,
    inputTileGridFactoryChanged: noop,
    tileGridChanged: noop,
    tileKeyChanged: noop,
    tilePixelRatioChanged: noop,
    zDirectionChanged: noop,
    inputTileUrlFunctionChanged: noop,
    inputUrlsChanged: noop,
    crossOriginChanged: noop,
    tileClassChanged: noop
  }
};

function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {
    if (typeof shadowMode !== 'boolean') {
        createInjectorSSR = createInjector;
        createInjector = shadowMode;
        shadowMode = false;
    }
    // Vue.extend constructor export interop.
    const options = typeof script === 'function' ? script.options : script;
    // render functions
    if (template && template.render) {
        options.render = template.render;
        options.staticRenderFns = template.staticRenderFns;
        options._compiled = true;
        // functional template
        if (isFunctionalTemplate) {
            options.functional = true;
        }
    }
    // scopedId
    if (scopeId) {
        options._scopeId = scopeId;
    }
    let hook;
    if (moduleIdentifier) {
        // server build
        hook = function (context) {
            // 2.3 injection
            context =
                context || // cached call
                    (this.$vnode && this.$vnode.ssrContext) || // stateful
                    (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional
            // 2.2 with runInNewContext: true
            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
                context = __VUE_SSR_CONTEXT__;
            }
            // inject component styles
            if (style) {
                style.call(this, createInjectorSSR(context));
            }
            // register component module identifier for async chunk inference
            if (context && context._registeredComponents) {
                context._registeredComponents.add(moduleIdentifier);
            }
        };
        // used by ssr in case component is cached and beforeCreate
        // never gets called
        options._ssrRegister = hook;
    }
    else if (style) {
        hook = shadowMode
            ? function (context) {
                style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));
            }
            : function (context) {
                style.call(this, createInjector(context));
            };
    }
    if (hook) {
        if (options.functional) {
            // register for functional component in vue file
            const originalRender = options.render;
            options.render = function renderWithStyleInjection(h, context) {
                hook.call(context);
                return originalRender(h, context);
            };
        }
        else {
            // inject component registration as beforeCreate hook
            const existing = options.beforeCreate;
            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];
        }
    }
    return script;
}

/* script */
var __vue_script__$S = script$S;
/* template */

/* style */

var __vue_inject_styles__$S = undefined;
/* scoped */

var __vue_scope_id__$S = undefined;
/* module identifier */

var __vue_module_identifier__$S = undefined;
/* functional template */

var __vue_is_functional_template__$S = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$S = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$S, __vue_script__$S, __vue_scope_id__$S, __vue_is_functional_template__$S, __vue_module_identifier__$S, false, undefined, undefined, undefined);

/**
 * @param {Vue} Vue
 * @param {VueLayersOptions} [options]
 */

function plugin$A(Vue) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$A.installed) {
    return;
  }

  plugin$A.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$S, options);
  Vue.component(__vue_component__$S.name, __vue_component__$S);
}

var BingmapsSource = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$A,
  install: plugin$A,
  Source: __vue_component__$S
});

var script$R = {
  name: 'VlSourceInnerAdapter',
  mixins: [stubVNode, sourceContainer, olCmp],
  stubVNode: {
    empty: false,
    attrs: function attrs() {
      return {
        id: this.vmId,
        class: this.vmClass
      };
    }
  },
  computed: {
    source: function source() {
      if (!(this.rev && this.$source)) return;
      return {
        id: getSourceId(this.$source),
        type: this.$source.constructor.name
      };
    }
  },
  watch: {
    source: {
      deep: true,
      handler: function handler(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit('update:source', value && clonePlainObject(value));
      }
    }
  },
  created: function created() {
    var _this = this;

    Object.defineProperties(this, {
      $innerSourceContainer: {
        enumerable: true,
        get: function get() {
          var _this$$services;

          return (_this$$services = _this.$services) === null || _this$$services === void 0 ? void 0 : _this$$services.innerSourceContainer;
        }
      }
    });
  },
  methods: {
    createOlObject: function createOlObject() {
      var obj = stubObject();
      obj.id = this.currentId;
      return obj;
    },
    getServices: function getServices() {
      return mergeDescriptors(olCmp.methods.getServices.call(this), sourceContainer.methods.getServices.call(this));
    },
    getSourceTarget: function getSourceTarget() {
      var _this2 = this;

      return {
        getSource: function getSource() {
          var _this2$$innerSourceCo;

          return (_this2$$innerSourceCo = _this2.$innerSourceContainer) === null || _this2$$innerSourceCo === void 0 ? void 0 : _this2$$innerSourceCo.getInnerSource();
        },
        setSource: function setSource(source) {
          var _this2$$innerSourceCo2;

          return (_this2$$innerSourceCo2 = _this2.$innerSourceContainer) === null || _this2$$innerSourceCo2 === void 0 ? void 0 : _this2$$innerSourceCo2.setInnerSource(source);
        }
      };
    }
  }
};

/* script */
var __vue_script__$R = script$R;
/* template */

/* style */

var __vue_inject_styles__$R = undefined;
/* scoped */

var __vue_scope_id__$R = undefined;
/* module identifier */

var __vue_module_identifier__$R = undefined;
/* functional template */

var __vue_is_functional_template__$R = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$R = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$R, __vue_script__$R, __vue_scope_id__$R, __vue_is_functional_template__$R, __vue_module_identifier__$R, false, undefined, undefined, undefined);

function ownKeys$C(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$C(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$C(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$C(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var script$Q = {
  name: 'VlSourceCluster',
  components: {
    InnerSource: __vue_component__$R
  },
  mixins: [vectorSource],
  props: {
    distance: {
      type: Number,
      default: 20
    },
    geometryFunction: {
      type: Function // default: defaultGeomFunc,

    },

    /**
     * @deprecated
     * @todo remove later
     */
    geomFunc: Function,

    /**
     * @deprecated Use geomFunc prop instead.
     * @todo remove in v0.13.x
     */
    geomFuncFactory: Function
  },
  data: function data() {
    return {
      currentDistance: this.distance
    };
  },
  computed: {
    inputGeometryFunction: function inputGeometryFunction() {
      var geomFunc = this.geometryFunction || this.geomFunc;

      if (!geomFunc && this.geomFuncFactory) {
        geomFunc = this.geomFuncFactory();
      }

      return geomFunc || defaultGeomFunc;
    },
    innerSource: function innerSource() {
      if (!(this.rev && this.$innerSource)) return;
      return {
        id: getSourceId(this.$innerSource),
        type: this.$innerSource.constructor.name
      };
    },
    inputUrl: noop,
    inputLoader: noop,
    inputLoadingStrategy: noop,
    formatIdent: noop,
    inputFormatFactory: noop
  },
  watch: _objectSpread$C({
    rev: function rev() {
      if (!this.$source) return;

      if (this.currentDistance !== this.$source.getDistance()) {
        this.currentDistance = this.$source.getDistance();
      }
    },
    distance: function distance(value) {
      this.setDistance(value);
    },
    currentDistance: function currentDistance(value) {
      if (value === this.distance) return;
      this.$emit('update:distance', value);
    },
    innerSource: {
      deep: true,
      handler: function handler(value, prev) {
        if (value === prev) return;
        this.$emit('update:innerSource', value && clonePlainObject(value));
      }
    }
  }, /*#__PURE__*/makeChangeOrRecreateWatchers(['inputGeometryFunction'])),
  created: function created() {
    if (process.env.NODE_ENV !== 'production') {
      if (this.geomFuncFactory) {
        this.$logger.warn("'geomFuncFactory' prop is deprecated. Use 'geometryFunction' prop instead.");
      }

      if (this.geomFunc) {
        this.$logger.warn("'geomFunc' prop is deprecated. Use 'geometryFunction' prop instead.");
      }
    }

    this._innerSource = undefined;
    this._innerSourceVm = undefined;
    defineServices$9.call(this);
  },
  updated: function updated() {
    if (process.env.NODE_ENV !== 'production') {
      if (this.geomFuncFactory) {
        this.$logger.warn("'geomFuncFactory' prop is deprecated. Use 'geometryFunction' prop instead.");
      }

      if (this.geomFunc) {
        this.$logger.warn("'geomFunc' prop is deprecated. Use 'geometryFunction' prop instead.");
      }
    }
  },
  methods: {
    createSource: function createSource() {
      return new Cluster({
        // ol/source/Source
        attributions: this.currentAttributions,
        wrapX: this.wrapX,
        // ol/source/Cluster
        source: this.$innerSource,
        distance: this.currentDistance,
        geometryFunction: this.inputGeometryFunction
      });
    },
    getServices: function getServices() {
      var vm = this;
      return mergeDescriptors(vectorSource.methods.getServices.call(this), {
        get innerSourceContainer() {
          return vm;
        }

      });
    },
    getDistance: function getDistance() {
      var _this$$source;

      return coalesce((_this$$source = this.$source) === null || _this$$source === void 0 ? void 0 : _this$$source.getDistance(), this.currentDistance);
    },
    setDistance: function setDistance(distance) {
      assert(isNumber(distance), 'Invalid distance');

      if (distance !== this.currentDistance) {
        this.currentDistance = distance;
      }

      if (this.$source && distance !== this.$source.getDistance()) {
        this.$source.setDistance(distance);
      }
    },
    getInnerSource: function getInnerSource() {
      return this._innerSource;
    },
    getInnerSourceVm: function getInnerSourceVm() {
      return this._innerSourceVm;
    },
    setInnerSource: function setInnerSource(innerSource) {
      var _innerSource;

      innerSource = ((_innerSource = innerSource) === null || _innerSource === void 0 ? void 0 : _innerSource.$source) || innerSource;
      assert(!innerSource || innerSource instanceof Source);
      innerSource || (innerSource = undefined);

      if (innerSource !== this._innerSource) {
        var _innerSource2;

        this._innerSource = innerSource;
        this._innerSourceVm = ((_innerSource2 = innerSource) === null || _innerSource2 === void 0 ? void 0 : _innerSource2.vm) && innerSource.vm[0];
        this.scheduleRefresh();
      }

      if (this.$source && innerSource !== this.$source.getSource()) {
        this.$source.setSource(innerSource);
        this.scheduleRefresh();
      }
    },
    projectionChanged: noop,
    inputUrlChanged: noop,
    inputLoaderChanged: noop,
    inputLoadingStrategyChanged: noop,
    inputFormatFactoryChanged: noop,
    formatIdentChanged: noop,
    formatChanged: noop,
    overlapsChanged: noop,
    useSpatialIndexChanged: noop
  }
};

function defineServices$9() {
  Object.defineProperties(this, {
    $innerSource: {
      enumerable: true,
      get: this.getInnerSource
    },
    $innerSourceVm: {
      enumerable: true,
      get: this.getInnerSourceVm
    }
  });
}

function defaultGeomFunc(feature) {
  var geometry = feature.getGeometry();
  if (!geometry) return;
  var coordinate = findPointOnSurface(geometry);

  if (coordinate) {
    return createPointGeom(coordinate);
  }
}

/* script */
var __vue_script__$Q = script$Q;
/* template */

var __vue_render__$a = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('i', {
    class: _vm.vmClass,
    staticStyle: {
      "display": "none !important"
    },
    attrs: {
      "id": _vm.vmId
    }
  }, [_c('InnerSource', {
    attrs: {
      "id": 'vl-' + _vm.currentId + '-inner-source'
    }
  }, [_vm._t("default")], 2)], 1);
};

var __vue_staticRenderFns__$a = [];
/* style */

var __vue_inject_styles__$Q = undefined;
/* scoped */

var __vue_scope_id__$Q = undefined;
/* module identifier */

var __vue_module_identifier__$Q = undefined;
/* functional template */

var __vue_is_functional_template__$Q = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$Q = /*#__PURE__*/normalizeComponent({
  render: __vue_render__$a,
  staticRenderFns: __vue_staticRenderFns__$a
}, __vue_inject_styles__$Q, __vue_script__$Q, __vue_scope_id__$Q, __vue_is_functional_template__$Q, __vue_module_identifier__$Q, false, undefined, undefined, undefined);

function plugin$z(Vue) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$z.installed) {
    return;
  }

  plugin$z.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$Q, options);
  Vue.component(__vue_component__$Q.name, __vue_component__$Q);
}

var ClusterSource = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$z,
  install: plugin$z,
  Source: __vue_component__$Q
});

function ownKeys$B(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$B(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$B(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$B(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var transformType = /*#__PURE__*/function transformType(type) {
  return upperFirst(camelCase(type));
};

var script$P = {
  name: 'VlInteractionDraw',
  mixins: [interaction, styleContainer],
  stubVNode: {
    empty: false,
    attrs: function attrs() {
      return {
        id: this.vmId,
        class: this.vmClass
      };
    }
  },
  props: {
    /**
     * Target source or collection identifier from IdentityMap.
     * @type {String}
     */
    source: {
      type: String,
      required: true
    },

    /**
     * The maximum distance in pixels between "down" and "up" for a "up" event to be considered a "click" event and
     * actually add a point/vertex to the geometry being drawn. Default is 6 pixels. That value was chosen for the
     * draw interaction to behave correctly on mouse as well as on touch devices.
     * @type {number}
     */
    clickTolerance: {
      type: Number,
      default: 6
    },

    /**
     * Pixel distance for snapping to the drawing finish.
     * @type {number}
     */
    snapTolerance: {
      type: Number,
      default: 12
    },

    /**
     * Drawing type ('Point', 'LineString', 'Polygon', 'MultiPoint', 'MultiLineString', 'MultiPolygon' or 'Circle').
     * @type {string}
     */
    type: {
      type: String,
      required: true,
      validator: function validator(value) {
        return Object.values(GeometryType).includes(transformType(value));
      }
    },

    /**
     * Stop click, singleclick, and doubleclick events from firing during drawing.
     * @type {boolean}
     */
    stopClick: {
      type: Boolean,
      default: false
    },

    /**
     * The number of points that can be drawn before a polygon ring or line string is finished.
     * @type {number|undefined}
     */
    maxPoints: Number,

    /**
     * The number of points that must be drawn before a polygon ring or line string can be finished.
     * Default is `3` for polygon rings and `2` for line strings.
     * @type {number|undefined}
     */
    minPoints: Number,

    /**
     * A function that takes an ol.MapBrowserEvent and returns a boolean to indicate whether the drawing can be finished.
     * @type {function|undefined}
     */
    finishCondition: Function,

    /**
     * Function that is called when a geometry's coordinates are updated.
     * @type {function|undefined}
     */
    geometryFunction: Function,

    /**
     * Name of the geometry attribute for newly created features.
     * @type {string}
     */
    geometryName: {
      type: String,
      default: 'geometry'
    },

    /**
     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.
     * By default `ol.events.condition.noModifierKeys`, i.e. a click, adds a vertex or deactivates freehand drawing.
     * @type {function|undefined}
     */
    condition: {
      type: Function,
      default: noModifierKeys
    },

    /**
     * Operate in freehand mode for lines, polygons, and circles. This makes the interaction always operate in
     * freehand mode and takes precedence over any `freehandCondition` option.
     * @type {boolean}
     */
    freehand: {
      type: Boolean,
      default: false
    },

    /**
     * Condition that activates freehand drawing for lines and polygons. This function takes an `ol.MapBrowserEvent` and
     * returns a boolean to indicate whether that event should be handled. The default is `ol.events.condition.shiftKeyOnly`,
     * meaning that the Shift key activates freehand drawing.
     * @type {function|undefined}
     */
    freehandCondition: {
      type: Function,
      default: shiftKeyOnly
    },

    /**
     * Wrap the world horizontally on the sketch overlay.
     * @type {boolean}
     */
    wrapX: {
      type: Boolean,
      default: false
    },

    /**
     * Delay in milliseconds after pointerdown before the current vertex can be dragged to its exact position.
     * @type {number}
     */
    dragVertexDelay: {
      type: Number,
      default: 500
    }
  },
  computed: {
    inputType: function inputType() {
      return transformType(this.type);
    }
  },
  watch: _objectSpread$B({}, /*#__PURE__*/makeChangeOrRecreateWatchers(['source', 'clickTolerance', 'snapTolerance', 'inputType', 'stopClick', 'maxPoints', 'minPoints', 'finishCondition', 'geometryFunction', 'geometryName', 'condition', 'freehand', 'freehandCondition', 'wrapX', 'dragVertexDelay'])),
  methods: {
    /**
     * @return {Promise<Draw>}
     * @protected
     */
    createInteraction: function createInteraction() {
      var _this = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var source, features;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _this.getInstance(_this.source);

              case 2:
                source = _this._source = _context.sent;
                assert(!!source, "Source \"".concat(_this.source, "\" not found in identity map."));

                if (!(source instanceof Vector)) {
                  if (isFunction(source.getFeaturesCollection)) {
                    features = source.getFeaturesCollection();
                  } else if (isFunction(source.getFeatures)) {
                    features = source.getFeatures();
                  }

                  instanceOf(features, Collection, "Source \"".concat(_this.source, "\" doesn't provide features collection."));
                  source = null;
                }

                return _context.abrupt("return", new Draw({
                  source: source,
                  features: features,
                  clickTolerance: _this.clickTolerance,
                  snapTolerance: _this.snapTolerance,
                  type: _this.inputType,
                  stopClick: _this.stopClick,
                  maxPoints: _this.maxPoints,
                  minPoints: _this.minPoints,
                  finishCondition: _this.finishCondition,
                  geometryFunction: _this.geometryFunction,
                  geometryName: _this.geometryName,
                  condition: _this.condition,
                  freehand: _this.freehand,
                  freehandCondition: _this.freehandCondition,
                  wrapX: _this.wrapX,
                  dragVertexDelay: _this.dragVertexDelay,
                  style: _this.$style
                }));

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    },

    /**
     * @returns {Object}
     * @protected
     */
    getServices: function getServices() {
      return mergeDescriptors(interaction.methods.getServices.call(this), styleContainer.methods.getServices.call(this));
    },

    /**
     * @return {void}
     * @protected
     */
    subscribeAll: function subscribeAll() {
      interaction.methods.subscribeAll.call(this);
      subscribeToInteractionChanges$4.call(this);
    },

    /**
     * @return {StyleTarget}
     * @protected
     */
    getStyleTarget: function getStyleTarget() {
      var _this2 = this;

      return {
        getStyle: function getStyle() {
          return _this2._style;
        },
        setStyle: function setStyle() {
          if (process.env.VUELAYERS_DEBUG) {
            _this2.$logger.log('style changed, scheduling recreate...');
          }

          _this2.scheduleRecreate();
        }
      };
    },
    getOverlay: function getOverlay() {
      var _this3 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return _this3.resolveInteraction();

              case 2:
                return _context2.abrupt("return", _context2.sent.getOverlay());

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }))();
    },
    abortDrawing: function abortDrawing() {
      var _this4 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return _this4.resolveInteraction();

              case 2:
                _context3.sent.abortDrawing();

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }))();
    },
    finishDrawing: function finishDrawing() {
      var _this5 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return _this5.resolveInteraction();

              case 2:
                _context4.sent.finishDrawing();

              case 3:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }))();
    },
    appendCoordinates: function appendCoordinates(coordinates) {
      var _arguments = arguments,
          _this6 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {
        var viewProj;
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                viewProj = _arguments.length > 1 && _arguments[1] !== undefined ? _arguments[1] : false;
                coordinates = viewProj ? roundLineCoords(coordinates) : _this6.lineToViewProj(coordinates);
                _context5.next = 4;
                return _this6.resolveInteraction();

              case 4:
                _context5.sent.appendCoordinates(coordinates);

              case 5:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5);
      }))();
    },
    removeLastPoint: function removeLastPoint() {
      var _this7 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {
        return _regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return _this7.resolveInteraction();

              case 2:
                _context6.sent.removeLastPoint();

              case 3:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6);
      }))();
    },
    getPointerCount: function getPointerCount() {
      var _this8 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {
        return _regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return _this8.resolveInteraction();

              case 2:
                return _context7.abrupt("return", _context7.sent.getPointerCount());

              case 3:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7);
      }))();
    }
  }
};
/**
 * @return {void}
 * @private
 */

function subscribeToInteractionChanges$4() {
  var _this9 = this;

  var start = fromOlEvent(this.$interaction, 'drawstart').pipe(map(function (evt) {
    return _objectSpread$B(_objectSpread$B({}, evt), {}, {
      feature: initializeFeature(evt.feature)
    });
  }), tap(function () {
    return _this9.setInteracting(true);
  }));

  var sourceUpdObs = function sourceUpdObs() {
    var _this9$_source, _this9$_source$vm;

    if (!((_this9$_source = _this9._source) !== null && _this9$_source !== void 0 && (_this9$_source$vm = _this9$_source.vm) !== null && _this9$_source$vm !== void 0 && _this9$_source$vm.length)) {
      return of(true).pipe(delay(3 * FRAME_TIME));
    } // update:features on the source (which is feature-container)
    // will be always after drawend with delay ~= computed property update time + FRAME_TIME
    // so we can safely just wait first event


    return fromVueEvent(_this9._source.vm[0], 'update:features').pipe(first());
  };

  var end = fromOlEvent(this.$interaction, 'drawend').pipe(mergeMap(function (evt) {
    return sourceUpdObs().pipe(mapTo(evt));
  }), tap(function () {
    return _this9.setInteracting(false);
  }));
  var events = merge(start, end).pipe(map(function (_ref) {
    var type = _ref.type,
        feature = _ref.feature;
    var viewProj = _this9.resolvedViewProjection;
    var dataProj = _this9.resolvedDataProjection;
    return {
      type: type,
      feature: feature,

      get json() {
        if (!this._json) {
          this._json = writeGeoJsonFeature(this.feature, viewProj, dataProj, COORD_PRECISION);
        }

        return this._json;
      }

    };
  }));
  this.subscribeTo(events, function (evt) {
    return _this9.$emit(evt.type, evt);
  });
}

/* script */
var __vue_script__$P = script$P;
/* template */

/* style */

var __vue_inject_styles__$P = undefined;
/* scoped */

var __vue_scope_id__$P = undefined;
/* module identifier */

var __vue_module_identifier__$P = undefined;
/* functional template */

var __vue_is_functional_template__$P = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$P = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$P, __vue_script__$P, __vue_scope_id__$P, __vue_is_functional_template__$P, __vue_module_identifier__$P, false, undefined, undefined, undefined);

function plugin$y(Vue) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$y.installed) {
    return;
  }

  plugin$y.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$P, options);
  Vue.component(__vue_component__$P.name, __vue_component__$P);
}

var DrawInteraction = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$y,
  install: plugin$y,
  Interaction: __vue_component__$P
});

function ownKeys$A(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$A(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$A(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$A(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var script$O = {
  name: 'VlGeomCircle',
  mixins: [simpleGeometry],
  props: {
    /* eslint-disable vue/require-prop-types */
    coordinates: _objectSpread$A(_objectSpread$A({}, simpleGeometry.props.coordinates), {}, {
      validator: isPointCoords
    }),

    /* eslint-enable vue/require-prop-types */

    /**
     * Circle radius always in meters.
     * @type {number}
     */
    radius: {
      type: Number,
      default: 0
    },

    /**
     * Projection in which radius provided.
     * Default: map data projection
     * @type {string}
     */
    radiusProjection: {
      type: String,
      validator: function validator(value) {
        return !!get(value);
      }
    }
  },
  data: function data() {
    return {
      currentRadiusViewProj: this.radius
    };
  },
  computed: {
    type: /*#__PURE__*/constant(GeometryType.CIRCLE),
    resolvedRadiusProjection: function resolvedRadiusProjection() {
      return this.radiusProjection || this.resolvedDataProjection;
    },
    radiusDataProj: function radiusDataProj() {
      return round(this.radius);
    },
    radiusViewProj: function radiusViewProj() {
      return this.radiusToViewProj(this.radius, this.coordinatesDataProj);
    },
    currentRadiusDataProj: function currentRadiusDataProj() {
      return this.radiusToDataProj(this.currentRadiusViewProj);
    }
  },
  watch: {
    radiusViewProj: function radiusViewProj(value) {
      this.setRadius(value, true);
    },
    currentRadiusDataProj: function currentRadiusDataProj(value) {
      if (value === this.radiusDataProj) return;
      this.$emit('update:radius', value);
    }
  },
  created: function created() {
    this.currentRadiusViewProj = this.radiusViewProj;
  },
  methods: {
    /**
     * @return {Circle}
     * @protected
     */
    createGeometry: function createGeometry() {
      return new Circle(this.currentCoordinatesViewProj, this.currentRadiusViewProj);
    },

    /**
     * @param {boolean} [viewProj=false]
     * @return {number[]}
     */
    getCoordinates: function getCoordinates() {
      var viewProj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      return this.getCenter(viewProj);
    },

    /**
     * @param {number[]} coordinate
     * @param {boolean} [viewProj=false]
     */
    setCoordinates: function setCoordinates(coordinate) {
      var viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      this.setCenter(coordinate, viewProj);
    },

    /**
     * @param {boolean} [viewProj=false]
     * @return {number[]}
     */
    getCenter: function getCenter() {
      var _this$$geometry;

      var viewProj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var center = coalesce((_this$$geometry = this.$geometry) === null || _this$$geometry === void 0 ? void 0 : _this$$geometry.getCenter(), this.currentCoordinatesViewProj);
      return viewProj ? roundPointCoords(center) : this.pointToDataProj(center);
    },

    /**
     * @param {number[]} center
     * @param {boolean} [viewProj=false]
     */
    setCenter: function setCenter(center) {
      var viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      assert(isPointCoords(center), 'Invalid center');
      center = viewProj ? roundPointCoords(center) : this.pointToViewProj(center);

      if (!isEqual(center, this.currentCoordinatesViewProj)) {
        this.currentCoordinatesViewProj = center;
      }

      if (this.$geometry && !isEqual(center, this.$geometry.getCenter())) {
        this.$geometry.setCenter(center);
      }
    },

    /**
     * @param {boolean} [viewProj=false]
     * @return {number}
     */
    getRadius: function getRadius() {
      var _this$$geometry2;

      var viewProj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var radius = coalesce((_this$$geometry2 = this.$geometry) === null || _this$$geometry2 === void 0 ? void 0 : _this$$geometry2.getRadius(), this.currentRadiusViewProj);
      return viewProj ? round(radius) : this.radiusToDataProj(radius);
    },

    /**
     * @param {number} radius
     * @param {boolean} [viewProj=false]
     */
    setRadius: function setRadius(radius) {
      var viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      assert(isNumber(radius), 'Invalid radius');
      radius = viewProj ? round(radius) : this.radiusToDataProj(radius);

      if (radius !== this.currentRadiusViewProj) {
        this.currentRadiusViewProj = radius;
      }

      if (this.$geometry && radius !== this.$geometry.getRadius()) {
        this.$geometry.setRadius(radius);
      }
    },

    /**
     * @param {number[]} center
     * @param {number} radius
     * @param {boolean} [viewProj=false]
     * @return {Promise<void>}
     */
    setCenterAndRadius: function setCenterAndRadius(center, radius) {
      var viewProj = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      center = viewProj ? roundPointCoords(center) : this.pointToViewProj(center);
      radius = viewProj ? round(radius) : this.radiusToViewProj(radius);

      if (this.$geometry) {
        this.$geometry.setCenterAndRadius(center, radius);
      } else {
        this.setCenter(center, true);
        this.setRadius(radius, true);
      }
    },

    /**
     * @param {number} radius
     * @return {undefined|number}
     * @protected
     */
    radiusToViewProj: function radiusToViewProj(radius) {
      return transformDistance(radius, this.resolvedRadiusProjection, this.resolvedViewProjection);
    },

    /**
     * @param {number} radius
     * @return {undefined|number}
     * @protected
     */
    radiusToDataProj: function radiusToDataProj(radius) {
      return transformDistance(radius, this.resolvedViewProjection, this.resolvedRadiusProjection);
    }
  }
};

/* script */
var __vue_script__$O = script$O;
/* template */

/* style */

var __vue_inject_styles__$O = undefined;
/* scoped */

var __vue_scope_id__$O = undefined;
/* module identifier */

var __vue_module_identifier__$O = undefined;
/* functional template */

var __vue_is_functional_template__$O = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$O = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$O, __vue_script__$O, __vue_scope_id__$O, __vue_is_functional_template__$O, __vue_module_identifier__$O, false, undefined, undefined, undefined);

function ownKeys$z(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$z(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$z(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$z(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var script$N = {
  name: 'VlGeomPoint',
  mixins: [simpleGeometry],
  props: {
    /* eslint-disable vue/require-prop-types */
    coordinates: _objectSpread$z(_objectSpread$z({}, simpleGeometry.props.coordinates), {}, {
      validator: isPointCoords
    })
    /* eslint-enable vue/require-prop-types */

  },
  computed: {
    type: /*#__PURE__*/constant(GeometryType.POINT)
  },
  methods: {
    /**
     * @return {Point}
     * @protected
     */
    createGeometry: function createGeometry() {
      return new Point(this.currentCoordinatesViewProj);
    },

    /**
     * @param {number[]} coordinates
     * @param {boolean} [viewProj=false]
     */
    setCoordinates: function setCoordinates(coordinates) {
      var viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      assert(isPointCoords(coordinates), 'Invalid coordinates');
      simpleGeometry.methods.setCoordinates.call(this, coordinates, viewProj);
    }
  }
};

/* script */
var __vue_script__$N = script$N;
/* template */

/* style */

var __vue_inject_styles__$N = undefined;
/* scoped */

var __vue_scope_id__$N = undefined;
/* module identifier */

var __vue_module_identifier__$N = undefined;
/* functional template */

var __vue_is_functional_template__$N = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$N = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$N, __vue_script__$N, __vue_scope_id__$N, __vue_is_functional_template__$N, __vue_module_identifier__$N, false, undefined, undefined, undefined);

//
/**
 * A vector object for geographic features with a geometry and other attribute properties,
 * similar to the features in vector file formats like **GeoJSON**.
 */

var script$M = {
  name: 'VlFeature',
  components: {
    PointGeom: __vue_component__$N
  },
  mixins: [feature]
};

/* script */
var __vue_script__$M = script$M;
/* template */

var __vue_render__$9 = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('i', {
    class: _vm.vmClass,
    staticStyle: {
      "display": "none !important"
    },
    attrs: {
      "id": _vm.vmId
    }
  }, [_vm._t("default", [_c('PointGeom', {
    attrs: {
      "id": 'vl-' + _vm.currentId + '-default-geom',
      "coordinates": [0, 0]
    }
  })], {
    "id": _vm.currentId,
    "properties": _vm.currentProperties
  })], 2);
};

var __vue_staticRenderFns__$9 = [];
/* style */

var __vue_inject_styles__$M = undefined;
/* scoped */

var __vue_scope_id__$M = undefined;
/* module identifier */

var __vue_module_identifier__$M = undefined;
/* functional template */

var __vue_is_functional_template__$M = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$M = /*#__PURE__*/normalizeComponent({
  render: __vue_render__$9,
  staticRenderFns: __vue_staticRenderFns__$9
}, __vue_inject_styles__$M, __vue_script__$M, __vue_scope_id__$M, __vue_is_functional_template__$M, __vue_module_identifier__$M, false, undefined, undefined, undefined);

function ownKeys$y(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$y(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$y(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$y(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var script$L = {
  name: 'VlGeomLineString',
  mixins: [simpleGeometry],
  props: {
    /* eslint-disable vue/require-prop-types */
    coordinates: _objectSpread$y(_objectSpread$y({}, simpleGeometry.props.coordinates), {}, {
      validator: isLineCoords
    })
    /* eslint-enable vue/require-prop-types */

  },
  computed: {
    type: /*#__PURE__*/constant(GeometryType.LINE_STRING)
  },
  methods: {
    /**
     * @returns {LineString}
     * @protected
     */
    createGeometry: function createGeometry() {
      return new LineString(this.currentCoordinatesViewProj);
    },

    /**
     * @param {number[]} coordinates
     * @param {boolean} [viewProj=false]
     */
    setCoordinates: function setCoordinates(coordinates) {
      var viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      assert(isLineCoords(coordinates), 'Invalid coordinates');
      simpleGeometry.methods.setCoordinates.call(this, coordinates, viewProj);
    }
  }
};

/* script */
var __vue_script__$L = script$L;
/* template */

/* style */

var __vue_inject_styles__$L = undefined;
/* scoped */

var __vue_scope_id__$L = undefined;
/* module identifier */

var __vue_module_identifier__$L = undefined;
/* functional template */

var __vue_is_functional_template__$L = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$L = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$L, __vue_script__$L, __vue_scope_id__$L, __vue_is_functional_template__$L, __vue_module_identifier__$L, false, undefined, undefined, undefined);

function ownKeys$x(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$x(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$x(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$x(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var script$K = {
  name: 'VlGeomMultiLineString',
  mixins: [simpleGeometry],
  props: {
    /* eslint-disable vue/require-prop-types */
    coordinates: _objectSpread$x(_objectSpread$x({}, simpleGeometry.props.coordinates), {}, {
      validator: isMultiLineCoords
    })
    /* eslint-enable vue/require-prop-types */

  },
  computed: {
    type: /*#__PURE__*/constant(GeometryType.MULTI_LINE_STRING)
  },
  methods: {
    /**
     * @returns {MultiLineString}
     * @protected
     */
    createGeometry: function createGeometry() {
      return new MultiLineString(this.currentCoordinatesViewProj);
    },

    /**
     * @param {number[]} coordinates
     * @param {boolean} [viewProj=false]
     */
    setCoordinates: function setCoordinates(coordinates) {
      var viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      assert(isMultiLineCoords(coordinates), 'Invalid coordinates');
      simpleGeometry.methods.setCoordinates.call(this, coordinates, viewProj);
    }
  }
};

/* script */
var __vue_script__$K = script$K;
/* template */

/* style */

var __vue_inject_styles__$K = undefined;
/* scoped */

var __vue_scope_id__$K = undefined;
/* module identifier */

var __vue_module_identifier__$K = undefined;
/* functional template */

var __vue_is_functional_template__$K = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$K = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$K, __vue_script__$K, __vue_scope_id__$K, __vue_is_functional_template__$K, __vue_module_identifier__$K, false, undefined, undefined, undefined);

function ownKeys$w(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$w(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$w(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$w(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var script$J = {
  name: 'VlGeomMultiPoint',
  mixins: [simpleGeometry],
  props: {
    /* eslint-disable vue/require-prop-types */
    coordinates: _objectSpread$w(_objectSpread$w({}, simpleGeometry.props.coordinates), {}, {
      validator: isMultiPointCoords
    })
    /* eslint-enable vue/require-prop-types */

  },
  computed: {
    type: /*#__PURE__*/constant(GeometryType.MULTI_POINT)
  },
  methods: {
    /**
     * @returns {MultiPoint}
     * @protected
     */
    createGeometry: function createGeometry() {
      return new MultiPoint(this.currentCoordinatesViewProj);
    },

    /**
     * @param {number[]} coordinates
     * @param {boolean} [viewProj=false]
     */
    setCoordinates: function setCoordinates(coordinates) {
      var viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      assert(isMultiPointCoords(coordinates), 'Invalid coordinates');
      simpleGeometry.methods.setCoordinates.call(this, coordinates, viewProj);
    }
  }
};

/* script */
var __vue_script__$J = script$J;
/* template */

/* style */

var __vue_inject_styles__$J = undefined;
/* scoped */

var __vue_scope_id__$J = undefined;
/* module identifier */

var __vue_module_identifier__$J = undefined;
/* functional template */

var __vue_is_functional_template__$J = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$J = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$J, __vue_script__$J, __vue_scope_id__$J, __vue_is_functional_template__$J, __vue_module_identifier__$J, false, undefined, undefined, undefined);

function ownKeys$v(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$v(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$v(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$v(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var script$I = {
  name: 'VlGeomMultiPolygon',
  mixins: [simpleGeometry],
  props: {
    /* eslint-disable vue/require-prop-types */
    coordinates: _objectSpread$v(_objectSpread$v({}, simpleGeometry.props.coordinates), {}, {
      validator: isMultiPolygonCoords
    })
    /* eslint-enable vue/require-prop-types */

  },
  computed: {
    type: /*#__PURE__*/constant(GeometryType.MULTI_POLYGON)
  },
  methods: {
    /**
     * @returns {MultiPolygon}
     * @protected
     */
    createGeometry: function createGeometry() {
      return new MultiPolygon(this.currentCoordinatesViewProj);
    },

    /**
     * @param {number[]} coordinates
     * @param {boolean} [viewProj=false]
     */
    setCoordinates: function setCoordinates(coordinates) {
      var viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      assert(isMultiPolygonCoords(coordinates), 'Invalid coordinates');
      simpleGeometry.methods.setCoordinates.call(this, coordinates, viewProj);
    }
  }
};

/* script */
var __vue_script__$I = script$I;
/* template */

/* style */

var __vue_inject_styles__$I = undefined;
/* scoped */

var __vue_scope_id__$I = undefined;
/* module identifier */

var __vue_module_identifier__$I = undefined;
/* functional template */

var __vue_is_functional_template__$I = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$I = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$I, __vue_script__$I, __vue_scope_id__$I, __vue_is_functional_template__$I, __vue_module_identifier__$I, false, undefined, undefined, undefined);

function ownKeys$u(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$u(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$u(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$u(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var script$H = {
  name: 'VlGeomPolygon',
  mixins: [simpleGeometry],
  props: {
    /* eslint-disable vue/require-prop-types */
    coordinates: _objectSpread$u(_objectSpread$u({}, simpleGeometry.props.coordinates), {}, {
      validator: isPolygonCoords
    })
    /* eslint-enable vue/require-prop-types */

  },
  computed: {
    type: /*#__PURE__*/constant(GeometryType.POLYGON)
  },
  methods: {
    /**
     * @returns {Polygon}
     * @protected
     */
    createGeometry: function createGeometry() {
      return new Polygon(this.currentCoordinatesViewProj);
    },

    /**
     * @param {number[]} coordinates
     * @param {boolean} [viewProj=false]
     */
    setCoordinates: function setCoordinates(coordinates) {
      var viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      assert(isPolygonCoords(coordinates), 'Invalid coordinates');
      simpleGeometry.methods.setCoordinates.call(this, coordinates, viewProj);
    }
  }
};

/* script */
var __vue_script__$H = script$H;
/* template */

/* style */

var __vue_inject_styles__$H = undefined;
/* scoped */

var __vue_scope_id__$H = undefined;
/* module identifier */

var __vue_module_identifier__$H = undefined;
/* functional template */

var __vue_is_functional_template__$H = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$H = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$H, __vue_script__$H, __vue_scope_id__$H, __vue_is_functional_template__$H, __vue_module_identifier__$H, false, undefined, undefined, undefined);

function plugin$x(Vue) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$x.installed) {
    return;
  }

  plugin$x.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$M, options);
  Object.assign(__vue_component__$O, options);
  Object.assign(__vue_component__$N, options);
  Object.assign(__vue_component__$L, options);
  Object.assign(__vue_component__$H, options);
  Object.assign(__vue_component__$J, options);
  Object.assign(__vue_component__$K, options);
  Object.assign(__vue_component__$I, options);
  Vue.component(__vue_component__$M.name, __vue_component__$M);
  Vue.component(__vue_component__$O.name, __vue_component__$O);
  Vue.component(__vue_component__$N.name, __vue_component__$N);
  Vue.component(__vue_component__$L.name, __vue_component__$L);
  Vue.component(__vue_component__$H.name, __vue_component__$H);
  Vue.component(__vue_component__$J.name, __vue_component__$J);
  Vue.component(__vue_component__$K.name, __vue_component__$K);
  Vue.component(__vue_component__$I.name, __vue_component__$I);
}

var Feature = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$x,
  install: plugin$x,
  Feature: __vue_component__$M,
  CircleGeom: __vue_component__$O,
  PointGeom: __vue_component__$N,
  LineStringGeom: __vue_component__$L,
  PolygonGeom: __vue_component__$H,
  MultiPointGeom: __vue_component__$J,
  MultiLineStringGeom: __vue_component__$K,
  MultiPolygonGeom: __vue_component__$I
});

function ownKeys$t(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$t(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$t(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$t(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var validateProjection = /*#__PURE__*/and(isString, function (value) {
  return get(value) != null;
});
var script$G = {
  name: 'VlGeoloc',
  mixins: [projTransforms, olCmp, waitForMap],
  stubVNode: {
    empty: function empty() {
      return this.vmId;
    }
  },
  props: {
    tracking: {
      type: Boolean,
      default: true
    },
    trackingOptions: Object,
    projection: {
      type: String,
      validator: validateProjection
    }
  },
  data: function data() {
    return {
      viewProjection: EPSG_3857,
      dataProjection: EPSG_3857,
      currentTracking: this.tracking,
      currentTrackingOptions: this.trackingOptions && clonePlainObject(this.trackingOptions),
      currentProjection: this.projection
    };
  },
  computed: {
    resolvedDataProjection: function resolvedDataProjection() {
      var _this$$options;

      return coalesce(this.currentProjection, (_this$$options = this.$options) === null || _this$$options === void 0 ? void 0 : _this$$options.dataProjection, this.dataProjection, this.resolvedViewProjection);
    },
    accuracy: function accuracy() {
      return this.rev ? this.getAccuracy() : undefined;
    },
    accuracyGeometryDataProj: function accuracyGeometryDataProj() {
      return this.rev ? this.writeGeometryInDataProj(this.getAccuracyGeometry()) : undefined;
    },
    accuracyGeometryViewProj: function accuracyGeometryViewProj() {
      return this.rev ? this.writeGeometryInViewProj(this.getAccuracyGeometry()) : undefined;
    },
    altitude: function altitude() {
      return this.rev ? this.getAltitude() : undefined;
    },
    altitudeAccuracy: function altitudeAccuracy() {
      return this.rev ? this.getAltitudeAccuracy() : undefined;
    },
    heading: function heading() {
      return this.rev ? this.getHeading() : undefined;
    },
    speed: function speed() {
      return this.rev ? this.getSpeed() : undefined;
    },
    positionDataProj: function positionDataProj() {
      return this.rev ? this.getPosition() : undefined;
    },
    positionViewProj: function positionViewProj() {
      return this.rev ? this.pointToViewProj(this.getPosition()) : undefined;
    }
  },
  watch: {
    rev: function rev() {
      if (!this.$geolocation) return;

      if (this.currentTracking !== this.$geolocation.getTracking()) {
        this.currentTracking = this.$geolocation.getTracking();
      }

      if (!isEqual(this.currentTrackingOptions, this.$geolocation.getTrackingOptions())) {
        this.currentTrackingOptions = this.$geolocation.getTrackingOptions();
      }

      if (this.currentProjection !== this.$geolocation.getProjection().getCode()) {
        this.currentProjection = this.$geolocation.getProjection().getCode();
      }
    },
    tracking: function tracking(value) {
      this.setTracking(value);
    },
    currentTracking: function currentTracking(value) {
      if (value === this.tracking) return;
      this.$emit('update:tracking', value);
    },
    tracingOptions: {
      deep: true,
      handler: function handler(value) {
        this.setTrackingOptions(value);
      }
    },
    currentTrackingOptions: {
      deep: true,
      handler: function handler(value) {
        if (isEqual(value, this.trackingOptions)) return;
        this.$emit('update:tracingOptions', value && clonePlainObject(value));
      }
    },
    projection: function projection(value) {
      this.setProjection(value);
    },
    currentProjection: function currentProjection(value) {
      if (value === this.projection) return;
      this.$emit('update:projection', value);
    },
    accuracy: function accuracy(value, prev) {
      if (value === prev) return;
      this.$emit('update:accuracy', value);
    },
    accuracyGeometryDataProj: function accuracyGeometryDataProj(value, prev) {
      if (isEqual(value, prev)) return;
      this.$emit('update:accuracyGeometry', value);
    },
    currentAltitude: function currentAltitude(value, prev) {
      if (value === prev) return;
      this.$emit('update:altitude', value);
    },
    altitudeAccuracy: function altitudeAccuracy(value, prev) {
      if (value === prev) return;
      this.$emit('update:altitudeAccuracy', value);
    },
    heading: function heading(value, prev) {
      if (value === prev) return;
      this.$emit('update:heading', value);
    },
    speed: function speed(value, prev) {
      if (value === prev) return;
      this.$emit('update:speed', value);
    },
    positionDataProj: function positionDataProj(value, prev) {
      if (isEqual(value, prev)) return;
      this.$emit('update:position', value);
    }
  },
  created: function created() {
    defineServices$8.call(this);
  },
  methods: {
    /**
     * @return {Promise<void>}
     * @protected
     */
    beforeInit: function beforeInit() {
      var _this = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return Promise.all([olCmp.methods.beforeInit.call(_this), waitForMap.methods.beforeInit.call(_this)]);

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    },

    /**
     * @return {module:ol/Geolocation~Geolocation}
     * @private
     */
    createOlObject: function createOlObject() {
      var geoloc = new Geolocation({
        tracking: this.currentTracking,
        trackingOptions: this.currentTrackingOptions,
        projection: this.resolvedDataProjection
      });
      geoloc.set('id', this.currentId);
      return geoloc;
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    mount: function mount() {
      this.setTracking(this.tracking);
      return olCmp.methods.mount.call(this);
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    unmount: function unmount() {
      this.setTracking(false);
      return olCmp.methods.unmount.call(this);
    },

    /**
     * @protected
     */
    subscribeAll: function subscribeAll() {
      olCmp.methods.subscribeAll.call(this);
      subscribeToGeolocation.call(this);
    },
    resolveGeolocation: olCmp.methods.resolveOlObject,

    /**
     * @return {number|string}
     */
    getIdInternal: function getIdInternal() {
      return this.$geolocation.get('id');
    },

    /**
     * @param {string|number} id
     * @return {void}
     */
    setIdInternal: function setIdInternal(id) {
      if (id === this.getIdInternal()) return;
      this.$geolocation.set('id', id);
    },

    /**
     * @return {number|undefined}
     */
    getAccuracy: function getAccuracy() {
      var _this$$geolocation;

      return (_this$$geolocation = this.$geolocation) === null || _this$$geolocation === void 0 ? void 0 : _this$$geolocation.getAccuracy();
    },

    /**
     * @return {module:/ol/geom/Geometry~Geometry|undefined}
     */
    getAccuracyGeometry: function getAccuracyGeometry() {
      var _this$$geolocation2;

      return (_this$$geolocation2 = this.$geolocation) === null || _this$$geolocation2 === void 0 ? void 0 : _this$$geolocation2.getAccuracyGeometry();
    },

    /**
     * @return {number|undefined}
     */
    getAltitude: function getAltitude() {
      var _this$$geolocation3;

      return (_this$$geolocation3 = this.$geolocation) === null || _this$$geolocation3 === void 0 ? void 0 : _this$$geolocation3.getAltitude();
    },

    /**
     * @return {number|undefined}
     */
    getAltitudeAccuracy: function getAltitudeAccuracy() {
      var _this$$geolocation4;

      return (_this$$geolocation4 = this.$geolocation) === null || _this$$geolocation4 === void 0 ? void 0 : _this$$geolocation4.getAltitudeAccuracy();
    },

    /**
     * @return {number|undefined}
     */
    getHeading: function getHeading() {
      var _this$$geolocation5;

      return (_this$$geolocation5 = this.$geolocation) === null || _this$$geolocation5 === void 0 ? void 0 : _this$$geolocation5.getHeading();
    },

    /**
     * @return {number[]|undefined}
     */
    getPosition: function getPosition() {
      var _this$$geolocation6;

      return (_this$$geolocation6 = this.$geolocation) === null || _this$$geolocation6 === void 0 ? void 0 : _this$$geolocation6.getPosition();
    },

    /**
     * @return {module:ol/proj~ProjectionLike|undefined}
     */
    getProjection: function getProjection() {
      var _this$$geolocation7;

      return coalesce((_this$$geolocation7 = this.$geolocation) === null || _this$$geolocation7 === void 0 ? void 0 : _this$$geolocation7.getProjection(), this.currentProjection);
    },

    /**
     * @param {module:ol/proj~ProjectionLike} projection
     */
    setProjection: function setProjection(projection) {
      assert(validateProjection(projection), 'Invalid projection');
      projection = get(projection);

      if (projection.getCode() !== this.currentProjection) {
        this.currentProjection = projection.getCode();
      }

      if (this.$geolocation && projection !== this.$geolocation.getProjection()) {
        this.$geolocation.setProjection(projection);
      }
    },

    /**
     * @return {number|undefined}
     */
    getSpeed: function getSpeed() {
      var _this$$geolocation8;

      return (_this$$geolocation8 = this.$geolocation) === null || _this$$geolocation8 === void 0 ? void 0 : _this$$geolocation8.getSpeed();
    },

    /**
     * @return {boolean}
     */
    getTracking: function getTracking() {
      var _this$$geolocation9;

      return coalesce((_this$$geolocation9 = this.$geolocation) === null || _this$$geolocation9 === void 0 ? void 0 : _this$$geolocation9.getTracking(), this.currentTracking);
    },

    /**
     * @param {boolean} tracking
     */
    setTracking: function setTracking(tracking) {
      if (tracking !== this.currentTracking) {
        this.currentTracking = tracking;
      }

      if (this.$geolocation && tracking !== this.$geolocation.getTracking()) {
        this.$geolocation.setTracking(tracking);
      }
    },

    /**
     * @return {Object|undefined}
     */
    getTrackingOptions: function getTrackingOptions() {
      var _this$$geolocation10;

      return coalesce((_this$$geolocation10 = this.$geolocation) === null || _this$$geolocation10 === void 0 ? void 0 : _this$$geolocation10.getTrackingOptions(), this.currentTrackingOptions);
    },

    /**
     * @param {Promise<Object|undefined>} options
     */
    setTrackingOptions: function setTrackingOptions(options) {
      if (!isEqual(options, this.currentTrackingOptions)) {
        this.currentTrackingOptions = options;
      }

      if (this.$geolocation && !isEqual(options, this.$geolocation.getTrackingOptions())) {
        this.$geolocation.setTrackingOptions(options);
      }
    }
  }
};

function defineServices$8() {
  var _this2 = this;

  Object.defineProperties(this, {
    $geolocation: {
      enumerable: true,
      get: function get() {
        return _this2.$olObject;
      }
    },
    $mapVm: {
      enumerable: true,
      get: function get() {
        var _this2$$services;

        return (_this2$$services = _this2.$services) === null || _this2$$services === void 0 ? void 0 : _this2$$services.mapVm;
      }
    },
    $viewVm: {
      enumerable: true,
      get: function get() {
        var _this2$$services2;

        return (_this2$$services2 = _this2.$services) === null || _this2$$services2 === void 0 ? void 0 : _this2$$services2.viewVm;
      }
    }
  });
}
/**
 * @return {void}
 * @private
 */


function subscribeToGeolocation() {
  var _this3 = this;

  var setterKey = addPrefix('set');
  var setPropsChanges = merge(fromOlChangeEvent(this.$geolocation, 'projection', true, function (evt) {
    return _objectSpread$t(_objectSpread$t({}, evt), {}, {
      value: get(evt.value).getCode()
    });
  }), fromOlChangeEvent(this.$geolocation, ['tracking', 'trackingOptions'], true)).pipe(map(function (evt) {
    return _objectSpread$t(_objectSpread$t({}, evt), {}, {
      setter: function setter(val) {
        _this3[setterKey(evt.prop)](val);

        _this3.scheduleRefresh();
      }
    });
  }));
  this.subscribeTo(setPropsChanges, function (_ref) {
    var setter = _ref.setter,
        value = _ref.value;
    return setter(value);
  });
  var otherChanged = fromOlChangeEvent(this.$geolocation, ['accuracy', 'accuracyGeometry', 'altitude', 'altitudeAccuracy', 'heading', 'speed', 'position'], true);
  this.subscribeTo(otherChanged, this.scheduleRefresh.bind(this));
}

/* script */
var __vue_script__$G = script$G;
/* template */

var __vue_render__$8 = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('i', {
    class: _vm.vmClass,
    staticStyle: {
      "display": "none !important"
    },
    attrs: {
      "id": _vm.vmId
    }
  }, [_vm._t("default", null, {
    "accuracy": _vm.accuracy,
    "accuracyGeometry": _vm.accuracyGeometryDataProj,
    "altitude": _vm.altitude,
    "altitudeAccuracy": _vm.altitudeAccuracy,
    "heading": _vm.heading,
    "position": _vm.positionDataProj,
    "speed": _vm.speed
  })], 2);
};

var __vue_staticRenderFns__$8 = [];
/* style */

var __vue_inject_styles__$G = undefined;
/* scoped */

var __vue_scope_id__$G = undefined;
/* module identifier */

var __vue_module_identifier__$G = undefined;
/* functional template */

var __vue_is_functional_template__$G = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$G = /*#__PURE__*/normalizeComponent({
  render: __vue_render__$8,
  staticRenderFns: __vue_staticRenderFns__$8
}, __vue_inject_styles__$G, __vue_script__$G, __vue_scope_id__$G, __vue_is_functional_template__$G, __vue_module_identifier__$G, false, undefined, undefined, undefined);

function plugin$w(Vue) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$w.installed) {
    return;
  }

  plugin$w.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$G, options);
  Vue.component(__vue_component__$G.name, __vue_component__$G);
}

var Geoloc = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$w,
  install: plugin$w,
  Geoloc: __vue_component__$G
});

var script$F = {
  name: 'VlStyleFill',
  mixins: [style],
  props: {
    color: {
      type: [String, Array],
      default: function _default() {
        return [255, 255, 255, 0.4];
      }
    }
  },
  data: function data() {
    return {
      currentColor: normalizeColor(this.color)
    };
  },
  computed: {
    inputColor: function inputColor() {
      return normalizeColor(this.color);
    }
  },
  watch: {
    rev: function rev() {
      if (!this.$style) return;
      this.setColor(this.getColor());
    },
    inputColor: {
      deep: true,
      handler: function handler(value) {
        this.setColor(value);
      }
    },
    currentColor: {
      deep: true,
      handler: function handler(value) {
        if (isEqual(value, this.inputColor)) return;
        this.$emit('update:color', value === null || value === void 0 ? void 0 : value.slice());
      }
    }
  },
  created: function created() {
    defineServices$7.call(this);
  },
  methods: {
    /**
     * @return {FillStyle}
     * @protected
     */
    createStyle: function createStyle() {
      return new Fill({
        color: this.currentColor
      });
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    mount: function mount() {
      var _this = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var _this$$fillStyleConta;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                (_this$$fillStyleConta = _this.$fillStyleContainer) === null || _this$$fillStyleConta === void 0 ? void 0 : _this$$fillStyleConta.setFill(_this);
                return _context.abrupt("return", style.methods.mount.call(_this));

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    unmount: function unmount() {
      var _this2 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
        var _this2$$fillStyleCont;

        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (((_this2$$fillStyleCont = _this2.$fillStyleContainer) === null || _this2$$fillStyleCont === void 0 ? void 0 : _this2$$fillStyleCont.getFillVm()) === _this2) {
                  _this2.$fillStyleContainer.setFill(null);
                }

                return _context2.abrupt("return", style.methods.unmount.call(_this2));

              case 2:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }))();
    },

    /**
     * @return {Promise<void>}
     */
    refresh: function refresh() {
      var _this3 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
        var _this3$$fillStyleCont;

        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return Promise.all([style.methods.refresh.call(_this3), (_this3$$fillStyleCont = _this3.$fillStyleContainer) === null || _this3$$fillStyleCont === void 0 ? void 0 : _this3$$fillStyleCont.refresh()]);

              case 2:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }))();
    },

    /**
     * @protected
     */
    syncNonObservable: function syncNonObservable() {
      style.methods.syncNonObservable.call(this);
      this.setColor(this.getColor());
    },
    getColor: function getColor() {
      var _this$$style;

      return normalizeColor(coalesce((_this$$style = this.$style) === null || _this$$style === void 0 ? void 0 : _this$$style.getColor(), this.currentColor));
    },
    setColor: function setColor(color) {
      color = normalizeColor(color);

      if (!isEqual(color, this.currentColor)) {
        this.currentColor = color;
        this.scheduleRefresh();
      }

      if (this.$style && !isEqual(color, this.$style.getColor())) {
        this.$style.setColor(color);
        this.scheduleRefresh();
      }
    }
  }
};

function defineServices$7() {
  var _this4 = this;

  Object.defineProperties(this, {
    $fillStyleContainer: {
      enumerable: true,
      get: function get() {
        var _this4$$services;

        return (_this4$$services = _this4.$services) === null || _this4$$services === void 0 ? void 0 : _this4$$services.fillStyleContainer;
      }
    }
  });
}

/* script */
var __vue_script__$F = script$F;
/* template */

/* style */

var __vue_inject_styles__$F = undefined;
/* scoped */

var __vue_scope_id__$F = undefined;
/* module identifier */

var __vue_module_identifier__$F = undefined;
/* functional template */

var __vue_is_functional_template__$F = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$F = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$F, __vue_script__$F, __vue_scope_id__$F, __vue_is_functional_template__$F, __vue_module_identifier__$F, false, undefined, undefined, undefined);

function ownKeys$s(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$s(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$s(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$s(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var script$E = {
  name: 'VlStyleStroke',
  mixins: [style],
  props: {
    color: {
      type: [Array, String],
      default: '#3399cc'
    },
    lineCap: {
      type: String,
      default: 'round' // round, butt, square

    },
    lineJoin: {
      type: String,
      default: 'round' // round, bevel, miter

    },
    lineDash: Array,
    lineDashOffset: {
      type: Number,
      default: 0
    },
    miterLimit: {
      type: Number,
      default: 10
    },
    width: {
      type: Number,
      default: 1.25
    }
  },
  data: function data() {
    var _this$lineDash;

    return {
      currentColor: normalizeColor(this.color),
      currentLineCap: this.lineCap,
      currentLineJoin: this.lineJoin,
      currentLineDash: (_this$lineDash = this.lineDash) === null || _this$lineDash === void 0 ? void 0 : _this$lineDash.slice(),
      currentLineDashOffset: this.lineDashOffset,
      currentMiterLimit: this.miterLimit,
      currentWidth: this.width
    };
  },
  computed: {
    inputColor: function inputColor() {
      return normalizeColor(this.color);
    },
    inputLineDash: function inputLineDash() {
      var _this$lineDash2;

      return (_this$lineDash2 = this.lineDash) === null || _this$lineDash2 === void 0 ? void 0 : _this$lineDash2.slice();
    }
  },
  watch: _objectSpread$s(_objectSpread$s(_objectSpread$s({
    rev: function rev() {
      if (!this.$style) return;
      this.setColor(this.getColor());
      this.setLineCap(this.getLineCap());
      this.setLineJoin(this.getLineJoin());
      this.setLineDash(this.getLineDash());
      this.setLineDashOffset(this.getLineDashOffset());
      this.setMiterLimit(this.getMiterLimit());
      this.setWidth(this.getWidth());
    }
  }, /*#__PURE__*/makeWatchers(['inputColor', 'lineCap', 'lineJoin', 'inputLineDash', 'lineDashOffset', 'miterLimit', 'width'], function (inProp) {
    var prop = inProp.slice(0, 5) === 'input' ? lowerFirst(inProp.slice(5)) : inProp;
    var setter = 'set' + upperFirst(prop);
    return {
      deep: ['inputColor', 'inputLineDash'].includes(inProp),
      handler: function handler(value) {
        this[setter](value);
      }
    };
  })), /*#__PURE__*/makeWatchers(['currentColor', 'currentLineCap', 'currentLineJoin', 'currentLineDash', 'currentLineDashOffset', 'currentMiterLimit', 'currentWidth'], function (curProp) {
    var prop = curProp.slice(0, 7) === 'current' ? lowerFirst(curProp.slice(7)) : curProp;
    var inProp = 'input' + upperFirst(prop);
    return {
      deep: ['currentColor', 'currentLineDash'].includes(curProp),
      handler: function handler(value) {
        if (isEqual(value, coalesce(this[inProp], this[prop]))) return;
        this.$emit("update:".concat(prop), isObjectLike(value) ? clonePlainObject(value) : value);
      }
    };
  })), {}, {
    inputColor: {
      deep: true,
      handler: function handler(value) {
        this.setColor(value);
      }
    },
    currentColor: {
      deep: true,
      handler: function handler(value) {
        if (isEqual(value, this.inputColor)) return;
        this.$emit('update:color', value === null || value === void 0 ? void 0 : value.slice());
      }
    },
    lineCap: function lineCap(value) {
      this.setLineCap(value);
    },
    currentLineCap: function currentLineCap(value) {
      if (value === this.lineCap) return;
      this.$emit('update:lineCap', value);
    },
    lineJoin: function lineJoin(value) {
      this.setLineJoin(value);
    },
    currentLineJoin: function currentLineJoin(value) {
      if (value === this.lineJoin) return;
      this.$emit('update:lineJoin', value);
    },
    inputLineDash: {
      deep: true,
      handler: function handler(value) {
        this.setLineDash(value);
      }
    },
    currentLineDash: {
      deep: true,
      handler: function handler(value) {
        if (isEqual(value, this.currentLineDash)) return;
        this.$emit('update:lineDash', value === null || value === void 0 ? void 0 : value.slice());
      }
    },
    lineDashOffset: function lineDashOffset(value) {
      this.setLineDashOffset(value);
    },
    currentLineDashOffset: function currentLineDashOffset(value) {
      if (value === this.lineDashOffset) return;
      this.$emit('update:lineDashOffset', value);
    },
    miterLimit: function miterLimit(value) {
      this.setMiterLimit(value);
    },
    currentMiterLimit: function currentMiterLimit(value) {
      if (value === this.miterLimit) return;
      this.$emit('update:miterLimit', value);
    },
    width: function width(value) {
      this.setWidth(value);
    },
    currentWidth: function currentWidth(value) {
      if (value === this.width) return;
      this.$emit('update:width', value);
    }
  }),
  created: function created() {
    defineServices$6.call(this);
  },
  methods: {
    /**
     * @return {StrokeStyle}
     * @protected
     */
    createStyle: function createStyle() {
      return new Stroke({
        color: this.currentColor,
        lineCap: this.currentLineCap,
        lineJoin: this.currentLineJoin,
        lineDash: this.currentLineDash,
        lineDashOffset: this.currentLineDashOffset,
        miterLimit: this.currentMiterLimit,
        width: this.currentWidth
      });
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    mount: function mount() {
      var _this = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var _this$$strokeStyleCon;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                (_this$$strokeStyleCon = _this.$strokeStyleContainer) === null || _this$$strokeStyleCon === void 0 ? void 0 : _this$$strokeStyleCon.setStroke(_this);
                return _context.abrupt("return", style.methods.mount.call(_this));

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    unmount: function unmount() {
      var _this2 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
        var _this2$$strokeStyleCo;

        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (((_this2$$strokeStyleCo = _this2.$strokeStyleContainer) === null || _this2$$strokeStyleCo === void 0 ? void 0 : _this2$$strokeStyleCo.getStrokeVm()) === _this2) {
                  _this2.$strokeStyleContainer.setStroke(null);
                }

                return _context2.abrupt("return", style.methods.unmount.call(_this2));

              case 2:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }))();
    },

    /**
     * @return {Promise}
     */
    refresh: function refresh() {
      var _this3 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
        var _this3$$strokeStyleCo;

        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return Promise.all([style.methods.refresh.call(_this3), (_this3$$strokeStyleCo = _this3.$strokeStyleContainer) === null || _this3$$strokeStyleCo === void 0 ? void 0 : _this3$$strokeStyleCo.refresh()]);

              case 2:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }))();
    },

    /**
     * @protected
     */
    syncNonObservable: function syncNonObservable() {
      style.methods.syncNonObservable.call(this);
      this.setColor(this.getColor());
      this.setLineCap(this.getLineCap());
      this.setLineJoin(this.getLineJoin());
      this.setLineDash(this.getLineDash());
      this.setLineDashOffset(this.getLineDashOffset());
      this.setMiterLimit(this.getMiterLimit());
      this.setWidth(this.getWidth());
    },
    getColor: function getColor() {
      var _this$$style;

      return coalesce((_this$$style = this.$style) === null || _this$$style === void 0 ? void 0 : _this$$style.getColor(), this.currentColor);
    },
    setColor: function setColor(color) {
      color = normalizeColor(color);

      if (!isEqual(color, this.currentColor)) {
        this.currentColor = color;
        this.scheduleRefresh();
      }

      if (this.$style && !isEqual(color, this.$style.getColor())) {
        this.$style.setColor(color);
        this.scheduleRefresh();
      }
    },
    getLineCap: function getLineCap() {
      var _this$$style2;

      return coalesce((_this$$style2 = this.$style) === null || _this$$style2 === void 0 ? void 0 : _this$$style2.getLineCap(), this.currentLineCap);
    },
    setLineCap: function setLineCap(lineCap) {
      if (lineCap !== this.currentLineCap) {
        this.currentLineCap = lineCap;
        this.scheduleRefresh();
      }

      if (this.$style && lineCap !== this.$style.getLineCap()) {
        this.$style.setLineCap(lineCap);
        this.scheduleRefresh();
      }
    },
    getLineJoin: function getLineJoin() {
      var _this$$style3;

      return coalesce((_this$$style3 = this.$style) === null || _this$$style3 === void 0 ? void 0 : _this$$style3.getLineJoin(), this.currentLineJoin);
    },
    setLineJoin: function setLineJoin(lineJoin) {
      if (lineJoin !== this.currentLineJoin) {
        this.currentLineJoin = lineJoin;
      }

      if (this.$style && lineJoin !== this.$style.getLineJoin()) {
        this.$style.setLineJoin(lineJoin);
        this.scheduleRefresh();
      }
    },
    getLineDash: function getLineDash() {
      var _this$$style4;

      return coalesce((_this$$style4 = this.$style) === null || _this$$style4 === void 0 ? void 0 : _this$$style4.getLineDash(), this.currentLineDash);
    },
    setLineDash: function setLineDash(lineDash) {
      var _lineDash;

      lineDash = (_lineDash = lineDash) === null || _lineDash === void 0 ? void 0 : _lineDash.slice();

      if (!isEqual(lineDash, this.currentLineDash)) {
        this.currentLineDash = lineDash;
        this.scheduleRefresh();
      }

      if (this.$style && !isEqual(lineDash, this.$style.getLineDash())) {
        this.$style.setLineDash(lineDash);
        this.scheduleRefresh();
      }
    },
    getLineDashOffset: function getLineDashOffset() {
      var _this$$style5;

      return coalesce((_this$$style5 = this.$style) === null || _this$$style5 === void 0 ? void 0 : _this$$style5.getLineDashOffset(), this.currentLineDashOffset);
    },
    setLineDashOffset: function setLineDashOffset(lineDashOffset) {
      if (lineDashOffset !== this.currentLineDashOffset) {
        this.currentLineDashOffset = lineDashOffset;
        this.scheduleRefresh();
      }

      if (this.$style && lineDashOffset !== this.$style.getLineDashOffset()) {
        this.$style.setLineDashOffset(lineDashOffset);
        this.scheduleRefresh();
      }
    },
    getMiterLimit: function getMiterLimit() {
      var _this$$style6;

      return coalesce((_this$$style6 = this.$style) === null || _this$$style6 === void 0 ? void 0 : _this$$style6.getMiterLimit(), this.currentMiterLimit);
    },
    setMiterLimit: function setMiterLimit(miterLimit) {
      if (miterLimit !== this.currentMiterLimit) {
        this.currentMiterLimit = miterLimit;
        this.scheduleRefresh();
      }

      if (this.$style && miterLimit !== this.$style.getMiterLimit()) {
        this.$style.setMiterLimit(miterLimit);
        this.scheduleRefresh();
      }
    },
    getWidth: function getWidth() {
      var _this$$style7;

      return coalesce((_this$$style7 = this.$style) === null || _this$$style7 === void 0 ? void 0 : _this$$style7.getWidth(), this.currentWidth);
    },
    setWidth: function setWidth(width) {
      if (width !== this.currentWidth) {
        this.currentWidth = width;
        this.scheduleRefresh();
      }

      if (this.$style && width !== this.$style.getWidth()) {
        this.$style.setWidth(width);
        this.scheduleRefresh();
      }
    }
  }
};

function defineServices$6() {
  var _this4 = this;

  Object.defineProperties(this, {
    $strokeStyleContainer: {
      enumerable: true,
      get: function get() {
        var _this4$$services;

        return (_this4$$services = _this4.$services) === null || _this4$$services === void 0 ? void 0 : _this4$$services.strokeStyleContainer;
      }
    }
  });
}

/* script */
var __vue_script__$E = script$E;
/* template */

/* style */

var __vue_inject_styles__$E = undefined;
/* scoped */

var __vue_scope_id__$E = undefined;
/* module identifier */

var __vue_module_identifier__$E = undefined;
/* functional template */

var __vue_is_functional_template__$E = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$E = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$E, __vue_script__$E, __vue_scope_id__$E, __vue_is_functional_template__$E, __vue_module_identifier__$E, false, undefined, undefined, undefined);

function ownKeys$r(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$r(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$r(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$r(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var script$D = {
  name: 'VlStyleCircle',
  components: {
    FillStyle: __vue_component__$F,
    StrokeStyle: __vue_component__$E
  },
  mixins: [regShapeStyle],
  props: {
    /* eslint-disable vue/require-prop-types */
    radius: _objectSpread$r(_objectSpread$r({}, regShapeStyle.props.radius), {}, {
      default: 5
    })
    /* eslint-enable vue/require-prop-types */

  },
  data: function data() {
    return {
      currentRadius: this.radius
    };
  },
  watch: {
    rev: function rev() {
      if (!this.$style) return;
      this.setRadius(this.getRadius());
    },
    currentRadius: function currentRadius(value) {
      if (value === this.radius) return;
      this.$emit('update:radius', value);
    }
  },
  methods: {
    /**
     * @return {CircleStyle}
     * @protected
     */
    createStyle: function createStyle() {
      return new Circle$1({
        // ol/style/Image
        displacement: this.inputDisplacement,
        // ol/style/RegularShape
        radius: this.currentRadius,
        fill: this.$fill,
        stroke: this.$stroke
      });
    },

    /**
     * @protected
     */
    syncNonObservable: function syncNonObservable() {
      regShapeStyle.methods.syncNonObservable.call(this);
      this.setRadius(this.getRadius());
    },
    getRadius: function getRadius() {
      var _this$$style;

      return coalesce((_this$$style = this.$style) === null || _this$$style === void 0 ? void 0 : _this$$style.getRadius(), this.currentRadius);
    },
    setRadius: function setRadius(radius) {
      if (radius !== this.currentRadius) {
        this.currentRadius = radius;
        this.scheduleRefresh();
      }

      if (this.$style && radius !== this.$style.getRadius()) {
        this.$style.setRadius(radius);
        this.scheduleRefresh();
      }
    },

    /**
     * @param {number} value
     * @protected
     */
    radiusChanged: function radiusChanged(value) {
      this.setRadius(value);
    },
    pointsChanged: noop,
    radius1Changed: noop,
    radius2Changed: noop,
    angleChanged: noop
  }
};

/* script */
var __vue_script__$D = script$D;
/* template */

var __vue_render__$7 = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('i', {
    class: _vm.vmClass,
    staticStyle: {
      "display": "none !important"
    },
    attrs: {
      "id": _vm.vmId
    }
  }, [_vm._t("default", [_c('FillStyle', {
    attrs: {
      "id": 'vl-' + _vm.currentId + '-default-fill-style'
    }
  }), _vm._v(" "), _c('StrokeStyle', {
    attrs: {
      "id": 'vl-' + _vm.currentId + '-default-stroke-style'
    }
  })])], 2);
};

var __vue_staticRenderFns__$7 = [];
/* style */

var __vue_inject_styles__$D = undefined;
/* scoped */

var __vue_scope_id__$D = undefined;
/* module identifier */

var __vue_module_identifier__$D = undefined;
/* functional template */

var __vue_is_functional_template__$D = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$D = /*#__PURE__*/normalizeComponent({
  render: __vue_render__$7,
  staticRenderFns: __vue_staticRenderFns__$7
}, __vue_inject_styles__$D, __vue_script__$D, __vue_scope_id__$D, __vue_is_functional_template__$D, __vue_module_identifier__$D, false, undefined, undefined, undefined);

function ownKeys$q(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$q(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$q(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$q(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var script$C = {
  name: 'VlStyleIcon',
  mixins: [imageStyle],
  props: {
    src: String,
    size: {
      type: Array,
      validator: function validator(val) {
        return val.length === 2;
      }
    },
    img: Image,
    imgSize: {
      type: Array,
      validator: function validator(val) {
        return val.length === 2;
      }
    },
    anchor: {
      type: Array,
      default: function _default() {
        return [0.5, 0.5];
      },
      validator: function validator(val) {
        return val.length === 2;
      }
    },
    anchorOrigin: {
      type: String,
      default: IconOrigin.TOP_LEFT // bottom-left, bottom-right, top-left or top-right

    },
    anchorXUnits: {
      type: String,
      default: IconAnchorUnits.FRACTION // pixels, fraction

    },
    anchorYUnits: {
      type: String,
      default: IconAnchorUnits.FRACTION // pixels, fraction

    },
    color: [Array, String],
    crossOrigin: String,
    offset: {
      type: Array,
      default: function _default() {
        return [0, 0];
      },
      validator: function validator(val) {
        return val.length === 2;
      }
    },
    offsetOrigin: {
      type: String,
      default: IconOrigin.TOP_LEFT // bottom-left, bottom-right, top-left or top-right

    }
  },
  data: function data() {
    var _this$anchor;

    return {
      currentAnchor: (_this$anchor = this.anchor) === null || _this$anchor === void 0 ? void 0 : _this$anchor.slice()
    };
  },
  computed: {
    inputSize: function inputSize() {
      var _this$size;

      return (_this$size = this.size) === null || _this$size === void 0 ? void 0 : _this$size.slice();
    },
    inputImgSize: function inputImgSize() {
      var _this$imgSize;

      return (_this$imgSize = this.imgSize) === null || _this$imgSize === void 0 ? void 0 : _this$imgSize.slice();
    },
    inputAnchor: function inputAnchor() {
      var _this$anchor2;

      return (_this$anchor2 = this.anchor) === null || _this$anchor2 === void 0 ? void 0 : _this$anchor2.slice();
    },
    inputColor: function inputColor() {
      return this.color ? normalizeColor(this.color) : undefined;
    },
    inputOffset: function inputOffset() {
      var _this$offset;

      return (_this$offset = this.offset) === null || _this$offset === void 0 ? void 0 : _this$offset.slice();
    }
  },
  watch: _objectSpread$q({
    rev: function rev() {
      if (!this.$style) return;
      this.setAnchor(this.getAnchor());
    },
    inputAnchor: {
      deep: true,
      handler: function handler(value) {
        this.setAnchor(value);
      }
    },
    currentAnchor: {
      deep: true,
      handler: function handler(value) {
        if (isEqual(value, this.inputAnchor)) return;
        this.$emit('update:anchor', value === null || value === void 0 ? void 0 : value.slice());
      }
    }
  }, /*#__PURE__*/makeChangeOrRecreateWatchers(['src', 'inputSize', 'img', 'inputImgSize', 'anchorOrigin', 'anchorXUnits', 'anchorYUnits', 'anchorYUnits', 'inputColor', 'crossOrigin', 'inputOffset', 'offsetOrigin'], ['inputSize', 'inputImgSize', 'inputColor', 'inputOffset'])),
  methods: {
    /**
     * @return {Icon}
     * @protected
     */
    createStyle: function createStyle() {
      assert(this.src && !this.img || !this.src && this.img, "vl-style-icon one of 'image' or 'src' prop must be provided.'");
      assert(!this.img || this.img && !isEmpty(this.imgSize), "vl-style-icon 'imgSize' must be set when image is provided.");
      return new Icon({
        // ol/style/Image
        opacity: this.currentOpacity,
        scale: this.currentScale,
        rotateWithView: this.currentRotateWithView,
        rotation: this.currentRotation,
        displacement: this.inputDisplacement,
        // ol/style/Icon
        anchor: this.currentAnchor,
        anchorOrigin: this.anchorOrigin,
        anchorXUnits: this.anchorXUnits,
        anchorYUnits: this.anchorYUnits,
        color: this.inputColor,
        crossOrigin: this.crossOrigin,
        offset: this.inputOffset,
        offsetOrigin: this.offsetOrigin,
        size: this.inputSize,
        src: this.src,
        img: this.img,
        imgSize: this.inputImgSize
      });
    },

    /**
     * @protected
     */
    syncNonObservable: function syncNonObservable() {
      imageStyle.methods.syncNonObservable.call(this);
      this.setAnchor(this.getAnchor());
    },
    getAnchor: function getAnchor() {
      var _this$$style, _this$$style$getAncho;

      var anchor = (_this$$style = this.$style) === null || _this$$style === void 0 ? void 0 : (_this$$style$getAncho = _this$$style.getAnchor()) === null || _this$$style$getAncho === void 0 ? void 0 : _this$$style$getAncho.slice();
      if (!anchor) return this.currentAnchor;
      var size = this.getSize();
      if (!size) return;

      if (this.anchorXUnits === IconAnchorUnits.FRACTION) {
        anchor[0] /= size[0];
      }

      if (this.anchorYUnits === IconAnchorUnits.FRACTION) {
        anchor[1] /= size[1];
      }

      if ([IconOrigin.TOP_RIGHT, IconOrigin.BOTTOM_RIGHT].includes(this.anchorOrigin)) {
        anchor[0] = 1 - anchor[0];
      }

      if ([IconOrigin.BOTTOM_LEFT, IconOrigin.BOTTOM_RIGHT].includes(this.anchorOrigin)) {
        anchor[1] = 1 - anchor[1];
      }

      anchor[0] = round(anchor[0], 3);
      anchor[1] = round(anchor[1], 3);
      return anchor;
    },
    setAnchor: function setAnchor(anchor) {
      var _anchor;

      anchor = (_anchor = anchor) === null || _anchor === void 0 ? void 0 : _anchor.slice();

      if (!isEqual(anchor, this.currentAnchor)) {
        this.currentAnchor = anchor;
        this.scheduleRefresh();
      }

      if (this.$style && !isEqual(anchor, this.$style.getAnchor())) {
        this.$style.setAnchor(anchor);
        this.scheduleRefresh();
      }
    },
    getColor: function getColor() {
      var _this$$style2;

      return coalesce((_this$$style2 = this.$style) === null || _this$$style2 === void 0 ? void 0 : _this$$style2.getColor(), this.inputColor);
    },
    getImage: function getImage(pixelRatio) {
      var _this$$style3;

      return (_this$$style3 = this.$style) === null || _this$$style3 === void 0 ? void 0 : _this$$style3.getImage(pixelRatio);
    },
    getPixelRatio: function getPixelRatio(pixelRatio) {
      var _this$$style4;

      return (_this$$style4 = this.$style) === null || _this$$style4 === void 0 ? void 0 : _this$$style4.getPixelRatio(pixelRatio);
    },
    getOrigin: function getOrigin() {
      var _this$$style5;

      return (_this$$style5 = this.$style) === null || _this$$style5 === void 0 ? void 0 : _this$$style5.getOrigin();
    },
    getSize: function getSize() {
      var _this$$style6;

      return coalesce((_this$$style6 = this.$style) === null || _this$$style6 === void 0 ? void 0 : _this$$style6.getSize(), this.inputSize);
    },
    getSrc: function getSrc() {
      var _this$$style7;

      return coalesce((_this$$style7 = this.$style) === null || _this$$style7 === void 0 ? void 0 : _this$$style7.getSrc(), this.src);
    },
    load: function load() {
      var _this = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _this.resolveStyle();

              case 2:
                _context.sent.load();

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    }
  }
};

/* script */
var __vue_script__$C = script$C;
/* template */

/* style */

var __vue_inject_styles__$C = undefined;
/* scoped */

var __vue_scope_id__$C = undefined;
/* module identifier */

var __vue_module_identifier__$C = undefined;
/* functional template */

var __vue_is_functional_template__$C = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$C = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$C, __vue_script__$C, __vue_scope_id__$C, __vue_is_functional_template__$C, __vue_module_identifier__$C, false, undefined, undefined, undefined);

var script$B = {
  name: 'VlStyleRegShape',
  mixins: [regShapeStyle],
  methods: {
    /**
     * @return {RegularShapeStyle}
     * @protected
     */
    createStyle: function createStyle() {
      return new RegularShape({
        // ol/style/Image
        rotation: this.currentRotation,
        rotateWithView: this.currentRotateWithView,
        displacement: this.inputDisplacement,
        // ol/style/RegularShape
        points: this.points,
        radius: this.radius,
        radius1: this.radius1,
        radius2: this.radius2,
        angle: this.angle,
        fill: this.$fill,
        stroke: this.$stroke
      });
    }
  }
};

/* script */
var __vue_script__$B = script$B;
/* template */

/* style */

var __vue_inject_styles__$B = undefined;
/* scoped */

var __vue_scope_id__$B = undefined;
/* module identifier */

var __vue_module_identifier__$B = undefined;
/* functional template */

var __vue_is_functional_template__$B = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$B = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$B, __vue_script__$B, __vue_scope_id__$B, __vue_is_functional_template__$B, __vue_module_identifier__$B, false, undefined, undefined, undefined);

function ownKeys$p(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$p(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$p(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$p(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
/**
 * Style box component.
 * Wrapper for Style class. Can be inserted into component with setStyle/getStyle methods (vl-layer-vector, vl-feature & etc.)
 * and acts as a box for inner style components (vl-style-fill, vl-style-stroke, icon ...)
 */

var script$A = {
  name: 'VlStyle',
  components: {
    CircleStyle: __vue_component__$D,
    FillStyle: __vue_component__$F,
    StrokeStyle: __vue_component__$E
  },
  mixins: [projTransforms, fillStyleContainer, strokeStyleContainer, textStyleContainer, imageStyleContainer, geometryContainer, style, waitForMap],
  stubVNode: {
    empty: false,
    attrs: function attrs() {
      return {
        id: this.vmId,
        class: this.vmClass
      };
    }
  },
  props: {
    /**
     * @type {number}
     */
    zIndex: {
      type: Number,
      default: 0
    },

    /**
     * @type {function}
     */
    renderer: Function,

    /**
     * @deprecated Use v-if directive.
     * @todo remove in v0.13.x
     */
    condition: [Boolean, Function]
  },
  data: function data() {
    return {
      viewProjection: EPSG_3857,
      dataProjection: EPSG_3857,
      currentZIndex: this.zIndex,
      currentRenderer: this.renderer
    };
  },
  computed: {
    stroke: function stroke() {
      if (!(this.rev && this.$stroke)) return;
      return dumpStrokeStyle(this.$stroke);
    },
    fill: function fill() {
      if (!(this.rev && this.$fill)) return;
      return dumpFillStyle(this.$fill);
    },
    text: function text() {
      if (!(this.rev && this.$text)) return;
      return dumpTextStyle(this.$text);
    },
    image: function image() {
      if (!(this.rev && this.$image)) return;
      return dumpImageStyle(this.$image);
    },
    geometryDataProj: function geometryDataProj() {
      if (!(this.rev && this.$geometry)) return;
      return this.writeGeometryInDataProj(this.$geometry);
    },
    geometryViewProj: function geometryViewProj() {
      if (!(this.rev && this.$geometry)) return;
      return this.writeGeometryInViewProj(this.$geometry);
    }
  },
  watch: _objectSpread$p(_objectSpread$p(_objectSpread$p({
    rev: function rev() {
      if (!this.$style) return;
      this.setZIndex(this.getZIndex());
      this.setRenderer(this.getRenderer());
    }
  }, /*#__PURE__*/makeWatchers(['zIndex', 'renderer'], function (inProp) {
    var prop = inProp.slice(0, 5) === 'input' ? lowerFirst(inProp.slice(5)) : inProp;
    var setter = 'set' + upperFirst(prop);
    return function (value) {
      this[setter](value);
    };
  })), /*#__PURE__*/makeWatchers(['currentZIndex', 'currentRenderer'], function (curProp) {
    var prop = curProp.slice(0, 7) === 'current' ? lowerFirst(curProp.slice(7)) : curProp;
    var inProp = 'input' + upperFirst(prop);
    return function (value) {
      if (isEqual(value, coalesce(this[inProp], this[prop]))) return;
      this.$emit("update:".concat(prop), isObjectLike(value) ? clonePlainObject(value) : value);
    };
  })), /*#__PURE__*/makeWatchers(['fill', 'stroke', 'text', 'image', 'geometryDataProj'], function (prop) {
    prop = prop.replace(/(DataProj|ViewProj)$/i, '');
    return {
      deep: true,
      handler: function handler(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit("update:".concat(prop), isObjectLike(value) ? clonePlainObject(value) : value);
      }
    };
  })),
  created: function created() {
    if (process.env.NODE_ENV !== 'production') {
      if (this.condition) {
        this.$logger.warn("'condition' is deprecated. Use v-if directive instead.");
      }
    }

    defineServices$5.call(this);
  },
  updated: function updated() {
    if (process.env.NODE_ENV !== 'production') {
      if (this.condition) {
        this.$logger.warn("'condition' is deprecated. Use v-if directive instead.");
      }
    }
  },
  methods: {
    /**
     * @return {Promise<void>}
     * @protected
     */
    beforeInit: function beforeInit() {
      var _this = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return Promise.all([style.methods.beforeInit.call(_this), waitForMap.methods.beforeInit.call(_this)]);

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    },

    /**
     * @return {module:ol/style/Style~Style}
     * @protected
     */
    createStyle: function createStyle() {
      return new Style$1({
        zIndex: this.currentZIndex,
        renderer: this.currentRenderer,
        fill: this.$fill,
        stroke: this.$stroke,
        image: this.$image,
        text: this.$text,
        geometry: this.$geometry
      });
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    mount: function mount() {
      var _this2 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
        var _this2$$styleContaine;

        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                (_this2$$styleContaine = _this2.$styleContainer) === null || _this2$$styleContaine === void 0 ? void 0 : _this2$$styleContaine.addStyle(_this2);
                return _context2.abrupt("return", style.methods.mount.call(_this2));

              case 2:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }))();
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    unmount: function unmount() {
      var _this3 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
        var _this3$$styleContaine;

        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                (_this3$$styleContaine = _this3.$styleContainer) === null || _this3$$styleContaine === void 0 ? void 0 : _this3$$styleContaine.removeStyle(_this3);
                return _context3.abrupt("return", style.methods.unmount.call(_this3));

              case 2:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }))();
    },

    /**
     * @return {Promise}
     */
    refresh: function refresh() {
      var _this4 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {
        var _this4$$styleContaine;

        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return Promise.all([style.methods.refresh.call(_this4), (_this4$$styleContaine = _this4.$styleContainer) === null || _this4$$styleContaine === void 0 ? void 0 : _this4$$styleContaine.refresh()]);

              case 2:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }))();
    },

    /**
     * @returns {Object}
     * @protected
     */
    getServices: function getServices() {
      return mergeDescriptors(style.methods.getServices.call(this), fillStyleContainer.methods.getServices.call(this), strokeStyleContainer.methods.getServices.call(this), textStyleContainer.methods.getServices.call(this), imageStyleContainer.methods.getServices.call(this), geometryContainer.methods.getServices.call(this));
    },

    /**
     * @protected
     */
    syncNonObservable: function syncNonObservable() {
      style.methods.syncNonObservable.call(this);
      this.setZIndex(this.getZIndex());
      this.setRenderer(this.getRenderer());
    },
    getFillStyleTarget: function getFillStyleTarget() {
      return this.$style;
    },
    getStrokeStyleTarget: function getStrokeStyleTarget() {
      return this.$style;
    },
    getTextStyleTarget: function getTextStyleTarget() {
      return this.$style;
    },
    getImageStyleTarget: function getImageStyleTarget() {
      return this.$style;
    },
    getGeometryTarget: function getGeometryTarget() {
      return this.$style;
    },
    getZIndex: function getZIndex() {
      var _this$$style;

      return coalesce((_this$$style = this.$style) === null || _this$$style === void 0 ? void 0 : _this$$style.getZIndex(), this.currentZIndex);
    },
    setZIndex: function setZIndex(zIndex) {
      if (zIndex !== this.currentZIndex) {
        this.currentZIndex = zIndex;
        this.scheduleRefresh();
      }

      if (this.$style && zIndex !== this.$style.getZIndex()) {
        this.$style.setZIndex(zIndex);
        this.scheduleRefresh();
      }
    },
    getRenderer: function getRenderer() {
      var _this$$style2;

      return coalesce((_this$$style2 = this.$style) === null || _this$$style2 === void 0 ? void 0 : _this$$style2.getRenderer(), this.currentRenderer);
    },
    setRenderer: function setRenderer(renderer) {
      if (renderer !== this.currentRenderer) {
        this.currentRenderer = renderer;
        this.scheduleRefresh();
      }

      if (this.$style && renderer !== this.$style.getRenderer()) {
        this.$style.setRenderer(renderer);
        this.scheduleRefresh();
      }
    },
    // todo add support for geometry function
    getGeometryFunction: function getGeometryFunction() {
      var _this$$style3;

      return (_this$$style3 = this.$style) === null || _this$$style3 === void 0 ? void 0 : _this$$style3.getGeometryFunction();
    }
  }
};

function defineServices$5() {
  var _this5 = this;

  Object.defineProperties(this, {
    /**
     * @type {Object|undefined}
     */
    $mapVm: {
      enumerable: true,
      get: function get() {
        var _this5$$services;

        return (_this5$$services = _this5.$services) === null || _this5$$services === void 0 ? void 0 : _this5$$services.mapVm;
      }
    },

    /**
     * @type {Object|undefined}
     */
    $viewVm: {
      enumerable: true,
      get: function get() {
        var _this5$$services2;

        return (_this5$$services2 = _this5.$services) === null || _this5$$services2 === void 0 ? void 0 : _this5$$services2.viewVm;
      }
    }
  });
}

/* script */
var __vue_script__$A = script$A;
/* template */

var __vue_render__$6 = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('i', {
    class: _vm.vmClass,
    staticStyle: {
      "display": "none !important"
    },
    attrs: {
      "id": _vm.vmId
    }
  }, [_vm._t("default", [_c('CircleStyle', {
    attrs: {
      "id": 'vl-' + _vm.currentId + '-default-circle-style'
    }
  }), _vm._v(" "), _c('FillStyle', {
    attrs: {
      "id": 'vl-' + _vm.currentId + '-default-fill-style'
    }
  }), _vm._v(" "), _c('StrokeStyle', {
    attrs: {
      "id": 'vl-' + _vm.currentId + '-default-stroke-style'
    }
  })])], 2);
};

var __vue_staticRenderFns__$6 = [];
/* style */

var __vue_inject_styles__$A = undefined;
/* scoped */

var __vue_scope_id__$A = undefined;
/* module identifier */

var __vue_module_identifier__$A = undefined;
/* functional template */

var __vue_is_functional_template__$A = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$A = /*#__PURE__*/normalizeComponent({
  render: __vue_render__$6,
  staticRenderFns: __vue_staticRenderFns__$6
}, __vue_inject_styles__$A, __vue_script__$A, __vue_scope_id__$A, __vue_is_functional_template__$A, __vue_module_identifier__$A, false, undefined, undefined, undefined);

function ownKeys$o(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$o(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$o(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$o(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var script$z = {
  name: 'VlStyleBackgroundAdapter',
  mixins: [stubVNode, fillStyleContainer, strokeStyleContainer, olCmp],
  stubVNode: {
    empty: false,
    attrs: function attrs() {
      return {
        id: this.vmId,
        class: this.vmClass
      };
    }
  },
  computed: {
    stroke: function stroke() {
      if (!(this.rev && this.$strokeStyle)) return;
      return dumpStrokeStyle(this.$strokeStyle);
    },
    fill: function fill() {
      if (!(this.rev && this.$fill)) return;
      return dumpFillStyle(this.$fill);
    }
  },
  watch: _objectSpread$o({}, /*#__PURE__*/makeWatchers(['fill', 'stroke'], function (prop) {
    return function (value, prev) {
      if (isEqual(value, prev)) return;
      this.$emit("update:".concat(prop), isObjectLike(value) ? clonePlainObject(value) : value);
    };
  })),
  created: function created() {
    var _this = this;

    Object.defineProperties(this, {
      $bgStyleContainer: {
        enumerable: true,
        get: function get() {
          var _this$$services;

          return (_this$$services = _this.$services) === null || _this$$services === void 0 ? void 0 : _this$$services.bgStyleContainer;
        }
      }
    });
  },
  methods: {
    createOlObject: function createOlObject() {
      var obj = stubObject();
      obj.id = this.currentId;
      return obj;
    },
    getServices: function getServices() {
      return mergeDescriptors(olCmp.methods.getServices.call(this), fillStyleContainer.methods.getServices.call(this), strokeStyleContainer.methods.getServices.call(this));
    },
    getFillStyleTarget: function getFillStyleTarget() {
      var _this2 = this;

      return {
        getFill: function getFill() {
          var _this2$$bgStyleContai;

          return (_this2$$bgStyleContai = _this2.$bgStyleContainer) === null || _this2$$bgStyleContai === void 0 ? void 0 : _this2$$bgStyleContai.getBackgroundFill();
        },
        setFill: function setFill(style) {
          var _this2$$bgStyleContai2;

          return (_this2$$bgStyleContai2 = _this2.$bgStyleContainer) === null || _this2$$bgStyleContai2 === void 0 ? void 0 : _this2$$bgStyleContai2.setBackgroundFill(style);
        }
      };
    },
    getStrokeStyleTarget: function getStrokeStyleTarget() {
      var _this3 = this;

      return {
        getStroke: function getStroke() {
          var _this3$$bgStyleContai;

          return (_this3$$bgStyleContai = _this3.$bgStyleContainer) === null || _this3$$bgStyleContai === void 0 ? void 0 : _this3$$bgStyleContai.getBackgroundStroke();
        },
        setStroke: function setStroke(style) {
          var _this3$$bgStyleContai2;

          return (_this3$$bgStyleContai2 = _this3.$bgStyleContainer) === null || _this3$$bgStyleContai2 === void 0 ? void 0 : _this3$$bgStyleContai2.setBackgroundStroke(style);
        }
      };
    }
  }
};

/* script */
var __vue_script__$z = script$z;
/* template */

/* style */

var __vue_inject_styles__$z = undefined;
/* scoped */

var __vue_scope_id__$z = undefined;
/* module identifier */

var __vue_module_identifier__$z = undefined;
/* functional template */

var __vue_is_functional_template__$z = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$z = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$z, __vue_script__$z, __vue_scope_id__$z, __vue_is_functional_template__$z, __vue_module_identifier__$z, false, undefined, undefined, undefined);

function ownKeys$n(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$n(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$n(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$n(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var script$y = {
  name: 'VlStyleText',
  components: {
    BackgroundStyle: __vue_component__$z,
    FillStyle: __vue_component__$F,
    StrokeStyle: __vue_component__$E
  },
  mixins: [fillStyleContainer, strokeStyleContainer, style],
  stubVNode: {
    empty: false,
    attrs: function attrs() {
      return {
        id: this.vmId,
        class: this.vmClass
      };
    }
  },
  props: {
    font: {
      type: String,
      default: '10px sans-serif' // css font format https://developer.mozilla.org/en-US/docs/Web/CSS/font?v=control

    },
    maxAngle: Number,
    placement: String,
    offsetX: {
      type: Number,
      default: 0
    },
    offsetY: {
      type: Number,
      default: 0
    },
    overflow: Boolean,
    rotateWithView: {
      type: Boolean,
      default: false
    },
    rotation: {
      type: Number,
      default: 0
    },
    scale: {
      type: Number,
      default: 1
    },
    text: String,
    textAlign: String,
    // left, right, center, end, start
    textBaseline: String,
    // bottom, top, middle, alphabetic, hanging, ideographic
    padding: {
      type: Array,
      default: function _default() {
        return [0, 0, 0, 0];
      },
      validate: function validate(val) {
        return val.length && val.length === 4;
      }
    }
  },
  data: function data() {
    var _this$padding;

    return {
      currentFont: this.font,
      currentMaxAngle: this.maxAngle,
      currentPlacement: this.placement,
      currentOffsetX: this.offsetX,
      currentOffsetY: this.offsetY,
      currentOverflow: this.overflow,
      currentRotateWithView: this.rotateWithView,
      currentRotation: this.rotation,
      currentScale: this.scale,
      currentText: this.text,
      currentTextAlign: this.textAlign,
      currentTextBaseline: this.textBaseline,
      currentPadding: (_this$padding = this.padding) === null || _this$padding === void 0 ? void 0 : _this$padding.slice()
    };
  },
  computed: {
    inputPadding: function inputPadding() {
      var _this$padding2;

      return (_this$padding2 = this.padding) === null || _this$padding2 === void 0 ? void 0 : _this$padding2.slice();
    },
    stroke: function stroke() {
      if (!(this.rev && this.$stroke)) return;
      return dumpStrokeStyle(this.$stroke);
    },
    fill: function fill() {
      if (!(this.rev && this.$fill)) return;
      return dumpFillStyle(this.$fill);
    },
    backgroundFill: function backgroundFill() {
      if (!(this.rev && this.$bgFill)) return;
      return dumpFillStyle(this.$bgFill);
    },
    backgroundStroke: function backgroundStroke() {
      if (!(this.rev && this.$bgStroke)) return;
      return dumpStrokeStyle(this.$bgStroke);
    }
  },
  watch: _objectSpread$n(_objectSpread$n(_objectSpread$n({
    rev: function rev() {
      if (!this.$style) return;
      this.setFont(this.getFont());
      this.setMaxAngle(this.getMaxAngle());
      this.setPlacement(this.getPlacement());
      this.setOffsetX(this.getOffsetX());
      this.setOffsetY(this.getOffsetY());
      this.setOverflow(this.getOverflow());
      this.setRotateWithView(this.getRotateWithView());
      this.setRotation(this.getRotation());
      this.setScale(this.getScale());
      this.setText(this.getText());
      this.setTextAlign(this.getTextAlign());
      this.setTextBaseline(this.getTextBaseline());
      this.setPadding(this.getPadding());
    }
  }, /*#__PURE__*/makeWatchers(['font', 'maxAngle', 'placement', 'offsetX', 'offsetY', 'overflow', 'rotateWithView', 'rotation', 'scale', 'text', 'textAlign', 'textBaseline', 'inputPadding'], function (inProp) {
    var prop = inProp.slice(0, 5) === 'input' ? lowerFirst(inProp.slice(5)) : inProp;
    var setter = 'set' + upperFirst(prop);
    return {
      deep: ['inputPadding'].includes(inProp),
      handler: function handler(value) {
        this[setter](value);
      }
    };
  })), /*#__PURE__*/makeWatchers(['currentFont', 'currentMaxAngle', 'currentPlacement', 'currentOffsetX', 'currentOffsetY', 'currentOverflow', 'currentRotateWithView', 'currentRotation', 'currentScale', 'currentText', 'currentTextAlign', 'currentTextBaseline', 'currentPadding'], function (curProp) {
    var prop = curProp.slice(0, 7) === 'current' ? lowerFirst(curProp.slice(7)) : curProp;
    var inProp = 'input' + upperFirst(prop);
    return {
      deep: ['currentPadding'].includes(curProp),
      handler: function handler(value) {
        if (isEqual(value, coalesce(this[inProp], this[prop]))) return;
        this.$emit("update:".concat(prop), isObjectLike(value) ? clonePlainObject(value) : value);
      }
    };
  })), /*#__PURE__*/makeWatchers(['fill', 'stroke', 'backgroundFill', 'backgroundStroke'], function (prop) {
    return {
      deep: true,
      handler: function handler(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit("update:".concat(prop), isObjectLike(value) ? clonePlainObject(value) : value);
      }
    };
  })),
  created: function created() {
    this._bgFill = undefined;
    this._bgFillVm = undefined;
    this._bgStroke = undefined;
    this._bgStrokeVm = undefined;
    defineServices$4.call(this);
  },
  methods: {
    /**
     * @returns {Text}
     * @protected
     */
    createStyle: function createStyle() {
      return new Text({
        font: this.currentFont,
        maxAngle: this.currentMaxAngle,
        placement: this.currentPlacement,
        offsetX: this.currentOffsetX,
        offsetY: this.currentOffsetY,
        overflow: this.currentOverflow,
        rotateWithView: this.currentRotateWithView,
        rotation: this.currentRotation,
        scale: this.currentScale,
        text: this.currentText,
        textAlign: this.currentTextAlign,
        textBaseline: this.currentTextBaseline,
        padding: this.currentPadding,
        fill: this.$fill,
        stroke: this.$stroke,
        backgroundFill: this.$bgFill,
        backgroundStroke: this.$bgStroke
      });
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    mount: function mount() {
      var _this = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var _this$$textStyleConta;

        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                (_this$$textStyleConta = _this.$textStyleContainer) === null || _this$$textStyleConta === void 0 ? void 0 : _this$$textStyleConta.setText(_this);
                return _context.abrupt("return", style.methods.mount.call(_this));

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    unmount: function unmount() {
      var _this2 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
        var _this2$$textStyleCont;

        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                if (!(((_this2$$textStyleCont = _this2.$textStyleContainer) === null || _this2$$textStyleCont === void 0 ? void 0 : _this2$$textStyleCont.getTextVm()) === _this2)) {
                  _context2.next = 3;
                  break;
                }

                _context2.next = 3;
                return _this2.$textStyleContainer.setText(null);

              case 3:
                return _context2.abrupt("return", style.methods.unmount.call(_this2));

              case 4:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }))();
    },

    /**
     * @return {Promise<void>}
     */
    refresh: function refresh() {
      var _this3 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
        var _this3$$textStyleCont;

        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return Promise.all([style.methods.refresh.call(_this3), (_this3$$textStyleCont = _this3.$textStyleContainer) === null || _this3$$textStyleCont === void 0 ? void 0 : _this3$$textStyleCont.refresh()]);

              case 2:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }))();
    },

    /**
     * @returns {Object}
     * @protected
     */
    getServices: function getServices() {
      var vm = this;
      return mergeDescriptors(style.methods.getServices.call(this), fillStyleContainer.methods.getServices.call(this), strokeStyleContainer.methods.getServices.call(this), {
        get bgStyleContainer() {
          return vm;
        }

      });
    },

    /**
     * @protected
     */
    syncNonObservable: function syncNonObservable() {
      style.methods.syncNonObservable.call(this);
      this.setFont(this.getFont());
      this.setMaxAngle(this.getMaxAngle());
      this.setPlacement(this.getPlacement());
      this.setOffsetX(this.getOffsetX());
      this.setOffsetY(this.getOffsetY());
      this.setOverflow(this.getOverflow());
      this.setRotateWithView(this.getRotateWithView());
      this.setRotation(this.getRotation());
      this.setScale(this.getScale());
      this.setText(this.getText());
      this.setTextAlign(this.getTextAlign());
      this.setTextBaseline(this.getTextBaseline());
      this.setPadding(this.getPadding());
    },
    getFont: function getFont() {
      var _this$$style;

      return coalesce((_this$$style = this.$style) === null || _this$$style === void 0 ? void 0 : _this$$style.getFont(), this.currentFont);
    },
    setFont: function setFont(font) {
      if (font !== this.currentFont) {
        this.currentFont = font;
        this.scheduleRefresh();
      }

      if (this.$style && font !== this.$style.getFont()) {
        this.$style.setFont(font);
        this.scheduleRefresh();
      }
    },
    getMaxAngle: function getMaxAngle() {
      var _this$$style2;

      return coalesce((_this$$style2 = this.$style) === null || _this$$style2 === void 0 ? void 0 : _this$$style2.getMaxAngle(), this.currentMaxAngle);
    },
    setMaxAngle: function setMaxAngle(maxAngle) {
      if (maxAngle !== this.currentMaxAngle) {
        this.currentMaxAngle = maxAngle;
        this.scheduleRefresh();
      }

      if (this.$style && maxAngle !== this.$style.getMaxAngle()) {
        this.$style.setMaxAngle(maxAngle);
        this.scheduleRefresh();
      }
    },
    getOffsetX: function getOffsetX() {
      var _this$$style3;

      return coalesce((_this$$style3 = this.$style) === null || _this$$style3 === void 0 ? void 0 : _this$$style3.getOffsetX(), this.currentOffsetX);
    },
    setOffsetX: function setOffsetX(offsetX) {
      if (offsetX !== this.currentOffsetX) {
        this.currentOffsetX = offsetX;
        this.scheduleRefresh();
      }

      if (this.$style && offsetX !== this.$style.getOffsetX()) {
        this.$style.setOffsetX(offsetX);
        this.scheduleRefresh();
      }
    },
    getOffsetY: function getOffsetY() {
      var _this$$style4;

      return coalesce((_this$$style4 = this.$style) === null || _this$$style4 === void 0 ? void 0 : _this$$style4.getOffsetY(), this.currentOffsetY);
    },
    setOffsetY: function setOffsetY(offsetY) {
      if (offsetY !== this.currentOffsetY) {
        this.currentOffsetY = offsetY;
        this.scheduleRefresh();
      }

      if (this.$style && offsetY !== this.$style.getOffsetY()) {
        this.$style.setOffsetY(offsetY);
        this.scheduleRefresh();
      }
    },
    getOverflow: function getOverflow() {
      var _this$$style5;

      return coalesce((_this$$style5 = this.$style) === null || _this$$style5 === void 0 ? void 0 : _this$$style5.getOverflow(), this.currentOverflow);
    },
    setOverflow: function setOverflow(overflow) {
      if (overflow !== this.currentOverflow) {
        this.currentOverflow = overflow;
        this.scheduleRefresh();
      }

      if (this.$style && overflow !== this.$style.getOverflow()) {
        this.$style.setOverflow(overflow);
        this.scheduleRefresh();
      }
    },
    getPadding: function getPadding() {
      var _this$$style6;

      return coalesce((_this$$style6 = this.$style) === null || _this$$style6 === void 0 ? void 0 : _this$$style6.getPadding(), this.currentPadding);
    },
    setPadding: function setPadding(padding) {
      var _padding;

      padding = (_padding = padding) === null || _padding === void 0 ? void 0 : _padding.slice();

      if (!isEqual(padding, this.currentPadding)) {
        this.currentPadding = padding;
        this.scheduleRefresh();
      }

      if (this.$style && !isEqual(padding, this.$style.getPadding())) {
        this.$style.setPadding(padding);
        this.scheduleRefresh();
      }
    },
    getPlacement: function getPlacement() {
      var _this$$source;

      return coalesce((_this$$source = this.$source) === null || _this$$source === void 0 ? void 0 : _this$$source.getPlacement(), this.currentPlacement);
    },
    setPlacement: function setPlacement(placement) {
      if (placement !== this.currentPlacement) {
        this.currentPlacement = placement;
        this.scheduleRefresh();
      }

      if (this.$style && placement !== this.$style.getPlacement()) {
        this.$style.setPlacement(placement);
        this.scheduleRefresh();
      }
    },
    getRotateWithView: function getRotateWithView() {
      var _this$$style7;

      return coalesce((_this$$style7 = this.$style) === null || _this$$style7 === void 0 ? void 0 : _this$$style7.getRotateWithView(), this.currentRotateWithView);
    },
    setRotateWithView: function setRotateWithView(rotateWithView) {
      if (rotateWithView !== this.currentRotateWithView) {
        this.currentRotateWithView = rotateWithView;
        this.scheduleRefresh();
      }

      if (this.$style && rotateWithView !== this.$style.getRotateWithView()) {
        this.$style.setRotateWithView(rotateWithView);
        this.scheduleRefresh();
      }
    },
    getRotation: function getRotation() {
      var _this$$style8;

      return coalesce((_this$$style8 = this.$style) === null || _this$$style8 === void 0 ? void 0 : _this$$style8.getRotation(), this.currentRotation);
    },
    setRotation: function setRotation(rotation) {
      if (rotation !== this.currentRotation) {
        this.currentRotation = rotation;
        this.scheduleRefresh();
      }

      if (this.$style && rotation !== this.$style.getRotation()) {
        this.$style.setRotation(rotation);
        this.scheduleRefresh();
      }
    },
    getScale: function getScale() {
      var _this$$style9;

      return coalesce((_this$$style9 = this.$style) === null || _this$$style9 === void 0 ? void 0 : _this$$style9.getScale(), this.currentScale);
    },
    setScale: function setScale(scale) {
      if (scale !== this.currentScale) {
        this.currentScale = scale;
        this.scheduleRefresh();
      }

      if (this.$style && scale !== this.$style.getScale()) {
        this.$style.setScale(scale);
        this.scheduleRefresh();
      }
    },
    getText: function getText() {
      var _this$$style10;

      return coalesce((_this$$style10 = this.$style) === null || _this$$style10 === void 0 ? void 0 : _this$$style10.getText(), this.currentText);
    },
    setText: function setText(text) {
      if (text !== this.currentText) {
        this.currentText = text;
        this.scheduleRefresh();
      }

      if (this.$style && text !== this.$style.getText()) {
        this.$style.setText(text);
        this.scheduleRefresh();
      }
    },
    getTextAlign: function getTextAlign() {
      var _this$$style11;

      return coalesce((_this$$style11 = this.$style) === null || _this$$style11 === void 0 ? void 0 : _this$$style11.getTextAlign(), this.currentTextAlign);
    },
    setTextAlign: function setTextAlign(textAlign) {
      if (textAlign !== this.currentTextAlign) {
        this.currentTextAlign = textAlign;
        this.scheduleRefresh();
      }

      if (this.$style && textAlign !== this.$style.getTextAlign()) {
        this.$style.setTextAlign(textAlign);
        this.scheduleRefresh();
      }
    },
    getTextBaseline: function getTextBaseline() {
      var _this$$style12;

      return coalesce((_this$$style12 = this.$style) === null || _this$$style12 === void 0 ? void 0 : _this$$style12.getTextBaseline(), this.currentTextBaseline);
    },
    setTextBaseline: function setTextBaseline(textBaseline) {
      if (textBaseline !== this.currentTextBaseline) {
        this.currentTextBaseline = textBaseline;
        this.scheduleRefresh();
      }

      if (this.$style && textBaseline !== this.$style.getTextBaseline()) {
        this.$style.setTextBaseline(textBaseline);
        this.scheduleRefresh();
      }
    },
    getFillStyleTarget: function getFillStyleTarget() {
      return this.$style;
    },
    getStrokeStyleTarget: function getStrokeStyleTarget() {
      return this.$style;
    },
    getBackgroundFill: function getBackgroundFill() {
      return this._bgFill;
    },
    setBackgroundFill: function setBackgroundFill(fill) {
      var _fill;

      fill = ((_fill = fill) === null || _fill === void 0 ? void 0 : _fill.$fill) || fill;
      fill || (fill = undefined);

      if (fill !== this._bgFill) {
        var _fill2;

        this._bgFill = fill;
        this._bgFillVm = ((_fill2 = fill) === null || _fill2 === void 0 ? void 0 : _fill2.vm) && fill.vm[0];
        this.scheduleRefresh();
      }

      if (this.$style && fill !== this.$style.getBackgroundFill()) {
        this.$style.setBackgroundFill(fill);
        this.scheduleRefresh();
      }
    },
    getBackgroundStroke: function getBackgroundStroke() {
      return this._bgStroke;
    },
    setBackgroundStroke: function setBackgroundStroke(stroke) {
      var _stroke;

      stroke = ((_stroke = stroke) === null || _stroke === void 0 ? void 0 : _stroke.$stroke) || stroke;
      stroke || (stroke = undefined);

      if (stroke !== this._bgStroke) {
        var _stroke2;

        this._bgStroke = stroke;
        this._bgStrokeVm = ((_stroke2 = stroke) === null || _stroke2 === void 0 ? void 0 : _stroke2.vm) && stroke.vm[0];
        this.scheduleRefresh();
      }

      if (this.$style && stroke !== this.$style.getBackgroundStroke()) {
        this.$style.setBackgroundStroke(stroke);
        this.scheduleRefresh();
      }
    }
  }
};

function defineServices$4() {
  var _this4 = this;

  Object.defineProperties(this, {
    $textStyleContainer: {
      enumerable: true,
      get: function get() {
        var _this4$$services;

        return (_this4$$services = _this4.$services) === null || _this4$$services === void 0 ? void 0 : _this4$$services.textStyleContainer;
      }
    },
    $bgFill: {
      enumerable: true,
      get: this.getBackgroundFill
    },
    $bgFillVm: {
      enumerable: true,
      get: function get() {
        return _this4._bgFillVm;
      }
    },
    $bgStroke: {
      enumerable: true,
      get: this.getBackgroundStroke
    },
    $bgStrokeVm: {
      enumerable: true,
      get: function get() {
        return _this4._bgStrokeVm;
      }
    }
  });
}

/* script */
var __vue_script__$y = script$y;
/* template */

var __vue_render__$5 = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('i', {
    class: _vm.vmClass,
    staticStyle: {
      "display": "none !important"
    },
    attrs: {
      "id": _vm.vmId
    }
  }, [_vm._t("default", [_c('FillStyle', {
    attrs: {
      "id": 'vl-' + _vm.currentId + '-default-fill-style',
      "color": "#333"
    }
  }), _vm._v(" "), _c('StrokeStyle', {
    attrs: {
      "id": 'vl-' + _vm.currentId + '-default-stroke-style',
      "color": "#eee"
    }
  })]), _vm._v(" "), _c('BackgroundStyle', {
    attrs: {
      "id": 'vl-' + _vm.currentId + '-background-style'
    }
  }, [_vm._t("background")], 2)], 2);
};

var __vue_staticRenderFns__$5 = [];
/* style */

var __vue_inject_styles__$y = undefined;
/* scoped */

var __vue_scope_id__$y = undefined;
/* module identifier */

var __vue_module_identifier__$y = undefined;
/* functional template */

var __vue_is_functional_template__$y = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$y = /*#__PURE__*/normalizeComponent({
  render: __vue_render__$5,
  staticRenderFns: __vue_staticRenderFns__$5
}, __vue_inject_styles__$y, __vue_script__$y, __vue_scope_id__$y, __vue_is_functional_template__$y, __vue_module_identifier__$y, false, undefined, undefined, undefined);

function plugin$v(Vue) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$v.installed) {
    return;
  }

  plugin$v.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$D, options);
  Object.assign(__vue_component__$F, options);
  Object.assign(__vue_component__$C, options);
  Object.assign(__vue_component__$B, options);
  Object.assign(__vue_component__$E, options);
  Object.assign(__vue_component__$A, options);
  Object.assign(__vue_component__$y, options);
  Vue.component(__vue_component__$D.name, __vue_component__$D);
  Vue.component(__vue_component__$F.name, __vue_component__$F);
  Vue.component(__vue_component__$C.name, __vue_component__$C);
  Vue.component(__vue_component__$B.name, __vue_component__$B);
  Vue.component(__vue_component__$E.name, __vue_component__$E);
  Vue.component(__vue_component__$A.name, __vue_component__$A);
  Vue.component(__vue_component__$y.name, __vue_component__$y); // todo remove in v0.13.x

  Vue.component('VlStyleBox', {
    name: 'VlStyleBox',
    extends: __vue_component__$A,
    created: function created() {
      if (process.env.NODE_ENV !== 'production') {
        this.$logger.warn('VlStyleBox component is deprecated. Use VlStyle component instead.');
      }
    }
  });
}

var Style = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$v,
  install: plugin$v,
  CircleStyle: __vue_component__$D,
  FillStyle: __vue_component__$F,
  IconStyle: __vue_component__$C,
  RegShapeStyle: __vue_component__$B,
  StrokeStyle: __vue_component__$E,
  Style: __vue_component__$A,
  TextStyle: __vue_component__$y
});

var script$x = {
  name: 'VlLayerGraticuleLatStyleAdapter',
  mixins: [stubVNode, textStyleContainer, olCmp],
  stubVNode: {
    empty: false,
    attrs: function attrs() {
      return {
        id: this.vmId,
        class: this.vmClass
      };
    }
  },
  computed: {
    text: function text() {
      if (!(this.rev && this.$text)) return;
      return dumpTextStyle(this.$text);
    }
  },
  watch: {
    text: {
      deep: true,
      handler: function handler(value, prev) {
        if (!isEqual(value, prev)) return;
        this.$emit('update:text', value && clonePlainObject(value));
      }
    }
  },
  created: function created() {
    var _this = this;

    Object.defineProperties(this, {
      $latStyleContainer: {
        enumerable: true,
        get: function get() {
          var _this$$services;

          return (_this$$services = _this.$services) === null || _this$$services === void 0 ? void 0 : _this$$services.latStyleContainer;
        }
      }
    });
  },
  methods: {
    createOlObject: function createOlObject() {
      var obj = stubObject();
      obj.id = this.currentId;
      return obj;
    },
    getServices: function getServices() {
      return mergeDescriptors(olCmp.methods.getServices.call(this), textStyleContainer.methods.getServices.call(this));
    },
    getTextStyleTarget: function getTextStyleTarget() {
      var _this2 = this;

      return {
        getText: function getText() {
          var _this2$$latStyleConta;

          return (_this2$$latStyleConta = _this2.$latStyleContainer) === null || _this2$$latStyleConta === void 0 ? void 0 : _this2$$latStyleConta.getLatLabelStyle();
        },
        setText: function setText(style) {
          var _this2$$latStyleConta2;

          return (_this2$$latStyleConta2 = _this2.$latStyleContainer) === null || _this2$$latStyleConta2 === void 0 ? void 0 : _this2$$latStyleConta2.setLatLabelStyle(style);
        }
      };
    }
  }
};

/* script */
var __vue_script__$x = script$x;
/* template */

/* style */

var __vue_inject_styles__$x = undefined;
/* scoped */

var __vue_scope_id__$x = undefined;
/* module identifier */

var __vue_module_identifier__$x = undefined;
/* functional template */

var __vue_is_functional_template__$x = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$x = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$x, __vue_script__$x, __vue_scope_id__$x, __vue_is_functional_template__$x, __vue_module_identifier__$x, false, undefined, undefined, undefined);

var script$w = {
  name: 'VlLayerGraticuleLonStyleAdapter',
  mixins: [stubVNode, textStyleContainer, olCmp],
  stubVNode: {
    empty: false,
    attrs: function attrs() {
      return {
        id: this.vmId,
        class: this.vmClass
      };
    }
  },
  computed: {
    text: function text() {
      if (!(this.rev && this.$text)) return;
      return dumpTextStyle(this.$text);
    }
  },
  watch: {
    text: {
      deep: true,
      handler: function handler(value, prev) {
        if (!isEqual(value, prev)) return;
        this.$emit('update:text', value && clonePlainObject(value));
      }
    }
  },
  created: function created() {
    var _this = this;

    Object.defineProperties(this, {
      $lonStyleContainer: {
        enumerable: true,
        get: function get() {
          var _this$$services;

          return (_this$$services = _this.$services) === null || _this$$services === void 0 ? void 0 : _this$$services.lonStyleContainer;
        }
      }
    });
  },
  methods: {
    createOlObject: function createOlObject() {
      var obj = stubObject();
      obj.id = this.currentId;
      return obj;
    },
    getServices: function getServices() {
      return mergeDescriptors(olCmp.methods.getServices.call(this), textStyleContainer.methods.getServices.call(this));
    },
    getTextStyleTarget: function getTextStyleTarget() {
      var _this2 = this;

      return {
        getText: function getText() {
          var _this2$$lonStyleConta;

          return (_this2$$lonStyleConta = _this2.$lonStyleContainer) === null || _this2$$lonStyleConta === void 0 ? void 0 : _this2$$lonStyleConta.getLonLabelStyle();
        },
        setText: function setText(style) {
          var _this2$$lonStyleConta2;

          return (_this2$$lonStyleConta2 = _this2.$lonStyleContainer) === null || _this2$$lonStyleConta2 === void 0 ? void 0 : _this2$$lonStyleConta2.setLonLabelStyle(style);
        }
      };
    }
  }
};

/* script */
var __vue_script__$w = script$w;
/* template */

/* style */

var __vue_inject_styles__$w = undefined;
/* scoped */

var __vue_scope_id__$w = undefined;
/* module identifier */

var __vue_module_identifier__$w = undefined;
/* functional template */

var __vue_is_functional_template__$w = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$w = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$w, __vue_script__$w, __vue_scope_id__$w, __vue_is_functional_template__$w, __vue_module_identifier__$w, false, undefined, undefined, undefined);

var script$v = {
  name: 'VlLayerGraticuleStrokeStyleAdapter',
  mixins: [stubVNode, strokeStyleContainer, olCmp],
  stubVNode: {
    empty: false,
    attrs: function attrs() {
      return {
        id: this.vmId,
        class: this.vmClass
      };
    }
  },
  computed: {
    stroke: function stroke() {
      if (!(this.rev && this.$stroke)) return;
      return dumpStrokeStyle(this.$stroke);
    }
  },
  watch: {
    stroke: {
      deep: true,
      handler: function handler(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit('update:stroke', value && clonePlainObject(value));
      }
    }
  },
  created: function created() {
    var _this = this;

    Object.defineProperties(this, {
      $strokeStyleContainer: {
        enumerable: true,
        get: function get() {
          var _this$$services;

          return (_this$$services = _this.$services) === null || _this$$services === void 0 ? void 0 : _this$$services.strokeStyleContainer;
        }
      }
    });
  },
  methods: {
    createOlObject: function createOlObject() {
      var obj = stubObject();
      obj.id = this.currentId;
      return obj;
    },
    getServices: function getServices() {
      return mergeDescriptors(olCmp.methods.getServices.call(this), strokeStyleContainer.methods.getServices.call(this));
    },
    getStrokeStyleTarget: function getStrokeStyleTarget() {
      var _this2 = this;

      return {
        setStroke: function setStroke(style) {
          return _this2.$strokeStyleContainer.setStrokeStyle(style);
        },
        getStroke: function getStroke() {
          return _this2.$strokeStyleContainer.getStrokeStyle();
        }
      };
    }
  }
};

/* script */
var __vue_script__$v = script$v;
/* template */

/* style */

var __vue_inject_styles__$v = undefined;
/* scoped */

var __vue_scope_id__$v = undefined;
/* module identifier */

var __vue_module_identifier__$v = undefined;
/* functional template */

var __vue_is_functional_template__$v = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$v = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$v, __vue_script__$v, __vue_scope_id__$v, __vue_is_functional_template__$v, __vue_module_identifier__$v, false, undefined, undefined, undefined);

function ownKeys$m(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$m(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$m(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$m(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var script$u = {
  name: 'VlLayerGraticule',
  components: {
    LonStyle: __vue_component__$w,
    LatStyle: __vue_component__$x,
    GStrokeStyle: __vue_component__$v,
    TextStyle: __vue_component__$y,
    FillStyle: __vue_component__$F,
    StrokeStyle: __vue_component__$E
  },
  mixins: [vectorLayer],
  props: {
    // ol/layer/Graticule
    maxLines: {
      type: Number,
      default: 100
    },
    targetSize: {
      type: Number,
      default: 100
    },
    showLabels: {
      type: Boolean,
      default: false
    },
    lonLabelFormatter: Function,
    latLabelFormatter: Function,
    lonLabelPosition: {
      type: Number,
      default: 0
    },
    latLabelPosition: {
      type: Number,
      default: 1
    },
    intervals: {
      type: Array,
      default: function _default() {
        return [90, 45, 30, 20, 10, 5, 2, 1, 0.5, 0.2, 0.1, 0.05, 0.01, 0.005, 0.002, 0.001];
      }
    },
    wrapX: {
      type: Boolean,
      default: true
    }
  },
  computed: {
    inputIntervals: function inputIntervals() {
      var _this$intervals;

      return (_this$intervals = this.intervals) === null || _this$intervals === void 0 ? void 0 : _this$intervals.slice();
    },
    meridians: function meridians() {
      var _this = this;

      if (!this.rev) return [];
      return map$1(this.getMeridians(), function (geom) {
        return _this.writeGeometryInDataProj(geom);
      });
    },
    parallels: function parallels() {
      var _this2 = this;

      if (!this.rev) return [];
      return map$1(this.getParallels(), function (geom) {
        return _this2.writeGeometryInDataProj(geom);
      });
    },
    lonLabelStyle: function lonLabelStyle() {
      if (!(this.rev && this.$lonLabelStyle)) return;
      return dumpTextStyle(this.$lonLabelStyle);
    },
    latLabelStyle: function latLabelStyle() {
      if (!(this.rev && this.$latLabelStyle)) return;
      return dumpTextStyle(this.$latLabelStyle);
    },
    strokeStyle: function strokeStyle() {
      if (!(this.rev && this.$strokeStyle)) return;
      return dumpStrokeStyle(this.$strokeStyle);
    }
  },
  watch: _objectSpread$m({
    meridians: {
      deep: true,
      handler: function handler(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit('update:meridians', clonePlainObject(value));
      }
    },
    parallels: {
      deep: true,
      handler: function handler(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit('update:parallels', clonePlainObject(value));
      }
    },
    lonLabelStyle: {
      deep: true,
      handler: function handler(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit('update:lonLabelStyle', value && clonePlainObject(value));
      }
    },
    latLabelStyle: {
      deep: true,
      handler: function handler(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit('update:latLabelStyle', value && clonePlainObject(value));
      }
    },
    strokeStyle: {
      deep: true,
      handler: function handler(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit('update:strokeStyle', value && clonePlainObject(value));
      }
    }
  }, /*#__PURE__*/makeChangeOrRecreateWatchers(['maxLines', 'targetSize', 'showLabels', 'lonLabelFormatter', 'latLabelFormatter', 'lonLabelPosition', 'latLabelPosition', 'inputIntervals', 'wrapX'], ['inputIntervals'])),
  created: function created() {
    this._lonLabelStyle = undefined;
    this._lonLabelStyleVm = undefined;
    this._latLabelStyle = undefined;
    this._latLabelStyleVm = undefined;
    this._strokeStyle = undefined;
    this._strokeStyleVm = undefined;
    Object.defineProperties(this, {
      $lonLabelStyle: {
        enumerable: true,
        get: this.getLonLabelStyle
      },
      $lonLabelStyleVm: {
        enumerable: true,
        get: this.getLonLabelStyleVm
      },
      $latLabelStyle: {
        enumerable: true,
        get: this.getLatLabelStyle
      },
      $latLabelStyleVm: {
        enumerable: true,
        get: this.getLatLabelStyleVm
      },
      $strokeStyle: {
        enumerable: true,
        get: this.getStrokeStyle
      },
      $strokeStyleVm: {
        enumerable: true,
        get: this.getStrokeStyleVm
      }
    });
  },
  methods: {
    createLayer: function createLayer() {
      return new GraticuleLayer$1({
        // ol/layer/Base
        className: this.className,
        opacity: this.currentOpacity,
        visible: this.currentVisible,
        extent: this.currentExtentViewProj,
        zIndex: this.currentZIndex,
        minResolution: this.currentMinResolution,
        maxResolution: this.currentMaxResolution,
        minZoom: this.currentMinZoom,
        maxZoom: this.currentMaxZoom,
        // ol/layer/Layer
        render: this.render,
        // ol/layer/Vector
        renderOrder: this.renderOrder,
        renderBuffer: this.renderBuffer,
        declutter: this.declutter,
        updateWhileAnimating: this.updateWhileAnimating,
        updateWhileInteracting: this.updateWhileInteracting,
        style: this.$style,
        // ol/layer/Graticule
        maxLines: this.maxLines,
        strokeStyle: this.$strokeStyle,
        targetSize: this.targetSize,
        showLabels: this.showLabels,
        lonLabelFormatter: this.lonLabelFormatter,
        latLabelFormatter: this.latLabelFormatter,
        lonLabelPosition: this.lonLabelPosition,
        latLabelPosition: this.latLabelPosition,
        lonLabelStyle: this.$lonLabelStyle,
        latLabelStyle: this.$latLabelStyle,
        intervals: this.inputIntervals,
        wrapX: this.wrapX
      });
    },
    getServices: function getServices() {
      var vm = this;
      return mergeDescriptors(vectorLayer.methods.getServices.call(this), {
        get lonStyleContainer() {
          return vm;
        },

        get latStyleContainer() {
          return vm;
        },

        get strokeStyleContainer() {
          return vm;
        }

      });
    },
    getMeridians: function getMeridians() {
      var _this$$layer;

      return coalesce((_this$$layer = this.$layer) === null || _this$$layer === void 0 ? void 0 : _this$$layer.getMeridians(), []);
    },
    getParallels: function getParallels() {
      var _this$$layer2;

      return coalesce((_this$$layer2 = this.$layer) === null || _this$$layer2 === void 0 ? void 0 : _this$$layer2.getParallels(), []);
    },
    getLonLabelStyle: function getLonLabelStyle() {
      return this._lonLabelStyle;
    },
    getLonLabelStyleVm: function getLonLabelStyleVm() {
      return this._lonLabelStyleVm;
    },
    setLonLabelStyle: function setLonLabelStyle(style) {
      var _style, _style2, _style3;

      style = ((_style = style) === null || _style === void 0 ? void 0 : _style.$style) || style;
      style || (style = undefined);
      assert(!style || style instanceof Text, 'Invalid lon label style');
      if (style === this._lonLabelStyle) return;
      this._lonLabelStyle = style;
      this._lonLabelStyleVm = ((_style2 = style) === null || _style2 === void 0 ? void 0 : _style2.vm) && ((_style3 = style) === null || _style3 === void 0 ? void 0 : _style3.vm[0]);

      if (process.env.VUELAYERS_DEBUG) {
        this.$logger.log('lonLabelStyle changed, scheduling recreate...');
      }

      this.scheduleRecreate();
    },
    getLatLabelStyle: function getLatLabelStyle() {
      return this._latLabelStyle;
    },
    getLatLabelStyleVm: function getLatLabelStyleVm() {
      return this._latLabelStyleVm;
    },
    setLatLabelStyle: function setLatLabelStyle(style) {
      var _style4, _style5, _style6;

      style = ((_style4 = style) === null || _style4 === void 0 ? void 0 : _style4.$style) || style;
      style || (style = undefined);
      assert(!style || style instanceof Text, 'Invalid lat label style');
      if (style === this._latLabelStyle) return;
      this._latLabelStyle = style;
      this._latLabelStyleVm = ((_style5 = style) === null || _style5 === void 0 ? void 0 : _style5.vm) && ((_style6 = style) === null || _style6 === void 0 ? void 0 : _style6.vm[0]);

      if (process.env.VUELAYERS_DEBUG) {
        this.$logger.log('latLabelStyle changed, scheduling recreate...');
      }

      this.scheduleRecreate();
    },
    getStrokeStyle: function getStrokeStyle() {
      return this._strokeStyle;
    },
    getStrokeStyleVm: function getStrokeStyleVm() {
      return this._strokeStyleVm;
    },
    setStrokeStyle: function setStrokeStyle(style) {
      var _style7, _style8, _style9;

      style = (_style7 = style) === null || _style7 === void 0 ? void 0 : _style7.$style;
      style || (style = undefined);
      assert(!style || style instanceof Stroke, 'Invalid stroke style');
      if (style === this._strokeStyle) return;
      this._strokeStyle = style;
      this._strokeStyleVm = ((_style8 = style) === null || _style8 === void 0 ? void 0 : _style8.vm) && ((_style9 = style) === null || _style9 === void 0 ? void 0 : _style9.vm[0]);

      if (process.env.VUELAYERS_DEBUG) {
        this.$logger.log('strokeStyle changed, scheduling recreate...');
      }

      this.scheduleRecreate();
    }
  }
};

/* script */
var __vue_script__$u = script$u;
/* template */

var __vue_render__$4 = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('i', {
    class: _vm.vmClass,
    staticStyle: {
      "display": "none !important"
    },
    attrs: {
      "id": _vm.vmId
    }
  }, [_c('LonStyle', {
    attrs: {
      "id": 'vl-' + _vm.currentId + '-lon-style'
    }
  }, [_vm._t("lon", [_c('TextStyle', {
    attrs: {
      "id": 'vl-' + _vm.currentId + '-default-text-style',
      "font": "'12px sans-serif'",
      "text-baseline": "bottom"
    }
  }, [_c('FillStyle', {
    attrs: {
      "id": 'vl-' + _vm.currentId + '-default-fill-style',
      "color": "rgba(0,0,0,1)"
    }
  }), _vm._v(" "), _c('StrokeStyle', {
    attrs: {
      "id": 'vl-' + _vm.currentId + '-default-stroke-style',
      "color": "rgba(255,255,255,1)",
      "width": 3
    }
  })], 1)])], 2), _vm._v(" "), _c('LatStyle', {
    attrs: {
      "id": 'vl-' + _vm.currentId + '-lat-style'
    }
  }, [_vm._t("lat", [_c('TextStyle', {
    attrs: {
      "id": 'vl-' + _vm.currentId + '-default-text-style',
      "font": "'12px Calibri,sans-serif'",
      "text-baseline": "bottom"
    }
  }, [_c('FillStyle', {
    attrs: {
      "id": 'vl-' + _vm.currentId + '-default-fill-style',
      "color": "rgba(0,0,0,1)"
    }
  }), _vm._v(" "), _c('StrokeStyle', {
    attrs: {
      "id": 'vl-' + _vm.currentId + '-default-stroke-style',
      "color": "rgba(255,255,255,1)",
      "width": 3
    }
  })], 1)])], 2), _vm._v(" "), _c('GStrokeStyle', {
    attrs: {
      "id": 'vl-' + _vm.currentId + '-graticule-style'
    }
  }, [_vm._t("stroke", [_c('StrokeStyle', {
    attrs: {
      "id": 'vl-' + _vm.currentId + '-default-graticule-stroke-style',
      "color": "rgba(0,0,0,0.2)"
    }
  })])], 2)], 1);
};

var __vue_staticRenderFns__$4 = [];
/* style */

var __vue_inject_styles__$u = undefined;
/* scoped */

var __vue_scope_id__$u = undefined;
/* module identifier */

var __vue_module_identifier__$u = undefined;
/* functional template */

var __vue_is_functional_template__$u = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$u = /*#__PURE__*/normalizeComponent({
  render: __vue_render__$4,
  staticRenderFns: __vue_staticRenderFns__$4
}, __vue_inject_styles__$u, __vue_script__$u, __vue_scope_id__$u, __vue_is_functional_template__$u, __vue_module_identifier__$u, false, undefined, undefined, undefined);

function plugin$u(Vue) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$u.installed) {
    return;
  }

  plugin$u.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$u, options);
  Vue.component(__vue_component__$u.name, __vue_component__$u); // todo remove in v0.13.x

  Vue.component('VlGraticule', {
    name: 'VlGraticule',
    extends: __vue_component__$u,
    created: function created() {
      if (process.env.NODE_ENV !== 'production') {
        this.$logger.warn('VlGraticule component is deprecated. Use VlLayerGraticule component instead.');
      }
    }
  });
}

var GraticuleLayer = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$u,
  install: plugin$u,
  Layer: __vue_component__$u
});

var script$t = {
  name: 'VlLayerGroup',
  mixins: [layersContainer, baseLayer],
  computed: {
    layers: function layers() {
      if (!this.rev) return [];
      return map$1(this.getLayers(), function (layer) {
        return {
          id: getLayerId(layer),
          type: layer.constructor.name
        };
      });
    }
  },
  watch: {
    layers: {
      deep: true,
      handler: function handler(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit('update:layers', value.slice());
      }
    }
  },
  methods: {
    createLayer: function createLayer() {
      return new Group({
        // ol/layer/Base
        className: this.className,
        opacity: this.currentOpacity,
        visible: this.currentVisible,
        extent: this.currentExtentViewProj,
        zIndex: this.currentZIndex,
        minResolution: this.currentMinResolution,
        maxResolution: this.currentMaxResolution,
        minZoom: this.currentMinZoom,
        maxZoom: this.currentMaxZoom,
        // ol/layer/Group
        layers: this.$layersCollection
      });
    },
    getServices: function getServices() {
      return mergeDescriptors(baseLayer.methods.getServices.call(this), layersContainer.methods.getServices.call(this));
    },
    subscribeAll: function subscribeAll() {
      layersContainer.methods.subscribeAll.call(this);
      baseLayer.methods.subscribeAll.call(this);
    }
  }
};

/* script */
var __vue_script__$t = script$t;
/* template */

/* style */

var __vue_inject_styles__$t = undefined;
/* scoped */

var __vue_scope_id__$t = undefined;
/* module identifier */

var __vue_module_identifier__$t = undefined;
/* functional template */

var __vue_is_functional_template__$t = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$t = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$t, __vue_script__$t, __vue_scope_id__$t, __vue_is_functional_template__$t, __vue_module_identifier__$t, false, undefined, undefined, undefined);

function plugin$t(Vue) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$t.installed) {
    return;
  }

  plugin$t.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$t, options);
  Vue.component(__vue_component__$t.name, __vue_component__$t);
}

var GroupLayer = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$t,
  install: plugin$t,
  Layer: __vue_component__$t
});

function ownKeys$l(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$l(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$l(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$l(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var script$s = {
  name: 'VlLayerHeatmap',
  mixins: [vectorLayer],
  props: {
    /**
     * @type {string[]}
     */
    gradient: {
      type: Array,
      default: function _default() {
        return ['#0000ff', '#00ffff', '#00ff00', '#ffff00', '#ff0000'];
      }
    },

    /**
     * @type {number}
     */
    radius: {
      type: Number,
      default: 8
    },

    /**
     * @type {number}
     */
    blur: {
      type: Number,
      default: 15
    },

    /**
     * @type {string}
     */
    weight: {
      type: [String, Function],
      default: 'weight'
    }
  },
  data: function data() {
    return {
      currentGradient: this.gradient.slice(),
      currentRadius: this.radius,
      currentBlur: this.blur
    };
  },
  computed: {
    inputGradient: function inputGradient() {
      return this.gradient.slice();
    }
  },
  watch: _objectSpread$l({
    rev: function rev() {
      if (!this.$layer) return;

      if (!isEqual(this.currentGradient, this.$layer.getGradient())) {
        this.currentGradient = this.$layer.getGradient();
      }

      if (this.currentRadius !== this.$layer.getRadius()) {
        this.currentRadius = this.$layer.getRadius();
      }

      if (this.currentBlur !== this.$layer.getBlur()) {
        this.currentBlur = this.$layer.getBlur();
      }
    },
    inputGradient: function inputGradient(value) {
      this.setGradient(value);
    },
    currentGradient: {
      deep: true,
      handler: function handler(value) {
        if (isEqual(value, this.inputGradient)) return;
        this.$emit('update:gradient', value.slice());
      }
    },
    radius: function radius(value) {
      this.setRadius(value);
    },
    currentRadius: function currentRadius(value) {
      if (value === this.radius) return;
      this.$emit('update:radius', value);
    },
    blur: function blur(value) {
      this.setBlur(value);
    },
    currentBlur: function currentBlur(value) {
      if (value === this.blur) return;
      this.$emit('update:blur', value);
    }
  }, /*#__PURE__*/makeChangeOrRecreateWatchers(['weight'])),
  methods: {
    /**
     * @returns {HeatmapLayer}
     */
    createLayer: function createLayer() {
      return new Heatmap({
        // ol/layer/Base
        className: this.className,
        opacity: this.currentOpacity,
        visible: this.currentVisible,
        extent: this.currentExtentViewProj,
        zIndex: this.currentZIndex,
        minResolution: this.currentMinResolution,
        maxResolution: this.currentMaxResolution,
        minZoom: this.currentMinZoom,
        maxZoom: this.currentMaxZoom,
        // ol/layer/Layer
        render: this.render,
        source: this.$source,
        // ol/layer/BaseVector
        renderOrder: this.renderOrder,
        renderBuffer: this.renderBuffer,
        declutter: this.declutter,
        updateWhileAnimating: this.updateWhileAnimating,
        updateWhileInteracting: this.updateWhileInteracting,
        style: this.$style,
        // ol/layer/Heatmap
        blur: this.currentBlur,
        gradient: this.currentGradient,
        radius: this.currentRadius,
        weight: this.weight
      });
    },
    subscribeAll: function subscribeAll() {
      vectorLayer.methods.subscribeAll.call(this);
      subscribeToLayerEvents.call(this);
    },
    getBlur: function getBlur() {
      var _this$$layer;

      return coalesce((_this$$layer = this.$layer) === null || _this$$layer === void 0 ? void 0 : _this$$layer.getBlur(), this.currentBlur);
    },
    setBlur: function setBlur(blur) {
      blur = Number(blur);
      assert(isNumber(blur), 'Invalid blur');

      if (blur !== this.currentBlur) {
        this.currentBlur = blur;
      }

      if (this.$layer && blur !== this.$layer.getBlur()) {
        this.$layer.setBlur(blur);
      }
    },
    getGradient: function getGradient() {
      var _this$$layer2;

      return coalesce((_this$$layer2 = this.$layer) === null || _this$$layer2 === void 0 ? void 0 : _this$$layer2.getGradient(), this.currentGradient);
    },
    setGradient: function setGradient(gradient) {
      assert(isArray(gradient), 'Invalid gradient');
      gradient = gradient.slice();

      if (!isEqual(gradient, this.currentGradient)) {
        this.currentGradient = gradient;
      }

      if (this.$layer && !isEqual(gradient, this.$layer.getGradient())) {
        this.$layer.setGradient(gradient);
      }
    },
    getRadius: function getRadius() {
      var _this$$layer3;

      return coalesce((_this$$layer3 = this.$layer) === null || _this$$layer3 === void 0 ? void 0 : _this$$layer3.getRadius(), this.currentRadius);
    },
    setRadius: function setRadius(radius) {
      radius = Number(radius);
      assert(isNumber(radius), 'Invalid radius');

      if (radius !== this.currentRadius) {
        this.currentRadius = radius;
      }

      if (this.$layer && radius !== this.$layer.getRadius()) {
        this.$layer.setRadius(radius);
      }
    }
  }
};

function subscribeToLayerEvents() {
  var _this = this;

  var setterKey = addPrefix('set');
  var propChanges = fromOlChangeEvent(this.$layer, ['blur', 'gradient', 'radius'], true, function (evt) {
    return _objectSpread$l(_objectSpread$l({}, evt), {}, {
      setter: _this[setterKey(evt.prop)]
    });
  });
  this.subscribeTo(propChanges, function (_ref) {
    var setter = _ref.setter,
        value = _ref.value;
    return setter(value);
  });
}

/* script */
var __vue_script__$s = script$s;
/* template */

/* style */

var __vue_inject_styles__$s = undefined;
/* scoped */

var __vue_scope_id__$s = undefined;
/* module identifier */

var __vue_module_identifier__$s = undefined;
/* functional template */

var __vue_is_functional_template__$s = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$s = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$s, __vue_script__$s, __vue_scope_id__$s, __vue_is_functional_template__$s, __vue_module_identifier__$s, false, undefined, undefined, undefined);

function plugin$s(Vue) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$s.installed) {
    return;
  }

  plugin$s.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$s, options);
  Vue.component(__vue_component__$s.name, __vue_component__$s);
}

var HeatmapLayer = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$s,
  install: plugin$s,
  Layer: __vue_component__$s
});

function ownKeys$k(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$k(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$k(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$k(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var validateUrl$1 = /*#__PURE__*/and(isString, negate(isEmpty));
var script$r = {
  name: 'VlSourceImageArcgisRest',
  mixins: [arcgisSource, imageSource],
  props: {
    // ol/source/ImageArcGISRest
    crossOrigin: String,
    imageLoadFunction: Function,

    /**
     * @deprecated
     * @todo remove later
     */
    imageLoadFunc: Function,
    imageSmoothing: {
      type: Boolean,
      default: true
    },
    ratio: {
      type: Number,
      default: 1.5
    },
    url: {
      type: String,
      required: true,
      validator: validateUrl$1
    }
  },
  data: function data() {
    return {
      currentImageLoadFunction: this.imageLoadFunction,
      currentUrl: this.url
    };
  },
  computed: {
    inputImageLoadFunction: function inputImageLoadFunction() {
      return this.imageLoadFunction || this.imageLoadFunc;
    }
  },
  watch: _objectSpread$k({
    rev: function rev() {
      if (!this.$source) return;

      if (this.currentImageLoadFunction !== this.$source.getImageLoadFunction()) {
        this.currentImageLoadFunction = this.$source.getImageLoadFunction();
      }

      if (this.currentUrl !== this.$source.getUrl()) {
        this.currentUrl = this.$source.getUrl();
      }
    },
    url: function url(value) {
      this.setUrl(value);
    },
    currentUrl: function currentUrl(value) {
      if (value === this.url) return;
      this.$emit('update:url', value);
    },
    inputImageLoadFunction: function inputImageLoadFunction(value) {
      this.setImageLoadFunction(value);
    },
    currentImageLoadFunction: function currentImageLoadFunction(value) {
      if (value === this.imageLoadFunction) return;
      this.$emit('update:imageLoadFunction', value);
    }
  }, /*#__PURE__*/makeChangeOrRecreateWatchers(['crossOrigin', 'imageSmoothing', 'ratio'])),
  created: function created() {
    if (process.env.NODE_ENV !== 'production') {
      if (this.imageLoadFunc) {
        this.$logger.warn("'imageLoadFunc' prop is deprecated. Use 'imageLoadFunction' prop instead.");
      }
    }

    this.currentImageLoadFunction = this.inputImageLoadFunction;
  },
  updated: function updated() {
    if (process.env.NODE_ENV !== 'production') {
      if (this.imageLoadFunc) {
        this.$logger.warn("'imageLoadFunc' prop is deprecated. Use 'imageLoadFunction' prop instead.");
      }
    }
  },
  methods: {
    createSource: function createSource() {
      return new ImageArcGISRest({
        // ol/source/Source
        attributions: this.currentAttributions,
        projection: this.resolvedDataProjection,
        // ol/source/Image
        resolutions: this.inputResolutions,
        // ol/source/ImageArcGISRest
        crossOrigin: this.crossOrigin,
        hidpi: this.hidpi,
        imageLoadFunction: this.currentImageLoadFunction,
        imageSmoothing: this.imageSmoothing,
        params: this.currentParams,
        ratio: this.ratio,
        url: this.currentUrl
      });
    },
    getUrl: function getUrl() {
      var _this$$source;

      return coalesce((_this$$source = this.$source) === null || _this$$source === void 0 ? void 0 : _this$$source.getUrl(), this.currentUrl);
    },
    setUrl: function setUrl(url) {
      assert(validateUrl$1(url), 'Invalid url');

      if (url !== this.currentUrl) {
        this.currentUrl = url;
      }

      if (this.$source && url !== this.$source.getUrl()) {
        this.$source.setUrl(url);
      }
    },
    getImageLoadFunction: function getImageLoadFunction() {
      var _this$$source2;

      return coalesce((_this$$source2 = this.$source) === null || _this$$source2 === void 0 ? void 0 : _this$$source2.getImageLoadFunction(), this.currentImageLoadFunction);
    },
    setImageLoadFunction: function setImageLoadFunction(func) {
      assert(isFunction(func), 'Invalid image load function');

      if (func !== this.currentImageLoadFunction) {
        this.currentImageLoadFunction = func;
      }

      if (this.$source && func !== this.$source.getImageLoadFunction()) {
        this.$source.setImageLoadFunction(func);
      }
    },
    stateChanged: noop
  }
};

/* script */
var __vue_script__$r = script$r;
/* template */

/* style */

var __vue_inject_styles__$r = undefined;
/* scoped */

var __vue_scope_id__$r = undefined;
/* module identifier */

var __vue_module_identifier__$r = undefined;
/* functional template */

var __vue_is_functional_template__$r = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$r = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$r, __vue_script__$r, __vue_scope_id__$r, __vue_is_functional_template__$r, __vue_module_identifier__$r, false, undefined, undefined, undefined);

function plugin$r(Vue) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$r.installed) {
    return;
  }

  plugin$r.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$r, options);
  Vue.component(__vue_component__$r.name, __vue_component__$r);
}

var ImageArcgisRestSource = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$r,
  install: plugin$r,
  Source: __vue_component__$r
});

/**
 * Layer for server-rendered images that are available for arbitrary extents and resolutions.
 */

var script$q = {
  name: 'VlLayerImage',
  mixins: [imageLayer],
  methods: {
    /**
     * @return {Image}
     * @protected
     */
    createLayer: function createLayer() {
      return new Image$1({
        // ol/layer/Base
        className: this.className,
        opacity: this.currentOpacity,
        visible: this.currentVisible,
        extent: this.currentExtentViewProj,
        zIndex: this.currentZIndex,
        minResolution: this.currentMinResolution,
        maxResolution: this.currentMaxResolution,
        minZoom: this.currentMinZoom,
        maxZoom: this.currentMaxZoom,
        // ol/layer/Layer
        render: this.render,
        source: this.$source
      });
    }
  }
};

/* script */
var __vue_script__$q = script$q;
/* template */

/* style */

var __vue_inject_styles__$q = undefined;
/* scoped */

var __vue_scope_id__$q = undefined;
/* module identifier */

var __vue_module_identifier__$q = undefined;
/* functional template */

var __vue_is_functional_template__$q = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$q = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$q, __vue_script__$q, __vue_scope_id__$q, __vue_is_functional_template__$q, __vue_module_identifier__$q, false, undefined, undefined, undefined);

function plugin$q(Vue) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$q.installed) {
    return;
  }

  plugin$q.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$q, options);
  Vue.component(__vue_component__$q.name, __vue_component__$q);
}

var ImageLayer = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$q,
  install: plugin$q,
  Layer: __vue_component__$q
});

function ownKeys$j(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$j(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$j(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$j(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
/**
 * A layer source for displaying a single, static image.
 */

var script$p = {
  name: 'VlSourceImageStatic',
  mixins: [imageSource],
  props: {
    // ol/source/ImageStatic
    crossOrigin: String,

    /**
     * Image extent in the source projection.
     * @type {number[]}
     */
    imageExtent: {
      type: Array,
      // required: true,
      validator: function validator(value) {
        return value.length === 4;
      }
    },

    /**
     * @deprecated
     * @todo remove later
     */
    imgExtent: {
      type: Array,
      validator: function validator(value) {
        return value.length === 4;
      }
    },

    /**
     * @deprecated Use `imgExtent` instead.
     * @todo remove in v0.13.x
     */
    extent: {
      type: Array,
      validator: function validator(value) {
        return value.length === 4;
      }
    },

    /**
     * Optional function to load an image given a URL.
     * @type {function|undefined}
     */
    imageLoadFunction: Function,

    /**
     * @deprecated
     * @todo remove later
     */
    imgLoadFunc: Function,

    /**
     * @deprecated Use `imgLoadFunc` instead.
     * @todo remove in v0.13.x
     */
    loadFunc: Function,

    /**
     * Image size in pixels.
     * @type {number[]}
     */
    imageSize: {
      type: Array,
      validator: function validator(value) {
        return value.length === 2;
      }
    },

    /**
     * @deprecated
     * @todo remove later
     */
    imgSize: {
      type: Array,
      validator: function validator(value) {
        return value.length === 2;
      }
    },

    /**
     * @deprecated Use `imgSize` instead.
     * @todo remove in v0.13.x
     */
    size: {
      type: Array,
      validator: function validator(value) {
        return value.length === 2;
      }
    },

    /**
     * @type {boolean}
     */
    imageSmoothing: {
      type: Boolean,
      default: true
    },

    /**
     * Image URL.
     * @type {string}
     */
    url: {
      type: String,
      required: true,
      validator: /*#__PURE__*/negate(isEmpty)
    }
  },
  computed: {
    inputImageExtent: function inputImageExtent() {
      var _coalesce;

      return (_coalesce = coalesce(this.imageExtent, this.imgExtent, this.extent)) === null || _coalesce === void 0 ? void 0 : _coalesce.slice();
    },
    inputImageLoadFunction: function inputImageLoadFunction() {
      return coalesce(this.imageLoadFunction, this.imgLoadFunc, this.loadFunc);
    },
    inputImageSize: function inputImageSize() {
      var _coalesce2;

      return (_coalesce2 = coalesce(this.imageSize, this.imgSize, this.size)) === null || _coalesce2 === void 0 ? void 0 : _coalesce2.slice();
    }
  },
  watch: _objectSpread$j({}, /*#__PURE__*/makeChangeOrRecreateWatchers(['crossOrigin', 'inputImageExtent', 'inputImageLoadFunction', 'inputImageSize', 'imageSmoothing', 'url'], ['inputImageExtent', 'inputImageSize'])),
  created: function created() {
    if (process.env.NODE_ENV !== 'production') {
      if (this.extent) {
        this.$logger.warn("'extent' is deprecated. Use `imageExtent` prop instead.");
      }

      if (this.imgExtent) {
        this.$logger.warn("'imgExtent' is deprecated. Use `imageExtent` prop instead.");
      }

      if (this.loadFunc) {
        this.$logger.warn("'loadFunc' is deprecated. Use `imageLoadFunction` prop instead.");
      }

      if (this.imgLoadFunc) {
        this.$logger.warn("'imgLoadFunc' is deprecated. Use `imageLoadFunction` prop instead.");
      }

      if (this.size) {
        this.$logger.warn("'size' is deprecated. Use `imageSize` prop instead.");
      }

      if (this.imgSize) {
        this.$logger.warn("'imgSize' is deprecated. Use `imageSize` prop instead.");
      }
    }
  },
  updated: function updated() {
    if (process.env.NODE_ENV !== 'production') {
      if (this.extent) {
        this.$logger.warn("'extent' is deprecated. Use `imageExtent` prop instead.");
      }

      if (this.imgExtent) {
        this.$logger.warn("'imgExtent' is deprecated. Use `imageExtent` prop instead.");
      }

      if (this.loadFunc) {
        this.$logger.warn("'loadFunc' is deprecated. Use `imageLoadFunction` prop instead.");
      }

      if (this.imgLoadFunc) {
        this.$logger.warn("'imgLoadFunc' is deprecated. Use `imageLoadFunction` prop instead.");
      }

      if (this.size) {
        this.$logger.warn("'size' is deprecated. Use `imageSize` prop instead.");
      }

      if (this.imgSize) {
        this.$logger.warn("'imgSize' is deprecated. Use `imageSize` prop instead.");
      }
    }
  },
  methods: {
    /**
     * @return {ImageStatic}
     * @protected
     */
    createSource: function createSource() {
      return new ImageStatic({
        // ol/source/Source
        attributions: this.currentAttributions,
        projection: this.resolvedDataProjection,
        // ol/source/ImageStatic
        crossOrigin: this.crossOrigin,
        imageExtent: this.inputImageExtent,
        imageLoadFunction: this.inputImageLoadFunction,
        imageSize: this.inputImageSize,
        imageSmoothing: this.imageSmoothing,
        url: this.url
      });
    },
    getUrl: function getUrl() {
      var _this$$source;

      return coalesce((_this$$source = this.$source) === null || _this$$source === void 0 ? void 0 : _this$$source.getUrl(), this.url);
    },
    getImageExtent: function getImageExtent() {
      var _this$$source2;

      return coalesce((_this$$source2 = this.$source) === null || _this$$source2 === void 0 ? void 0 : _this$$source2.getImageExtent(), this.inputImageExtent);
    },
    stateChanged: noop
  }
};

/* script */
var __vue_script__$p = script$p;
/* template */

/* style */

var __vue_inject_styles__$p = undefined;
/* scoped */

var __vue_scope_id__$p = undefined;
/* module identifier */

var __vue_module_identifier__$p = undefined;
/* functional template */

var __vue_is_functional_template__$p = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$p = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$p, __vue_script__$p, __vue_scope_id__$p, __vue_is_functional_template__$p, __vue_module_identifier__$p, false, undefined, undefined, undefined);

function plugin$p(Vue) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$p.installed) {
    return;
  }

  plugin$p.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$p, options);
  Vue.component(__vue_component__$p.name, __vue_component__$p);
}

var ImageStaticSource = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$p,
  install: plugin$p,
  Source: __vue_component__$p
});

function ownKeys$i(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$i(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$i(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$i(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var validateUrl = /*#__PURE__*/and(isString, negate(isEmpty));
var script$o = {
  name: 'VlSourceImageWms',
  mixins: [wmsSource, imageSource],
  props: {
    // ol/source/ImageArcGISRest
    crossOrigin: String,
    imageLoadFunction: Function,

    /**
     * @deprecated
     * @todo remove later
     */
    imageLoadFunc: Function,
    imageSmoothing: {
      type: Boolean,
      default: true
    },
    ratio: {
      type: Number,
      default: 1.5
    },
    url: {
      type: String,
      required: true,
      validator: validateUrl
    }
  },
  data: function data() {
    return {
      currentImageLoadFunction: this.imageLoadFunction,
      currentUrl: this.url
    };
  },
  computed: {
    inputImageLoadFunction: function inputImageLoadFunction() {
      return this.imageLoadFunction || this.imageLoadFunc;
    }
  },
  watch: _objectSpread$i({
    rev: function rev() {
      if (!this.$source) return;

      if (this.currentUrl !== this.$source.getUrl()) {
        this.currentUrl = this.$source.getUrl();
      }

      if (this.currentImageLoadFunction !== this.$source.getImageLoadFunction()) {
        this.currentImageLoadFunction = this.$source.getImageLoadFunction();
      }
    },
    url: function url(value) {
      this.setUrl(value);
    },
    currentUrl: function currentUrl(value) {
      if (value === this.url) return;
      this.$emit('update:url', value);
    },
    inputImageLoadFunction: function inputImageLoadFunction(value) {
      this.setImageLoadFunction(value);
    },
    currentImageLoadFunc: function currentImageLoadFunc(value) {
      if (value === this.imageLoadFunction) return;
      this.$emit('update:imageLoadFunction', value);
    }
  }, /*#__PURE__*/makeChangeOrRecreateWatchers(['crossOrigin', 'imageSmoothing', 'ratio'])),
  created: function created() {
    if (process.env.NODE_ENV !== 'production') {
      if (this.imageLoadFunc) {
        this.$logger.warn("'imageLoadFunc' prop is deprecated. Use 'imageLoadFunction' prop instead.");
      }
    }

    this.currentImageLoadFunction = this.inputImageLoadFunction;
  },
  updated: function updated() {
    if (process.env.NODE_ENV !== 'production') {
      if (this.imageLoadFunc) {
        this.$logger.warn("'imageLoadFunc' prop is deprecated. Use 'imageLoadFunction' prop instead.");
      }
    }
  },
  methods: {
    createSource: function createSource() {
      return new ImageWMS({
        // ol/source/Source
        attributions: this.currentAttributions,
        projection: this.resolvedDataProjection,
        // ol/source/Image
        resolutions: this.inputResolutions,
        // ol/source/ImageWMS
        crossOrigin: this.crossOrigin,
        hidpi: this.hidpi,
        serverType: this.serverType,
        imageLoadFunction: this.currentImageLoadFunction,
        imageSmoothing: this.imageSmoothing,
        params: this.currentParams,
        ratio: this.ratio,
        url: this.currentUrl
      });
    },
    getUrl: function getUrl() {
      var _this$$source;

      return coalesce((_this$$source = this.$source) === null || _this$$source === void 0 ? void 0 : _this$$source.getUrl(), this.currentUrl);
    },
    setUrl: function setUrl(url) {
      assert(validateUrl(url), 'Invalid url');

      if (url !== this.currentUrl) {
        this.currentUrl = url;
      }

      if (this.$source && url !== this.$source.getUrl()) {
        this.$source.setUrls(url);
      }
    },
    getImageLoadFunction: function getImageLoadFunction() {
      var _this$$source2;

      return coalesce((_this$$source2 = this.$source) === null || _this$$source2 === void 0 ? void 0 : _this$$source2.getImageLoadFunction(), this.currentImageLoadFunction);
    },
    setImageLoadFunction: function setImageLoadFunction(func) {
      assert(isFunction(func), 'Invalid image load function');

      if (func !== this.currentImageLoadFunction) {
        this.currentImageLoadFunction = func;
      }

      if (this.$source && func !== this.$source.getImageLoadFunction()) {
        this.$source.setImageLoadFunction(func);
      }
    },
    stateChanged: noop
  }
};

/* script */
var __vue_script__$o = script$o;
/* template */

/* style */

var __vue_inject_styles__$o = undefined;
/* scoped */

var __vue_scope_id__$o = undefined;
/* module identifier */

var __vue_module_identifier__$o = undefined;
/* functional template */

var __vue_is_functional_template__$o = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$o = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$o, __vue_script__$o, __vue_scope_id__$o, __vue_is_functional_template__$o, __vue_module_identifier__$o, false, undefined, undefined, undefined);

function plugin$o(Vue) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$o.installed) {
    return;
  }

  plugin$o.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$o, options);
  Vue.component(__vue_component__$o.name, __vue_component__$o);
}

var ImageWmsSource = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$o,
  install: plugin$o,
  Source: __vue_component__$o
});

/**
 * Layer for data that is rendered client-side.
 */

var script$n = {
  name: 'VlLayerVector',
  mixins: [vectorLayer],
  props: {
    /**
     * @deprecated Use `vl-layer-vector-image` to render vector layer as image
     * @todo remove in v0.13.x
     */
    renderMode: String
  },
  created: function created() {
    if (process.env.NODE_ENV !== 'production') {
      if (this.renderMode) {
        this.$logger.warn("'renderMode' is deprecated. Use vl-layer-vector-image to render vector layer as image");
      }
    }
  },
  updated: function updated() {
    if (process.env.NODE_ENV !== 'production') {
      if (this.renderMode) {
        this.$logger.warn("'renderMode' is deprecated. Use vl-layer-vector-image to render vector layer as image");
      }
    }
  },
  methods: {
    /**
     * @return {module:ol/layer/Vector~VectorLayer}
     * @protected
     */
    createLayer: function createLayer() {
      return new Vector$1({
        // ol/layer/Base
        className: this.className,
        opacity: this.currentOpacity,
        visible: this.currentVisible,
        extent: this.currentExtentViewProj,
        zIndex: this.currentZIndex,
        minResolution: this.currentMinResolution,
        maxResolution: this.currentMaxResolution,
        minZoom: this.currentMinZoom,
        maxZoom: this.currentMaxZoom,
        // ol/layer/Layer
        render: this.render,
        source: this.$source,
        // ol/layer/BaseVector
        renderOrder: this.renderOrder,
        renderBuffer: this.renderBuffer,
        declutter: this.declutter,
        updateWhileAnimating: this.updateWhileAnimating,
        updateWhileInteracting: this.updateWhileInteracting,
        style: this.$style
      });
    }
  }
};

/* script */
var __vue_script__$n = script$n;
/* template */

/* style */

var __vue_inject_styles__$n = undefined;
/* scoped */

var __vue_scope_id__$n = undefined;
/* module identifier */

var __vue_module_identifier__$n = undefined;
/* functional template */

var __vue_is_functional_template__$n = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$n = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$n, __vue_script__$n, __vue_scope_id__$n, __vue_is_functional_template__$n, __vue_module_identifier__$n, false, undefined, undefined, undefined);

function plugin$n(Vue) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$n.installed) {
    return;
  }

  plugin$n.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$n, options);
  Vue.component(__vue_component__$n.name, __vue_component__$n);
}

var VectorLayer = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$n,
  install: plugin$n,
  Layer: __vue_component__$n
});

var script$m = {
  name: 'VlSourceVector',
  mixins: [vectorSource]
};

/* script */
var __vue_script__$m = script$m;
/* template */

/* style */

var __vue_inject_styles__$m = undefined;
/* scoped */

var __vue_scope_id__$m = undefined;
/* module identifier */

var __vue_module_identifier__$m = undefined;
/* functional template */

var __vue_is_functional_template__$m = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$m = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$m, __vue_script__$m, __vue_scope_id__$m, __vue_is_functional_template__$m, __vue_module_identifier__$m, false, undefined, undefined, undefined);

function plugin$m(Vue) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$m.installed) {
    return;
  }

  plugin$m.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$m, options);
  Vue.component(__vue_component__$m.name, __vue_component__$m);
}

var VectorSource = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$m,
  install: plugin$m,
  Source: __vue_component__$m
});

function ownKeys$h(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$h(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$h(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$h(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
/**
 * Represents a simple **2D view** of the map. This is the component to act upon to change the **center**,
 * **resolution**, and **rotation** of the map.
 */

var script$l = {
  name: 'VlView',
  mixins: [projTransforms, olCmp, waitForMap],
  stubVNode: {
    empty: function empty() {
      return this.vmId;
    }
  },
  props: {
    /**
     * @type {number[]}
     */
    center: {
      type: Array,
      default: function _default() {
        return [0, 0];
      },
      validator: function validator(value) {
        return value.length === 2 && value.every(isNumber);
      }
    },

    /**
     * @type {boolean}
     */
    constrainOnlyCenter: Boolean,

    /**
     * @type {number[]|undefined}
     */
    extent: {
      type: Array,
      validator: function validator(value) {
        return value.length === 4 && value.every(isNumber);
      }
    },

    /**
     * @type {boolean}
     */
    smoothExtentConstraint: {
      type: Boolean,
      default: true
    },

    /**
     * @type {number}
     */
    rotation: {
      type: Number,
      default: 0
    },

    /**
     * @type {boolean}
     */
    enableRotation: {
      type: Boolean,
      default: true
    },

    /**
     * @type {boolean|number}
     */
    constrainRotation: {
      type: [Boolean, Number],
      default: true
    },

    /**
     * @type {number|undefined}
     */
    resolution: Number,

    /**
     * @type {number[]|undefined}
     */
    resolutions: {
      type: Array,
      validator: function validator(value) {
        return value.every(isNumber);
      }
    },

    /**
     * @type {number|undefined}
     */
    maxResolution: Number,

    /**
     * @type {number|undefined}
     */
    minResolution: Number,

    /**
     * @type {boolean}
     */
    constrainResolution: Boolean,

    /**
     * @type {boolean}
     */
    smoothResolutionConstraint: {
      type: Boolean,
      default: true
    },

    /**
     * @type {number}
     */
    zoom: {
      type: Number,
      default: 0
    },

    /**
     * @type {number}
     */
    zoomFactor: {
      type: Number,
      default: 2
    },

    /**
     * @type {number}
     */
    maxZoom: {
      type: Number,
      default: 28
    },

    /**
     * @type {number}
     */
    minZoom: {
      type: Number,
      default: 0
    },

    /**
     * @type {boolean}
     */
    multiWorld: Boolean,

    /**
     * @type {string}
     */
    projection: {
      type: String,
      default: EPSG_3857,
      validator: function validator(value) {
        return get(value) != null;
      }
    },
    showFullExtent: Boolean
  },
  data: function data() {
    var _this$resolutions;

    return {
      dataProjection: this.projection,
      currentProjection: this.projection,
      currentCenterViewProj: roundPointCoords(this.center),
      currentZoom: this.zoom,
      currentRotation: this.rotation,
      currentResolution: this.resolution,
      currentMinZoom: this.minZoom,
      currentMaxZoom: this.maxZoom,
      currentResolutions: (_this$resolutions = this.resolutions) === null || _this$resolutions === void 0 ? void 0 : _this$resolutions.slice(),
      currentMaxResolution: this.maxResolution,
      currentMinResolution: this.minResolution
    };
  },
  computed: {
    centerDataProj: function centerDataProj() {
      return roundPointCoords(this.center);
    },
    centerViewProj: function centerViewProj() {
      return this.pointToViewProj(this.center);
    },
    currentCenterDataProj: function currentCenterDataProj() {
      return this.pointToDataProj(this.currentCenterViewProj);
    },
    extentDataProj: function extentDataProj() {
      return roundExtent(this.extent);
    },
    extentViewProj: function extentViewProj() {
      return this.extentToViewProj(this.extent);
    },
    inputResolutions: function inputResolutions() {
      var _this$resolutions2;

      return (_this$resolutions2 = this.resolutions) === null || _this$resolutions2 === void 0 ? void 0 : _this$resolutions2.slice();
    },
    visibleExtentDataProj: function visibleExtentDataProj() {
      var _this$getExtent;

      if (!this.rev) return;
      return (_this$getExtent = this.getExtent()) === null || _this$getExtent === void 0 ? void 0 : _this$getExtent.slice();
    },
    visibleExtentViewProj: function visibleExtentViewProj() {
      var _this$getExtent2;

      if (!this.rev) return;
      return (_this$getExtent2 = this.getExtent(true)) === null || _this$getExtent2 === void 0 ? void 0 : _this$getExtent2.slice();
    },
    animating: function animating() {
      return !!(this.rev && this.getAnimating());
    },
    interacting: function interacting() {
      return !!(this.rev && this.getInteracting());
    },
    resolvedViewProjection: function resolvedViewProjection() {
      return this.currentProjection;
    }
  },
  watch: _objectSpread$h({
    rev: function rev() {
      if (!this.$view) return;

      if (this.currentProjection !== this.$view.getProjection().getCode()) {
        this.currentProjection = this.$view.getProjection().getCode();
      }

      if (!isEqual(this.currentCenterViewProj, this.$view.getCenter())) {
        this.currentCenterViewProj = this.$view.getCenter();
      }

      if (this.currentZoom !== this.$view.getZoom()) {
        this.currentZoom = this.$view.getZoom();
      }

      if (this.currentRotation !== this.$view.getRotation()) {
        this.currentRotation = this.$view.getRotation();
      }

      if (this.currentResolution !== this.$view.getResolution()) {
        this.currentResolution = this.$view.getResolution();
      }

      if (this.currentMinZoom !== this.$view.getMinZoom()) {
        this.currentMinZoom = this.$view.getMinZoom();
      }

      if (this.currentMaxZoom !== this.$view.getMaxZoom()) {
        this.currentMaxZoom = this.$view.getMaxZoom();
      }

      if (!isEqual(this.currentResolutions, this.$view.getResolutions())) {
        this.currentResolutions = this.$view.getResolutions();
      }

      if (this.currentMaxResolution !== this.$view.getMaxResolution()) {
        this.currentMaxResolution = this.$view.getMaxResolution();
      }

      if (this.currentMinResolution !== this.$view.getMinResolution()) {
        this.currentMinResolution = this.$view.getMinResolution();
      }
    },
    centerViewProj: {
      deep: true,
      handler: function handler(value, prev) {
        if (this.getAnimating()) return;
        this.setCenter(value, true);
      }
    },
    currentCenterDataProj: {
      deep: true,
      handler: function handler(value, prev) {
        if (isEqual(value, this.centerDataProj)) return;
        this.$emit('update:center', value.slice());
      }
    },
    rotation: function rotation(value) {
      if (this.getAnimating()) return;
      this.setRotation(value);
    },
    currentRotation: function currentRotation(value) {
      if (value === this.rotation) return;
      this.$emit('update:rotation', value);
    },
    resolution: function resolution(value) {
      if (this.getAnimating()) return;
      this.setResolution(value);
    },
    currentResolution: function currentResolution(value) {
      if (value === this.resolution) return;
      this.$emit('update:resolution', value);
    },
    constrainResolution: function constrainResolution(value) {
      this.setConstrainResolution(value);
    },
    zoom: function zoom(value) {
      if (this.getAnimating()) return;
      this.setZoom(value);
    },
    currentZoom: function currentZoom(value) {
      if (value === this.zoom) return;
      this.$emit('update:zoom', value);
    },
    minZoom: function minZoom(value) {
      this.setMinZoom(value);
    },
    currentMinZoom: function currentMinZoom(value) {
      if (value === this.minZoom) return;
      this.$emit('update:minZoom', value);
    },
    maxZoom: function maxZoom(value) {
      this.setMaxZoom(value);
    },
    currentMaxZoom: function currentMaxZoom(value) {
      if (value === this.maxZoom) return;
      this.$emit('update:maxZoom', value);
    },
    inputResolutions: {
      deep: true,
      handler: function handler(value) {
        if (value === this.currentResolutions) return;

        if (process.env.VUELAYERS_DEBUG) {
          this.$logger.log('resolutions changed, scheduling recreate... %O ===> %O', this.currentResolutions, value);
        }

        this.currentResolutions = value === null || value === void 0 ? void 0 : value.slice();
        return this.scheduleRecreate();
      }
    },
    currentResolutions: {
      deep: true,
      handler: function handler(value) {
        if (isEqual(value, this.inputResolutions)) return;
        this.$emit('update:resolutions', value === null || value === void 0 ? void 0 : value.slice());
      }
    },
    maxResolution: function maxResolution(value) {
      if (value === this.currentMaxResolution) return;

      if (process.env.VUELAYERS_DEBUG) {
        this.$logger.log('maxResolution changed, scheduling recreate... %O ===> %O', this.currentMaxResolution, value);
      }

      this.currentMaxResolution = value;
      return this.scheduleRecreate();
    },
    currentMaxResolution: function currentMaxResolution(value) {
      if (value === this.maxResolution) return;
      this.$emit('update:maxResolution', value);
    },
    minResolution: function minResolution(value) {
      if (value === this.currentMinResolution) return;

      if (process.env.VUELAYERS_DEBUG) {
        this.$logger.log('minResolution changed, scheduling recreate... %O ===> %O', this.currentMinResolution, value);
      }

      this.currentMinResolution = value;
      return this.scheduleRecreate();
    },
    currentMinResolution: function currentMinResolution(value) {
      if (value === this.minResolution) return;
      this.$emit('update:minResolution', value);
    },
    projection: function projection(value) {
      var _this$inputResolution;

      if (value === this.currentProjection) return;

      if (process.env.VUELAYERS_DEBUG) {
        this.$logger.log('projection changed, scheduling recreate... %O ===> %O', this.currentProjection, value);
      }

      this.currentProjection = this.dataProjection = value; // reset current resolution fields to inputs
      // so zoom fields will take precedence

      this.currentResolution = this.resolution;
      this.currentResolutions = (_this$inputResolution = this.inputResolutions) === null || _this$inputResolution === void 0 ? void 0 : _this$inputResolution.slice();
      this.currentMaxResolution = this.maxResolution;
      this.currentMinResolution = this.minResolution;
      return this.scheduleRecreate();
    },
    currentProjection: function currentProjection(value) {
      if (value === this.projection) return;
      this.$emit('update:projection', value);
    },
    animating: function animating(value, prev) {
      if (value === prev) return;
      this.$emit('update:animating', value);
    },
    interacting: function interacting(value, prev) {
      if (value === prev) return;
      this.$emit('update:interacting', value);
    },
    visibleExtentDataProj: {
      deep: true,
      handler: function handler(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit('update:visibleExtent', value === null || value === void 0 ? void 0 : value.slice());
      }
    }
  }, /*#__PURE__*/makeChangeOrRecreateWatchers(['constrainOnlyCenter', 'smoothExtentConstraint', 'enableRotation', 'constrainRotation', 'constrainResolution', 'smoothResolutionConstraint', 'zoomFactor', 'multiWorld', 'extentViewProj'], ['extentViewProj'])),
  created: function created() {
    defineServices$3.call(this);
    this.currentCenterViewProj = this.centerViewProj.slice();
  },
  methods: {
    /**
     * @return {Promise<void>}
     * @protected
     */
    beforeInit: function beforeInit() {
      var _this = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return Promise.all([olCmp.methods.beforeInit.call(_this), waitForMap.methods.beforeInit.call(_this)]);

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    },

    /**
     * @return {module:ol/View~View}
     * @protected
     */
    createOlObject: function createOlObject() {
      var view = new View({
        center: this.currentCenterViewProj,
        constrainOnlyCenter: this.constrainOnlyCenter,
        extent: this.extentViewProj,
        smoothExtentConstraint: this.smoothExtentConstraint,
        rotation: this.currentRotation,
        enableRotation: this.enableRotation,
        constrainRotation: this.constrainRotation,
        resolution: this.currentResolution,
        resolutions: this.currentResolutions,
        maxResolution: this.currentMaxResolution,
        minResolution: this.currentMinResolution,
        constrainResolution: this.constrainResolution,
        smoothResolutionConstraint: this.smoothResolutionConstraint,
        zoom: this.currentZoom,
        zoomFactor: this.zoomFactor,
        maxZoom: this.currentMaxZoom,
        minZoom: this.currentMinZoom,
        multiWorld: this.multiWorld,
        projection: this.currentProjection,
        showFullExtent: this.showFullExtent
      });
      initializeView(view, this.currentId);
      return view;
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    mount: function mount() {
      var _this2 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
        var _this2$$viewContainer;

        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                (_this2$$viewContainer = _this2.$viewContainer) === null || _this2$$viewContainer === void 0 ? void 0 : _this2$$viewContainer.setView(_this2);
                return _context2.abrupt("return", olCmp.methods.mount.call(_this2));

              case 2:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }))();
    },

    /**
     * @return {void}
     * @protected
     */
    unmount: function unmount() {
      var _this3 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
        var _this3$$viewContainer;

        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (((_this3$$viewContainer = _this3.$viewContainer) === null || _this3$$viewContainer === void 0 ? void 0 : _this3$$viewContainer.getViewVm()) === _this3) {
                  _this3.$viewContainer.setView(null);
                }

                return _context3.abrupt("return", olCmp.methods.unmount.call(_this3));

              case 2:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }))();
    },

    /**
     * @return {void}
     * @protected
     */
    subscribeAll: function subscribeAll() {
      olCmp.methods.subscribeAll.call(this);
      subscribeToEvents$1.call(this);
    },

    /**
     * @return {*}
     * @protected
     */
    getIdInternal: function getIdInternal() {
      return getViewId(this.$view);
    },

    /**
     * @param {*} id
     * @protected
     */
    setIdInternal: function setIdInternal(id) {
      if (id === this.getIdInternal()) return;
      setViewId(this.$view, id);
    },

    /**
     * @return {Promise<module:ol/View~View>}
     */
    resolveView: olCmp.methods.resolveOlObject,

    /**
     * @see {@link https://openlayers.org/en/latest/apidoc/module-ol_View-View.html#animate}
     * @param {...(module:ol/View~AnimationOptions|function(boolean))} args
     * @return {Promise<boolean>} Resolves when animation completes
     */
    animate: function animate() {
      var _arguments = arguments,
          _this4 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {
        var _len, args, _key, cb, view;

        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                for (_len = _arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                  args[_key] = _arguments[_key];
                }

                cb = noop;

                if (isFunction(args[args.length - 1])) {
                  cb = args[args.length - 1];
                  args = args.slice(0, args.length - 1);
                }

                args.forEach(function (opts) {
                  if (!isArray(opts.center)) return;

                  if (!opts.viewProj) {
                    opts.center = _this4.pointToViewProj(opts.center);
                  }
                });
                _context4.next = 6;
                return _this4.resolveView();

              case 6:
                view = _context4.sent;
                return _context4.abrupt("return", new Promise(function (resolve) {
                  view.animate.apply(view, _toConsumableArray(args).concat([function (complete) {
                    cb(complete);
                    resolve(complete);
                  }]));
                }));

              case 8:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }))();
    },

    /**
     * @see {@link https://openlayers.org/en/latest/apidoc/module-ol_View-View.html#fit}
     * @param {Object|module:ol/geom/SimpleGeometry~SimpleGeometry|module:ol/extent~Extent} geometryOrExtent
     * @param {module:ol/View~FitOptions} [options]
     * @return {Promise<boolean>} Resolves when view changes
     */
    fit: function fit(geometryOrExtent) {
      var _arguments2 = arguments,
          _this5 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {
        var options, cb, view;
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                options = _arguments2.length > 1 && _arguments2[1] !== undefined ? _arguments2[1] : {};

                if (!isGeoJSONGeometry(geometryOrExtent)) {
                  _context5.next = 5;
                  break;
                }

                if (options.viewProj) {
                  geometryOrExtent = _this5.readGeometryInViewProj(geometryOrExtent);
                } else {
                  geometryOrExtent = _this5.readGeometryInDataProj(geometryOrExtent);
                }

                _context5.next = 9;
                break;

              case 5:
                if (!isFunction(geometryOrExtent.resolveOlObject)) {
                  _context5.next = 9;
                  break;
                }

                _context5.next = 8;
                return geometryOrExtent.resolveOlObject();

              case 8:
                geometryOrExtent = _context5.sent;

              case 9:
                cb = options.callback || noop;
                _context5.next = 12;
                return _this5.resolveView();

              case 12:
                view = _context5.sent;
                return _context5.abrupt("return", new Promise(function (resolve) {
                  view.fit(geometryOrExtent, _objectSpread$h(_objectSpread$h({}, options), {}, {
                    callback: function callback(complete) {
                      cb(complete);
                      resolve(complete);
                    }
                  }));
                }));

              case 14:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5);
      }))();
    },

    /**
     * @return {Promise<void>}
     */
    cancelAnimations: function cancelAnimations() {
      var _this6 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {
        return _regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                _context6.next = 2;
                return _this6.resolveView();

              case 2:
                _context6.sent.cancelAnimations();

              case 3:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6);
      }))();
    },

    /**
     * @return {boolean}
     */
    getAnimating: function getAnimating() {
      var _this$$view;

      return coalesce((_this$$view = this.$view) === null || _this$$view === void 0 ? void 0 : _this$$view.getAnimating(), false);
    },

    /**
     * @return {Promise<void>}
     */
    beginInteraction: function beginInteraction() {
      var _this7 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {
        return _regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                _context7.next = 2;
                return _this7.resolveView();

              case 2:
                _context7.sent.beginInteraction();

              case 3:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7);
      }))();
    },

    /**
     * @param {number} [duration]
     * @param {number} [resolutionDirection]
     * @param {number[]} [anchor]
     * @param {boolean} [viewProj=false]
     * @return {Promise<void>}
     */
    endInteraction: function endInteraction(duration, resolutionDirection, anchor) {
      var _arguments3 = arguments,
          _this8 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {
        var viewProj;
        return _regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                viewProj = _arguments3.length > 3 && _arguments3[3] !== undefined ? _arguments3[3] : false;

                if (!viewProj) {
                  anchor = _this8.pointToViewProj(anchor);
                }

                _context8.next = 4;
                return _this8.resolveView();

              case 4:
                _context8.sent.endInteraction(duration, resolutionDirection, anchor);

              case 5:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8);
      }))();
    },

    /**
     * @return {boolean}
     */
    getInteracting: function getInteracting() {
      var _this$$view2;

      return coalesce((_this$$view2 = this.$view) === null || _this$$view2 === void 0 ? void 0 : _this$$view2.getInteracting(), false);
    },

    /**
     * @param {number[]|undefined} [size]
     * @param {boolean} [viewProj=false]
     * @return {Promise<number[]>}
     */
    calculateExtent: function calculateExtent(size) {
      var _arguments4 = arguments,
          _this9 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {
        var viewProj, extent;
        return _regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                viewProj = _arguments4.length > 1 && _arguments4[1] !== undefined ? _arguments4[1] : false;
                _context9.next = 3;
                return _this9.resolveView();

              case 3:
                extent = _context9.sent.calculateExtent(size);

                if (!viewProj) {
                  _context9.next = 6;
                  break;
                }

                return _context9.abrupt("return", roundExtent(extent));

              case 6:
                return _context9.abrupt("return", _this9.extentToDataProj(extent));

              case 7:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9);
      }))();
    },

    /**
     * @param {boolean} [viewProj=false]
     * @return {number[]|undefined}
     */
    getExtent: function getExtent() {
      var viewProj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      if (!this.$view) return;
      var extent = this.$view.calculateExtent();
      if (viewProj) return roundExtent(extent);
      return this.extentToDataProj(extent);
    },

    /**
     * @param {number[]} coordinate
     * @param {number[]} size
     * @param {number[]} position
     * @param {boolean} [viewProj=false]
     * @return {Promise<void>}
     */
    centerOn: function centerOn(coordinate, size, position) {
      var _arguments5 = arguments,
          _this10 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {
        var viewProj;
        return _regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                viewProj = _arguments5.length > 3 && _arguments5[3] !== undefined ? _arguments5[3] : false;

                if (!viewProj) {
                  coordinate = _this10.pointToViewProj(coordinate);
                }

                _context10.next = 4;
                return _this10.resolveView();

              case 4:
                _context10.sent.centerOn(coordinate, size, position);

              case 5:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10);
      }))();
    },

    /**
     * @param {boolean} [viewProj=false]
     * @return {number[]}
     */
    getCenter: function getCenter() {
      var viewProj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (!this.$view) {
        return viewProj ? this.currentCenterViewProj : this.currentCenterDataProj;
      }

      var center = this.$view.getCenter();
      if (viewProj) return center;
      return this.pointToDataProj(center);
    },

    /**
     * @param {number[]} center
     * @param {boolean} [viewProj=false]
     */
    setCenter: function setCenter(center) {
      var viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      assert(isArray(center) && center.length === 2, 'Invalid center');

      if (viewProj) {
        center = roundPointCoords(center);
      } else {
        center = this.pointToViewProj(center);
      }

      if (!isEqual(center, this.currentCenterViewProj)) {
        this.currentCenterViewProj = center;
      }

      if (this.$view && !isEqual(center, this.$view.getCenter())) {
        this.$view.setCenter(center);
      }
    },

    /**
     * @return {number}
     */
    getResolution: function getResolution() {
      var _this$$view3;

      return coalesce((_this$$view3 = this.$view) === null || _this$$view3 === void 0 ? void 0 : _this$$view3.getResolution(), this.currentResolution);
    },

    /**
     * @param {number} resolution
     */
    setResolution: function setResolution(resolution) {
      resolution = Number(resolution);
      assert(isNumber(resolution), 'Invalid resolution');

      if (resolution !== this.currentResolution) {
        this.currentResolution = resolution;
      }

      if (this.$view && resolution !== this.$view.getResolution()) {
        this.$view.setResolution(resolution);
      }
    },

    /**
     * @param {number[]} extent
     * @param {number[]} size
     * @param {boolean} [viewProj=false]
     * @return {Promise<number>}
     */
    getResolutionForExtent: function getResolutionForExtent(extent, size) {
      var _arguments6 = arguments,
          _this11 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11() {
        var viewProj;
        return _regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                viewProj = _arguments6.length > 2 && _arguments6[2] !== undefined ? _arguments6[2] : false;

                if (!viewProj) {
                  extent = _this11.extentToViewProj(extent);
                }

                _context11.next = 4;
                return _this11.resolveView();

              case 4:
                return _context11.abrupt("return", _context11.sent.getResolutionForExtent(extent, size));

              case 5:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11);
      }))();
    },

    /**
     * @param {number} zoom
     * @return {Promise<number>}
     */
    getResolutionForZoom: function getResolutionForZoom(zoom) {
      var _this12 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12() {
        return _regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return _this12.resolveView();

              case 2:
                return _context12.abrupt("return", _context12.sent.getResolutionForZoom(zoom));

              case 3:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12);
      }))();
    },

    /**
     * @return {number[]|undefined}
     */
    getResolutions: function getResolutions() {
      var _this$$view4;

      return coalesce((_this$$view4 = this.$view) === null || _this$$view4 === void 0 ? void 0 : _this$$view4.getResolutions(), this.currentResolutions);
    },

    /**
     * @return {number|undefined}
     */
    getMaxResolution: function getMaxResolution() {
      var _this$$view5;

      return coalesce((_this$$view5 = this.$view) === null || _this$$view5 === void 0 ? void 0 : _this$$view5.getMaxResolution(), this.currentMaxResolution);
    },

    /**
     * @return {number|undefined}
     */
    getMinResolution: function getMinResolution() {
      var _this$$view6;

      return coalesce((_this$$view6 = this.$view) === null || _this$$view6 === void 0 ? void 0 : _this$$view6.getMinResolution(), this.currentMinResolution);
    },

    /**
     * @return {number|undefined}
     */
    getZoom: function getZoom() {
      var _this$$view7;

      return coalesce((_this$$view7 = this.$view) === null || _this$$view7 === void 0 ? void 0 : _this$$view7.getZoom(), this.currentZoom);
    },

    /**
     * @param {number} zoom
     */
    setZoom: function setZoom(zoom) {
      zoom = Number(zoom);
      assert(isNumber(zoom), 'Invalid zoom');

      if (zoom !== this.currentZoom) {
        this.currentZoom = zoom;
      }

      if (this.$view && zoom !== this.$view.getZoom()) {
        this.$view.setZoom(zoom);
      }
    },

    /**
     * @param {number} resolution
     * @return {Promise<number|undefined>}
     */
    getZoomForResolution: function getZoomForResolution(resolution) {
      var _this13 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13() {
        return _regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                _context13.next = 2;
                return _this13.resolveView();

              case 2:
                return _context13.abrupt("return", _context13.sent.getZoomForResolution(resolution));

              case 3:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13);
      }))();
    },

    /**
     * @return {number|undefined}
     */
    getMaxZoom: function getMaxZoom() {
      var _this$$view8;

      return coalesce((_this$$view8 = this.$view) === null || _this$$view8 === void 0 ? void 0 : _this$$view8.getMaxZoom(), this.currentMaxZoom);
    },

    /**
     * @param {number} zoom
     */
    setMaxZoom: function setMaxZoom(zoom) {
      zoom = Number(zoom);
      assert(isNumber(zoom), 'Invalid maxZoom');

      if (zoom !== this.currentMaxZoom) {
        this.currentMaxZoom = zoom;
      }

      if (this.$view && zoom !== this.$view.getMaxZoom()) {
        this.$view.setMaxZoom(zoom);
      }
    },

    /**
     * @return {number|undefined}
     */
    getMinZoom: function getMinZoom() {
      var _this$$view9;

      return coalesce((_this$$view9 = this.$view) === null || _this$$view9 === void 0 ? void 0 : _this$$view9.getMinZoom(), this.currentMinZoom);
    },

    /**
     * @param {number} zoom
     */
    setMinZoom: function setMinZoom(zoom) {
      zoom = Number(zoom);
      assert(isNumber(zoom), 'Invalid minZoom');

      if (zoom !== this.currentMinZoom) {
        this.currentMinZoom = zoom;
      }

      if (this.$view && zoom !== this.$view.getMinZoom()) {
        this.$view.setMinZoom(zoom);
      }
    },

    /**
     * @return {module:ol/proj/ProjectionLike}
     */
    getProjection: function getProjection() {
      var _this$$view10;

      return coalesce((_this$$view10 = this.$view) === null || _this$$view10 === void 0 ? void 0 : _this$$view10.getProjection(), get(this.currentProjection));
    },

    /**
     * @return {number|undefined}
     */
    getRotation: function getRotation() {
      var _this$$view11;

      return coalesce((_this$$view11 = this.$view) === null || _this$$view11 === void 0 ? void 0 : _this$$view11.getRotation(), this.currentRotation);
    },

    /**
     * @param {number} rotation
     */
    setRotation: function setRotation(rotation) {
      rotation = Number(rotation);
      assert(isNumber(rotation), 'Invalid rotation');

      if (rotation !== this.currentRotation) {
        this.currentRotation = rotation;
      }

      if (this.$view && rotation !== this.$view.getRotation()) {
        this.$view.setRotation(rotation);
      }
    }
  }
};

function defineServices$3() {
  var _this14 = this;

  Object.defineProperties(this, {
    /**
     * @type {module:ol/View~View|undefined}
     */
    $view: {
      enumerable: true,
      get: function get() {
        return _this14.$olObject;
      }
    },

    /**
     * @type {Object|undefined}
     */
    $viewContainer: {
      enumerable: true,
      get: function get() {
        var _this14$$services;

        return (_this14$$services = _this14.$services) === null || _this14$$services === void 0 ? void 0 : _this14$$services.viewContainer;
      }
    },

    /**
     * @type {Object|undefined}
     */
    $mapVm: {
      enumerable: true,
      get: function get() {
        var _this14$$services2;

        return (_this14$$services2 = _this14.$services) === null || _this14$$services2 === void 0 ? void 0 : _this14$$services2.mapVm;
      }
    }
  });
}
/**
 * Subscribe to OpenLayers significant events
 * @return {void}
 * @private
 */


function subscribeToEvents$1() {
  return _subscribeToEvents$1.apply(this, arguments);
}

function _subscribeToEvents$1() {
  _subscribeToEvents$1 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14() {
    var _this15 = this;

    var setterKey, resolutionChanges, zoomChanges, propChanges;
    return _regeneratorRuntime.wrap(function _callee14$(_context14) {
      while (1) {
        switch (_context14.prev = _context14.next) {
          case 0:
            setterKey = addPrefix('set');
            resolutionChanges = fromOlChangeEvent(this.$view, 'resolution', true);
            zoomChanges = resolutionChanges.pipe(map(function () {
              return {
                prop: 'zoom',
                value: _this15.getZoom()
              };
            }), distinctUntilKeyChanged('value'));
            propChanges = merge(fromOlChangeEvent(this.$view, ['id', 'rotation', 'center'], true), resolutionChanges, zoomChanges).pipe(map(function (evt) {
              return _objectSpread$h(_objectSpread$h({}, evt), {}, {
                setter: function setter(val) {
                  var args = [val];

                  if (evt.prop === 'center') {
                    args.push(true);
                  }

                  _this15[setterKey(evt.prop)].apply(_this15, args);
                }
              });
            }));
            this.subscribeTo(propChanges, function (_ref) {
              var setter = _ref.setter,
                  value = _ref.value;
              return setter(value);
            });

          case 5:
          case "end":
            return _context14.stop();
        }
      }
    }, _callee14, this);
  }));
  return _subscribeToEvents$1.apply(this, arguments);
}

/* script */
var __vue_script__$l = script$l;
/* template */

var __vue_render__$3 = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('i', {
    class: _vm.vmClass,
    staticStyle: {
      "display": "none !important"
    },
    attrs: {
      "id": _vm.vmId
    }
  }, [_vm._t("default", null, {
    "center": _vm.currentCenterDataProj,
    "zoom": _vm.currentZoom,
    "resolution": _vm.currentResolution,
    "rotation": _vm.currentRotation,
    "extent": _vm.visibleExtentDataProj
  })], 2);
};

var __vue_staticRenderFns__$3 = [];
/* style */

var __vue_inject_styles__$l = undefined;
/* scoped */

var __vue_scope_id__$l = undefined;
/* module identifier */

var __vue_module_identifier__$l = undefined;
/* functional template */

var __vue_is_functional_template__$l = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$l = /*#__PURE__*/normalizeComponent({
  render: __vue_render__$3,
  staticRenderFns: __vue_staticRenderFns__$3
}, __vue_inject_styles__$l, __vue_script__$l, __vue_scope_id__$l, __vue_is_functional_template__$l, __vue_module_identifier__$l, false, undefined, undefined, undefined);

function ownKeys$g(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$g(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$g(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$g(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
/**
 * Container for **layers**, **interactions**, **controls** and **overlays**. It responsible for viewport
 * rendering and low level interaction events.
 *
 * todo make render function that injects VlView if it is not provided by the user,
 *      then it can be provided to lower components
 */

var script$k = {
  name: 'VlMap',
  components: {
    ViewCmp: __vue_component__$l,
    VectorLayerCmp: __vue_component__$n,
    VectorSourceCmp: __vue_component__$m
  },
  mixins: [projTransforms, layersContainer, controlsContainer, interactionsContainer, overlaysContainer, featuresContainer, olCmp],
  props: {
    /**
     * Options for default controls added to the map by default. Set to `false` to disable all map controls. Object
     * value is used to configure controls.
     * @type {Object|boolean}
     * @todo remove when vl-control-* components will be ready
     */
    defaultControls: {
      type: [Object, Boolean],
      default: true
    },

    /**
     * Options for default interactions added to the map by default. Object
     * value is used to configure default interactions.
     * @type {Object|boolean}
     */
    defaultInteractions: {
      type: [Object, Boolean],
      default: true
    },

    /**
     * The element to listen to keyboard events on. For example, if this option is set to `document` the keyboard
     * interactions will always trigger. If this option is not specified, the element the library listens to keyboard
     * events on is the component root element.
     * @type {string|Element|Document|undefined}
     */
    keyboardEventTarget: [String, Element, Document],

    /**
     * The minimum distance in pixels the cursor must move to be detected as a map move event instead of a click.
     * Increasing this value can make it easier to click on the map.
     * @type {number}
     */
    moveTolerance: {
      type: Number,
      default: 1
    },

    /**
     * The ratio between physical pixels and device-independent pixels (dips) on the device.
     * @type {number}
     */
    pixelRatio: {
      type: Number,
      default: function _default() {
        return window.devicePixelRatio || 1;
      }
    },

    /**
     * Maximum number tiles to load simultaneously.
     * @type {number}
     */
    maxTilesLoading: {
      type: Number,
      default: 16
    },

    /**
     * Root element `tabindex` attribute value. Value should be provided to allow keyboard events on map.
     * @type {number|string}
     */
    tabindex: [String, Number],

    /**
     * Projection for input/output coordinates in plain data.
     * @type {string|undefined}
     */
    dataProjection: {
      type: String,
      validator: function validator(value) {
        return get(value) != null;
      }
    },

    /**
     * @type {boolean}
     */
    wrapX: {
      type: Boolean,
      default: true
    },

    /**
     * @type {boolean}
     */
    updateWhileAnimating: {
      type: Boolean,
      default: false
    },

    /**
     * @type {boolean}
     */
    updateWhileInteracting: {
      type: Boolean,
      default: false
    }
  },
  data: function data() {
    return {
      viewProjection: EPSG_3857,
      withCustomView: false,
      size: undefined,
      currentDataProjection: this.dataProjection
    };
  },
  computed: {
    resolvedDataProjection: function resolvedDataProjection() {
      var _this$$options;

      return coalesce(this.currentDataProjection, this.dataProjection, (_this$$options = this.$options) === null || _this$$options === void 0 ? void 0 : _this$$options.dataProjection, this.viewProjection);
    },
    view: function view() {
      if (!(this.rev && this.$view)) return;
      return {
        id: getViewId(this.$view),
        type: this.$view.constructor.name
      };
    },

    /**
     * @returns {string[]}
     */
    layers: function layers() {
      if (!this.rev) return [];
      return map$1(this.getLayers(), function (layer) {
        return {
          id: getLayerId(layer),
          type: layer.constructor.name
        };
      });
    },

    /**
     * @returns {string[]}
     */
    controls: function controls() {
      if (!this.rev) return [];
      return map$1(this.getControls(), function (control) {
        return {
          id: getControlId(control),
          type: control.constructor.name
        };
      });
    },

    /**
     * @returns {string[]}
     */
    interactions: function interactions() {
      if (!this.rev) return [];
      return map$1(this.getInteractions(), function (interaction) {
        return {
          id: getInteractionId(interaction),
          type: interaction.constructor.name
        };
      });
    },

    /**
     * @returns {string[]}
     */
    overlays: function overlays() {
      if (!this.rev) return [];
      return map$1(this.getOverlays(), function (overlay) {
        return {
          id: getOverlayId(overlay),
          type: overlay.constructor.name
        };
      });
    },

    /**
     * @type {Object[]}
     */
    featuresDataProj: function featuresDataProj() {
      var _this = this;

      if (!this.rev) return [];
      return map$1(this.getFeatures(), function (feature) {
        return _this.writeFeatureInDataProj(feature);
      });
    },

    /**
     * @type {Object[]}
     */
    featuresViewProj: function featuresViewProj() {
      var _this2 = this;

      if (!this.rev) return [];
      return map$1(this.getFeatures(), function (feature) {
        return _this2.writeFeatureInViewProj(feature);
      });
    }
  },
  watch: _objectSpread$g({
    rev: function rev() {
      if (!this.$map) return;

      if (!isEqual(this.size, this.$map.getSize())) {
        this.size = this.$map.getSize();
      }
    },
    size: {
      deep: true,
      handler: function handler(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit('update:size', value === null || value === void 0 ? void 0 : value.slice());
      }
    },
    defaultControls: {
      deep: true,
      handler: function handler(value) {
        this.initDefaultControls(value);
      }
    },
    defaultInteractions: {
      deep: true,
      handler: function handler(value) {
        this.initDefaultInteractions(value);
      }
    },
    dataProjection: function dataProjection(value) {
      this.setDataProjection(value);
    },
    view: {
      deep: true,
      handler: function handler(value, prev) {
        if (value === prev) return;
        this.$emit('update:view', value);
      }
    },
    layers: {
      deep: true,
      handler: function handler(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit('update:layers', value.slice());
      }
    },
    controls: {
      deep: true,
      handler: function handler(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit('update:controls', value.slice());
      }
    },
    interactions: {
      deep: true,
      handler: function handler(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit('update:interactions', value.slice());
      }
    },
    overlays: {
      deep: true,
      handler: function handler(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit('update:overlays', value.slice());
      }
    },
    featuresDataProj: {
      deep: true,
      handler: function handler(value, prev) {
        if (isEqual(value, prev)) return;
        this.$emit('update:features', clonePlainObject(value));
      }
    }
  }, /*#__PURE__*/makeChangeOrRecreateWatchers(['keyboardEventTarget', 'moveTolerance', 'pixelRatio', 'maxTilesLoading'])),
  created: function created() {
    /**
     * @type {module:ol/View~View}
     * @private
     */
    this._view = new View({
      center: [0, 0],
      zoom: 2
    });
    /**
     * @type {Object|undefined}
     */

    this._viewVm = undefined;
    defineServices$2.call(this); // todo wrap controls into components and provide vl-control-default

    this.initDefaultControls(this.defaultControls); // todo initialize without interactions and provide vl-interaction-default component

    this.initDefaultInteractions(this.defaultInteractions);
  },
  methods: {
    /**
     * @return {module:ol/Map~Map}
     * @protected
     */
    createOlObject: function createOlObject() {
      var _this3 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var map;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                map = new Map$1({
                  pixelRatio: _this3.pixelRatio,
                  moveTolerance: _this3.moveTolerance,
                  keyboardEventTarget: _this3.keyboardEventTarget,
                  maxTilesLoading: _this3.maxTilesLoading,
                  controls: _this3.$controlsCollection,
                  interactions: _this3.$interactionsCollection,
                  layers: _this3.$layersCollection,
                  overlays: _this3.$overlaysCollection,
                  view: _this3.$view
                });
                setMapId(map, _this3.currentId);
                setMapDataProjection(map, _this3.resolvedDataProjection);
                _this3.size && map.setSize(_this3.size);
                return _context.abrupt("return", map);

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    mount: function mount() {
      var _this4 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _this4.setTarget(_this4.$el);

                return _context2.abrupt("return", olCmp.methods.mount.call(_this4));

              case 2:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }))();
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    unmount: function unmount() {
      var _this5 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _this5.setTarget(null);

                return _context3.abrupt("return", olCmp.methods.unmount.call(_this5));

              case 2:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }))();
    },

    /**
     * @protected
     */
    subscribeAll: function subscribeAll() {
      var _this6 = this;

      olCmp.methods.subscribeAll.call(this);
      layersContainer.methods.subscribeAll.call(this);
      controlsContainer.methods.subscribeAll.call(this);
      interactionsContainer.methods.subscribeAll.call(this);
      overlaysContainer.methods.subscribeAll.call(this);
      featuresContainer.methods.subscribeAll.call(this);
      subscribeToEvents.call(this); // view projection can be changed in runtime only through vl-view vm

      this.subscribeTo(fromVueWatcher(this, function () {
        var _this6$$viewVm;

        return (_this6$$viewVm = _this6.$viewVm) === null || _this6$$viewVm === void 0 ? void 0 : _this6$$viewVm.resolvedViewProjection;
      }), function (_ref) {
        var value = _ref.value;
        _this6.viewProjection = value || EPSG_3857;
      });
    },

    /**
     * @returns {Object}
     * @protected
     */
    getServices: function getServices() {
      var vm = this;
      return mergeDescriptors(olCmp.methods.getServices.call(this), layersContainer.methods.getServices.call(this), controlsContainer.methods.getServices.call(this), interactionsContainer.methods.getServices.call(this), overlaysContainer.methods.getServices.call(this), featuresContainer.methods.getServices.call(this), {
        get mapVm() {
          return vm;
        },

        get viewVm() {
          return vm.$viewVm;
        },

        get viewContainer() {
          return vm;
        }

      });
    },

    /**
     * @return {string|number}
     * @protected
     */
    getIdInternal: function getIdInternal() {
      return getMapId(this.$map);
    },

    /**
     * @param {string|number} id
     * @protected
     */
    setIdInternal: function setIdInternal(id) {
      if (id === this.getIdInternal()) return;
      setMapId(this.$map, id);
    },

    /**
     * @return {Promise<module:ol/Map~Map>}
     */
    resolveMap: olCmp.methods.resolveOlObject,

    /**
     * @param {number[]} pixel
     * @param {function} callback
     * @param {Object} [opts]
     * @return {Promise}
     */
    forEachFeatureAtPixel: function forEachFeatureAtPixel(pixel, callback) {
      var _arguments = arguments,
          _this7 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {
        var opts;
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                opts = _arguments.length > 2 && _arguments[2] !== undefined ? _arguments[2] : {};
                _context4.next = 3;
                return _this7.resolveMap();

              case 3:
                return _context4.abrupt("return", _context4.sent.forEachFeatureAtPixel(pixel, callback, opts));

              case 4:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }))();
    },

    /**
     * @param {number[]} pixel
     * @param {function} callback
     * @param {Object} [opts]
     * @return {Promise}
     */
    forEachLayerAtPixel: function forEachLayerAtPixel(pixel, callback) {
      var _arguments2 = arguments,
          _this8 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {
        var opts;
        return _regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                opts = _arguments2.length > 2 && _arguments2[2] !== undefined ? _arguments2[2] : {};
                _context5.next = 3;
                return _this8.resolveMap();

              case 3:
                return _context5.abrupt("return", _context5.sent.forEachLayerAtPixel(pixel, callback, opts));

              case 4:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5);
      }))();
    },

    /**
     * @param {number[]} pixel
     * @param {boolean} [viewProj=false]
     * @return {Promise<number[]>} Coordinates in the map view projection.
     */
    getCoordinateFromPixel: function getCoordinateFromPixel(pixel) {
      var _arguments3 = arguments,
          _this9 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {
        var viewProj, coordinate;
        return _regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                viewProj = _arguments3.length > 1 && _arguments3[1] !== undefined ? _arguments3[1] : false;
                _context6.next = 3;
                return _this9.resolveMap();

              case 3:
                coordinate = _context6.sent.getCoordinateFromPixel(pixel);

                if (!viewProj) {
                  _context6.next = 6;
                  break;
                }

                return _context6.abrupt("return", roundPointCoords(coordinate));

              case 6:
                return _context6.abrupt("return", _this9.pointToDataProj(coordinate));

              case 7:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6);
      }))();
    },

    /**
     * @param {Event} event
     * @param {boolean} [viewProj=false]
     * @return {Promise<number[]>}
     */
    getEventCoordinate: function getEventCoordinate(event) {
      var _arguments4 = arguments,
          _this10 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {
        var viewProj, coordinate;
        return _regeneratorRuntime.wrap(function _callee7$(_context7) {
          while (1) {
            switch (_context7.prev = _context7.next) {
              case 0:
                viewProj = _arguments4.length > 1 && _arguments4[1] !== undefined ? _arguments4[1] : false;
                _context7.next = 3;
                return _this10.resolveMap();

              case 3:
                coordinate = _context7.sent.getEventCoordinate(event);

                if (!viewProj) {
                  _context7.next = 6;
                  break;
                }

                return _context7.abrupt("return", roundPointCoords(coordinate));

              case 6:
                return _context7.abrupt("return", _this10.pointToDataProj(coordinate));

              case 7:
              case "end":
                return _context7.stop();
            }
          }
        }, _callee7);
      }))();
    },

    /**
     * @param {Event} event
     * @return {Promise<number[]>}
     */
    getEventPixel: function getEventPixel(event) {
      var _this11 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {
        return _regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                _context8.next = 2;
                return _this11.resolveMap();

              case 2:
                return _context8.abrupt("return", _context8.sent.getEventPixel(event));

              case 3:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8);
      }))();
    },

    /**
     * @param {number[]} pixel
     * @param {Object} [opts]
     * @return {Promise}
     */
    getFeaturesAtPixel: function getFeaturesAtPixel(pixel) {
      var _arguments5 = arguments,
          _this12 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee9() {
        var opts;
        return _regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                opts = _arguments5.length > 1 && _arguments5[1] !== undefined ? _arguments5[1] : {};
                _context9.next = 3;
                return _this12.resolveMap();

              case 3:
                return _context9.abrupt("return", _context9.sent.getFeaturesAtPixel(pixel, opts));

              case 4:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9);
      }))();
    },

    /**
     * @param {number[]} pixel
     * @param {Object} [options]
     * @return {Promise<boolean>}
     */
    hasFeatureAtPixel: function hasFeatureAtPixel(pixel) {
      var _arguments6 = arguments,
          _this13 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee10() {
        var options;
        return _regeneratorRuntime.wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                options = _arguments6.length > 1 && _arguments6[1] !== undefined ? _arguments6[1] : {};
                _context10.next = 3;
                return _this13.resolveMap();

              case 3:
                return _context10.abrupt("return", _context10.sent.hasFeatureAtPixel(pixel, options));

              case 4:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10);
      }))();
    },

    /**
     * @param {number[]} coordinate Coordinates in map view projection
     * @param {boolean} [viewProj=false]
     * @return {Promise<number[]>}
     */
    getPixelFromCoordinate: function getPixelFromCoordinate(coordinate) {
      var _arguments7 = arguments,
          _this14 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee11() {
        var viewProj;
        return _regeneratorRuntime.wrap(function _callee11$(_context11) {
          while (1) {
            switch (_context11.prev = _context11.next) {
              case 0:
                viewProj = _arguments7.length > 1 && _arguments7[1] !== undefined ? _arguments7[1] : false;

                if (!viewProj) {
                  coordinate = _this14.pointToViewProj(coordinate);
                }

                _context11.next = 4;
                return _this14.resolveMap();

              case 4:
                return _context11.abrupt("return", _context11.sent.getPixelFromCoordinate(coordinate));

              case 5:
              case "end":
                return _context11.stop();
            }
          }
        }, _callee11);
      }))();
    },

    /**
     * @return {number[]|undefined}
     */
    getSize: function getSize() {
      var _this$$map;

      return coalesce((_this$$map = this.$map) === null || _this$$map === void 0 ? void 0 : _this$$map.getSize(), this.size);
    },

    /**
     * @param {number[]} size
     */
    setSize: function setSize(size) {
      assert(isArray(size) && size.length === 2, 'Invalid size');
      size = size.slice();

      if (!isEqual(size, this.size)) {
        this.size = size;
      }

      if (this.$map && !isEqual(size, this.$map.getSize())) {
        this.$map.setSize(size);
      }
    },

    /**
     * Updates map size.
     * @return {Promise<void>}
     */
    updateSize: function updateSize() {
      var _this15 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee12() {
        return _regeneratorRuntime.wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                _context12.next = 2;
                return _this15.resolveMap();

              case 2:
                _context12.sent.updateSize();

              case 3:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12);
      }))();
    },

    /**
     * @return {Promise<void>}
     */
    render: function render() {
      var _this16 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee13() {
        var map;
        return _regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                _context13.next = 2;
                return _this16.resolveMap();

              case 2:
                map = _context13.sent;
                return _context13.abrupt("return", new Promise(function (resolve) {
                  map.once('postrender', function () {
                    return resolve();
                  });
                  map.render();
                }));

              case 4:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13);
      }))();
    },

    /**
     * @return {HTMLElement|undefined}
     */
    getTarget: function getTarget() {
      var _this$$map2;

      return coalesce((_this$$map2 = this.$map) === null || _this$$map2 === void 0 ? void 0 : _this$$map2.getTarget(), this.$el);
    },

    /**
     * @param {HTMLElement} target
     */
    setTarget: function setTarget(target) {
      if (this.$map && target !== this.$map.getTarget()) {
        this.$map.setTarget(target);
        this.$emit('update:target', target);
      }
    },

    /**
     * @return {HTMLElement|undefined}
     */
    getViewport: function getViewport() {
      var _this$$map3;

      return (_this$$map3 = this.$map) === null || _this$$map3 === void 0 ? void 0 : _this$$map3.getViewport();
    },

    /**
     * @return {module:ol/View~View|undefined}
     */
    getView: function getView() {
      var _this$$map4;

      return coalesce((_this$$map4 = this.$map) === null || _this$$map4 === void 0 ? void 0 : _this$$map4.getView(), this._view);
    },

    /**
     * @return {Object}
     */
    getViewVm: function getViewVm() {
      return this._viewVm;
    },

    /**
     * @param {module:ol/View~View|Vue|undefined} view
     */
    setView: function setView(view) {
      var _view;

      view = ((_view = view) === null || _view === void 0 ? void 0 : _view.$view) || view;
      assert(!view || view instanceof View, 'Invalid view');

      if (view !== this._view) {
        var _view2, _view3;

        this._view = view;
        this._viewVm = ((_view2 = view) === null || _view2 === void 0 ? void 0 : _view2.vm) && ((_view3 = view) === null || _view3 === void 0 ? void 0 : _view3.vm[0]);
      }

      if (this.$map && view !== this.$map.getView()) {
        this.$map.setView(view);
      }

      this.scheduleRefresh();
    },

    /**
     * @return {module:ol/proj~ProjectionLike|undefined}
     */
    getDataProjection: function getDataProjection() {
      return coalesce(this.$map && getMapDataProjection(this.$map), this.resolvedDataProjection);
    },

    /**
     * @param {module:ol/proj~ProjectionLike} projection
     */
    setDataProjection: function setDataProjection(projection) {
      projection = get(projection);
      assert(projection != null, 'Invalid projection');

      if (projection.getCode() !== this.currentDataProjection) {
        this.currentDataProjection = projection.getCode();
      }

      if (this.$map && projection.getCode() !== getMapDataProjection(this.$map)) {
        setMapDataProjection(this.$map, projection.getCode());
      }
    },

    /**
     * Triggers focus on map container.
     */
    focus: function focus() {
      this.$el.focus();
    },

    /**
     * Updates map size and re-renders map.
     * @return {Promise}
     */
    refresh: function refresh() {
      var _this17 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee14() {
        return _regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                _context14.next = 2;
                return _this17.updateSize();

              case 2:
                _context14.next = 4;
                return _this17.render();

              case 4:
                return _context14.abrupt("return", olCmp.methods.refresh.call(_this17));

              case 5:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14);
      }))();
    },
    isInteracting: function isInteracting() {
      if (!this.$map) return false;
      return this.getInteractions().some(function (interaction) {
        return !!interaction.get('interacting');
      });
    },

    /**
     * @param {Object} sourceVm
     * @protected
     */
    featuresOverlaySourceCreated: function featuresOverlaySourceCreated(sourceVm) {
      sourceVm.addFeatures(this.getFeatures());
      var adds = fromVueEvent(this, 'addfeature').pipe(map(function (_ref2) {
        var feature = _ref2.feature;
        return feature;
      }), bufferDebounceTime(FRAME_TIME));
      this.subscribeTo(adds, function (features) {
        return sourceVm.addFeatures(features);
      });
      var removes = fromVueEvent(this, 'removefeature').pipe(map(function (_ref3) {
        var feature = _ref3.feature;
        return feature;
      }), bufferDebounceTime(FRAME_TIME));
      this.subscribeTo(removes, function (features) {
        return sourceVm.removeFeatures(features);
      });
    },

    /**
     * @protected {string} value
     * @protected
     */
    resolvedDataProjectionChanged: function resolvedDataProjectionChanged(value) {
      if (value === this.dataProjection) return;
      this.$emit('update:dataProjection', value);
    }
  }
};

function defineServices$2() {
  var _this18 = this;

  Object.defineProperties(this, {
    /**
     * OpenLayers map instance.
     * @type {module:ol/Map~Map|undefined}
     */
    $map: {
      enumerable: true,
      get: function get() {
        return _this18.$olObject;
      }
    },

    /**
     * @type {module:ol/View~View|undefined}
     */
    $view: {
      enumerable: true,
      get: this.getView
    },

    /**
     * @type {Object|undefined}
     */
    $viewVm: {
      enumerable: true,
      get: this.getViewVm
    },
    $featuresOverlayVm: {
      enumerable: true,
      get: function get() {
        var _this18$$refs;

        return (_this18$$refs = _this18.$refs) === null || _this18$$refs === void 0 ? void 0 : _this18$$refs.featuresOverlay;
      }
    },
    $featuresOverlaySourceVm: {
      enumerable: true,
      get: function get() {
        var _this18$$refs2;

        return (_this18$$refs2 = _this18.$refs) === null || _this18$$refs2 === void 0 ? void 0 : _this18$$refs2.featuresOverlaySource;
      }
    }
  });
}
/**
 * Subscribe to OL map events.
 *
 * @return {void}
 * @private
 */


function subscribeToEvents() {
  return _subscribeToEvents.apply(this, arguments);
}

function _subscribeToEvents() {
  _subscribeToEvents = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee15() {
    var _this19 = this;

    var setterKey, viewChanges, propChanges, pointerEvents, otherEvents;
    return _regeneratorRuntime.wrap(function _callee15$(_context15) {
      while (1) {
        switch (_context15.prev = _context15.next) {
          case 0:
            setterKey = addPrefix('set');
            viewChanges = fromOlChangeEvent(this.$map, 'view', true).pipe(tap(function (_ref4) {
              var view = _ref4.value;

              if (_this19._viewSubs) {
                _this19.unsubscribe(_this19._viewSubs);
              }

              if (view) {
                _this19._viewSubs = _this19.subscribeTo(fromOlChangeEvent(view, 'id', true), _this19.scheduleRefresh.bind(_this19));
              }

              _this19.viewProjection = (view === null || view === void 0 ? void 0 : view.getProjection().getCode()) || EPSG_3857;
              _this19.withCustomView = view && (!view.vm || view.vm.some(function (vm) {
                return vm !== _this19.$refs.view;
              }));
            }));
            propChanges = merge(viewChanges, fromOlChangeEvent(this.$map, ['dataProjection', 'size', 'target' // 'layerGroup', FIXME not ready
            ], true)).pipe(map(function (evt) {
              return _objectSpread$g(_objectSpread$g({}, evt), {}, {
                setter: _this19[setterKey(evt.prop)]
              });
            }));
            this.subscribeTo(propChanges, function (_ref5) {
              var setter = _ref5.setter,
                  value = _ref5.value;
              return setter(value);
            }); // pointer

            pointerEvents = merge(fromOlEvent(this.$map, [MapBrowserEventType.CLICK, MapBrowserEventType.DBLCLICK, MapBrowserEventType.SINGLECLICK]), fromOlEvent(this.$map, [MapBrowserEventType.POINTERDRAG, MapBrowserEventType.POINTERMOVE], null, [distinctUntilChanged(function (a, b) {
              return isEqual({
                t: a.type,
                c: a.coordinate
              }, {
                t: b.type,
                c: b.coordinate
              });
            })])).pipe(map(function (evt) {
              return omit(_objectSpread$g(_objectSpread$g({}, evt), {}, {
                pixel: evt.pixel,
                coordinate: _this19.pointToDataProj(evt.coordinate)
              }), ['pixel_', 'coordinate_']);
            })); // other

            otherEvents = fromOlEvent(this.$map, [MapEventType.MOVESTART, MapEventType.MOVEEND, MapEventType.POSTRENDER, RenderEventType.PRECOMPOSE, RenderEventType.POSTCOMPOSE, RenderEventType.RENDERCOMPLETE]);
            this.subscribeTo(merge(pointerEvents, otherEvents), function (evt) {
              return _this19.$emit(evt.type, evt);
            });

          case 7:
          case "end":
            return _context15.stop();
        }
      }
    }, _callee15, this);
  }));
  return _subscribeToEvents.apply(this, arguments);
}

/* script */
var __vue_script__$k = script$k;
/* template */

var __vue_render__$2 = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    class: _vm.vmClass,
    attrs: {
      "id": _vm.vmId,
      "tabindex": _vm.tabindex
    }
  }, [_vm._t("default"), _vm._v(" "), !_vm.withCustomView ? _c('ViewCmp', {
    ref: "view",
    attrs: {
      "id": 'vl-' + _vm.currentId + '-default-view'
    }
  }) : _vm._e(), _vm._v(" "), _c('VectorLayerCmp', {
    ref: "featuresOverlay",
    attrs: {
      "id": 'vl-' + _vm.currentId + '-default-layer',
      "overlay": true,
      "update-while-animating": _vm.updateWhileAnimating,
      "update-while-interacting": _vm.updateWhileInteracting
    }
  }, [_c('VectorSourceCmp', {
    ref: "featuresOverlaySource",
    attrs: {
      "id": 'vl-' + _vm.currentId + '-default-source',
      "wrap-x": _vm.wrapX,
      "projection": _vm.currentDataProjection
    },
    on: {
      "created": _vm.featuresOverlaySourceCreated
    }
  }, [_vm._t("overlay")], 2)], 1)], 2);
};

var __vue_staticRenderFns__$2 = [];
/* style */

var __vue_inject_styles__$k = undefined;
/* scoped */

var __vue_scope_id__$k = undefined;
/* module identifier */

var __vue_module_identifier__$k = undefined;
/* functional template */

var __vue_is_functional_template__$k = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$k = /*#__PURE__*/normalizeComponent({
  render: __vue_render__$2,
  staticRenderFns: __vue_staticRenderFns__$2
}, __vue_inject_styles__$k, __vue_script__$k, __vue_scope_id__$k, __vue_is_functional_template__$k, __vue_module_identifier__$k, false, undefined, undefined, undefined);

function plugin$l(Vue) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$l.installed) {
    return;
  }

  plugin$l.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$k, options);
  Object.assign(__vue_component__$l, options);
  Vue.component(__vue_component__$k.name, __vue_component__$k);
  Vue.component(__vue_component__$l.name, __vue_component__$l);
}

var Map = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$l,
  install: plugin$l,
  Map: __vue_component__$k,
  View: __vue_component__$l
});

function ownKeys$f(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$f(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$f(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$f(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var MAPBOX_URL_TEMPLATE = 'https://{a-c}.tiles.mapbox.com/v4/{mapId}/{z}/{x}/{y}{tileNameSuffix}.{tileFormat}?access_token={accessToken}';
var MAPBOX_ATTRIBUTIONS = '&copy; <a href="https://www.mapbox.com/" target="_blank">MapBox</a>.';
var script$j = {
  name: 'VlSourceMapbox',
  mixins: [xyzSource],
  props: {
    /* eslint-disable vue/require-prop-types */
    // ol/source/Source
    attributions: _objectSpread$f(_objectSpread$f({}, source.props.attributions), {}, {
      default: MAPBOX_ATTRIBUTIONS
    }),
    // ol/source/UrlTile
    url: _objectSpread$f(_objectSpread$f({}, urlTileSource.props.url), {}, {
      default: MAPBOX_URL_TEMPLATE
    }),

    /* eslint-enable vue/require-prop-types */
    // custom
    accessToken: {
      type: String,
      required: true
    },
    mapId: {
      type: String,
      required: true
    },
    tileFormat: {
      type: String,
      default: 'png'
    }
  },
  computed: {
    /**
     * @type {string}
     */
    tileNameSuffix: function tileNameSuffix() {
      return _tileNameSuffix(this.tilePixelRatio);
    },

    /**
     * @type {string[]}
     */
    urlTokens: function urlTokens() {
      return ['mapId', 'accessToken', 'tileNameSuffix', 'tileFormat'];
    }
  }
};
/**
 * @param {number} [ratio]
 * @returns {number}
 * @private
 */

function tileRatio(ratio) {
  ratio = coalesce(ratio, 1);
  return ratio > 1 ? 2 : 1;
}
/**
 * @param {number} [ratio]
 * @returns {string}
 * @private
 */


function _tileNameSuffix(ratio) {
  ratio = tileRatio(ratio);
  return ratio > 1 ? ['@', ratio, 'x'].join('') : '';
}

/* script */
var __vue_script__$j = script$j;
/* template */

/* style */

var __vue_inject_styles__$j = undefined;
/* scoped */

var __vue_scope_id__$j = undefined;
/* module identifier */

var __vue_module_identifier__$j = undefined;
/* functional template */

var __vue_is_functional_template__$j = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$j = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$j, __vue_script__$j, __vue_scope_id__$j, __vue_is_functional_template__$j, __vue_module_identifier__$j, false, undefined, undefined, undefined);

function plugin$k(Vue) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$k.installed) {
    return;
  }

  plugin$k.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$j, options);
  Vue.component(__vue_component__$j.name, __vue_component__$j);
}

var MapboxSource = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$k,
  install: plugin$k,
  Source: __vue_component__$j
});

function ownKeys$e(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$e(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$e(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$e(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var script$i = {
  name: 'VlLayerVectorTile',
  mixins: [tileLayer, vectorLayer],
  props: {
    renderMode: {
      type: String,
      default: RenderType.HYBRID,
      validator: function validator(val) {
        return Object.values(RenderType).includes(val);
      }
    }
  },
  watch: _objectSpread$e({}, /*#__PURE__*/makeChangeOrRecreateWatchers(['renderMode'])),
  methods: {
    /**
     * @return {VectorTileLayer}
     * @protected
     */
    createLayer: function createLayer() {
      return new VectorTile({
        // ol/layer/Base
        className: this.className,
        opacity: this.currentOpacity,
        visible: this.currentVisible,
        extent: this.currentExtentViewProj,
        zIndex: this.currentZIndex,
        minResolution: this.currentMinResolution,
        maxResolution: this.currentMaxResolution,
        minZoom: this.currentMinZoom,
        maxZoom: this.currentMaxZoom,
        // ol/layer/Layer
        render: this.render,
        source: this.$source,
        // ol/layer/BaseVector
        renderOrder: this.renderOrder,
        renderBuffer: this.renderBuffer,
        declutter: this.declutter,
        updateWhileAnimating: this.updateWhileAnimating,
        updateWhileInteracting: this.updateWhileInteracting,
        style: this.$style,
        // ol/layer/VectorTile
        // tile layer props
        preload: this.currentPreload,
        useInterimTilesOnError: this.currentUseInterimTilesOnError,
        // vector tile props
        renderMode: this.renderMode
      });
    }
  }
};

/* script */
var __vue_script__$i = script$i;
/* template */

/* style */

var __vue_inject_styles__$i = undefined;
/* scoped */

var __vue_scope_id__$i = undefined;
/* module identifier */

var __vue_module_identifier__$i = undefined;
/* functional template */

var __vue_is_functional_template__$i = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$i = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$i, __vue_script__$i, __vue_scope_id__$i, __vue_is_functional_template__$i, __vue_module_identifier__$i, false, undefined, undefined, undefined);

function plugin$j(Vue) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$j.installed) {
    return;
  }

  plugin$j.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$i, options);
  Vue.component(__vue_component__$i.name, __vue_component__$i);
}

var VectorTileLayer = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$j,
  install: plugin$j,
  Layer: __vue_component__$i
});

function ownKeys$d(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$d(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$d(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$d(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var script$h = {
  name: 'VlLayerMapboxVector',
  extends: __vue_component__$i,
  props: {
    styleUrl: {
      type: String,
      required: true
    },
    accessToken: {
      type: String,
      required: true
    },
    sourceId: String,
    layerIds: {
      type: Array,
      validate: function validate(val) {
        return isArray(val) && val.every(isString);
      }
    },
    // eslint-disable-next-line vue/require-prop-types
    declutter: _objectSpread$d(_objectSpread$d({}, vectorLayer.props.declutter), {}, {
      default: true
    })
  },
  watch: _objectSpread$d({}, makeChangeOrRecreateWatchers(['styleUrl', 'accessToken', 'sourceId', 'layerIds'], ['layerIds'])),
  methods: {
    /**
     * @returns {HeatmapLayer}
     */
    createLayer: function createLayer() {
      return new MapboxVector({
        // ol/layer/Base
        className: this.className,
        opacity: this.currentOpacity,
        visible: this.currentVisible,
        extent: this.currentExtentViewProj,
        zIndex: this.currentZIndex,
        minResolution: this.currentMinResolution,
        maxResolution: this.currentMaxResolution,
        minZoom: this.currentMinZoom,
        maxZoom: this.currentMaxZoom,
        // ol/layer/BaseVector
        renderOrder: this.renderOrder,
        renderBuffer: this.renderBuffer,
        declutter: this.declutter,
        updateWhileAnimating: this.updateWhileAnimating,
        updateWhileInteracting: this.updateWhileInteracting,
        // ol/layer/Tile
        preload: this.currentPreload,
        useInterimTilesOnError: this.currentUseInterimTilesOnError,
        // ol/layer/MapboxVector
        styleUrl: this.styleUrl,
        accessToken: this.accessToken,
        source: this.sourceId,
        layers: this.layerIds
      });
    }
  }
};

/* script */
var __vue_script__$h = script$h;
/* template */

/* style */

var __vue_inject_styles__$h = undefined;
/* scoped */

var __vue_scope_id__$h = undefined;
/* module identifier */

var __vue_module_identifier__$h = undefined;
/* functional template */

var __vue_is_functional_template__$h = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$h = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$h, __vue_script__$h, __vue_scope_id__$h, __vue_is_functional_template__$h, __vue_module_identifier__$h, false, undefined, undefined, undefined);

function plugin$i(Vue) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$i.installed) {
    return;
  }

  plugin$i.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$h, options);
  Vue.component(__vue_component__$h.name, __vue_component__$h);
}

var MapboxVectorLayer = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$i,
  install: plugin$i,
  Layer: __vue_component__$h
});

function ownKeys$c(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$c(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$c(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$c(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var script$g = {
  name: 'VlInteractionModify',
  mixins: [interaction, styleContainer],
  stubVNode: {
    empty: false,
    attrs: function attrs() {
      return {
        id: this.vmId,
        class: this.vmClass
      };
    }
  },
  props: {
    /**
     * Source or collection identifier from IdentityMap.
     * @type {String}
     */
    source: {
      type: String,
      required: true
    },

    /**
     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event will be
     * considered to add or move a vertex to the sketch. Default is `ol.events.condition.primaryAction`.
     * @type {function|undefined}
     */
    condition: {
      type: Function,
      default: primaryAction
    },

    /**
     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.
     * By default, `ol.events.condition.singleClick` with `ol.events.condition.altKeyOnly` results in a vertex deletion.
     * @type {function|undefined}
     */
    deleteCondition: {
      type: Function,
      default: altKeyOnly
    },

    /**
     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether a new vertex can be added
     * to the sketch features. Default is `ol.events.condition.always`.
     * @type {function|undefined}
     */
    insertVertexCondition: {
      type: Function,
      default: always
    },

    /**
     * Pixel tolerance for considering the pointer close enough to a segment or vertex for editing.
     * @type {number}
     */
    pixelTolerance: {
      type: Number,
      default: 10
    },

    /**
     * Wrap the world horizontally on the sketch overlay.
     * @type {boolean}
     */
    wrapX: {
      type: Boolean,
      default: false
    }
  },
  watch: _objectSpread$c({}, /*#__PURE__*/makeChangeOrRecreateWatchers(['source', 'condition', 'deleteCondition', 'insertVertexCondition', 'pixelTolerance', 'wrapX'])),
  methods: {
    /**
     * @return {Promise<Modify>}
     * @protected
     */
    createInteraction: function createInteraction() {
      var _this = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var source, features;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _this.getInstance(_this.source);

              case 2:
                source = _this._source = _context.sent;
                assert(!!source, "Source \"".concat(_this.source, "\" not found in identity map."));

                if (source instanceof Vector) {
                  features = source.getFeaturesCollection();

                  if (features) {
                    instanceOf(features, Collection, "Source \"".concat(_this.source, "\" doesn't provide features collection."));
                    source = null;
                  }
                } else {
                  if (isFunction(source.getFeaturesCollection)) {
                    features = source.getFeaturesCollection();
                  } else if (isFunction(source.getFeatures)) {
                    features = source.getFeatures();
                  }

                  instanceOf(features, Collection, "Source \"".concat(_this.source, "\" doesn't provide features collection."));
                  source = null;
                }

                return _context.abrupt("return", new Modify({
                  source: source,
                  features: features,
                  condition: _this.condition,
                  deleteCondition: _this.deleteCondition,
                  insertVertexCondition: _this.insertVertexCondition,
                  pixelTolerance: _this.pixelTolerance,
                  wrapX: _this.wrapX,
                  style: _this.$style
                }));

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    },

    /**
     * @returns {Object}
     * @protected
     */
    getServices: function getServices() {
      return mergeDescriptors(interaction.methods.getServices.call(this), styleContainer.methods.getServices.call(this));
    },

    /**
     * @return {void}
     * @protected
     */
    subscribeAll: function subscribeAll() {
      interaction.methods.subscribeAll.call(this);
      subscribeToInteractionChanges$3.call(this);
    },

    /**
     * @return {StyleTarget}
     * @protected
     */
    getStyleTarget: function getStyleTarget() {
      var _this2 = this;

      return {
        getStyle: function getStyle() {
          return _this2._style;
        },
        setStyle: function setStyle() {
          if (process.env.VUELAYERS_DEBUG) {
            _this2.$logger.log('style changed, scheduling recreate...');
          }

          _this2.scheduleRecreate();
        }
      };
    },
    getOverlay: function getOverlay() {
      var _this3 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return _this3.resolveInteraction();

              case 2:
                return _context2.abrupt("return", _context2.sent.getOverlay());

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }))();
    },
    getPointerCount: function getPointerCount() {
      var _this4 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return _this4.resolveInteraction();

              case 2:
                return _context3.abrupt("return", _context3.sent.getPointerCount());

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }))();
    },
    removePoint: function removePoint() {
      var _this5 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return _this5.resolveInteraction();

              case 2:
                return _context4.abrupt("return", _context4.sent.removePoint());

              case 3:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }))();
    }
  }
};
/**
 * @private
 */

function subscribeToInteractionChanges$3() {
  var _this6 = this;

  var modifying;
  var start = fromOlEvent(this.$interaction, 'modifystart').pipe(tap(function (evt) {
    _this6.setInteracting(true);

    modifying = [];
    evt.features.forEach(function (feature) {
      modifying[feature.getId()] = feature.getRevision();
    });
  }));
  var end = fromOlEvent(this.$interaction, 'modifyend').pipe(map(function (evt) {
    return _objectSpread$c(_objectSpread$c({}, evt), {}, {
      modified: evt.features.getArray().reduce(function (modified, feature, idx) {
        if (modifying[feature.getId()] !== feature.getRevision()) {
          modified[idx] = feature.getId();
        }

        return modified;
      }, {})
    });
  }), tap(function () {
    return _this6.setInteracting(false);
  }));
  var events = merge(start, end).pipe(map(function (_ref) {
    var type = _ref.type,
        features = _ref.features,
        modified = _ref.modified;
    var viewProj = _this6.resolvedViewProjection;
    var dataProj = _this6.resolvedDataProjection;
    return {
      type: type,
      features: features instanceof Collection ? features.getArray() : features,
      modified: modified || {},

      get json() {
        if (!this._json) {
          this._json = map$1(this.features, function (feature) {
            return writeGeoJsonFeature(feature, viewProj, dataProj, COORD_PRECISION);
          });
        }

        return this._json;
      }

    };
  }));
  this.subscribeTo(events, function (evt) {
    return _this6.$emit(evt.type, evt);
  });
}

/* script */
var __vue_script__$g = script$g;
/* template */

/* style */

var __vue_inject_styles__$g = undefined;
/* scoped */

var __vue_scope_id__$g = undefined;
/* module identifier */

var __vue_module_identifier__$g = undefined;
/* functional template */

var __vue_is_functional_template__$g = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$g = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$g, __vue_script__$g, __vue_scope_id__$g, __vue_is_functional_template__$g, __vue_module_identifier__$g, false, undefined, undefined, undefined);

function plugin$h(Vue) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$h.installed) {
    return;
  }

  plugin$h.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$g, options);
  Vue.component(__vue_component__$g.name, __vue_component__$g);
}

var ModifyInteraction = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$h,
  install: plugin$h,
  Interaction: __vue_component__$g
});

function ownKeys$b(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$b(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$b(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$b(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var OSM_ATTRIBUTIONS = '&copy; <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a> contributors.';
var OSM_URL_TEMPLATE = 'https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png';
var OSM_MAX_ZOOM = 19;
var script$f = {
  name: 'VlSourceOsm',
  mixins: [xyzSource],
  props: {
    /* eslint-disable vue/require-prop-types */
    // ol/source/Source
    attributions: _objectSpread$b(_objectSpread$b({}, source.props.attributions), {}, {
      default: OSM_ATTRIBUTIONS
    }),
    // ol/source/UrlTile
    url: _objectSpread$b(_objectSpread$b({}, urlTileSource.props.url), {}, {
      default: OSM_URL_TEMPLATE
    }),
    // ol/source/XYZ
    maxZoom: _objectSpread$b(_objectSpread$b({}, xyzSource.props.maxZoom), {}, {
      default: OSM_MAX_ZOOM
    })
    /* eslint-enable vue/require-prop-types */

  },
  computed: {
    tileGridIdent: noop,
    inputTileGridFactory: noop,
    inputTileUrlFunction: noop
  },
  watch: _objectSpread$b({}, /*#__PURE__*/makeChangeOrRecreateWatchers(['inputUrl', 'maxZoom'])),
  methods: {
    createSource: function createSource() {
      // always EPSG:3857, size: 256x256, format png
      return new OSM({
        // ol/source/Source
        attributions: this.currentAttributions,
        wrapX: this.wrapX,
        // ol/source/Tile
        cacheSize: this.cacheSize,
        opaque: this.opaque,
        // ol/source/UrlTile
        tileLoadFunction: this.currentTileLoadFunction,
        url: this.currentUrls[0],
        // ol/source/TileImage
        crossOrigin: this.crossOrigin,
        reprojectionErrorThreshold: this.reprojectionErrorThreshold,
        imageSmoothing: this.imageSmoothing,
        // ol/source/XYZ
        maxZoom: this.maxZoom
      });
    },
    inputUrlChanged: function inputUrlChanged(value) {
      this.setUrl(value);
    },
    // skip all other handlers
    tileClassChanged: noop,
    inputTileUrlFunctionChanged: noop,
    inputTileGridFactoryChanged: noop,
    tileGridChanged: noop,
    tilePixelRatioChanged: noop,
    transitionChanged: noop,
    zDirectionChanged: noop,
    attributionsCollapsibleChanged: noop,
    projectionChanged: noop
  }
};

/* script */
var __vue_script__$f = script$f;
/* template */

/* style */

var __vue_inject_styles__$f = undefined;
/* scoped */

var __vue_scope_id__$f = undefined;
/* module identifier */

var __vue_module_identifier__$f = undefined;
/* functional template */

var __vue_is_functional_template__$f = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$f = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$f, __vue_script__$f, __vue_scope_id__$f, __vue_is_functional_template__$f, __vue_module_identifier__$f, false, undefined, undefined, undefined);

function plugin$g(Vue) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$g.installed) {
    return;
  }

  plugin$g.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$f, options);
  Vue.component(__vue_component__$f.name, __vue_component__$f);
}

var OsmSource = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$g,
  install: plugin$g,
  Source: __vue_component__$f
});

function ownKeys$a(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$a(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$a(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$a(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var script$e = {
  name: 'VlOverlay',
  mixins: [projTransforms, olCmp, waitForMap],
  props: {
    offset: {
      type: Array,
      default: function _default() {
        return [0, 0];
      },
      validator: function validator(value) {
        return value.length === 2;
      }
    },
    position: {
      type: Array,
      validator: function validator(value) {
        return value.length === 2;
      } // required: true,

    },
    positioning: {
      type: String,
      default: OverlayPositioning.TOP_LEFT,
      validator: function validator(value) {
        return Object.values(OverlayPositioning).includes(value);
      }
    },
    stopEvent: {
      type: Boolean,
      default: true
    },
    insertFirst: {
      type: Boolean,
      default: true
    },
    autoPan: [Boolean, Object],
    autoPanMargin: Number,
    autoPanAnimation: Object,
    autoPanOptions: Object,
    className: String
  },
  data: function data() {
    return {
      visible: false,
      viewProjection: EPSG_3857,
      dataProjection: EPSG_3857,
      currentOffset: this.offset.slice(),
      currentPositionViewProj: roundPointCoords(this.position),
      currentPositioning: this.positioning
    };
  },
  computed: {
    positionDataProj: function positionDataProj() {
      return roundPointCoords(this.position);
    },
    positionViewProj: function positionViewProj() {
      return this.pointToViewProj(this.position);
    },
    currentPositionDataProj: function currentPositionDataProj() {
      return this.pointToDataProj(this.currentPositionViewProj);
    },
    inputOffset: function inputOffset() {
      return this.offset.slice();
    },
    inputAutoPan: function inputAutoPan() {
      return isPlainObject(this.autoPan) ? clonePlainObject(this.autoPan) : this.autoPan;
    },
    inputAutoPanAnimation: function inputAutoPanAnimation() {
      return isPlainObject(this.autoPanAnimation) ? clonePlainObject(this.autoPanAnimation) : this.autoPanAnimation;
    },
    inputAutoPanOptions: function inputAutoPanOptions() {
      return isPlainObject(this.autoPanOptions) ? clonePlainObject(this.autoPanOptions) : this.autoPanOptions;
    },
    classes: function classes() {
      return [this.vmClass, this.visible ? 'visible' : undefined].filter(identity);
    }
  },
  watch: _objectSpread$a({
    rev: function rev() {
      if (!this.$overlay) return;

      if (!isEqual(this.currentOffset, this.$overlay.getOffset())) {
        this.currentOffset = this.$overlay.getOffset();
      }

      if (!isEqual(this.currentPositionViewProj, this.$overlay.getPosition())) {
        this.currentPositionViewProj = this.$overlay.getPosition();
      }

      if (this.currentPositioning !== this.$overlay.getPositioning()) {
        this.currentPositioning = this.$overlay.getPositioning();
      }
    },
    inputOffset: {
      deep: true,
      handler: function handler(value) {
        this.setOffset(value);
      }
    },
    currentOffset: {
      deep: true,
      handler: function handler(value) {
        if (isEqual(value, this.inputOffset)) return;
        this.$emit('update:offset', value.slice());
      }
    },
    positionViewProj: {
      deep: true,
      handler: function handler(value) {
        this.setPosition(value, true);
      }
    },
    currentPositionDataProj: {
      deep: true,
      handler: function handler(value) {
        if (isEqual(value, this.positionDataProj)) return;
        this.$emit('update:position', value === null || value === void 0 ? void 0 : value.slice());
      }
    },
    positioning: function positioning(value) {
      this.setPositioning(value);
    },
    currentPositioning: function currentPositioning(value) {
      if (value === this.positioning) return;
      this.$emit('update:positioning', value);
    }
  }, /*#__PURE__*/makeChangeOrRecreateWatchers(['stopEvent', 'insertFirst', 'autoPanMargin', 'className', 'inputAutoPan', 'inputAutoPanAnimation', 'inputAutoPanOptions'], ['inputAutoPan', 'inputAutoPanAnimation', 'inputAutoPanOptions'])),
  methods: {
    /**
     * @return {Promise<void>}
     * @protected
     */
    beforeInit: function beforeInit() {
      var _this = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                defineServices$1.call(_this);
                _context.next = 3;
                return Promise.all([olCmp.methods.beforeInit.call(_this), waitForMap.methods.beforeInit.call(_this)]);

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    },

    /**
     * @return {module:ol/Overlay~Overlay}
     * @protected
     */
    createOlObject: function createOlObject() {
      var overlay = new Overlay$1({
        id: this.currentId,
        element: this.$el,
        offset: this.currentOffset,
        position: this.currentPositionViewProj,
        positioning: this.currentPositioning,
        stopEvent: this.stopEvent,
        insertFirst: this.insertFirst,
        autoPan: this.inputAutoPan,
        autoPanMargin: this.autoPanMargin,
        autoPanAnimation: this.inputAutoPanAnimation,
        autoPanOptions: this.inputAutoPanOptions,
        className: this.className
      });
      initializeOverlay(overlay, this.currentId);
      return overlay;
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    mount: function mount() {
      var _this2 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
        var _this2$$overlaysConta;

        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _this2.visible = true;
                (_this2$$overlaysConta = _this2.$overlaysContainer) === null || _this2$$overlaysConta === void 0 ? void 0 : _this2$$overlaysConta.addOverlay(_this2.$overlay);
                return _context2.abrupt("return", olCmp.methods.mount.call(_this2));

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }))();
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    unmount: function unmount() {
      var _this3 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
        var _this3$$overlaysConta;

        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                (_this3$$overlaysConta = _this3.$overlaysContainer) === null || _this3$$overlaysConta === void 0 ? void 0 : _this3$$overlaysConta.removeOverlay(_this3.$overlay);
                _this3.visible = false;
                return _context3.abrupt("return", olCmp.methods.unmount.call(_this3));

              case 3:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }))();
    },

    /**
     * @return {void}
     * @protected
     */
    subscribeAll: function subscribeAll() {
      olCmp.methods.subscribeAll.call(this);
      subscribeToOverlayChanges.call(this);
    },

    /**
     * @return {*}
     * @protected
     */
    getIdInternal: function getIdInternal() {
      return getOverlayId(this.$overlay);
    },

    /**
     * @param {*} id
     * @protected
     */
    setIdInternal: function setIdInternal(id) {
      if (id === this.getIdInternal()) return;
      setOverlayId(this.$overlay, id);
    },

    /**
     * @return {Promise<module:ol/Overlay~Overlay>}
     */
    resolveOverlay: olCmp.methods.resolveOlObject,
    getOffset: function getOffset() {
      var _this$$overlay;

      return coalesce((_this$$overlay = this.$overlay) === null || _this$$overlay === void 0 ? void 0 : _this$$overlay.getOffset(), this.currentOffset);
    },
    setOffset: function setOffset(offset) {
      assert(isArray(offset) && offset.length === 2, 'Invalid offset');
      offset = offset.slice();

      if (!isEqual(offset, this.currentOffset)) {
        this.currentOffset = offset;
      }

      if (this.$overlay && !isEqual(offset, this.$overlay.getOffset())) {
        this.$overlay.setOffset(offset);
      }
    },
    getPosition: function getPosition() {
      var viewProj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (!this.$overlay) {
        return viewProj ? this.currentPositionViewProj : this.currentPositionDataProj;
      }

      var position = this.$overlay.getPosition();
      if (viewProj) return roundPointCoords(position);
      return this.pointToDataProj(position);
    },
    setPosition: function setPosition(position) {
      var _position;

      var viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      assert(position == null || isArray(position) && position.length === 2, 'Invalid position');
      position = (_position = position) === null || _position === void 0 ? void 0 : _position.slice();

      if (!viewProj) {
        position = this.pointToViewProj(position);
      }

      if (!isEqual(position, this.currentPositionViewProj)) {
        this.currentPositionViewProj = position;
      }

      if (this.$overlay && !isEqual(position, this.$overlay.getPosition())) {
        this.$overlay.setPosition(position);
      }
    },
    getPositioning: function getPositioning() {
      var _this$$overlay2;

      return ((_this$$overlay2 = this.$overlay) === null || _this$$overlay2 === void 0 ? void 0 : _this$$overlay2.getPositioning()) || this.currentPositioning;
    },
    setPositioning: function setPositioning(positioning) {
      if (positioning !== this.currentPositioning) {
        this.currentPositioning = positioning;
      }

      if (this.$overlay && positioning !== this.$overlay.getPositioning()) {
        this.$overlay.setPositioning(positioning);
      }
    },
    panIntoView: function panIntoView() {
      var _arguments = arguments,
          _this4 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {
        var options;
        return _regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                options = _arguments.length > 0 && _arguments[0] !== undefined ? _arguments[0] : {};
                _context4.next = 3;
                return _this4.resolveOverlay();

              case 3:
                _context4.sent.panIntoView(options);

              case 4:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4);
      }))();
    }
  }
};

function defineServices$1() {
  var _this5 = this;

  Object.defineProperties(this, {
    $overlay: {
      enumerable: true,
      get: function get() {
        return _this5.$olObject;
      }
    },
    $mapVm: {
      enumerable: true,
      get: function get() {
        var _this5$$services;

        return (_this5$$services = _this5.$services) === null || _this5$$services === void 0 ? void 0 : _this5$$services.mapVm;
      }
    },
    $viewVm: {
      enumerable: true,
      get: function get() {
        var _this5$$services2;

        return (_this5$$services2 = _this5.$services) === null || _this5$$services2 === void 0 ? void 0 : _this5$$services2.viewVm;
      }
    },
    $overlaysContainer: {
      enumerable: true,
      get: function get() {
        var _this5$$services3;

        return (_this5$$services3 = _this5.$services) === null || _this5$$services3 === void 0 ? void 0 : _this5$$services3.overlaysContainer;
      }
    }
  });
}
/**
 * @return {void}
 * @private
 */


function subscribeToOverlayChanges() {
  var _this6 = this;

  var setterKey = addPrefix('set');
  var propChanges = fromOlChangeEvent(this.$overlay, ['offset', 'position', 'positioning'], true, function (evt) {
    return _objectSpread$a(_objectSpread$a({}, evt), {}, {
      setter: function setter(val) {
        var args = [val];

        if (evt.prop === 'position') {
          args.push(true);
        }

        _this6[setterKey(evt.prop)].apply(_this6, args);
      }
    });
  });
  this.subscribeTo(propChanges, function (_ref) {
    var setter = _ref.setter,
        value = _ref.value;
    return setter(value);
  });
}

/* script */
var __vue_script__$e = script$e;
/* template */

var __vue_render__$1 = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    class: _vm.classes,
    attrs: {
      "id": _vm.vmId
    }
  }, [_vm._t("default", null, {
    "id": _vm.currentId,
    "position": _vm.currentPositionDataProj,
    "offset": _vm.currentOffset,
    "positioning": _vm.currentPositioning
  })], 2);
};

var __vue_staticRenderFns__$1 = [];
/* style */

var __vue_inject_styles__$e = undefined;
/* scoped */

var __vue_scope_id__$e = undefined;
/* module identifier */

var __vue_module_identifier__$e = undefined;
/* functional template */

var __vue_is_functional_template__$e = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$e = /*#__PURE__*/normalizeComponent({
  render: __vue_render__$1,
  staticRenderFns: __vue_staticRenderFns__$1
}, __vue_inject_styles__$e, __vue_script__$e, __vue_scope_id__$e, __vue_is_functional_template__$e, __vue_module_identifier__$e, false, undefined, undefined, undefined);

function plugin$f(Vue) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$f.installed) {
    return;
  }

  plugin$f.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$e, options);
  Vue.component(__vue_component__$e.name, __vue_component__$e);
}

var Overlay = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$f,
  install: plugin$f,
  Overlay: __vue_component__$e
});

function ownKeys$9(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$9(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$9(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$9(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var script$d = {
  name: 'VlInteractionRotate',
  mixins: [interaction, styleContainer],
  stubVNode: {
    empty: false,
    attrs: function attrs() {
      return {
        id: this.vmId,
        class: this.vmClass
      };
    }
  },
  props: {
    /**
     * Source or collection identifier from IdentityMap.
     * @type {String}
     */
    source: {
      type: String,
      required: true
    },
    angle: {
      type: Number,
      default: 0
    },
    anchor: {
      type: Array,
      validator: function validator(val) {
        return val.length >= 2;
      }
    },
    condition: {
      type: Function,
      default: always
    },
    allowAnchorMovement: {
      type: Boolean,
      default: true
    }
  },
  data: function data() {
    return {
      currentAnchorViewProj: roundPointCoords(this.anchor),
      currentAngle: this.angle
    };
  },
  computed: {
    anchorDataProj: function anchorDataProj() {
      return roundPointCoords(this.anchor);
    },
    anchorViewProj: function anchorViewProj() {
      return this.pointToViewProj(this.anchor);
    },
    currentAnchorDataProj: function currentAnchorDataProj() {
      return this.pointToDataProj(this.currentAnchorViewProj);
    }
  },
  watch: _objectSpread$9({
    rev: function rev() {
      if (!this.$interaction) return;

      if (!isEqual(this.currentAnchorViewProj, this.$interaction.getAnchor())) {
        this.currentAnchorViewProj = this.$interaction.getAnchor();
      }

      if (this.currentAngle !== this.$interaction.getAngle()) {
        this.currentAngle = this.$interaction.getAngle();
      }
    },
    anchorViewProj: {
      deep: true,
      handler: function handler(value) {
        if (!value) return;
        this.setAnchor(value, true);
      }
    },
    currentAnchorDataProj: {
      deep: true,
      handler: function handler(value) {
        if (isEqual(value, this.anchorDataProj)) return;
        this.$emit('update:anchor', value === null || value === void 0 ? void 0 : value.slice());
      }
    },
    angle: function angle(value) {
      this.setAngle(value);
    },
    currentAngle: function currentAngle(value) {
      if (value === this.angle) return;
      this.$emit('update:angle', value);
    }
  }, /*#__PURE__*/makeChangeOrRecreateWatchers(['source', 'condition', 'allowAnchorMovement'])),
  created: function created() {
    var _this$anchorViewProj;

    this.currentAnchorViewProj = (_this$anchorViewProj = this.anchorViewProj) === null || _this$anchorViewProj === void 0 ? void 0 : _this$anchorViewProj.slice();
  },
  methods: {
    /**
     * @return {Promise<Modify>}
     * @protected
     */
    createInteraction: function createInteraction() {
      var _this = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var source, features;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _this.getInstance(_this.source);

              case 2:
                source = _this._source = _context.sent;
                assert(!!source, "Source \"".concat(_this.source, "\" not found in identity map."));

                if (source instanceof Vector) {
                  features = source.getFeaturesCollection();

                  if (!features) {
                    features = new Collection(source.getFeatures());

                    _this.subscribeTo(fromOlEvent(source, VectorEventType.ADDFEATURE), function (_ref) {
                      var feature = _ref.feature;
                      return feature && features.push(feature);
                    });

                    _this.subscribeTo(fromOlEvent(source, VectorEventType.REMOVEFEATURE), function (_ref2) {
                      var feature = _ref2.feature;
                      return feature && features.remove(feature);
                    });
                  }

                  instanceOf(features, Collection, "Source \"".concat(_this.source, "\" doesn't provide features collection."));
                } else {
                  if (isFunction(source.getFeaturesCollection)) {
                    features = source.getFeaturesCollection();
                  } else if (isFunction(source.getFeatures)) {
                    features = source.getFeatures();
                  }

                  instanceOf(features, Collection, "Source \"".concat(_this.source, "\" doesn't provide features collection."));
                }

                return _context.abrupt("return", new RotateInteraction$1({
                  features: features,
                  angle: _this.currentAngle,
                  anchor: _this.currentAnchorViewProj,
                  allowAnchorMovement: _this.allowAnchorMovement,
                  condition: _this.condition,
                  style: _this.$style
                }));

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    },

    /**
     * @returns {Object}
     * @protected
     */
    getServices: function getServices() {
      return mergeDescriptors(interaction.methods.getServices.call(this), styleContainer.methods.getServices.call(this));
    },

    /**
     * @protected
     */
    subscribeAll: function subscribeAll() {
      interaction.methods.subscribeAll.call(this);
      subscribeToInteractionChanges$2.call(this);
    },

    /**
     * @return {StyleTarget}
     * @protected
     */
    getStyleTarget: function getStyleTarget() {
      var _this2 = this;

      return {
        getStyle: function getStyle() {
          return _this2._style;
        },
        setStyle: function setStyle() {
          if (process.env.VUELAYERS_DEBUG) {
            _this2.$logger.log('style changed, scheduling recreate...');
          }

          _this2.scheduleRecreate();
        }
      };
    },
    getAngle: function getAngle() {
      var _this$$interaction;

      return coalesce((_this$$interaction = this.$interaction) === null || _this$$interaction === void 0 ? void 0 : _this$$interaction.getAngle(), this.currentAngle);
    },
    setAngle: function setAngle(angle) {
      assert(isNumber(angle), 'Invalid angle');

      if (angle !== this.currentAngle) {
        this.currentAngle = angle;
      }

      if (this.$interaction && angle !== this.$interaction.getAngle()) {
        this.$interaction.setAngle(angle);
      }
    },
    getAnchor: function getAnchor() {
      var _this$$interaction2;

      var viewProj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var anchor = coalesce((_this$$interaction2 = this.$interaction) === null || _this$$interaction2 === void 0 ? void 0 : _this$$interaction2.getAnchor(), this.currentAnchorViewProj);
      return viewProj ? roundPointCoords(anchor) : this.pointToDataProj(anchor);
    },
    setAnchor: function setAnchor(anchor) {
      var viewProj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      assert(isPointCoords(anchor), 'Invalid anchor');
      anchor = viewProj ? roundPointCoords(anchor) : this.pointToViewProj(anchor);

      if (!isEqual(anchor, this.currentAnchorViewProj)) {
        this.currentAnchorViewProj = anchor;
      }

      if (this.$interaction && !isEqual(anchor, this.$interaction.getAnchor())) {
        this.$interaction.setAnchor(anchor);
      }
    }
  }
};
/**
 * @private
 */

function subscribeToInteractionChanges$2() {
  var _this3 = this;

  var setterKey = addPrefix('set');
  var propChanges = fromOlChangeEvent(this.$interaction, ['angle', 'anchor'], true, function (evt) {
    return _objectSpread$9(_objectSpread$9({}, evt), {}, {
      setter: function setter(val) {
        var args = [val];

        if (evt.prop === 'anchor') {
          args.push(true);
        }

        _this3[setterKey(evt.prop)].apply(_this3, args);
      }
    });
  });
  this.subscribeTo(propChanges, function (_ref3) {
    var setter = _ref3.setter,
        value = _ref3.value;
    return setter(value);
  });
  var start = fromOlEvent(this.$interaction, 'rotatestart').pipe(tap(function () {
    return _this3.setInteracting(true);
  }));
  var end = fromOlEvent(this.$interaction, 'rotateend').pipe(tap(function () {
    return _this3.setInteracting(false);
  }));
  var progress = fromOlEvent(this.$interaction, 'rotating');
  var events = merge(start, end, progress).pipe(map(function (_ref4) {
    var type = _ref4.type,
        features = _ref4.features,
        angle = _ref4.angle,
        anchor = _ref4.anchor;
    var viewProj = _this3.resolvedViewProjection;
    var dataProj = _this3.resolvedDataProjection;
    return {
      type: type,
      features: features instanceof Collection ? features.getArray() : features,
      angle: angle,
      anchor: _this3.pointToDataProj(anchor),

      get json() {
        if (!this._json) {
          this._json = map$1(this.features, function (feature) {
            return writeGeoJsonFeature(feature, viewProj, dataProj, COORD_PRECISION);
          });
        }

        return this._json;
      }

    };
  }));
  this.subscribeTo(events, function (evt) {
    return _this3.$emit(evt.type, evt);
  });
}

/* script */
var __vue_script__$d = script$d;
/* template */

/* style */

var __vue_inject_styles__$d = undefined;
/* scoped */

var __vue_scope_id__$d = undefined;
/* module identifier */

var __vue_module_identifier__$d = undefined;
/* functional template */

var __vue_is_functional_template__$d = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$d = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$d, __vue_script__$d, __vue_scope_id__$d, __vue_is_functional_template__$d, __vue_module_identifier__$d, false, undefined, undefined, undefined);

function plugin$e(Vue) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$e.installed) {
    return;
  }

  plugin$e.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$d, options);
  Vue.component(__vue_component__$d.name, __vue_component__$d);
}

var RotateInteraction = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$e,
  install: plugin$e,
  Interaction: __vue_component__$d
});

function ownKeys$8(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$8(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$8(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$8(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var script$c = {
  name: 'VlInteractionSelect',
  mixins: [featuresContainer, styleContainer, interaction],
  props: {
    /**
     * A function that takes an `ol.Feature` and an `ol.layer.Layer` and returns `true` if the feature may be selected or `false` otherwise.
     * @type {function|undefined}
     */
    filter: {
      type: Function,
      default: /*#__PURE__*/constant(true)
    },

    /**
     * A list of layers from which features should be selected. Alternatively, a filter function can be provided.
     * @type {string[]|function|undefined}
     */
    layers: {
      type: [Array, Function],
      default: undefined
    },

    /**
     * Hit-detection tolerance. Pixels inside the radius around the given position will be checked for features.
     * This only works for the canvas renderer and not for WebGL.
     * @type {number}
     */
    hitTolerance: {
      type: Number,
      default: 0
    },

    /**
     * A boolean that determines if the default behaviour should select only single features or all (overlapping)
     * features at the clicked map position.
     * @type {boolean}
     */
    multi: {
      type: Boolean,
      default: false
    },

    /**
     * Selected features as array of GeoJSON features with coordinates in the map view projection.
     * @type {string[]|number[]|Object[]}
     */
    features: {
      type: Array,
      default: stubArray,
      validator: function validator(value) {
        return value.every(or(isString, isNumber, isGeoJSONFeature));
      }
    },

    /**
     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should
     * be handled. By default, this is `ol.events.condition.never`. Use this if you want to use different events
     * for `add` and `remove` instead of `toggle`.
     * @type {function|undefined}
     */
    addCondition: {
      type: Function,
      default: never
    },

    /**
     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.
     * This is the event for the selected features as a whole. By default, this is `ol.events.condition.singleClick`.
     * Clicking on a feature selects that feature and removes any that were in the selection. Clicking outside any feature
     * removes all from the selection.
     * @type {function|undefined}
     */
    condition: {
      type: Function,
      default: singleClick
    },

    /**
     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.
     * By default, this is `ol.events.condition.never`. Use this if you want to use different events for `add` and `remove`
     * instead of `toggle`.
     * @type {function|undefined}
     */
    removeCondition: {
      type: Function,
      default: never
    },

    /**
     * A function that takes an `ol.MapBrowserEvent` and returns a boolean to indicate whether that event should be handled.
     * This is in addition to the `condition` event. By default, `ol.events.condition.shiftKeyOnly`, i.e. pressing `shift`
     * as well as the `condition` event, adds that feature to the current selection if it is not currently selected,
     * and removes it if it is.
     * @type {function|undefined}
     */
    toggleCondition: {
      type: Function,
      default: shiftKeyOnly
    }
  },
  data: function data() {
    return {
      currentHitTolerance: this.hitTolerance
    };
  },
  computed: {
    featuresDataProj: function featuresDataProj() {
      return map$1(this.features, function (feature) {
        if (isGeoJSONFeature(feature)) {
          feature = initializeFeature(clonePlainObject(feature));
        }

        return feature;
      });
    },
    featuresViewProj: function featuresViewProj() {
      var _this = this;

      return map$1(this.features, function (feature) {
        if (isGeoJSONFeature(feature)) {
          feature = _this.writeFeatureInViewProj(_this.readFeatureInDataProj(feature));
        }

        return feature;
      });
    },
    currentFeaturesDataProj: function currentFeaturesDataProj() {
      var _this2 = this;

      if (!this.rev) return [];
      return map$1(this.getFeatures(), function (feature) {
        return _this2.writeFeatureInDataProj(feature);
      });
    },
    currentFeaturesViewProj: function currentFeaturesViewProj() {
      var _this3 = this;

      if (!this.rev) return [];
      return map$1(this.getFeatures(), function (feature) {
        return _this3.writeFeatureInViewProj(feature);
      });
    },
    currentFeatureIds: function currentFeatureIds() {
      return map$1(this.currentFeaturesDataProj, function (feature) {
        return getFeatureId(feature);
      });
    },
    layerFilter: function layerFilter() {
      var _this4 = this;

      return Array.isArray(this.layers) ? function (layer) {
        return _this4.layers.includes(getLayerId(layer));
      } : this.layers;
    },
    style: function style() {
      var _this5 = this;

      if (!(this.rev && this.$style)) return;
      var style = this.$style;
      if (isFunction(style)) return style;
      if (!style) return;
      isArray(style) || (style = [style]);
      return style.map(function (style) {
        return dumpStyle(style, function (geom) {
          return _this5.writeGeometryInDataProj(geom);
        });
      });
    }
  },
  watch: _objectSpread$8({
    rev: function rev() {
      if (!this.$interaction) return;

      if (this.currentHitTolerance !== this.$interaction.getHitTolerance()) {
        this.currentHitTolerance = this.$interaction.getHitTolerance();
      }
    },
    featuresViewProj: {
      deep: true,
      handler: function handler(features) {
        var ids = map$1(features, function (feature) {
          return isObjectLike(feature) ? getFeatureId(feature) : feature;
        });
        if (isEqual(ids, this.currentFeatureIds)) return;
        this.unselectAll();
        forEach(features, this.select.bind(this));
      }
    },
    currentFeaturesDataProj: {
      deep: true,
      handler: function handler(value) {
        if (isEqual(value, this.featuresDataProj)) return;
        this.$emit('update:features', value && clonePlainObject(value));
      }
    },
    hitTolerance: function hitTolerance(value) {
      this.setHitTolerance(value);
    },
    currentHitTolerance: function currentHitTolerance(value) {
      if (value === this.hitTolerance) return;
      this.$emit('update:hitTolerance', value);
    },
    style: {
      deep: true,
      handler: function handler(value, prev) {
        if (isEqual(value, prev)) return;

        if (isPlainObject(value) || isArray(value)) {
          value = clonePlainObject(value);
        }

        this.$emit('update:style', value);
      }
    }
  }, /*#__PURE__*/makeChangeOrRecreateWatchers(['filter', 'multi', 'wrapX', 'addCondition', 'condition', 'removeCondition', 'toggleCondition'])),
  methods: {
    /**
     * @return {Select}
     * @protected
     */
    createInteraction: function createInteraction() {
      return new Select({
        multi: this.multi,
        filter: this.filter,
        layers: this.layerFilter,
        hitTolerance: this.currentHitTolerance,
        addCondition: this.addCondition,
        condition: this.condition,
        removeCondition: this.removeCondition,
        toggleCondition: this.toggleCondition,
        style: this.$style,
        features: this.$featuresCollection
      });
    },

    /**
     * @returns {Object}
     * @protected
     */
    getServices: function getServices() {
      return mergeDescriptors(interaction.methods.getServices.call(this), featuresContainer.methods.getServices.call(this), styleContainer.methods.getServices.call(this));
    },

    /**
     * @return {void}
     * @protected
     */
    subscribeAll: function subscribeAll() {
      interaction.methods.subscribeAll.call(this);
      featuresContainer.methods.subscribeAll.call(this);
      subscribeToInteractionChanges$1.call(this);
    },

    /**
     * @return {StyleTarget}
     * @protected
     */
    getStyleTarget: function getStyleTarget() {
      var _this6 = this;

      return {
        getStyle: function getStyle() {
          return _this6._style;
        },
        setStyle: function setStyle() {
          if (process.env.VUELAYERS_DEBUG) {
            _this6.$logger.log('style changed, scheduling recreate...');
          }

          _this6.scheduleRecreate();
        }
      };
    },

    /**
     * @param {FeatureLike} feature
     */
    select: function select(feature) {
      feature = this.resolveFeature(feature);
      if (!feature) return;
      this.addFeature(feature);
    },

    /**
     * @param {FeatureLike} feature
     */
    unselect: function unselect(feature) {
      feature = this.resolveFeature(feature);
      if (!feature) return;
      this.removeFeature(feature);
    },

    /**
     * @return {void}
     */
    unselectAll: function unselectAll() {
      this.clearFeatures();
    },

    /**
     * @param {Object|Vue|Feature|string|number} feature
     * @return {Feature|undefined}
     * @protected
     */
    resolveFeature: function resolveFeature(feature) {
      var _feature,
          _this7 = this;

      if (!feature) return;
      feature = ((_feature = feature) === null || _feature === void 0 ? void 0 : _feature.$feature) || feature;
      if (feature instanceof Feature$1) return feature;
      var featureId = isString(feature) || isNumber(feature) ? feature : getFeatureId(feature);

      if (!featureId) {
        throw new Error("".concat(this.vmName, " undefined feature id"));
      }

      feature = null;
      forEach(this.$mapVm.getLayers(), function (layer) {
        if (_this7.layerFilter && !_this7.layerFilter(layer)) {
          return;
        }

        var source = layer.getSource();

        if (isFunction(source === null || source === void 0 ? void 0 : source.getFeatureById)) {
          feature = source.getFeatureById(featureId);
        }

        return !feature;
      });
      return feature;
    },
    updateFeature: function updateFeature(feature) {
      /* disable update here, because wil always work with origin feature */
    },
    getHitTolerance: function getHitTolerance() {
      var _this$$interaction;

      return coalesce((_this$$interaction = this.$interaction) === null || _this$$interaction === void 0 ? void 0 : _this$$interaction.getHitTolerance(), this.currentHitTolerance);
    },
    setHitTolerance: function setHitTolerance(tolerance) {
      assert(isNumber(tolerance), 'Invalid tolerance');

      if (tolerance !== this.currentHitTolerance) {
        this.currentHitTolerance = tolerance;
      }

      if (this.$interaction && tolerance !== this.$interaction.getHitTolerance()) {
        this.$interaction.setHitTolerance(tolerance);
      }
    },
    getLayer: function getLayer(feature) {
      var _this8 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                feature = _this8.resolveFeature(feature);
                _context.next = 3;
                return _this8.resolveInteraction();

              case 3:
                return _context.abrupt("return", _context.sent.getLayer(feature));

              case 4:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    }
  }
};
/**
 * @return {void}
 * @private
 */

function subscribeToInteractionChanges$1() {
  var _this9 = this;

  var select = fromVueEvent(this, 'addfeature', function (evt) {
    return {
      type: 'select',
      feature: evt.feature,

      get json() {
        return evt.json;
      }

    };
  });
  var unselect = fromVueEvent(this, 'removefeature', function (evt) {
    return {
      type: 'unselect',
      feature: evt.feature,

      get json() {
        return evt.json;
      }

    };
  });
  var events = merge(select, unselect);
  this.subscribeTo(events, function (evt) {
    return _this9.$emit(evt.type, evt);
  });
}

/* script */
var __vue_script__$c = script$c;
/* template */

var __vue_render__ = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('i', {
    class: _vm.vmClass,
    staticStyle: {
      "display": "none !important"
    },
    attrs: {
      "id": _vm.vmId
    }
  }, [_vm._t("default", null, {
    "features": _vm.currentFeaturesDataProj
  })], 2);
};

var __vue_staticRenderFns__ = [];
/* style */

var __vue_inject_styles__$c = undefined;
/* scoped */

var __vue_scope_id__$c = undefined;
/* module identifier */

var __vue_module_identifier__$c = undefined;
/* functional template */

var __vue_is_functional_template__$c = false;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$c = /*#__PURE__*/normalizeComponent({
  render: __vue_render__,
  staticRenderFns: __vue_staticRenderFns__
}, __vue_inject_styles__$c, __vue_script__$c, __vue_scope_id__$c, __vue_is_functional_template__$c, __vue_module_identifier__$c, false, undefined, undefined, undefined);

function plugin$d(Vue) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$d.installed) {
    return;
  }

  plugin$d.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$c, options);
  Vue.component(__vue_component__$c.name, __vue_component__$c);
}

var SelectInteraction = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$d,
  install: plugin$d,
  Interaction: __vue_component__$c
});

function ownKeys$7(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$7(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$7(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$7(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var script$b = {
  name: 'VlInteractionSnap',
  mixins: [interaction],
  props: {
    /**
     * Target source identifier from IdentityMap.
     * @type {string}
     */
    source: {
      type: String,
      required: true
    },

    /**
     * Snap to edges
     * @type {boolean}
     */
    edge: {
      type: Boolean,
      default: true
    },

    /**
     * Snap to vertices.
     * @type {boolean}
     */
    vertex: {
      type: Boolean,
      default: true
    },

    /**
     * Pixel tolerance for considering the pointer close enough to a segment or vertex for snapping.
     * @type {number}
     */
    pixelTolerance: {
      type: Number,
      default: 10
    }
  },
  watch: _objectSpread$7({}, /*#__PURE__*/makeChangeOrRecreateWatchers(['source', 'edge', 'vertex', 'pixelTolerance'])),
  methods: {
    /**
     * @return {Promise<Snap>}
     * @protected
     */
    createInteraction: function createInteraction() {
      var _this = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var source, features;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _this.getInstance(_this.source);

              case 2:
                source = _context.sent;
                assert(!!source, "Source \"".concat(_this.source, "\" not found in identity map."));

                if (!(source instanceof Vector)) {
                  if (isFunction(source.getFeaturesCollection)) {
                    features = source.getFeaturesCollection();
                  } else if (isFunction(source.getFeatures)) {
                    features = source.getFeatures();
                  }

                  instanceOf(features, Collection, "Source \"".concat(_this.source, "\" doesn't provide features collection."));
                  source = null;
                }

                return _context.abrupt("return", new Snap({
                  source: source,
                  features: features,
                  edge: _this.edge,
                  vertex: _this.vertex,
                  pixelTolerance: _this.pixelTolerance
                }));

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    }
  }
};

/* script */
var __vue_script__$b = script$b;
/* template */

/* style */

var __vue_inject_styles__$b = undefined;
/* scoped */

var __vue_scope_id__$b = undefined;
/* module identifier */

var __vue_module_identifier__$b = undefined;
/* functional template */

var __vue_is_functional_template__$b = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$b = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$b, __vue_script__$b, __vue_scope_id__$b, __vue_is_functional_template__$b, __vue_module_identifier__$b, false, undefined, undefined, undefined);

function plugin$c(Vue) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$c.installed) {
    return;
  }

  plugin$c.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$b, options);
  Vue.component(__vue_component__$b.name, __vue_component__$b);
}

var SnapInteraction = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$c,
  install: plugin$c,
  Interaction: __vue_component__$b
});

function ownKeys$6(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$6(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$6(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$6(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var SPUTNIK_URL_TEMPLATE = 'http://tiles.maps.sputnik.ru/{z}/{x}/{y}.png?apikey={apikey}';
var SPUTNIK_ATTRIBUTIONS = '&copy; <a href="http://rt.ru/" target="_blank">Ростелеком</a>. ';
var script$a = {
  name: 'VlSourceSputnik',
  mixins: [xyzSource],
  props: {
    /* eslint-disable vue/require-prop-types */
    // ol/source/Source
    attributions: _objectSpread$6(_objectSpread$6({}, source.props.attributions), {}, {
      default: SPUTNIK_ATTRIBUTIONS
    }),
    // ol/source/UrlTile
    url: _objectSpread$6(_objectSpread$6({}, urlTileSource.props.url), {}, {
      default: SPUTNIK_URL_TEMPLATE
    }),

    /* eslint-enable vue/require-prop-types */
    // custom
    apiKey: {
      type: String
    }
  },
  computed: {
    /**
     * @type {string[]}
     */
    urlTokens: function urlTokens() {
      return ['apiKey'];
    }
  }
};

/* script */
var __vue_script__$a = script$a;
/* template */

/* style */

var __vue_inject_styles__$a = undefined;
/* scoped */

var __vue_scope_id__$a = undefined;
/* module identifier */

var __vue_module_identifier__$a = undefined;
/* functional template */

var __vue_is_functional_template__$a = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$a = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$a, __vue_script__$a, __vue_scope_id__$a, __vue_is_functional_template__$a, __vue_module_identifier__$a, false, undefined, undefined, undefined);

function plugin$b(Vue) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$b.installed) {
    return;
  }

  plugin$b.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$a, options);
  Vue.component(__vue_component__$a.name, __vue_component__$a);
}

var SputnikSource = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$b,
  install: plugin$b,
  Source: __vue_component__$a
});

var script$9 = {
  name: 'VlSourceStamen',
  mixins: [xyzSource],
  props: {
    // ol/source/Stamen

    /**
     * Stamen layer name
     *
     * @type {string}
     */
    layer: {
      type: String,
      required: true
    }
  },
  computed: {
    tileGridIdent: noop,
    inputTileGridFactory: noop,
    inputTileUrlFunction: noop
  },
  methods: {
    createSource: function createSource() {
      return new Stamen({
        // ol/source/Source
        wrapX: this.wrapX,
        // ol/source/Tile
        cacheSize: this.cacheSize,
        opaque: this.opaque,
        transition: this.transition,
        // ol/source/UrlTile
        tileLoadFunction: this.currentTileLoadFunction,
        url: this.currentUrls[0],
        // ol/source/TileImage
        reprojectionErrorThreshold: this.reprojectionErrorThreshold,
        imageSmoothing: this.imageSmoothing,
        // ol/source/XYZ
        minZoom: this.minZoom,
        maxZoom: this.maxZoom,
        // ol/source/Stamen
        layer: this.layer
      });
    },
    inputUrlChanged: function inputUrlChanged(value) {
      this.setUrl(value);
    },
    attributionsCollapsibleChanged: noop,
    projectionChanged: noop,
    inputTileGridFactoryChanged: noop,
    tileGridChanged: noop,
    zDirectionChanged: noop,
    inputTileUrlFunctionChanged: noop,
    crossOriginChanged: noop,
    tileClassChanged: noop
  }
};

/* script */
var __vue_script__$9 = script$9;
/* template */

/* style */

var __vue_inject_styles__$9 = undefined;
/* scoped */

var __vue_scope_id__$9 = undefined;
/* module identifier */

var __vue_module_identifier__$9 = undefined;
/* functional template */

var __vue_is_functional_template__$9 = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$9 = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$9, __vue_script__$9, __vue_scope_id__$9, __vue_is_functional_template__$9, __vue_module_identifier__$9, false, undefined, undefined, undefined);

function plugin$a(Vue) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$a.installed) {
    return;
  }

  plugin$a.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$9, options);
  Vue.component(__vue_component__$9.name, __vue_component__$9);
}

var StamenSource = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$a,
  install: plugin$a,
  Source: __vue_component__$9
});

function ownKeys$5(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$5(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$5(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
/**
 * Style function component for advanced styling.
 * Plays the role of both a style that mounts itself to style target component (vl-layer-vector, vl-feature & etc.)
 * and style target for inner style containers (vl-style-box) as fallback style.
 */

var script$8 = {
  name: 'VlStyleFunc',
  mixins: [stubVNode, projTransforms, styleContainer, olCmp, waitForMap],
  stubVNode: {
    empty: false,
    attrs: function attrs() {
      return {
        id: this.vmId,
        class: this.vmClass
      };
    }
  },
  props: {
    /**
     * @type {function(): function(feature: Feature): Style}
     */
    function: {
      type: Function // required: true,

    },

    /**
     * @deprecated
     * @todo remove later
     */
    func: Function,

    /**
     * @deprecated Use `func` prop instead.
     * @todo remove in v0.13.x
     */
    factory: Function
  },
  data: function data() {
    return {
      viewProjection: EPSG_3857,
      dataProjection: EPSG_3857
    };
  },
  computed: {
    inputFunction: function inputFunction() {
      var func = this.function || this.func;

      if (!func && this.factory) {
        func = this.factory();
      }

      return func;
    }
  },
  watch: _objectSpread$5({}, /*#__PURE__*/makeChangeOrRecreateWatchers(['inputFunction'])),
  created: function created() {
    if (process.env.NODE_ENV !== 'production') {
      if (this.factory) {
        this.$logger.warn("'factory' prop is deprecated. Use 'function' prop instead.");
      }

      if (this.func) {
        this.$logger.warn("'func' prop is deprecated. Use 'function' prop instead.");
      }
    }

    defineServices.call(this);
  },
  updated: function updated() {
    if (process.env.NODE_ENV !== 'production') {
      if (this.factory) {
        this.$logger.warn("'factory' prop is deprecated. Use 'function' prop instead.");
      }

      if (this.func) {
        this.$logger.warn("'func' prop is deprecated. Use 'function' prop instead.");
      }
    }
  },
  methods: {
    /**
     * @return {Promise<void>}
     * @protected
     */
    beforeInit: function beforeInit() {
      var _this = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return Promise.all([olCmp.methods.beforeInit.call(_this), waitForMap.methods.beforeInit.call(_this)]);

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    },

    /**
     * @return {function(feature: Feature): Style}
     * @protected
     */
    createOlObject: function createOlObject() {
      // user provided style function
      var providedStyleFunc = this.inputFunction; // fallback style function made from inner style containers

      var fallbackStyleFunc = this.createStyleFunc(this.$style, this.getDefaultStyle());

      var func = function __styleFunc(feature, resolution) {
        var style = providedStyleFunc(feature, resolution); // not empty or null style

        if (style == null || Array.isArray(style) && style.length || style instanceof Style$1) {
          return style;
        }

        return fallbackStyleFunc(feature, resolution);
      };

      func.id = this.currentId;
      return func;
    },

    /**
     * @returns {Object}
     * @protected
     */
    getServices: function getServices() {
      return mergeDescriptors(olCmp.methods.getServices.call(this), styleContainer.methods.getServices.call(this));
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    mount: function mount() {
      var _this2 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
        var _this2$$styleContaine;

        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                (_this2$$styleContaine = _this2.$styleContainer) === null || _this2$$styleContaine === void 0 ? void 0 : _this2$$styleContaine.setStyle(_this2);
                return _context2.abrupt("return", olCmp.methods.mount.call(_this2));

              case 2:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }))();
    },

    /**
     * @return {Promise<void>}
     * @protected
     */
    unmount: function unmount() {
      var _this3 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {
        var _this3$$styleContaine;

        return _regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (((_this3$$styleContaine = _this3.$styleContainer) === null || _this3$$styleContaine === void 0 ? void 0 : _this3$$styleContaine.getStyle()) === _this3.$styleFunction) {
                  _this3.$styleContainer.setStyle(null);
                }

                return _context3.abrupt("return", olCmp.methods.unmount.call(_this3));

              case 2:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3);
      }))();
    },

    /**
     * @protected
     */
    getStyleTarget: function getStyleTarget() {
      var _this4 = this;

      return {
        getStyle: function getStyle() {
          return _this4._style;
        },
        setStyle: function () {
          var _setStyle = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {
            return _regeneratorRuntime.wrap(function _callee4$(_context4) {
              while (1) {
                switch (_context4.prev = _context4.next) {
                  case 0:
                    if (process.env.VUELAYERS_DEBUG) {
                      _this4.$logger.log('style changed, scheduling recreate...');
                    }

                    _context4.next = 3;
                    return _this4.scheduleRecreate();

                  case 3:
                  case "end":
                    return _context4.stop();
                }
              }
            }, _callee4);
          }));

          function setStyle() {
            return _setStyle.apply(this, arguments);
          }

          return setStyle;
        }()
      };
    }
  }
};

function defineServices() {
  var _this5 = this;

  Object.defineProperties(this, {
    $styleFunction: {
      enumerable: true,
      get: function get() {
        return _this5.$olObject;
      }
    },

    /**
     * @type {Object|undefined}
     */
    $mapVm: {
      enumerable: true,
      get: function get() {
        var _this5$$services;

        return (_this5$$services = _this5.$services) === null || _this5$$services === void 0 ? void 0 : _this5$$services.mapVm;
      }
    },

    /**
     * @type {Object|undefined}
     */
    $viewVm: {
      enumerable: true,
      get: function get() {
        var _this5$$services2;

        return (_this5$$services2 = _this5.$services) === null || _this5$$services2 === void 0 ? void 0 : _this5$$services2.viewVm;
      }
    },

    /**
     * @type {Object|undefined}
     */
    $styleContainer: {
      enumerable: true,
      get: function get() {
        var _this5$$services3;

        return (_this5$$services3 = _this5.$services) === null || _this5$$services3 === void 0 ? void 0 : _this5$$services3.styleContainer;
      }
    }
  });
}

/* script */
var __vue_script__$8 = script$8;
/* template */

/* style */

var __vue_inject_styles__$8 = undefined;
/* scoped */

var __vue_scope_id__$8 = undefined;
/* module identifier */

var __vue_module_identifier__$8 = undefined;
/* functional template */

var __vue_is_functional_template__$8 = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$8 = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$8, __vue_script__$8, __vue_scope_id__$8, __vue_is_functional_template__$8, __vue_module_identifier__$8, false, undefined, undefined, undefined);

function plugin$9(Vue) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$9.installed) {
    return;
  }

  plugin$9.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$8, options);
  Vue.component(__vue_component__$8.name, __vue_component__$8);
}

var StyleFunc = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$9,
  install: plugin$9,
  Style: __vue_component__$8
});

var script$7 = {
  name: 'VlSourceTileArcgisRest',
  mixins: [arcgisSource, tileImageSource],
  computed: {
    inputTileUrlFunction: noop
  },
  methods: {
    createSource: function createSource() {
      return new TileArcGISRest({
        // ol/source/Source
        attributions: this.currentAttributions,
        projection: this.resolvedDataProjection,
        wrapX: this.wrapX,
        // ol/source/Tile
        cacheSize: this.cacheSize,
        tileGrid: this.tileGrid,
        transition: this.transition,
        // ol/source/UrlTile
        tileLoadFunction: this.currentTileLoadFunction,
        urls: this.currentUrls,
        // ol/source/TileImage
        crossOrigin: this.crossOrigin,
        reprojectionErrorThreshold: this.reprojectionErrorThreshold,
        imageSmoothing: this.imageSmoothing,
        // ol/source/TileArcGISRest
        hidpi: this.hidpi,
        params: this.currentParams
      });
    },
    stateChanged: noop,
    attributionsCollapsibleChanged: noop,
    tileKeyChanged: noop,
    opaqueChanged: noop,
    tilePixelRatioChanged: noop,
    zDirectionChanged: noop,
    inputTileUrlFunctionChanged: noop,
    tileClassChanged: noop
  }
};

/* script */
var __vue_script__$7 = script$7;
/* template */

/* style */

var __vue_inject_styles__$7 = undefined;
/* scoped */

var __vue_scope_id__$7 = undefined;
/* module identifier */

var __vue_module_identifier__$7 = undefined;
/* functional template */

var __vue_is_functional_template__$7 = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$7 = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$7, __vue_script__$7, __vue_scope_id__$7, __vue_is_functional_template__$7, __vue_module_identifier__$7, false, undefined, undefined, undefined);

function plugin$8(Vue) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$8.installed) {
    return;
  }

  plugin$8.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$7, options);
  Vue.component(__vue_component__$7.name, __vue_component__$7);
  Vue.component('VlSourceArcgisRest', {
    name: 'VlSourceArcgisRest',
    extends: __vue_component__$7,
    created: function created() {
      if (process.env.NODE_ENV !== 'production') {
        this.$logger.warn('VlSourceArcgisRest component is deprecated. Use VlSourceTileArcgisRest component instead.');
      }
    }
  });
}

var TileArcgisRestSource = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$8,
  install: plugin$8,
  Source: __vue_component__$7
});

/**
 * Layer that provide pre-rendered, tiled images in grid that are organized by zoom levels for
 * specific resolutions. `vl-tile-layer` component implements a **source container** interface, so it should be
 * used together with tile-like `vl-source-*` components.
 */

var script$6 = {
  name: 'VlLayerTile',
  mixins: [tileLayer],
  methods: {
    /**
     * @return {Tile}
     * @protected
     */
    createLayer: function createLayer() {
      return new Tile({
        // ol/layer/Base
        className: this.className,
        opacity: this.currentOpacity,
        visible: this.currentVisible,
        extent: this.currentExtentViewProj,
        zIndex: this.currentZIndex,
        minResolution: this.currentMinResolution,
        maxResolution: this.currentMaxResolution,
        minZoom: this.currentMinZoom,
        maxZoom: this.currentMaxZoom,
        // ol/layer/Layer
        render: this.render,
        source: this.$source,
        // ol/layer/BaseTile
        preload: this.currentPreload,
        useInterimTilesOnError: this.currentUseInterimTilesOnError
      });
    }
  }
};

/* script */
var __vue_script__$6 = script$6;
/* template */

/* style */

var __vue_inject_styles__$6 = undefined;
/* scoped */

var __vue_scope_id__$6 = undefined;
/* module identifier */

var __vue_module_identifier__$6 = undefined;
/* functional template */

var __vue_is_functional_template__$6 = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$6 = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$6, __vue_script__$6, __vue_scope_id__$6, __vue_is_functional_template__$6, __vue_module_identifier__$6, false, undefined, undefined, undefined);

function plugin$7(Vue) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$7.installed) {
    return;
  }

  plugin$7.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$6, options);
  Vue.component(__vue_component__$6.name, __vue_component__$6);
}

var TileLayer = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$7,
  install: plugin$7,
  Layer: __vue_component__$6
});

function ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$4(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var script$5 = {
  name: 'VlSourceTileWms',
  mixins: [wmsSource, tileImageSource],
  props: {
    gutter: {
      type: Number,
      default: 0
    }
  },
  computed: {
    inputTileUrlFunction: noop
  },
  watch: _objectSpread$4({}, /*#__PURE__*/makeChangeOrRecreateWatchers(['gutter'])),
  methods: {
    createSource: function createSource() {
      return new TileWMS({
        // ol/source/Source
        attributions: this.currentAttributions,
        projection: this.resolvedDataProjection,
        wrapX: this.wrapX,
        // ol/source/Tile
        cacheSize: this.cacheSize,
        tileGrid: this.tileGrid,
        transition: this.transition,
        // ol/source/UrlTile
        tileLoadFunction: this.currentTileLoadFunction,
        urls: this.currentUrls,
        // ol/source/TileImage
        crossOrigin: this.crossOrigin,
        reprojectionErrorThreshold: this.reprojectionErrorThreshold,
        tileClass: this.tileClass,
        imageSmoothing: this.imageSmoothing,
        // ol/source/TileWMS
        gutter: this.gutter,
        hidpi: this.hidpi,
        serverType: this.serverType,
        params: this.currentParams
      });
    },
    stateChanged: noop,
    attributionsCollapsibleChanged: noop,
    tileKeyChanged: noop,
    opaqueChanged: noop,
    tilePixelRatioChanged: noop,
    zDirectionChanged: noop,
    inputTileUrlFunctionChanged: noop
  }
};

/* script */
var __vue_script__$5 = script$5;
/* template */

/* style */

var __vue_inject_styles__$5 = undefined;
/* scoped */

var __vue_scope_id__$5 = undefined;
/* module identifier */

var __vue_module_identifier__$5 = undefined;
/* functional template */

var __vue_is_functional_template__$5 = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$5 = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$5, __vue_script__$5, __vue_scope_id__$5, __vue_is_functional_template__$5, __vue_module_identifier__$5, false, undefined, undefined, undefined);

function plugin$6(Vue) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$6.installed) {
    return;
  }

  plugin$6.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$5, options);
  Vue.component(__vue_component__$5.name, __vue_component__$5); // todo remove in v0.13.x

  Vue.component('VlSourceWms', {
    name: 'VlSourceWms',
    extends: __vue_component__$5,
    created: function created() {
      if (process.env.NODE_ENV !== 'production') {
        this.$logger.warn('VlSourceWms component is deprecated. Use VlSourceTileWms component instead.');
      }
    }
  });
}

var TileWmsSource = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$6,
  install: plugin$6,
  Source: __vue_component__$5
});

function ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var script$4 = {
  name: 'VlInteractionTranslate',
  mixins: [interaction],
  stubVNode: {
    empty: false,
    attrs: function attrs() {
      return {
        id: this.vmId,
        class: this.vmClass
      };
    }
  },
  props: {
    source: {
      type: String,
      required: true
    },
    layers: [String, Array],
    filter: Function,
    hitTolerance: {
      type: Number,
      default: 0
    }
  },
  data: function data() {
    return {
      currentHitTolerance: this.hitTolerance
    };
  },
  computed: {
    inputFilter: function inputFilter() {
      if (isFunction(this.filter)) return this.filter;
      var layers = this.layers;
      if (!layers) return;
      if (isString(layers)) layers = [layers];
      return function (feature, layer) {
        return layers.includes(getLayerId(layer));
      };
    }
  },
  watch: _objectSpread$3({
    rev: function rev() {
      if (!this.$interaction) return;

      if (this.currentHitTolerance !== this.$interaction.getHitTolerance()) {
        this.currentHitTolerance = this.$interaction.getHitTolerance();
      }
    },
    hitTolerance: function hitTolerance(value) {
      this.setHitTolerance(value);
    },
    currentHitTolerance: function currentHitTolerance(value) {
      if (value === this.hitTolerance) return;
      this.$emit('update:hitTolerance', value);
    }
  }, /*#__PURE__*/makeChangeOrRecreateWatchers(['source', 'inputFilter'])),
  methods: {
    /**
     * @return {Promise<Modify>}
     * @protected
     */
    createInteraction: function createInteraction() {
      var _this = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var source, features;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return _this.getInstance(_this.source);

              case 2:
                source = _this._source = _context.sent;
                assert(!!source, "Source \"".concat(_this.source, "\" not found in identity map."));

                if (source instanceof Vector) {
                  features = source.getFeaturesCollection();

                  if (!features) {
                    features = new Collection(source.getFeatures());

                    _this.subscribeTo(fromOlEvent(source, VectorEventType.ADDFEATURE), function (_ref) {
                      var feature = _ref.feature;
                      return feature && features.push(feature);
                    });

                    _this.subscribeTo(fromOlEvent(source, VectorEventType.REMOVEFEATURE), function (_ref2) {
                      var feature = _ref2.feature;
                      return feature && features.remove(feature);
                    });
                  }

                  instanceOf(features, Collection, "Source \"".concat(_this.source, "\" doesn't provide features collection."));
                } else {
                  if (isFunction(source.getFeaturesCollection)) {
                    features = source.getFeaturesCollection();
                  } else if (isFunction(source.getFeatures)) {
                    features = source.getFeatures();
                  }

                  instanceOf(features, Collection, "Source \"".concat(_this.source, "\" doesn't provide features collection."));
                }

                return _context.abrupt("return", new Translate({
                  features: features,
                  filter: _this.inputFilter,
                  hitTolerance: _this.currentHitTolerance
                }));

              case 6:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    },

    /**
     * @return {void}
     * @protected
     */
    subscribeAll: function subscribeAll() {
      interaction.methods.subscribeAll.call(this);
      subscribeToInteractionChanges.call(this);
    },
    getHitTolerance: function getHitTolerance() {
      var _this$$interaction;

      return coalesce((_this$$interaction = this.$interaction) === null || _this$$interaction === void 0 ? void 0 : _this$$interaction.getHitTolerance(), this.currentHitTolerance);
    },
    setHitTolerance: function setHitTolerance(tolerance) {
      assert(isNumber(tolerance), 'Invalid hit tolerance');

      if (tolerance !== this.currentHitTolerance) {
        this.currentHitTolerance = tolerance;
      }

      if (this.$interaction && tolerance !== this.$interaction.getHitTolerance()) {
        this.$interaction.setHitTolerance(tolerance);
      }
    }
  }
};
/**
 * @private
 */

function subscribeToInteractionChanges() {
  var _this2 = this;

  var start = fromOlEvent(this.$interaction, 'translatestart').pipe(tap(function () {
    return _this2.setInteracting(true);
  }));
  var end = fromOlEvent(this.$interaction, 'translateend').pipe(tap(function () {
    return _this2.setInteracting(false);
  }));
  var progress = fromOlEvent(this.$interaction, 'translating');
  var events = merge(start, end, progress).pipe(map(function (_ref3) {
    var type = _ref3.type,
        features = _ref3.features,
        coordinate = _ref3.coordinate,
        startCoordinate = _ref3.startCoordinate;
    var viewProj = _this2.resolvedViewProjection;
    var dataProj = _this2.resolvedDataProjection;
    return {
      type: type,
      features: features instanceof Collection ? features.getArray() : features,
      coordinate: _this2.pointToDataProj(coordinate),
      startCoordinate: _this2.pointToDataProj(startCoordinate),

      get json() {
        if (!this._json) {
          this._json = map$1(this.features, function (feature) {
            return writeGeoJsonFeature(feature, viewProj, dataProj, COORD_PRECISION);
          });
        }

        return this._json;
      }

    };
  }));
  this.subscribeTo(events, function (evt) {
    return _this2.$emit(evt.type, evt);
  });
}

/* script */
var __vue_script__$4 = script$4;
/* template */

/* style */

var __vue_inject_styles__$4 = undefined;
/* scoped */

var __vue_scope_id__$4 = undefined;
/* module identifier */

var __vue_module_identifier__$4 = undefined;
/* functional template */

var __vue_is_functional_template__$4 = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$4 = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$4, __vue_script__$4, __vue_scope_id__$4, __vue_is_functional_template__$4, __vue_module_identifier__$4, false, undefined, undefined, undefined);

function plugin$5(Vue) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$5.installed) {
    return;
  }

  plugin$5.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$4, options);
  Vue.component(__vue_component__$4.name, __vue_component__$4);
}

var TranslateInteraction = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$5,
  install: plugin$5,
  Interaction: __vue_component__$4
});

function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
/**
 * Layer for data that is rendered client-side.
 */

var script$3 = {
  name: 'VlLayerVectorImage',
  mixins: [vectorLayer],
  props: {
    // ol/layer/VectorImage

    /**
     * @type {number}
     */
    imageRatio: {
      type: Number,
      default: 1
    }
  },
  watch: _objectSpread$2({}, /*#__PURE__*/makeChangeOrRecreateWatchers(['imageRatio'])),
  methods: {
    /**
     * @return {VectorImageLayer}
     * @protected
     */
    createLayer: function createLayer() {
      return new VectorImage({
        // ol/layer/Base
        className: this.className,
        opacity: this.currentOpacity,
        visible: this.currentVisible,
        extent: this.currentExtentViewProj,
        zIndex: this.currentZIndex,
        minResolution: this.currentMinResolution,
        maxResolution: this.currentMaxResolution,
        minZoom: this.currentMinZoom,
        maxZoom: this.currentMaxZoom,
        // ol/layer/Layer
        render: this.render,
        source: this.$source,
        // ol/layer/BaseVector
        renderOrder: this.renderOrder,
        renderBuffer: this.renderBuffer,
        declutter: this.declutter,
        updateWhileAnimating: this.updateWhileAnimating,
        updateWhileInteracting: this.updateWhileInteracting,
        style: this.$style,
        // ol/layer/VectorImage
        imageRatio: this.imageRatio
      });
    }
  }
};

/* script */
var __vue_script__$3 = script$3;
/* template */

/* style */

var __vue_inject_styles__$3 = undefined;
/* scoped */

var __vue_scope_id__$3 = undefined;
/* module identifier */

var __vue_module_identifier__$3 = undefined;
/* functional template */

var __vue_is_functional_template__$3 = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$3 = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$3, __vue_script__$3, __vue_scope_id__$3, __vue_is_functional_template__$3, __vue_module_identifier__$3, false, undefined, undefined, undefined);

function plugin$4(Vue) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$4.installed) {
    return;
  }

  plugin$4.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$3, options);
  Vue.component(__vue_component__$3.name, __vue_component__$3);
}

var VectorImageLayer = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$4,
  install: plugin$4,
  Layer: __vue_component__$3
});

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var validateTileSize = /*#__PURE__*/or(isNumber, and(isArray, function (value) {
  return value.length === 2 && value.every(isNumber);
}));
var script$2 = {
  name: 'VlSourceVectorTile',
  mixins: [urlTileSource, featureHelper],
  props: {
    /* eslint-disable vue/require-prop-types */
    // ol/source/Tile
    cacheSize: _objectSpread$1(_objectSpread$1({}, tileSource.props.cacheSize), {}, {
      default: 128
    }),
    zDirection: _objectSpread$1(_objectSpread$1({}, tileSource.props.zDirection), {}, {
      default: 1
    }),

    /* eslint-enable vue/require-prop-types */
    // ol/source/VectorTile
    extent: {
      type: Array,
      validator: function validator(value) {
        return value.length === 4 && value.every(isNumber);
      }
    },
    formatFactory: {
      type: Function,
      default: createMvtFmt
    },
    overlaps: {
      type: Boolean,
      default: true
    },
    tileClass: Function,
    maxZoom: {
      type: Number,
      default: 22
    },
    minZoom: {
      type: Number,
      default: 0,
      validator: function validator(value) {
        return value >= 0;
      }
    },
    maxResolution: Number,
    tileSize: {
      type: [Number, Array],
      default: function _default() {
        return [512, 512];
      },
      validator: validateTileSize
    }
  },
  data: function data() {
    return {
      format: undefined
    };
  },
  computed: {
    inputTileSize: function inputTileSize() {
      return isArray(this.tileSize) ? this.tileSize : [this.tileSize, this.tileSize];
    },
    derivedTileGridFactory: function derivedTileGridFactory() {
      if (isFunction(this.tileGridFactory)) {
        return this.tileGridFactory;
      }

      var extent = this.extentDataProj || extentFromProjection(this.resolvedDataProjection);
      var maxZoom = this.maxZoom;
      var minZoom = this.minZoom;
      var maxResolution = this.maxResolution;
      var tileSize = this.inputTileSize;
      return function () {
        return createXYZ({
          extent: extent,
          maxZoom: maxZoom,
          minZoom: minZoom,
          maxResolution: maxResolution,
          tileSize: tileSize
        });
      };
    },
    extentDataProj: function extentDataProj() {
      return roundExtent(this.extent);
    },
    extentViewProj: function extentViewProj() {
      return this.extentToViewProj(this.extent);
    },
    formatIdent: function formatIdent() {
      if (!this.olObjIdent) return;
      return this.makeIdent(this.olObjIdent, 'format');
    },
    inputFormatFactory: function inputFormatFactory() {
      return sealFactory(this.formatFactory.bind(this));
    },
    inputTileUrlFunction: function inputTileUrlFunction() {
      var urlFunc = coalesce(this.tileUrlFunction, this.tileUrlFunc);
      if (isFunction(urlFunc)) return urlFunc;
      if (this.currentUrls.length === 0) return;
      return createTileUrlFunctionFromTemplates(this.currentUrls, this.tileGrid);
    }
  },
  watch: _objectSpread$1({
    formatIdent: function formatIdent(value, prevValue) {
      if (value && prevValue) {
        this.moveInstance(value, prevValue);
      } else if (value && !prevValue && this.format) {
        this.setInstance(value, this.format);
      } else if (!value && prevValue) {
        this.unsetInstance(prevValue);
      }
    },
    inputFormatFactory: function inputFormatFactory(value) {
      while (this.hasInstance(this.formatIdent)) {
        this.unsetInstance(this.formatIdent);
      }

      if (isFunction(value)) {
        this.format = this.instanceFactoryCall(this.formatIdent, value.bind(this));
      } else {
        this.format = undefined;
      }
    }
  }, /*#__PURE__*/makeChangeOrRecreateWatchers(['extentViewProj', 'overlaps', 'tileClass'], ['extentViewProj'])),
  created: function created() {
    if (isFunction(this.inputFormatFactory)) {
      this.format = this.instanceFactoryCall(this.formatIdent, this.inputFormatFactory.bind(this));
    }
  },
  methods: {
    /**
     * @return {VectorTileSource}
     */
    createSource: function createSource() {
      return new VectorTile$1({
        // ol/source/Source
        attributions: this.currentAttributions,
        attributionsCollapsible: this.attributionsCollapsible,
        projection: this.resolvedDataProjection,
        state: this.currentState,
        wrapX: this.wrapX,
        // ol/source/Tile
        cacheSize: this.cacheSize,
        tileGrid: this.tileGrid,
        transition: this.transition,
        zDirection: this.zDirection,
        // ol/source/UrlTile
        tileLoadFunction: this.currentTileLoadFunction,
        tileUrlFunction: this.currentTileUrlFunction,
        // ol/source/VectorTile
        format: this.format,
        extent: this.extentViewProj,
        overlaps: this.overlaps,
        tileClass: this.tileClass
      });
    },

    /**
     * @returns {void}
     */
    subscribeAll: function subscribeAll() {
      urlTileSource.methods.subscribeAll.call(this);
      subscribeToSourceEvents.call(this);
    },
    getFeaturesInExtent: function getFeaturesInExtent(extent) {
      var _arguments = arguments,
          _this = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {
        var viewProj;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                viewProj = _arguments.length > 1 && _arguments[1] !== undefined ? _arguments[1] : false;
                extent = viewProj ? roundExtent(extent) : _this.extentToViewProj(extent);
                _context.next = 4;
                return _this.resolveSource();

              case 4:
                return _context.abrupt("return", _context.sent.getFeaturesInExtent(extent));

              case 5:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    },
    clear: function clear() {
      var _this2 = this;

      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {
        return _regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return _this2.resolveSource();

              case 2:
                _context2.sent.clear();

              case 3:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }))();
    },
    tileKeyChanged: noop,
    opaqueChanged: noop,
    tilePixelRatioChanged: noop
  }
};

function subscribeToSourceEvents() {
  var _this3 = this;

  this.subscribeTo(fromOlEvent(this.$source, TileEventType.TILELOADEND), function (evt) {
    if (!evt.tile) return;
    forEach(evt.tile.getFeatures(), function (feature) {
      if (!(feature instanceof Feature$1)) return;

      _this3.initializeFeature(feature);
    });
  });
}

/* script */
var __vue_script__$2 = script$2;
/* template */

/* style */

var __vue_inject_styles__$2 = undefined;
/* scoped */

var __vue_scope_id__$2 = undefined;
/* module identifier */

var __vue_module_identifier__$2 = undefined;
/* functional template */

var __vue_is_functional_template__$2 = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$2 = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$2, __vue_script__$2, __vue_scope_id__$2, __vue_is_functional_template__$2, __vue_module_identifier__$2, false, undefined, undefined, undefined);

function plugin$3(Vue) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$3.installed) {
    return;
  }

  plugin$3.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$2, options);
  Vue.component(__vue_component__$2.name, __vue_component__$2);
}

var VectorTileSource = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$3,
  install: plugin$3,
  Source: __vue_component__$2
});

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
var script$1 = {
  name: 'VlSourceWmts',
  mixins: [tileImageSource],
  props: {
    // ol/source/WMTS
    layerName: {
      type: String,
      required: true
    },
    styleName: {
      type: String,
      required: true
    },
    matrixSet: {
      type: String,
      required: true
    },
    dimensions: Object,
    format: {
      type: String,
      default: 'image/jpeg'
    },
    requestEncoding: {
      type: String,
      default: 'KVP'
    },
    version: {
      type: String,
      default: '1.0.0'
    },
    // custom
    extent: {
      type: Array,
      validator: function validator(value) {
        return value.length === 4 && value.every(isNumber);
      }
    },
    resolutions: {
      type: Array,
      validator: function validator(value) {
        return value.every(isNumber);
      }
    },
    origin: {
      type: Array,
      validator: function validator(value) {
        return value.length === 2 && value.every(isNumber);
      }
    },
    matrixIds: {
      type: Array,
      validator: function validator(value) {
        return value.every(isNumber);
      }
    },
    maxZoom: {
      type: Number,
      default: DEFAULT_MAX_ZOOM
    },
    minZoom: {
      type: Number,
      default: 0
    },
    tileSize: {
      type: [Number, Array],
      default: function _default() {
        return [DEFAULT_TILE_SIZE, DEFAULT_TILE_SIZE];
      }
    }
  },
  computed: {
    extentDataProj: function extentDataProj() {
      return roundExtent(this.extent);
    },
    extentViewProj: function extentViewProj() {
      return this.extentToViewProj(this.extent);
    },
    originDataProj: function originDataProj() {
      return roundPointCoords(this.origin);
    },
    originViewProj: function originViewProj() {
      return this.pointToViewProj(this.origin);
    },
    inputTileSize: function inputTileSize() {
      return isArray(this.tileSize) ? this.tileSize : [this.tileSize, this.tileSize];
    },
    derivedTileGridFactory: function derivedTileGridFactory() {
      if (isFunction(this.tileGridFactory)) {
        return this.tileGridFactory;
      }

      var extent = this.extentDataProj || extentFromProjection(this.resolvedDataProjection);
      var resolutions = this.resolutions || resolutionsFromExtent(extent, this.maxZoom, this.inputTileSize);
      var origin = this.originDataProj || getCorner(extent, ExtentCorner.TOP_LEFT);
      var matrixIds = this.matrixIds || range(this.minZoom, resolutions.length);
      var tileSize = this.inputTileSize;
      var minZoom = this.minZoom;
      return function () {
        return new WMTSTileGrid({
          extent: extent,
          origin: origin,
          resolutions: resolutions,
          minZoom: minZoom,
          matrixIds: matrixIds,
          tileSize: tileSize
        });
      };
    },
    inputTileUrlFunction: noop
  },
  watch: _objectSpread({}, /*#__PURE__*/makeChangeOrRecreateWatchers(['dimensions', 'format', 'layerName', 'styleName', 'matrixSet', 'requestEncoding', 'version'], ['dimensions'])),
  methods: {
    /**
     * @returns {WMTS}
     * @protected
     */
    createSource: function createSource() {
      return new WMTS({
        // ol/source/Source
        attributions: this.currentAttributions,
        projection: this.resolvedDataProjection,
        wrapX: this.wrapX,
        // ol/source/Tile
        cacheSize: this.cacheSize,
        tileGrid: this.tileGrid,
        tilePixelRatio: this.tilePixelRatio,
        transition: this.transition,
        // ol/source/UrlTile
        urls: this.currentUrls,
        tileLoadFunction: this.currentTileLoadFunction,
        // ol/source/TileImage
        crossOrigin: this.crossOrigin,
        reprojectionErrorThreshold: this.reprojectionErrorThreshold,
        tileClass: this.tileClass,
        imageSmoothing: this.imageSmoothing,
        // ol/source/WMTS
        dimensions: this.dimensions,
        format: this.format,
        layer: this.layerName,
        style: this.styleName,
        matrixSet: this.matrixSet,
        requestEncoding: this.requestEncoding,
        version: this.version
      });
    },
    getDimensions: function getDimensions() {
      var _this$$source;

      return coalesce((_this$$source = this.$source) === null || _this$$source === void 0 ? void 0 : _this$$source.getDimensions(), this.dimensions);
    },
    getFormat: function getFormat() {
      var _this$$source2;

      return coalesce((_this$$source2 = this.$source) === null || _this$$source2 === void 0 ? void 0 : _this$$source2.getFormat(), this.format);
    },
    getLayer: function getLayer() {
      var _this$$source3;

      return coalesce((_this$$source3 = this.$source) === null || _this$$source3 === void 0 ? void 0 : _this$$source3.getLayer(), this.layerName);
    },
    getMatrixSet: function getMatrixSet() {
      var _this$$source4;

      return coalesce((_this$$source4 = this.$source) === null || _this$$source4 === void 0 ? void 0 : _this$$source4.getMatrixSet(), this.matrixSet);
    },
    getRequestEncoding: function getRequestEncoding() {
      var _this$$source5;

      return coalesce((_this$$source5 = this.$source) === null || _this$$source5 === void 0 ? void 0 : _this$$source5.getRequestEncoding(), this.requestEncoding);
    },
    getStyle: function getStyle() {
      var _this$$source6;

      return coalesce((_this$$source6 = this.$source) === null || _this$$source6 === void 0 ? void 0 : _this$$source6.getStyle(), this.styleName);
    },
    getVersion: function getVersion() {
      var _this$$source7;

      return coalesce((_this$$source7 = this.$source) === null || _this$$source7 === void 0 ? void 0 : _this$$source7.getVersion(), this.version);
    },
    attributionsCollapsibleChanged: noop,
    stateChanged: noop,
    tileKeyChanged: noop,
    opaqueChanged: noop,
    zDirectionChanged: noop,
    inputTileUrlFunctionChanged: noop
  }
};

function resolutionsFromExtent(extent, maxZoom, tileSize, maxResolution) {
  maxZoom = maxZoom !== undefined ? maxZoom : DEFAULT_MAX_ZOOM;
  var height = getHeight(extent);
  var width = getWidth(extent);
  tileSize = toSize(tileSize !== undefined ? tileSize : DEFAULT_TILE_SIZE);
  maxResolution = maxResolution > 0 ? maxResolution : Math.max(width / tileSize[0], height / tileSize[1]);
  var length = maxZoom + 1;
  var resolutions = new Array(length);

  for (var z = 0; z < length; ++z) {
    resolutions[z] = maxResolution / Math.pow(2, z);
  }

  return resolutions;
}

/* script */
var __vue_script__$1 = script$1;
/* template */

/* style */

var __vue_inject_styles__$1 = undefined;
/* scoped */

var __vue_scope_id__$1 = undefined;
/* module identifier */

var __vue_module_identifier__$1 = undefined;
/* functional template */

var __vue_is_functional_template__$1 = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__$1 = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__$1, __vue_script__$1, __vue_scope_id__$1, __vue_is_functional_template__$1, __vue_module_identifier__$1, false, undefined, undefined, undefined);

function plugin$2(Vue) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$2.installed) {
    return;
  }

  plugin$2.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__$1, options);
  Vue.component(__vue_component__$1.name, __vue_component__$1);
}

var WmtsSource = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$2,
  install: plugin$2,
  Source: __vue_component__$1
});

var script = {
  name: 'VlSourceXyz',
  mixins: [xyzSource]
};

/* script */
var __vue_script__ = script;
/* template */

/* style */

var __vue_inject_styles__ = undefined;
/* scoped */

var __vue_scope_id__ = undefined;
/* module identifier */

var __vue_module_identifier__ = undefined;
/* functional template */

var __vue_is_functional_template__ = undefined;
/* style inject */

/* style inject SSR */

/* style inject shadow dom */

var __vue_component__ = /*#__PURE__*/normalizeComponent({}, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, false, undefined, undefined, undefined);

function plugin$1(Vue) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin$1.installed) {
    return;
  }

  plugin$1.installed = true;
  options = pick(options, 'dataProjection');
  Object.assign(__vue_component__, options);
  Vue.component(__vue_component__.name, __vue_component__);
}

var XyzSource = /*#__PURE__*/Object.freeze({
  __proto__: null,
  'default': plugin$1,
  install: plugin$1,
  Source: __vue_component__
});

/**
 * @const {string} VueLayers version.
 */

var VERSION = '0.12.0-rc.26';
/**
 * @typedef {Object} VueLayersOptions
 * @property {string} [dataProjection] Projection for all properties, events and other plain values.
 */

/**
 * Registers all VueLayers components.
 * @param {Vue|VueConstructor} Vue
 * @param {VueLayersOptions} [options]
 */

function plugin(Vue) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (plugin.installed) {
    return;
  }

  plugin.installed = true; // install components

  Vue.use(BingmapsSource, options);
  Vue.use(ClusterSource, options);
  Vue.use(DrawInteraction, options);
  Vue.use(Feature, options);
  Vue.use(Geoloc, options);
  Vue.use(GraticuleLayer, options);
  Vue.use(GroupLayer, options);
  Vue.use(HeatmapLayer, options);
  Vue.use(ImageArcgisRestSource, options);
  Vue.use(ImageLayer, options);
  Vue.use(ImageStaticSource, options);
  Vue.use(ImageWmsSource, options);
  Vue.use(Map, options);
  Vue.use(MapboxSource, options);
  Vue.use(MapboxVectorLayer, options);
  Vue.use(ModifyInteraction, options);
  Vue.use(OsmSource, options);
  Vue.use(Overlay, options);
  Vue.use(RotateInteraction, options);
  Vue.use(SelectInteraction, options);
  Vue.use(SnapInteraction, options);
  Vue.use(SputnikSource, options);
  Vue.use(StamenSource, options);
  Vue.use(Style, options);
  Vue.use(StyleFunc, options);
  Vue.use(TileArcgisRestSource, options);
  Vue.use(TileLayer, options);
  Vue.use(TileWmsSource, options);
  Vue.use(TranslateInteraction, options);
  Vue.use(VectorImageLayer, options);
  Vue.use(VectorLayer, options);
  Vue.use(VectorSource, options);
  Vue.use(VectorTileLayer, options);
  Vue.use(VectorTileSource, options);
  Vue.use(WmtsSource, options);
  Vue.use(XyzSource, options);
}

export default plugin;
export { BingmapsSource, ClusterSource, DrawInteraction, Feature, Geoloc, GraticuleLayer, GroupLayer, HeatmapLayer, ImageArcgisRestSource, ImageLayer, ImageStaticSource, ImageWmsSource, Map, MapboxSource, MapboxVectorLayer, ModifyInteraction, OsmSource, Overlay, RotateInteraction, SelectInteraction, SnapInteraction, SputnikSource, StamenSource, Style, StyleFunc, TileArcgisRestSource, TileLayer, TileWmsSource, TranslateInteraction, VERSION, VectorImageLayer, VectorLayer, VectorSource, VectorTileLayer, VectorTileSource, WmtsSource, XyzSource, plugin as install };
//# sourceMappingURL=vuelayers.esm.js.map
