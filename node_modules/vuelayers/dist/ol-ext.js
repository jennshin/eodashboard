/**
 * VueLayers
 * Web map Vue components with the power of OpenLayers
 *
 * @package vuelayers
 * @author Vladimir Vershinin <ghettovoice@gmail.com>
 * @version 0.12.0-rc.26
 * @license MIT
 * @copyright (c) 2017-2021, Vladimir Vershinin <ghettovoice@gmail.com>
 */
import { Control } from 'ol/control';
import { v4 } from 'uuid';
import GeometryType from 'ol/geom/GeometryType';
import { round, isEqual, and, isArray, every, isNumber, assert, isPlainObject, addPrefix, reduce, isNumeric, isFunction, filter, identity, noop, clonePlainObject, omit, map } from './utils';
import { getBottomLeft, getBottomRight, getTopLeft, getTopRight } from 'ol/extent';
import Corner from 'ol/extent/Corner';
import { Feature, PluggableMap, Overlay, View } from 'ol';
import _defineProperty from '@babel/runtime/helpers/esm/defineProperty';
import _classCallCheck from '@babel/runtime/helpers/esm/classCallCheck';
import _createClass from '@babel/runtime/helpers/esm/createClass';
import _get from '@babel/runtime/helpers/esm/get';
import _inherits from '@babel/runtime/helpers/esm/inherits';
import _possibleConstructorReturn from '@babel/runtime/helpers/esm/possibleConstructorReturn';
import _getPrototypeOf from '@babel/runtime/helpers/esm/getPrototypeOf';
import { MVT, GeoJSON as GeoJSON$1 } from 'ol/format';
import { Point, LineString, Polygon, MultiPoint, MultiLineString, MultiPolygon, GeometryCollection, Circle, Geometry } from 'ol/geom';
import { isEmpty as isEmpty$1 } from 'ol/obj';
import { getLength } from 'ol/sphere';
import pointOnFeature from '@turf/point-on-feature';
import { circular } from 'ol/geom/Polygon';
import { toLonLat, fromLonLat, transform as transform$1, transformExtent as transformExtent$1, get } from 'ol/proj';
import { Style, Image, Fill, Stroke, Text, RegularShape, Circle as Circle$1, Icon } from 'ol/style';
import parseColor from 'parse-color';
import { Interaction } from 'ol/interaction';
import BaseLayer from 'ol/layer/Base';
import { Source } from 'ol/source';
import Units, { METERS_PER_UNIT } from 'ol/proj/Units';

function getControlId(control) {
  if (control instanceof Control) {
    return control.get('id');
  }

  throw new Error('Illegal control argument');
}
function setControlId(control, controlId) {
  if (control instanceof Control) {
    control.set('id', controlId);
    return control;
  }

  throw new Error('Illegal control argument');
}
function initializeControl(control, defaultControlId) {
  if (getControlId(control) == null) {
    setControlId(control, defaultControlId || v4());
  }

  return control;
}

var COORD_PRECISION = -1;
function roundExtent(extent) {
  var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
  if (!extent) return;
  return extent.map(function (x) {
    return round(x, precision);
  });
}
function roundPointCoords(coordinates) {
  var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
  if (!coordinates) return;
  return coordinates.map(function (x) {
    return round(x, precision);
  });
}
function roundLineCoords(coordinates) {
  var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
  if (!coordinates) return;
  return coordinates.map(function (point) {
    return roundPointCoords(point, precision);
  });
}
function roundPolygonCoords(coordinates) {
  var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
  if (!coordinates) return;
  return coordinates.map(function (line) {
    return roundLineCoords(line, precision);
  });
}
function roundMultiPointCoords(coordinates) {
  var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
  return roundLineCoords(coordinates, precision);
}
function roundMultiLineCoords(coordinates) {
  var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
  return roundPolygonCoords(coordinates, precision);
}
function roundMultiPolygonCoords(coordinates) {
  var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
  if (!coordinates) return;
  return coordinates.map(function (polygon) {
    return roundPolygonCoords(polygon, precision);
  });
}
function roundCoords(geomType, coordinates) {
  var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;

  switch (geomType) {
    case GeometryType.POINT:
    case GeometryType.CIRCLE:
      return roundPointCoords(coordinates, precision);

    case GeometryType.LINE_STRING:
    case GeometryType.MULTI_POINT:
      return roundLineCoords(coordinates, precision);

    case GeometryType.POLYGON:
    case GeometryType.MULTI_LINE_STRING:
      return roundPolygonCoords(coordinates, precision);

    case GeometryType.MULTI_POLYGON:
      return roundMultiPolygonCoords(coordinates, precision);
  }
}
function flatCoords(geomType, coordinates) {
  var polygonReducer = function polygonReducer(coords, lineString) {
    return coords.concat(lineString);
  };

  switch (geomType) {
    case GeometryType.POINT:
      return [coordinates];

    case GeometryType.LINE_STRING:
    case GeometryType.MULTI_POINT:
      return coordinates;

    case GeometryType.POLYGON:
    case GeometryType.MULTI_LINE_STRING:
      return coordinates.reduce(polygonReducer, []);

    case GeometryType.MULTI_POLYGON:
      return coordinates.reduce(function (coords, polygon) {
        return coords.concat(polygon.reduce(polygonReducer, []));
      }, []);

    default:
      // todo maybe return null?
      return [];
  }
}
/**
 * @param {{coordinates: number[], extent: number[]}} a
 * @param {{coordinates: number[], extent: number[]}} b
 * @returns {boolean}
 */

function isEqualCoord(a, b) {
  return isEqual(a.extent, b.extent) ? isEqual(a.coordinates, b.coordinates) : false;
}
function calcDistance(point1, point2) {
  var dx = point2[0] - point1[0];
  var dy = point2[1] - point1[1];
  var squared = dx * dx + dy * dy;
  return round(Math.sqrt(squared), COORD_PRECISION);
}
var isPointCoords = /*#__PURE__*/and(isArray, function (point) {
  return point.length >= 2;
}, function (point) {
  return every(point, isNumber);
});
var isLineCoords = /*#__PURE__*/and(isArray, function (line) {
  return line.length >= 0;
}, function (line) {
  return every(line, isPointCoords);
});
var isPolygonCoords = /*#__PURE__*/and(isArray, function (polygon) {
  return polygon.length >= 0;
}, function (polygon) {
  return every(polygon, isLineCoords);
});
var isMultiPointCoords = isLineCoords;
var isMultiLineCoords = isPolygonCoords;
var isMultiPolygonCoords = /*#__PURE__*/and(isArray, function (multiPolygon) {
  return multiPolygon.length >= 0;
}, function (multiPolygon) {
  return every(multiPolygon, isPolygonCoords);
});

// copy-paste from ol/extent
function createOrUpdate(minX, minY, maxX, maxY, extent) {
  if (extent) {
    extent[0] = minX;
    extent[1] = minY;
    extent[2] = maxX;
    extent[3] = maxY;
    return extent;
  }

  return [minX, minY, maxX, maxY];
}
function getCorner(extent, corner) {
  var coordinate;

  if (corner === Corner.BOTTOM_LEFT) {
    coordinate = getBottomLeft(extent);
  } else if (corner === Corner.BOTTOM_RIGHT) {
    coordinate = getBottomRight(extent);
  } else if (corner === Corner.TOP_LEFT) {
    coordinate = getTopLeft(extent);
  } else if (corner === Corner.TOP_RIGHT) {
    coordinate = getTopRight(extent);
  } else {
    assert(false, 'Invalid extent corner');
  }

  return coordinate;
}

function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
/**
 * @param {number|number[]} lonOrCoordinates
 * @param {number} [lat]
 * @return {Point}
 */

function createPointGeom(lonOrCoordinates, lat) {
  var coordinates = Array.isArray(lonOrCoordinates) ? lonOrCoordinates : [lonOrCoordinates, lat];
  return new Point(coordinates);
}
/**
 * @param {Array<number[]>} points
 * @returns {LineString}
 */

function createLineGeom(points) {
  return new LineString(points);
}
/**
 * @param {Array<Array<number[]>>} rings
 * @returns {Polygon}
 */

function createPolygonGeom(rings) {
  return new Polygon(rings);
}
/**
 * @param {Array<number[]>} points
 * @returns {MultiPoint}
 */

function createMultiPointGeom(points) {
  return new MultiPoint(points);
}
/**
 * @param {Array<Array<number[]>>} lines
 * @returns {MultiLineString}
 */

function createMultiLineGeom(lines) {
  return new MultiLineString(lines);
}
/**
 * @param {Array<Array<Array<number[]>>>} polygons
 * @returns {MultiPolygon}
 */

function createMultiPolygonGeom(polygons) {
  return new MultiPolygon(polygons);
}
/**
 * @param {Geometry[]} geoms
 * @returns {GeometryCollection}
 */

function createGeomCollection(geoms) {
  return new GeometryCollection(geoms);
}
/**
 * @param {Coordinate|number[]} center
 * @param {number} radius
 * @return {Polygon}
 */

function createCircularPolygon(center, radius) {
  return circular(center, radius);
}
/**
 * @param {Geometry|Object} geom
 * @return {boolean}
 * @throws {Error}
 */

function isMultiGeom(geom) {
  var multiTypes = [GeometryType.MULTI_POINT, GeometryType.MULTI_LINE_STRING, GeometryType.MULTI_POLYGON, GeometryType.GEOMETRY_COLLECTION];
  return multiTypes.includes(geom.type || geom.getType());
}
/**
 * @param {Geometry|Object} geom
 * @return {SimpleGeometry|Object}
 * @throws {Error}
 */

function toSimpleGeom(geom) {
  if (geom instanceof Circle) {
    geom = createPointGeom(geom.getCenter());
  } else if (geom.type === GeometryType.CIRCLE) {
    geom = _objectSpread$2(_objectSpread$2({}, geom), {}, {
      type: GeometryType.POINT
    });
  }

  var type = geom.type || geom.getType();
  var complexTypes = [GeometryType.GEOMETRY_COLLECTION];

  if (complexTypes.includes(type) === false) {
    return geom;
  }

  return (geom.geometries || geom.getGeometries())[0];
}
/**
 * @param {Geometry|Object} geom
 * @param {number} [precision=COORD_PRECISION]
 * @return {Coordinate|undefined}
 */

function findPointOnSurface(geom) {
  var precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : COORD_PRECISION;
  var simpleGeom = toSimpleGeom(geom);
  var pointFeature = pointOnFeature({
    type: simpleGeom.type || simpleGeom.getType(),
    coordinates: simpleGeom.coordinates || simpleGeom.getCoordinates()
  });

  if (pointFeature !== null && pointFeature !== void 0 && pointFeature.geometry) {
    return roundCoords(pointFeature.geometry.type, pointFeature.geometry.coordinates, precision);
  }
}
function getGeometryId(geometry) {
  if (geometry instanceof Geometry) {
    return geometry.get('id');
  } else if (isPlainObject(geometry)) {
    return geometry.id;
  }

  throw new Error('Illegal geometry argument');
}
function setGeometryId(geometry, geometryId) {
  if (geometry instanceof Geometry) {
    geometry.set('id', geometryId);
    return geometry;
  } else if (isPlainObject(geometry)) {
    geometry.id = geometryId;
    return geometry;
  }

  throw new Error('Illegal geometry argument');
}
function initializeGeometry(geometry, defaultGeometryId) {
  if (getGeometryId(geometry) == null) {
    setGeometryId(geometry, defaultGeometryId || v4());
  }

  return geometry;
}
/**
 * @param value
 * @return {boolean}
 */

function isCircleGeom(value) {
  return getGeomType(value) === GeometryType.CIRCLE;
}
function getGeomCoords(geom) {
  if (!geom) return;
  var type = getGeomType(geom);

  switch (type) {
    case GeometryType.CIRCLE:
      return roundCoords(type, geom.coordinates || geom.getCenter());

    default:
      return roundCoords(type, geom.coordinates || geom.getCoordinates());
  }
}
function getGeomType(geom) {
  if (geom instanceof Geometry) {
    return geom.getType();
  }

  return geom === null || geom === void 0 ? void 0 : geom.type;
}

var _transforms;
var EPSG_4326 = 'EPSG:4326';
var EPSG_3857 = 'EPSG:3857';
/**
 * @param {number[]} coordinate
 * @param {module:ol/proj.ProjectionLike} [projection=EPSG_3857]
 * @param {number} [precision=COORD_PRECISION]
 * @return {Coordinate|number[]}
 */

function pointToLonLat(coordinate) {
  var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
  var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;
  if (!coordinate) return;
  return roundCoords(GeometryType.POINT, toLonLat(coordinate, projection), precision);
}
/**
 * @param {number[]} coordinate
 * @param {module:ol/proj.ProjectionLike} [projection]
 * @param {number} [precision=COORD_PRECISION]
 * @return {number[]}
 */

function pointFromLonLat(coordinate) {
  var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
  var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;
  if (!coordinate) return;
  return roundCoords(GeometryType.POINT, fromLonLat(coordinate, projection), precision);
}
/**
 * @param {number[]} coordinate
 * @param {module:ol/proj.ProjectionLike} sourceProjection
 * @param {module:ol/proj.ProjectionLike} destProjection
 * @param {number} [precision=COORD_PRECISION]
 * @returns {number[]}
 */

function transformPoint(coordinate, sourceProjection, destProjection) {
  var precision = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : COORD_PRECISION;
  if (!coordinate) return;
  return transform(coordinate, sourceProjection, destProjection, precision);
}
/**
 * @param {number[]} coordinate
 * @param {module:ol/proj.ProjectionLike} sourceProjection
 * @param {module:ol/proj.ProjectionLike} destProjection
 * @param {number} [precision=COORD_PRECISION]
 * @returns {number[]}
 */

function transform(coordinate, sourceProjection, destProjection) {
  var precision = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : COORD_PRECISION;
  if (!coordinate) return;
  var coord = transform$1(coordinate, sourceProjection, destProjection);

  if (coord.some(function (x) {
    return isNaN(x);
  })) {
    coord = transform$1(transform$1(coordinate, sourceProjection, EPSG_4326), EPSG_4326, destProjection);
  }

  return roundCoords(GeometryType.POINT, coord, precision);
}
/**
 * @param {Array<number[]>} coordinates
 * @param {module:ol/proj.ProjectionLike} [projection=EPSG_3857]
 * @param {number} [precision=COORD_PRECISION]
 * @return {Array<number[]>}
 */

function lineToLonLat(coordinates) {
  var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
  var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;
  if (!coordinates) return;
  return coordinates.map(function (point) {
    return pointToLonLat(point, projection, precision);
  });
}
/**
 * @param {Array<number[]>} coordinates
 * @param {ProjectionLike} [projection=EPSG_3857]
 * @param {number} [precision=COORD_PRECISION]
 * @return {Array<number[]>}
 */

function lineFromLonLat(coordinates) {
  var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
  var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;
  if (!coordinates) return;
  return coordinates.map(function (point) {
    return pointFromLonLat(point, projection, precision);
  });
}
/**
 * @param {Array<number[]>} coordinates
 * @param {module:ol/proj.ProjectionLike} sourceProjection
 * @param {module:ol/proj.ProjectionLike} destProjection
 * @param {number} [precision=COORD_PRECISION]
 * @returns {number[]}
 */

function transformLine(coordinates, sourceProjection, destProjection) {
  var precision = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : COORD_PRECISION;
  if (!coordinates) return;
  return coordinates.map(function (point) {
    return transformPoint(point, sourceProjection, destProjection, precision);
  });
}
/**
 * @param {Array<Array<number[]>>} coordinates
 * @param {module:ol/proj.ProjectionLike} [projection=EPSG_3857]
 * @param {number} [precision=COORD_PRECISION]
 * @return {Array<Array<number[]>>}
 */

function polygonToLonLat(coordinates) {
  var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
  var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;
  if (!coordinates) return;
  return coordinates.map(function (line) {
    return lineToLonLat(line, projection, precision);
  });
}
/**
 * @param {Array<Array<number[]>>} coordinates
 * @param {module:ol/proj.ProjectionLike} [projection=EPSG_3857]
 * @param {number} [precision=COORD_PRECISION]
 * @return {Array<Array<number[]>>}
 */

function polygonFromLonLat(coordinates) {
  var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
  var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;
  if (!coordinates) return;
  return coordinates.map(function (line) {
    return lineFromLonLat(line, projection, precision);
  });
}
/**
 * @param {Array<Array<number[]>>} coordinates
 * @param {module:ol/proj.ProjectionLike} sourceProjection
 * @param {module:ol/proj.ProjectionLike} destProjection
 * @param {number} [precision=COORD_PRECISION]
 * @returns {*}
 */

function transformPolygon(coordinates, sourceProjection, destProjection) {
  var precision = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : COORD_PRECISION;
  if (!coordinates) return;
  return coordinates.map(function (line) {
    return transformLine(line, sourceProjection, destProjection, precision);
  });
}
/**
 * @param {Array<number[]>} coordinates
 * @param {module:ol/proj.ProjectionLike} [projection=EPSG_3857]
 * @param {number} [precision=COORD_PRECISION]
 * @return {Array<number[]>}
 */

function multiPointToLonLat(coordinates) {
  var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
  var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;
  if (!coordinates) return;
  return coordinates.map(function (point) {
    return pointToLonLat(point, projection, precision);
  });
}
/**
 * @param {Array<number[]>} coordinates
 * @param {module:ol/proj.ProjectionLike} [projection=EPSG_3857]
 * @param {number} [precision=COORD_PRECISION]
 * @return {Array<number[]>}
 */

function multiPointFromLonLat(coordinates) {
  var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
  var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;
  if (!coordinates) return;
  return coordinates.map(function (point) {
    return pointFromLonLat(point, projection, precision);
  });
}
/**
 * @param {Array<number[]>} coordinates
 * @param {module:ol/proj.ProjectionLike} sourceProjection
 * @param {module:ol/proj.ProjectionLike} destProjection
 * @param {number} [precision=COORD_PRECISION]
 * @return {Array<number[]>}
 */

function transformMultiPoint(coordinates, sourceProjection, destProjection) {
  var precision = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : COORD_PRECISION;
  if (!coordinates) return;
  return coordinates.map(function (point) {
    return transformPoint(point, sourceProjection, destProjection, precision);
  });
}
/**
 * @param {Array<Array<number[]>>} coordinates
 * @param {module:ol/proj.ProjectionLike} [projection=EPSG_3857]
 * @param {number} [precision=COORD_PRECISION]
 * @return {Array<Array<number[]>>}
 */

function multiLineToLonLat(coordinates) {
  var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
  var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;
  if (!coordinates) return;
  return coordinates.map(function (line) {
    return lineToLonLat(line, projection, precision);
  });
}
/**
 * @param {Array<Array<number[]>>} coordinates
 * @param {module:ol/proj.ProjectionLike} [projection=EPSG_3857]
 * @param {number} [precision=COORD_PRECISION]
 * @return {Array<Array<number[]>>}
 */

function multiLineFromLonLat(coordinates) {
  var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
  var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;
  if (!coordinates) return;
  return coordinates.map(function (line) {
    return lineFromLonLat(line, projection, precision);
  });
}
/**
 * @param {Array<Array<number[]>>} coordinates
 * @param {module:ol/proj.ProjectionLike} sourceProjection
 * @param {module:ol/proj.ProjectionLike} destProjection
 * @param {number} [precision=COORD_PRECISION]
 * @return {Array<Array<number[]>>}
 */

function transformMultiLine(coordinates, sourceProjection, destProjection) {
  var precision = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : COORD_PRECISION;
  if (!coordinates) return;
  return coordinates.map(function (line) {
    return transformLine(line, sourceProjection, destProjection, precision);
  });
}
/**
 * @param {Array<Array<Array<number[]>>>} coordinates
 * @param {module:ol/proj.ProjectionLike} [projection=EPSG_3857]
 * @param {number} [precision=COORD_PRECISION]
 * @return {Array<Array<Array<number[]>>>}
 */

function multiPolygonToLonLat(coordinates) {
  var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
  var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;
  if (!coordinates) return;
  return coordinates.map(function (polygon) {
    return polygonToLonLat(polygon, projection, precision);
  });
}
/**
 * @param {Array<Array<Array<number[]>>>} coordinates
 * @param {module:ol/proj.ProjectionLike} [projection=EPSG_3857]
 * @param {number} [precision=COORD_PRECISION]
 * @return {Array<Array<Array<number[]>>>}
 */

function multiPolygonFromLonLat(coordinates) {
  var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
  var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;
  if (!coordinates) return;
  return coordinates.map(function (polygon) {
    return polygonFromLonLat(polygon, projection, precision);
  });
}
/**
 * @param {Array<Array<Array<number[]>>>} coordinates
 * @param {module:ol/proj.ProjectionLike} sourceProjection
 * @param {module:ol/proj.ProjectionLike} destProjection
 * @param {number} [precision=COORD_PRECISION]
 * @return {Array<Array<Array<number[]>>>}
 */

function transformMultiPolygon(coordinates, sourceProjection, destProjection) {
  var precision = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : COORD_PRECISION;
  if (!coordinates) return;
  return coordinates.map(function (polygon) {
    return transformPolygon(polygon, sourceProjection, destProjection, precision);
  });
}
/**
 * Transforms by geom type
 * @type {Object<string, function>}
 */

var transforms = (_transforms = {}, _defineProperty(_transforms, GeometryType.POINT, {
  toLonLat: pointToLonLat,
  fromLonLat: pointFromLonLat,
  transform: transformPoint
}), _defineProperty(_transforms, GeometryType.LINE_STRING, {
  toLonLat: lineToLonLat,
  fromLonLat: lineFromLonLat,
  transform: transformLine
}), _defineProperty(_transforms, GeometryType.POLYGON, {
  toLonLat: polygonToLonLat,
  fromLonLat: polygonFromLonLat,
  transform: transformPolygon
}), _defineProperty(_transforms, GeometryType.MULTI_POINT, {
  toLonLat: multiPointToLonLat,
  fromLonLat: multiPointFromLonLat,
  transform: transformMultiPoint
}), _defineProperty(_transforms, GeometryType.MULTI_LINE_STRING, {
  toLonLat: multiLineToLonLat,
  fromLonLat: multiLineFromLonLat,
  transform: transformMultiLine
}), _defineProperty(_transforms, GeometryType.MULTI_POLYGON, {
  toLonLat: multiPolygonToLonLat,
  fromLonLat: multiPolygonFromLonLat,
  transform: transformMultiPolygon
}), _defineProperty(_transforms, GeometryType.CIRCLE, {
  toLonLat: pointToLonLat,
  fromLonLat: pointFromLonLat,
  transform: transformPoint
}), _transforms);
/**
 * @param {number[]} extent
 * @param {module:ol/proj.ProjectionLike} sourceProjection
 * @param {module:ol/proj.ProjectionLike} destProjection
 * @param {number} [precision=COORD_PRECISION]
 * @return {number[]}
 */

function transformExtent(extent, sourceProjection, destProjection) {
  var precision = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : COORD_PRECISION;
  if (!extent) return;
  if (extent.every(function (x) {
    return !isFinite(x);
  })) return extent;
  var ext = transformExtent$1(extent, sourceProjection, destProjection);

  if (ext.some(function (x) {
    return isNaN(x);
  })) {
    ext = transformExtent$1(transformExtent$1(extent, sourceProjection, EPSG_4326), EPSG_4326, destProjection);
  }

  return roundExtent(ext, precision);
}
/**
 * @param {number[]} extent
 * @param {module:ol/proj.ProjectionLike} [projection=EPSG:3857]
 * @param {number} [precision=COORD_PRECISION]
 * @return {number[]}
 */

function extentFromLonLat(extent) {
  var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
  var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;
  if (!extent) return;
  return transformExtent(extent, EPSG_4326, projection, precision);
}
/**
 * @param {number[]} extent
 * @param {module:ol/proj.ProjectionLike} [projection=EPSG:3857]
 * @param {number} [precision=COORD_PRECISION]
 * @return {number[]}
 */

function extentToLonLat(extent) {
  var projection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
  var precision = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : COORD_PRECISION;
  if (!extent) return;
  return transformExtent(extent, projection, EPSG_4326, precision);
}
function transformDistance(distance, sourceProjection, destProjection) {
  var precision = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : COORD_PRECISION;
  if (!distance) return;
  var line = transformLine([[0, 0], [distance, 0]], sourceProjection, destProjection, precision);
  return calcDistance(line[0], line[1]);
}

function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function isStyle(style) {
  return style instanceof Style || style instanceof Image || style instanceof Fill || style instanceof Stroke || style instanceof Text || style instanceof Function;
}

function getStyleId(style) {
  if (isStyle(style)) {
    return style.id;
  }

  throw new Error('Illegal style argument');
}
function setStyleId(style, styleId) {
  if (isStyle(style)) {
    style.id = styleId;
    return style;
  }

  throw new Error('Illegal style argument');
}
function initializeStyle(style, defaultStyleId) {
  if (getStyleId(style) == null) {
    setStyleId(style, defaultStyleId || v4());
  }

  return style;
}
/**
 * @return {VlStyle[]}
 */

function defaultStyle() {
  return [{
    fillColor: [255, 255, 255, 0.4],
    strokeColor: '#3399cc',
    strokeWidth: 1.25,
    imageRadius: 5
  }];
}
/**
 * @return {Object<GeometryType, VlStyle[]>}
 */

function defaultEditStyle() {
  /** @type {Object<GeometryType, VlStyle[]>} */
  var styles = {};
  var white = [255, 255, 255, 1];
  var blue = [0, 153, 255, 1];
  var width = 3;
  styles[GeometryType.LINE_STRING] = [{
    strokeColor: white,
    strokeWidth: width + 2
  }, {
    strokeColor: blue,
    strokeWidth: width
  }];
  styles[GeometryType.MULTI_LINE_STRING] = styles[GeometryType.LINE_STRING];
  styles[GeometryType.POLYGON] = [{
    fillColor: [255, 255, 255, 0.5]
  }].concat(styles[GeometryType.LINE_STRING]);
  styles[GeometryType.MULTI_POLYGON] = styles[GeometryType.POLYGON];
  styles[GeometryType.CIRCLE] = styles[GeometryType.POLYGON].concat(styles[GeometryType.LINE_STRING]);
  styles[GeometryType.POINT] = [{
    imageRadius: width * 2,
    fillColor: blue,
    strokeColor: white,
    strokeWidth: width / 2,
    zIndex: Infinity
  }];
  styles[GeometryType.MULTI_POINT] = styles[GeometryType.POINT];
  styles[GeometryType.GEOMETRY_COLLECTION] = styles[GeometryType.POLYGON].concat(styles[GeometryType.LINE_STRING], styles[GeometryType.POINT]);
  return styles;
}

var isEmpty = function isEmpty(x) {
  if (x == null) return true;
  if (typeof x === 'number') return false;
  return (typeof x === 'string' || Array.isArray(x)) && !x.length || !Object.keys(x).length;
};
/**
 * @param {VlStyle} vlStyle
 * @param {function} [geomReader=identity]
 * @return {Style|undefined}
 */


function createStyle(vlStyle) {
  var geomReader = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;
  if (isEmpty(vlStyle)) return;
  var olStyle = {
    text: createTextStyle(vlStyle, 'text'),
    fill: createFillStyle(vlStyle, 'fill'),
    stroke: createStrokeStyle(vlStyle, 'stroke'),
    image: createImageStyle(vlStyle, 'image'),
    geometry: createGeomStyle(vlStyle, geomReader),
    zIndex: vlStyle.zIndex,
    renderer: vlStyle.renderer
  };

  if (!isEmpty(olStyle)) {
    return new Style(olStyle);
  }
}
/**
 * @param {*} color
 * @returns {*}
 */

function normalizeColor(color) {
  var c = color;

  if (typeof color === 'string') {
    c = parseColor(color).rgba;
  }

  return c;
}
/**
 * @param {VlStyle} vlStyle
 * @param {string} [prefix]
 * @returns {Fill|undefined}
 */

function createFillStyle(vlStyle) {
  var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var prefixKey = addPrefix(prefix); // check on already compiled style existence

  if (vlStyle[prefixKey()] instanceof Fill) return vlStyle[prefixKey()];
  var keys = ['color'].reduce(function (keys, key) {
    return _objectSpread$1(_objectSpread$1({}, keys), {}, _defineProperty({}, prefixKey(key), key));
  }, {});
  var fillStyle = reduce(vlStyle, function (style, value, name) {
    if (!keys[name] || value == null) return style;

    switch (keys[name]) {
      case 'color':
        value = normalizeColor(value);
        break;
    }

    style[keys[name]] = value;
    return style;
  }, {});

  if (!isEmpty(fillStyle)) {
    return new Fill(fillStyle);
  }
}
/**
 * @param {VlStyle} vlStyle
 * @param {string} [prefix]
 * @returns {Stroke|undefined}
 */

function createStrokeStyle(vlStyle) {
  var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var prefixKey = addPrefix(prefix);
  if (vlStyle[prefixKey()] instanceof Stroke) return vlStyle[prefixKey()];
  var keys = ['color', 'width', 'miterLimit', 'lineCap', 'lineJoin', 'lineDash', 'lineDashOffset'].reduce(function (keys, key) {
    return _objectSpread$1(_objectSpread$1({}, keys), {}, _defineProperty({}, prefixKey(key), key));
  }, {});
  var strokeStyle = reduce(vlStyle, function (style, value, name) {
    if (!keys[name] || value == null) return style;

    switch (keys[name]) {
      case 'color':
        value = normalizeColor(value);
        break;
    }

    style[keys[name]] = value;
    return style;
  }, {});

  if (!isEmpty(strokeStyle)) {
    return new Stroke(strokeStyle);
  }
}
/**
 * @param {VlStyle} vlStyle
 * @param {string} [prefix]
 * @returns {Image|undefined}
 * @todo split to separate circle, regShape, Icon
 */

function createImageStyle(vlStyle) {
  var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  var prefixKey = addPrefix(prefix);

  if (isEmpty(vlStyle[prefixKey('src')]) && isEmpty(vlStyle.image) && isEmpty(vlStyle[prefixKey('points')]) && !isNumeric(vlStyle[prefixKey('radius')])) {
    return;
  }

  if (vlStyle.image instanceof Image) return vlStyle.image;
  var imageStyle, Ctor;

  if (!isEmpty(vlStyle[prefixKey('src')]) || !isEmpty(vlStyle.image)) {
    // icon construction
    Ctor = Icon; // then create Icon options

    imageStyle = {
      anchor: vlStyle[prefixKey('anchor')],
      anchorOrigin: vlStyle[prefixKey('anchorOrigin')],
      anchorXUnits: vlStyle[prefixKey('anchorXUnits')],
      anchorYUnits: vlStyle[prefixKey('anchorYUnits')],
      color: vlStyle[prefixKey('color')],
      offset: vlStyle[prefixKey('offset')],
      offsetOrigin: vlStyle[prefixKey('offsetOrigin')],
      size: vlStyle[prefixKey('size')],
      img: vlStyle.image,
      imgSize: vlStyle[prefixKey('imgSize')],
      src: vlStyle[prefixKey('src')],
      crossOrigin: vlStyle[prefixKey('crossOrigin')]
    };
  } else if (vlStyle[prefixKey('points')] != null) {
    // regular shape construction
    Ctor = RegularShape; // create RegularShape options

    imageStyle = {
      points: vlStyle[prefixKey('points')],
      radius: vlStyle[prefixKey('radius')],
      radius1: vlStyle[prefixKey('radius1')],
      radius2: vlStyle[prefixKey('radius2')],
      angle: vlStyle[prefixKey('angle')]
    };
  } else {
    // circle construction
    Ctor = Circle$1; // create Circle options

    imageStyle = {
      radius: vlStyle[prefixKey('radius')]
    };
  }

  imageStyle = _objectSpread$1(_objectSpread$1({}, imageStyle), {}, {
    fill: createFillStyle(vlStyle, prefixKey('fill')),
    stroke: createStrokeStyle(vlStyle, prefixKey('stroke')),
    opacity: vlStyle[prefixKey('opacity')],
    scale: vlStyle[prefixKey('scale')],
    rotation: vlStyle[prefixKey('rotation')],
    rotateWithView: vlStyle[prefixKey('rotateWithView')],
    displacement: vlStyle[prefixKey('displacement')]
  });

  if (!isEmpty(imageStyle)) {
    return new Ctor(imageStyle);
  }
}
/**
 * @param {VlStyle} vlStyle
 * @param {string} [prefix]
 * @returns {Text|undefined}
 */

function createTextStyle(vlStyle) {
  var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  if (vlStyle.text == null) return;
  if (vlStyle.text instanceof Text) return vlStyle.text;
  var prefixKey = addPrefix(prefix);
  var textStyle = {
    text: vlStyle.text,
    textAlign: vlStyle.textAlign,
    textBaseline: vlStyle.textBaseline,
    font: vlStyle[prefixKey('font')],
    scale: vlStyle[prefixKey('scale')],
    offsetX: vlStyle[prefixKey('offsetX')],
    offsetY: vlStyle[prefixKey('offsetY')],
    rotation: vlStyle[prefixKey('rotation')],
    rotateWithView: vlStyle[prefixKey('rotateWithView')],
    padding: vlStyle[prefixKey('padding')],
    maxAngle: vlStyle[prefixKey('maxAngle')],
    overflow: vlStyle[prefixKey('overflow')],
    placement: vlStyle[prefixKey('placement')],
    fill: createFillStyle(vlStyle, prefixKey('fill')),
    stroke: createStrokeStyle(vlStyle, prefixKey('stroke')),
    backgroundFill: createFillStyle(vlStyle, prefixKey('backgroundFill')),
    backgroundStroke: createStrokeStyle(vlStyle, prefixKey('backgroundStroke'))
  };

  if (!isEmpty(textStyle)) {
    return new Text(textStyle);
  }
}
/**
 * @param {VlStyle} vlStyle
 * @param {function} [geomReader=identity]
 * @return {Geometry|Object|function|undefined}
 */

function createGeomStyle(vlStyle) {
  var geomReader = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;

  if (isFunction(vlStyle.geom)) {
    return function __styleGeomFunc(feature) {
      return vlStyle.geom(feature);
    };
  }

  if (vlStyle.geom instanceof Geometry) {
    return vlStyle.geom;
  }

  if (vlStyle.geom) {
    return geomReader(vlStyle.geom);
  }

  return null;
}
function dumpStyle(olStyle) {
  var geomWriter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;
  if (!olStyle || isFunction(olStyle)) return;
  return _objectSpread$1(_objectSpread$1(_objectSpread$1(_objectSpread$1(_objectSpread$1(_objectSpread$1({}, dumpFillStyle(olStyle.getFill(), 'fill')), dumpStrokeStyle(olStyle.getStroke(), 'stroke')), dumpImageStyle(olStyle.getImage(), 'image')), dumpTextStyle(olStyle.getText(), 'text')), dumpGeomStyle(olStyle.getGeometry(), geomWriter)), {}, {
    zIndex: olStyle.getZIndex() // renderer: olStyle.getRenderer(),

  });
}
function dumpFillStyle(fillStyle) {
  var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  if (!fillStyle) return {};
  var prefixKey = addPrefix(prefix);
  return _defineProperty({}, prefixKey('color'), fillStyle.getColor());
}
function dumpStrokeStyle(strokeStyle) {
  var _ref2;

  var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  if (!strokeStyle) return {};
  var prefixKey = addPrefix(prefix);
  return _ref2 = {}, _defineProperty(_ref2, prefixKey('color'), strokeStyle.getColor()), _defineProperty(_ref2, prefixKey('width'), strokeStyle.getWidth()), _defineProperty(_ref2, prefixKey('miterLimit'), strokeStyle.getMiterLimit()), _defineProperty(_ref2, prefixKey('lineCap'), strokeStyle.getLineCap()), _defineProperty(_ref2, prefixKey('lineJoin'), strokeStyle.getLineJoin()), _defineProperty(_ref2, prefixKey('lineDash'), strokeStyle.getLineDash()), _defineProperty(_ref2, prefixKey('lineDashOffset'), strokeStyle.getLineDashOffset()), _ref2;
}
function dumpImageStyle(imageStyle) {
  var _common, _objectSpread4, _objectSpread6;

  var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  if (!imageStyle) return {};
  var prefixKey = addPrefix(prefix);
  var common = (_common = {}, _defineProperty(_common, prefixKey('opacity'), imageStyle.getOpacity()), _defineProperty(_common, prefixKey('scale'), imageStyle.getScale()), _defineProperty(_common, prefixKey('rotation'), imageStyle.getRotation()), _defineProperty(_common, prefixKey('rotateWithView'), imageStyle.getRotateWithView()), _defineProperty(_common, prefixKey('displacement'), imageStyle.getDisplacement()), _common);

  switch (true) {
    case imageStyle instanceof Icon:
      return _objectSpread$1(_objectSpread$1({}, common), {}, (_objectSpread4 = {}, _defineProperty(_objectSpread4, prefixKey('anchor'), imageStyle.anchor_.slice()), _defineProperty(_objectSpread4, prefixKey('anchorOrigin'), imageStyle.anchorOrigin_), _defineProperty(_objectSpread4, prefixKey('anchorXUnits'), imageStyle.anchorXUnits_), _defineProperty(_objectSpread4, prefixKey('anchorYUnits'), imageStyle.anchorYUnits_), _defineProperty(_objectSpread4, prefixKey('color'), isArray(imageStyle.getColor()) ? imageStyle.getColor().slice() : imageStyle.getColor()), _defineProperty(_objectSpread4, prefixKey('offset'), imageStyle.offset_.slice()), _defineProperty(_objectSpread4, prefixKey('offsetOrigin'), imageStyle.offsetOrigin_), _defineProperty(_objectSpread4, prefixKey('size'), isArray(imageStyle.getSize()) ? imageStyle.getSize().slice() : imageStyle.getSize()), _defineProperty(_objectSpread4, prefixKey('src'), imageStyle.getSrc()), _defineProperty(_objectSpread4, prefixKey('crossOrigin'), imageStyle.crossOrigin_), _objectSpread4));

    case imageStyle instanceof Circle$1:
      return _objectSpread$1(_objectSpread$1(_objectSpread$1(_objectSpread$1({}, common), dumpFillStyle(imageStyle.getFill(), prefixKey('fill'))), dumpStrokeStyle(imageStyle.getStroke(), prefixKey('stroke'))), {}, _defineProperty({}, prefixKey('radius'), imageStyle.getRadius()));

    case imageStyle instanceof RegularShape:
      return _objectSpread$1(_objectSpread$1(_objectSpread$1(_objectSpread$1({}, common), dumpFillStyle(imageStyle.getFill(), prefixKey('fill'))), dumpStrokeStyle(imageStyle.getStroke(), prefixKey('stroke'))), {}, (_objectSpread6 = {}, _defineProperty(_objectSpread6, prefixKey('points'), imageStyle.getPoints()), _defineProperty(_objectSpread6, prefixKey('radius'), imageStyle.getRadius()), _defineProperty(_objectSpread6, prefixKey('radius2'), imageStyle.getRadius2()), _defineProperty(_objectSpread6, prefixKey('angle'), imageStyle.getAngle()), _objectSpread6));

    default:
      return _objectSpread$1({}, common);
  }
}
function dumpTextStyle(textStyle) {
  var _objectSpread7;

  var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  if (!textStyle) return {};
  var prefixKey = addPrefix(prefix);
  return filter(_objectSpread$1(_objectSpread$1(_objectSpread$1(_objectSpread$1((_objectSpread7 = {
    text: textStyle.getText(),
    textAlign: textStyle.getTextAlign(),
    textBaseline: textStyle.getTextBaseline()
  }, _defineProperty(_objectSpread7, prefixKey('font'), textStyle.getFont()), _defineProperty(_objectSpread7, prefixKey('scale'), textStyle.getScale()), _defineProperty(_objectSpread7, prefixKey('rotation'), textStyle.getRotation()), _defineProperty(_objectSpread7, prefixKey('offsetX'), textStyle.getOffsetX()), _defineProperty(_objectSpread7, prefixKey('offsetY'), textStyle.getOffsetY()), _defineProperty(_objectSpread7, prefixKey('rotateWithView'), textStyle.getRotateWithView()), _defineProperty(_objectSpread7, prefixKey('padding'), textStyle.getPadding()), _defineProperty(_objectSpread7, prefixKey('maxAngle'), textStyle.getMaxAngle()), _defineProperty(_objectSpread7, prefixKey('overflow'), textStyle.getOverflow()), _defineProperty(_objectSpread7, prefixKey('placement'), textStyle.getPlacement()), _objectSpread7), dumpFillStyle(textStyle.getFill(), prefixKey('fill'))), dumpStrokeStyle(textStyle.getStroke(), prefixKey('stroke'))), dumpFillStyle(textStyle.getBackgroundFill(), prefixKey('backgroundFill'))), dumpStrokeStyle(textStyle.getBackgroundStroke(), prefixKey('backgroundStroke'))), function (value) {
    return value != null;
  });
}
function dumpGeomStyle(geom) {
  var geomWriter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;
  if (!geom) return {};
  return {
    geom: geomWriter(geom)
  };
}
/**
 * @typedef {
 *            module:ol/style/Style~Style |
 *            module:ol/style/Image~ImageStyle |
 *            module:ol/style/Fill~Fill |
 *            module:ol/style/Stroke~Stroke |
 *            module:ol/style/Text~Text |
 *            module:ol/style/Style~StyleFunction
 *          } OlAllStyle
 */

/**
 * @typedef {Object} VlStyle
 *
 * Shared
 * @property {string|number[]|undefined} fillColor
 * @property {string|number[]|undefined} strokeColor
 * @property {number|undefined} strokeWidth
 * @property {number|undefined} strokeMiterLimit
 * @property {number[]|undefined} strokeLineDash
 * @property {number|undefined} strokeLineDashOffset
 * @property {string|undefined} strokeLineCap
 * @property {string|undefined} strokeLineJoin
 * @property {number|undefined} zIndex
 * @property {Fill|undefined} fill
 * @property {Stroke|undefined} stroke
 * @property {RenderFunction|undefined} renderer
 *
 * Text only
 * @property {string|Text|undefined} text
 * @property {string|undefined} textFont
 * @property {number|string|undefined} textFontSize
 * @property {string|undefined} textFontWeight
 * @property {string|number[]|undefined} textFillColor
 * @property {string|number[]|undefined} textStrokeColor
 * @property {number|undefined} textStrokeWidth
 * @property {number|undefined} textStrokeMiterLimit
 * @property {number[]|undefined} textStrokeLineDash
 * @property {number|undefined} textStrokeLineDashOffset
 * @property {string|undefined} textStrokeLineCap
 * @property {string|undefined} textStrokeLineJoin
 * @property {number|undefined} textScale
 * @property {string|undefined} textAlign
 * @property {number|undefined} textRotation
 * @property {number|undefined} textOffsetX
 * @property {number|undefined} textOffsetY
 * @property {Stroke|undefined} textStroke
 * @property {Fill|undefined} textFill
 * @property {boolean|undefined} textRotateWithView
 * @property {number[]|undefined} textPadding
 * @property {number|undefined} textMaxAngle
 * @property {boolean|undefined} textOverflow
 * @property {string|undefined} textPlacement
 * @property {string|undefined} textBaseline
 * @property {Fill|undefined} textBackgroundFillColor
 * @property {Stroke|undefined} textBackgroundStrokeColor
 * @property {Stroke|undefined} textBackgroundStrokeWidth
 * @property {number|undefined} textBackgroundStrokeMiterLimit
 * @property {Stroke|undefined} textBackgroundStrokeLineDash
 * @property {number|undefined} textBackgroundStrokeLineDashOffset
 * @property {Stroke|undefined} textBackgroundStrokeCap
 * @property {Stroke|undefined} textBackgroundStrokeJoin
 *
 * Image only
 * @property {Image|undefined} image
 * @property {string|undefined} imageSrc
 * @property {number[]|undefined} imageSize
 * @property {number[]|undefined} imageImgSize
 * @property {number|undefined} imageOffset
 * @property {number[]|undefined} imageAnchor
 * @property {string|undefined} imageAnchorXUnits
 * @property {string|undefined} imageAnchorYUnits
 * @property {number|undefined} imageScale
 * @property {number|undefined} imageRotation
 * @property {number|undefined} imageRadius
 * @property {number|undefined} imageRadius1
 * @property {number|undefined} imageRadius2
 * @property {number|undefined} imagePoints
 * @property {number|undefined} imageAngle
 * @property {number|undefined} imageOpacity
 * @property {string|number[]|undefined} imageFillColor
 * @property {string|number[]|undefined} imageStrokeColor
 * @property {number|undefined} imageStrokeWidth
 * @property {number|undefined} imageStrokeMiterLimit
 * @property {number[]|undefined} imageStrokeLineDash
 * @property {number|undefined} imageStrokeLineDashOffset
 * @property {string|undefined} imageStrokeLineCap
 * @property {string|undefined} imageStrokeLineJoin
 * @property {IconOrigin|undefined} imageAnchorOrigin
 * @property {ColorLike|undefined} imageColor
 * @property {IconOrigin|undefined} imageOffsetOrigin
 * @property {Stroke|undefined} imageStroke
 * @property {Fill|undefined} imageFill
 * @property {string|undefined} imageCrossOrigin
 * @property {boolean|undefined} imageRotateWithView
 * @property {number[]|undefined} imageDisplacement
 *
 * @property {Geometry|Object|function|undefined} geom Coordinates should be in map projection
 */

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
/**
 * @param {Object} [options]
 * @return {GeoJSON}
 */

function createGeoJsonFmt(options) {
  return new GeoJSON(options);
}
/**
 * @param [options]
 * @return {MVT}
 */

function createMvtFmt(options) {
  return new MVT(options);
}
var CIRCLE_SERIALIZE_PROP = 'vl_circle';
var STYLE_SERIALIZE_PROP = 'vl_style';

var GeoJSON = /*#__PURE__*/function (_BaseGeoJSON) {
  _inherits(GeoJSON, _BaseGeoJSON);

  var _super = _createSuper(GeoJSON);

  function GeoJSON() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, GeoJSON);

    _this = _super.call(this, options);
    _this.defaultDecimals = options.decimals != null && options.decimals > -1 ? options.decimals : undefined;
    _this.defaultStyleReader = options.styleReader || noop;
    _this.defaultStyleWriter = options.styleWriter || noop;
    return _this;
  }

  _createClass(GeoJSON, [{
    key: "adaptOptions",
    value: function adaptOptions() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (options.decimals != null && options.decimals < 0) {
        options.decimals = undefined;
      }

      return _get(_getPrototypeOf(GeoJSON.prototype), "adaptOptions", this).call(this, _objectSpread({
        decimals: this.defaultDecimals,
        styleReader: this.defaultStyleReader,
        styleWriter: this.defaultStyleWriter
      }, options));
    }
  }, {
    key: "writeGeometryObject",
    value: function writeGeometryObject(geometry, options) {
      options = this.adaptOptions(options);

      if (isCircleGeom(geometry)) {
        var center = geometry.getCenter().slice();
        var end = [center[0] + geometry.getRadius(), center[1]];
        var radius = getLength(new LineString([center, end]), options.featureProjection);
        center = transformPoint(center, options.featureProjection, EPSG_4326);
        geometry = createCircularPolygon(center, radius);
        options.featureProjection = EPSG_4326;
      }

      return _get(_getPrototypeOf(GeoJSON.prototype), "writeGeometryObject", this).call(this, geometry, options);
    }
  }, {
    key: "writeFeatureObject",
    value: function writeFeatureObject(feature, options) {
      var _this2 = this;

      options = this.adaptOptions(options);
      /** @type {GeoJSONFeature} */

      var object = {
        type: 'Feature',
        geometry: null,
        properties: null
      };
      var id = feature.getId();

      if (id !== undefined) {
        object.id = id;
      }
      /* eslint-disable quote-props */


      var geometry = feature.getGeometry();

      if (geometry) {
        object.geometry = this.writeGeometryObject(geometry, options);

        if (isCircleGeom(geometry)) {
          object.properties = _objectSpread(_objectSpread({}, object.properties || {}), {}, _defineProperty({}, CIRCLE_SERIALIZE_PROP, {
            center: transformPoint(geometry.getCenter(), options.featureProjection, options.dataProjection),
            radius: transformDistance(geometry.getRadius(), options.featureProjection, options.dataProjection)
          }));
        }
      }

      var properties = feature.getProperties();
      delete properties[feature.getGeometryName()];

      if (!isEmpty$1(properties)) {
        object.properties = _objectSpread(_objectSpread({}, object.properties || {}), clonePlainObject(omit(properties, 'features')));

        if (isArray(properties.features)) {
          object.properties.features = map(properties.features, function (feature) {
            if (feature instanceof Feature) {
              return _this2.writeFeatureObject(feature, options);
            }

            return feature;
          });
        }
      }

      var style = feature.getStyle();

      if (style && !isFunction(style)) {
        isArray(style) || (style = [style]);
        object.properties = _objectSpread(_objectSpread({}, object.properties || {}), {}, _defineProperty({}, STYLE_SERIALIZE_PROP, style.map(function (style) {
          return options.styleWriter(style, function (geometry) {
            return _this2.writeGeometryObject(geometry, options);
          });
        })));
      }
      /* eslint-enable quote-props */


      return object;
    }
  }, {
    key: "readFeatureFromObject",
    value: function readFeatureFromObject(object, options) {
      var _this3 = this;

      options = this.adaptOptions(options);
      /**
       * @type {GeoJSONFeature}
       */

      var geoJSONFeature;

      if (object.type === 'Feature') {
        geoJSONFeature = clonePlainObject(object);
      } else {
        geoJSONFeature = {
          type: 'Feature',
          geometry: clonePlainObject(object),
          properties: null
        };
      }

      var feature = new Feature();
      /* eslint-disable dot-notation */

      if (geoJSONFeature.properties && geoJSONFeature.properties[CIRCLE_SERIALIZE_PROP]) {
        options.circle = geoJSONFeature.properties[CIRCLE_SERIALIZE_PROP];
        delete geoJSONFeature.properties[CIRCLE_SERIALIZE_PROP];
      }

      var geometry = this.readGeometryFromObject(geoJSONFeature.geometry, options);

      if (this.geometryName_) {
        feature.setGeometryName(this.geometryName_);
      } else if (this.extractGeometryName_ && 'geometry_name' in geoJSONFeature !== undefined) {
        feature.setGeometryName(geoJSONFeature.geometry_name);
      }

      feature.setGeometry(geometry);

      if ('id' in geoJSONFeature) {
        feature.setId(geoJSONFeature.id);
      }

      if (geoJSONFeature.properties) {
        if (geoJSONFeature.properties[STYLE_SERIALIZE_PROP]) {
          var style = geoJSONFeature.properties[STYLE_SERIALIZE_PROP];
          isArray(style) || (style = [style]);
          feature.setStyle(style.map(function (style) {
            return options.styleReader(style, function (geometry) {
              return _this3.readGeometryFromObject(geometry, omit(options, ['circle']));
            });
          }));
          delete geoJSONFeature.properties[STYLE_SERIALIZE_PROP];
        }

        if (isArray(geoJSONFeature.properties.features)) {
          geoJSONFeature.properties.features = map(geoJSONFeature.properties.features, function (feature) {
            if (isGeoJSONFeature(feature)) {
              return _this3.readFeatureFromObject(feature, options);
            }

            return feature;
          });
        }

        feature.setProperties(geoJSONFeature.properties, true);
      }
      /* eslint-enable dot-notation */


      return feature;
    }
  }, {
    key: "readGeometryFromObject",
    value: function readGeometryFromObject(object, options) {
      var _options$circle, _options$circle2;

      options = this.adaptOptions(options);

      if ((_options$circle = options.circle) !== null && _options$circle !== void 0 && _options$circle.center && (_options$circle2 = options.circle) !== null && _options$circle2 !== void 0 && _options$circle2.radius) {
        return new Circle(transformPoint(options.circle.center, options.dataProjection, options.featureProjection), transformDistance(options.circle.radius, options.dataProjection, options.featureProjection));
      }

      return _get(_getPrototypeOf(GeoJSON.prototype), "readGeometryFromObject", this).call(this, clonePlainObject(object), options);
    }
  }]);

  return GeoJSON;
}(GeoJSON$1);
function getGeoJsonFmt() {

  return createGeoJsonFmt({
    decimals: COORD_PRECISION,
    styleReader: createStyle,
    styleWriter: dumpStyle
  });
}
/**
 * @param {Feature} feature
 * @param {ProjectionLike|undefined} [featureProjection=EPSG:3857]
 * @param {ProjectionLike|undefined} [dataProjection=EPSG:4326]
 * @param {number} [decimals=COORD_PRECISION]
 * @return {Object}
 */

function writeGeoJsonFeature(feature) {
  var featureProjection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
  var dataProjection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EPSG_4326;
  var decimals = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : COORD_PRECISION;
  if (!feature) return;
  return getGeoJsonFmt().writeFeatureObject(feature, {
    featureProjection: featureProjection,
    dataProjection: dataProjection,
    decimals: decimals
  });
}
/**
 * @param {Object} geoJsonFeature
 * @param {ProjectionLike|undefined} [featureProjection=EPSG:3857]
 * @param {ProjectionLike|undefined} [dataProjection=EPSG:4326]
 * @param {number} [decimals=COORD_PRECISION]
 * @return {Feature}
 */

function readGeoJsonFeature(geoJsonFeature) {
  var featureProjection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
  var dataProjection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EPSG_4326;
  var decimals = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : COORD_PRECISION;
  if (!geoJsonFeature) return;
  return getGeoJsonFmt().readFeature(geoJsonFeature, {
    featureProjection: featureProjection,
    dataProjection: dataProjection,
    decimals: decimals
  });
}
/**
 * @param {Geometry} geometry
 * @param {ProjectionLike|undefined} [geometryProjection=EPSG:3857]
 * @param {ProjectionLike|undefined} [dataProjection=EPSG:4326]
 * @param {number} [decimals=COORD_PRECISION]
 * @return {Object}
 */

function writeGeoJsonGeometry(geometry) {
  var geometryProjection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
  var dataProjection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EPSG_4326;
  var decimals = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : COORD_PRECISION;
  if (!geometry) return;
  return getGeoJsonFmt().writeGeometryObject(geometry, {
    featureProjection: geometryProjection,
    dataProjection: dataProjection,
    decimals: decimals
  });
}
/**
 * @param {Object|Object} geoJsonGeometry
 * @param {ProjectionLike|undefined} [geometryProjection=EPSG:3857]
 * @param {ProjectionLike|undefined} [dataProjection=EPSG:4326]
 * @param {number} [decimals=COORD_PRECISION]
 * @return {Geometry}
 */

function readGeoJsonGeometry(geoJsonGeometry) {
  var geometryProjection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : EPSG_3857;
  var dataProjection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : EPSG_4326;
  var decimals = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : COORD_PRECISION;
  if (!geoJsonGeometry) return;
  dataProjection = readProjection(geoJsonGeometry, dataProjection);
  return getGeoJsonFmt().readGeometry(geoJsonGeometry, {
    featureProjection: geometryProjection,
    dataProjection: dataProjection,
    decimals: decimals
  });
}
function readProjection(geoJsonObj, defaultProjection) {
  return getGeoJsonFmt().readProjection(geoJsonObj) || defaultProjection;
}
/**
 * @param {Object} feature
 * @returns {boolean}
 */

function isGeoJSONFeature(feature) {
  return isPlainObject(feature) && feature.type === 'Feature' && isGeoJSONGeometry(feature.geometry);
}
function isGeoJSONGeometry(geometry) {
  return isPlainObject(geometry) && Object.values(GeometryType).includes(geometry.type) && isArray(geometry.coordinates);
}

/**
 * @param {Object|module:ol/Feature~Feature|string|number} feature
 * @return {string|number}
 * @throws {Error}
 */

function getFeatureId(feature) {
  if (feature instanceof Feature) {
    return feature.getId();
  } else if (isPlainObject(feature)) {
    return feature.id;
  }

  throw new Error('Illegal feature format');
}
/**
 * @param {module:ol/Feature~Feature|Object} feature
 * @param {string} featureId
 * @returns {module:ol/Feature~Feature|Object}
 */

function setFeatureId(feature, featureId) {
  if (feature instanceof Feature) {
    feature.setId(featureId);
    return feature;
  } else if (isPlainObject(feature)) {
    feature.id = featureId;
    return feature;
  }

  throw new Error('Illegal feature format');
}
/**
 * @param {module:ol/Feature~Feature} feature
 * @param {string|undefined} defaultFeatureId
 * @returns {Feature}
 */

function initializeFeature(feature, defaultFeatureId) {
  if (getFeatureId(feature) == null) {
    setFeatureId(feature, defaultFeatureId || v4());
  }

  return feature;
}
function getFeatureGeomName(feature) {
  if (feature instanceof Feature) {
    return feature.getGeometryName();
  }

  return 'geometry';
}
function getFeatureGeom(feature) {
  if (feature instanceof Feature) {
    return feature.getGeometry();
  } else if (isPlainObject(feature)) {
    return feature.geometry;
  }

  throw new Error('Illegal feature format');
}
function getFeatureProperties(feature) {
  if (!feature) return;
  return omit((feature instanceof Feature ? feature.getProperties() : feature.properties) || {}, [getFeatureGeomName(feature), CIRCLE_SERIALIZE_PROP, STYLE_SERIALIZE_PROP]);
}
function setFeatureProperties(feature, properties) {
  if (!feature) return;
  properties = omit(properties || {}, [getFeatureGeomName(feature), CIRCLE_SERIALIZE_PROP, STYLE_SERIALIZE_PROP]);

  if (feature instanceof Feature) {
    feature.setProperties(properties);
  } else {
    feature.properties = properties;
  }
}

/**
 * @param {module:ol/interaction/Interaction~Interaction|Object} interaction
 * @returns {string|null}
 */

function getInteractionId(interaction) {
  if (interaction instanceof Interaction) {
    return interaction.get('id');
  }

  throw new Error('Illegal interaction argument');
}
/**
 * @param {module:ol/interaction/Interaction~Interaction|Object} interaction
 * @param {string} interactionId
 * @returns {module:ol/interaction/Interaction~Interaction|Object}
 */

function setInteractionId(interaction, interactionId) {
  if (interaction instanceof Interaction) {
    interaction.set('id', interactionId);
    return interaction;
  }

  throw new Error('Illegal interaction argument');
}
function getInteractionPriority(interaction) {
  if (interaction instanceof Interaction) {
    return interaction.get('priority');
  }

  throw new Error('Illegal interaction argument');
}
function setInteractionPriority(interaction, priority) {
  if (interaction instanceof Interaction) {
    interaction.set('priority', priority);
    return interaction;
  }

  throw new Error('Illegal interaction argument');
}
function initializeInteraction(interaction, defaultInteractionId, defaultPriority) {
  if (getInteractionId(interaction) == null) {
    setInteractionId(interaction, defaultInteractionId || v4());
  }

  if (getInteractionPriority(interaction) == null) {
    setInteractionPriority(interaction, defaultPriority || 0);
  }

  return interaction;
}

function getLayerId(layer) {
  if (layer instanceof BaseLayer) {
    return layer.get('id');
  }

  throw new Error('Illegal layer argument');
}
function setLayerId(layer, layerId) {
  if (layer instanceof BaseLayer) {
    layer.set('id', layerId);
    return layer;
  }

  throw new Error('Illegal layer argument');
}
function initializeLayer(layer, defaultLayerId) {
  if (getLayerId(layer) == null) {
    setLayerId(layer, defaultLayerId || v4());
  }

  return layer;
}

function getMapId(map) {
  if (map instanceof PluggableMap) {
    return map.get('id');
  }

  throw new Error('Illegal map argument');
}
function setMapId(map, mapId) {
  if (map instanceof PluggableMap) {
    map.set('id', mapId);
    return map;
  }

  throw new Error('Illegal map argument');
}
function getMapDataProjection(map) {
  if (map instanceof PluggableMap) {
    return map.get('dataProjection');
  }

  throw new Error('Illegal map argument');
}
function setMapDataProjection(map, dataProjection) {
  if (map instanceof PluggableMap) {
    map.set('dataProjection', dataProjection);
    return map;
  }

  throw new Error('Illegal map argument');
}

function getOverlayId(overlay) {
  if (overlay instanceof Overlay) {
    return overlay.get('id');
  }

  throw new Error('Illegal overlay argument');
}
function setOverlayId(overlay, overlayId) {
  if (overlay instanceof Overlay) {
    overlay.set('id', overlayId);
    return overlay;
  }

  throw new Error('Illegal overlay argument');
}
function initializeOverlay(overlay, defaultOverlay) {
  if (getOverlayId(overlay) == null) {
    setOverlayId(overlay, defaultOverlay || v4());
  }

  return overlay;
}

function getSourceId(source) {
  if (source instanceof Source) {
    return source.get('id');
  }

  throw new Error('Illegal source argument');
}
function setSourceId(source, sourceId) {
  if (source instanceof Source) {
    source.set('id', sourceId);
    return source;
  }

  throw new Error('Illegal source argument');
}
function initializeSource(source, defaultSourceId) {
  if (getSourceId(source) == null) {
    setSourceId(source, defaultSourceId || v4());
  }

  return source;
}
function cleanSourceParams(params, filterKeys) {
  return reduce(params, function (params, value, key) {
    key = key.toUpperCase();

    if (filterKeys.includes(key)) {
      return params;
    }

    params[key] = value;
    return params;
  }, {});
}

function extentFromProjection(projection) {
  projection = get(projection);
  var extent = projection.getExtent();

  if (!extent) {
    var half = 180 * METERS_PER_UNIT[Units.DEGREES] / projection.getMetersPerUnit();
    extent = createOrUpdate(-half, -half, half, half);
  }

  return extent;
}

function getViewId(view) {
  if (view instanceof View) {
    return view.get('id');
  }

  throw new Error('Illegal view argument');
}
function setViewId(view, viewId) {
  if (view instanceof View) {
    view.set('id', viewId);
    return view;
  }

  throw new Error('Illegal view argument');
}
function initializeView(view, defaultViewId) {
  if (getViewId(view) == null) {
    setViewId(view, defaultViewId || v4());
  }

  return view;
}

function expandUrl(url) {
  var urls = [];
  var match = /\{([a-z])-([a-z])\}/.exec(url);

  if (match) {
    // char range
    var startCharCode = match[1].charCodeAt(0);
    var stopCharCode = match[2].charCodeAt(0);
    var charCode;

    for (charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
      urls.push(url.replace(match[0], String.fromCharCode(charCode)));
    }

    return urls;
  }

  match = /\{(\d+)-(\d+)\}/.exec(url);

  if (match) {
    // number range
    var stop1 = parseInt(match[2], 10);

    for (var i = parseInt(match[1], 10); i <= stop1; i++) {
      urls.push(url.replace(match[0], i.toString()));
    }

    return urls;
  }

  urls.push(url);
  return urls;
}

export { CIRCLE_SERIALIZE_PROP, COORD_PRECISION, EPSG_3857, EPSG_4326, STYLE_SERIALIZE_PROP, calcDistance, cleanSourceParams, createCircularPolygon, createFillStyle, createGeoJsonFmt, createGeomCollection, createGeomStyle, createImageStyle, createLineGeom, createMultiLineGeom, createMultiPointGeom, createMultiPolygonGeom, createMvtFmt, createOrUpdate, createPointGeom, createPolygonGeom, createStrokeStyle, createStyle, createTextStyle, defaultEditStyle, defaultStyle, dumpFillStyle, dumpGeomStyle, dumpImageStyle, dumpStrokeStyle, dumpStyle, dumpTextStyle, expandUrl, extentFromLonLat, extentFromProjection, extentToLonLat, findPointOnSurface, flatCoords, getControlId, getCorner, getFeatureGeom, getFeatureGeomName, getFeatureId, getFeatureProperties, getGeoJsonFmt, getGeomCoords, getGeomType, getGeometryId, getInteractionId, getInteractionPriority, getLayerId, getMapDataProjection, getMapId, getOverlayId, getSourceId, getStyleId, getViewId, initializeControl, initializeFeature, initializeGeometry, initializeInteraction, initializeLayer, initializeOverlay, initializeSource, initializeStyle, initializeView, isCircleGeom, isEqualCoord, isGeoJSONFeature, isGeoJSONGeometry, isLineCoords, isMultiGeom, isMultiLineCoords, isMultiPointCoords, isMultiPolygonCoords, isPointCoords, isPolygonCoords, lineFromLonLat, lineToLonLat, multiLineFromLonLat, multiLineToLonLat, multiPointFromLonLat, multiPointToLonLat, multiPolygonFromLonLat, multiPolygonToLonLat, normalizeColor, pointFromLonLat, pointToLonLat, polygonFromLonLat, polygonToLonLat, readGeoJsonFeature, readGeoJsonGeometry, readProjection, roundCoords, roundExtent, roundLineCoords, roundMultiLineCoords, roundMultiPointCoords, roundMultiPolygonCoords, roundPointCoords, roundPolygonCoords, setControlId, setFeatureId, setFeatureProperties, setGeometryId, setInteractionId, setInteractionPriority, setLayerId, setMapDataProjection, setMapId, setOverlayId, setSourceId, setStyleId, setViewId, toSimpleGeom, transform, transformDistance, transformExtent, transformLine, transformMultiLine, transformMultiPoint, transformMultiPolygon, transformPoint, transformPolygon, transforms, writeGeoJsonFeature, writeGeoJsonGeometry };
//# sourceMappingURL=ol-ext.js.map
