{"version":3,"file":"ol-rotate-feature.umd.min.js","sources":["../node_modules/@babel/runtime/helpers/defineProperty.js","../node_modules/@babel/runtime/helpers/typeof.js","../node_modules/@babel/runtime/helpers/classCallCheck.js","../node_modules/@babel/runtime/helpers/createClass.js","../node_modules/@babel/runtime/helpers/getPrototypeOf.js","../node_modules/@babel/runtime/helpers/superPropBase.js","../node_modules/@babel/runtime/helpers/get.js","../node_modules/@babel/runtime/helpers/setPrototypeOf.js","../node_modules/@babel/runtime/helpers/inherits.js","../node_modules/@babel/runtime/helpers/assertThisInitialized.js","../node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","../src/util.js","../src/event.js","../src/shim.js","../src/interaction.js","../src/index.js"],"sourcesContent":["function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;","function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;","function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;","function _getPrototypeOf(o) {\n  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nmodule.exports = _getPrototypeOf;","var getPrototypeOf = require(\"./getPrototypeOf\");\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nmodule.exports = _superPropBase;","var superPropBase = require(\"./superPropBase\");\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    module.exports = _get = Reflect.get;\n  } else {\n    module.exports = _get = function _get(target, property, receiver) {\n      var base = superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nmodule.exports = _get;","function _setPrototypeOf(o, p) {\n  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nmodule.exports = _setPrototypeOf;","var setPrototypeOf = require(\"./setPrototypeOf\");\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}\n\nmodule.exports = _inherits;","function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nmodule.exports = _assertThisInitialized;","var _typeof = require(\"../helpers/typeof\");\n\nvar assertThisInitialized = require(\"./assertThisInitialized\");\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}\n\nmodule.exports = _possibleConstructorReturn;","/**\n * This file is part of ol-rotate-feature package.\n * @module ol-rotate-feature\n * @license MIT\n * @author Vladimir Vershinin\n */\n\n/**\n * @param {boolean} condition\n * @param {string} message\n * @throws Error\n */\nexport function assert (condition, message = '') {\n  message = [ 'Assertion failed', message ].join(': ')\n\n  if (!condition) {\n    throw new Error(message)\n  }\n}\n\n/**\n * @param {*} arg\n * @returns {*}\n */\nexport function identity (arg) {\n  return arg\n}\n\n/**\n * @param {...*} args\n * @return {*}\n */\nexport function coalesce (...args) {\n  return args.filter(value => value != null).shift()\n}\n\nconst counters = {}\n/**\n * @param {string} [prefix]\n * @return {number}\n */\nexport function uniqId (prefix = '') {\n  const ns = prefix || 'default'\n  counters[ ns ] = counters[ ns ] == null ? 0 : counters[ ns ]\n\n  return String(prefix) + (++counters[ ns ])\n}\n\nexport function includes (arr, value) {\n  return arr.indexOf(value) !== -1\n}\n\nexport function isArray (val) {\n  return val::Object.prototype.toString() === '[object Array]'\n}\n","/**\n * This file is part of ol-rotate-feature package.\n * @module ol-rotate-feature\n * @license MIT\n * @author Vladimir Vershinin\n */\n/**\n * @enum {string}\n */\nexport const RotateFeatureEventType = {\n  /**\n   * Triggered upon feature rotate start.\n   * @event RotateFeatureEvent#rotatestart\n   */\n  START: 'rotatestart',\n  /**\n   * Triggered upon feature rotation.\n   * @event RotateFeatureEvent#rotating\n   */\n  ROTATING: 'rotating',\n  /**\n   * Triggered upon feature rotation end.\n   * @event RotateFeatureEvent#rotateend\n   */\n  END: 'rotateend'\n}\n\n/**\n * Events emitted by RotateFeatureInteraction instances are instances of this type.\n *\n * @class\n * @author Vladimir Vershinin\n */\nexport default class RotateFeatureEvent {\n  /**\n   * @param {string} type Type.\n   * @param {ol.Collection<ol.Feature>} features Rotated features.\n   * @param {number} angle Angle in radians.\n   * @param {ol.Coordinate} anchor Anchor position.\n   */\n  constructor (type, features, angle, anchor) {\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.propagationStopped_ = false\n\n    /**\n     * The event type.\n     * @type {string}\n     * @private\n     */\n    this.type_ = type\n\n    /**\n     * The features being rotated.\n     * @type {ol.Collection<ol.Feature>}\n     * @private\n     */\n    this.features_ = features\n    /**\n     * Current angle in radians.\n     * @type {number}\n     * @private\n     */\n    this.angle_ = angle\n    /**\n     * Current rotation anchor.\n     * @type {ol.Coordinate}\n     * @private\n     */\n    this.anchor_ = anchor\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get propagationStopped () {\n    return this.propagationStopped_\n  }\n\n  /**\n   * @type {string}\n   */\n  get type () {\n    return this.type_\n  }\n\n  /**\n   * @type {ol.Collection<ol.Feature>}\n   */\n  get features () {\n    return this.features_\n  }\n\n  /**\n   * @type {number}\n   */\n  get angle () {\n    return this.angle_\n  }\n\n  /**\n   * @type {ol.Coordinate}\n   */\n  get anchor () {\n    return this.anchor_\n  }\n\n  /**\n   * Prevent event propagation.\n   */\n  preventDefault () {\n    this.propagationStopped_ = true\n  }\n\n  /**\n   * Stop event propagation.\n   */\n  stopPropagation () {\n    this.propagationStopped_ = true\n  }\n}\n","const ua = typeof navigator !== 'undefined' ? navigator.userAgent.toLowerCase() : ''\n\nexport const MAC = ua.indexOf('macintosh') !== -1\n\nexport const WEBKIT = ua.indexOf('webkit') !== -1 && ua.indexOf('edge') == -1\n\nexport const mouseActionButton = function (mapBrowserEvent) {\n  const originalEvent = /** @type {MouseEvent} */ (mapBrowserEvent.originalEvent)\n  return originalEvent.button == 0 && !(WEBKIT && MAC && originalEvent.ctrlKey)\n}\n","/**\n * This file is part of ol-rotate-feature package.\n * @module ol-rotate-feature\n * @license MIT\n * @author Vladimir Vershinin\n */\n/**\n * Rotate interaction class.\n * Adds controls to rotate vector features.\n * Writes out total angle in radians (positive is counter-clockwise) to property for each feature.\n */\nimport { Pointer as PointerInteraction } from 'ol/interaction'\nimport { Collection, Feature } from 'ol'\nimport { Vector as VectorLayer } from 'ol/layer'\nimport { Vector as VectorSource } from 'ol/source'\nimport { GeometryCollection, Point, Polygon } from 'ol/geom'\nimport { Fill, RegularShape, Stroke, Style, Text } from 'ol/style'\nimport { getCenter as getExtentCenter } from 'ol/extent'\nimport { always, mouseOnly } from 'ol/events/condition'\nimport { assert, identity, includes, isArray } from './util'\nimport RotateFeatureEvent, { RotateFeatureEventType } from './event'\nimport { mouseActionButton } from './shim'\n\nconst ANCHOR_KEY = 'rotate-anchor'\nconst ARROW_KEY = 'rotate-arrow'\n\nconst ANGLE_PROP = 'angle'\nconst ANCHOR_PROP = 'anchor'\n\n/**\n * @todo todo добавить опцию condition - для возможности переопределения клавиш\n */\nexport default class RotateFeatureInteraction extends PointerInteraction {\n  /**\n   * @param {InteractionOptions} options\n   */\n  constructor (options = {}) {\n    super({\n      // handleEvent: handleEvent,\n      handleDownEvent,\n      handleUpEvent,\n      handleDragEvent,\n      handleMoveEvent,\n    })\n    /**\n     * @type {string}\n     * @private\n     */\n    this.previousCursor_ = undefined\n    /**\n     * @type {Feature}\n     * @private\n     */\n    this.anchorFeature_ = undefined\n    /**\n     * @type {Feature}\n     * @private\n     */\n    this.arrowFeature_ = undefined\n    /**\n     * @type {Coordinate}\n     * @private\n     */\n    this.lastCoordinate_ = undefined\n    /**\n     * @type {boolean}\n     * @private\n     */\n    this.anchorMoving_ = false\n    /**\n     * @type {Vector}\n     * @private\n     */\n    this.overlay_ = new VectorLayer({\n      style: options.style || getDefaultStyle(),\n      source: new VectorSource({\n        features: new Collection(),\n      }),\n    })\n    /**\n     * @private\n     * @type {module:ol/events/condition~Condition}\n     */\n    this.condition_ = options.condition ? options.condition : always\n    /**\n     * @type {Collection<Feature>}\n     * @private\n     */\n    this.features_ = undefined\n    if (options.features) {\n      if (isArray(options.features)) {\n        this.features_ = new Collection(options.features)\n      } else if (options.features instanceof Collection) {\n        this.features_ = options.features\n      } else {\n        throw new Error('Features option should be an array or collection of features, ' +\n          'got ' + (typeof options.features))\n      }\n    } else {\n      this.features_ = new Collection()\n    }\n\n    /**\n     * @type {boolean}\n     * @public\n     */\n    this.allowAnchorMovement = options.allowAnchorMovement === undefined ? true : options.allowAnchorMovement\n\n    this.setAnchor(options.anchor || getFeaturesCentroid(this.features_))\n    this.setAngle(options.angle || 0)\n\n    this.features_.on('add', ::this.onFeatureAdd_)\n    this.features_.on('remove', ::this.onFeatureRemove_)\n    this.on('change:' + ANGLE_PROP, ::this.onAngleChange_)\n    this.on('change:' + ANCHOR_PROP, ::this.onAnchorChange_)\n\n    this.createOrUpdateAnchorFeature_()\n    this.createOrUpdateArrowFeature_()\n  }\n\n  /**\n   * @type {Collection<Feature>}\n   */\n  get features () {\n    return this.features_\n  }\n\n  /**\n   * @type {number}\n   */\n  get angle () {\n    return this.getAngle()\n  }\n\n  /**\n   * @param {number} angle\n   */\n  set angle (angle) {\n    this.setAngle(angle)\n  }\n\n  /**\n   * @type {Coordinate|number[]|undefined}\n   */\n  get anchor () {\n    return this.getAnchor()\n  }\n\n  /**\n   * @param {Coordinate|undefined} anchor\n   */\n  set anchor (anchor) {\n    this.setAnchor(anchor)\n  }\n\n  /**\n   * @param {PluggableMap} map\n   */\n  set map (map) {\n    this.setMap(map)\n  }\n\n  /**\n   * @type {PluggableMap}\n   */\n  get map () {\n    return this.getMap()\n  }\n\n  /**\n   * @param {boolean} active\n   */\n  set active (active) {\n    this.setActive(active)\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get active () {\n    return this.getActive()\n  }\n\n  /**\n   * @param {ol.Map} map\n   */\n  setMap (map) {\n    this.overlay_.setMap(map)\n    super.setMap(map)\n  }\n\n  /**\n   * @param {boolean} active\n   */\n  setActive (active) {\n    if (this.overlay_) {\n      this.overlay_.setMap(active ? this.map : undefined)\n    }\n\n    super.setActive(active)\n  }\n\n  /**\n   * Set current angle of interaction features.\n   *\n   * @param {number} angle\n   */\n  setAngle (angle) {\n    assert(!isNaN(parseFloat(angle)), 'Numeric value passed')\n\n    this.set(ANGLE_PROP, parseFloat(angle))\n  }\n\n  /**\n   * Returns current angle of interaction features.\n   *\n   * @return {number}\n   */\n  getAngle () {\n    return this.get(ANGLE_PROP)\n  }\n\n  /**\n   * Set current anchor position.\n   *\n   * @param {Coordinate | undefined} anchor\n   */\n  setAnchor (anchor) {\n    assert(anchor == null || isArray(anchor) && anchor.length === 2, 'Array of two elements passed')\n\n    this.set(ANCHOR_PROP, anchor != null ? anchor.map(parseFloat) : getFeaturesCentroid(this.features_))\n  }\n\n  /**\n   * Returns current anchor position.\n   *\n   * @return {Coordinate | undefined}\n   */\n  getAnchor () {\n    return this.get(ANCHOR_PROP)\n  }\n\n  /**\n   * @private\n   */\n  createOrUpdateAnchorFeature_ () {\n    const angle = this.getAngle()\n    const anchor = this.getAnchor()\n\n    if (!anchor) return\n\n    if (this.anchorFeature_) {\n      this.anchorFeature_.getGeometry().setCoordinates(anchor)\n      this.anchorFeature_.set(ANGLE_PROP, angle)\n    } else {\n      this.anchorFeature_ = new Feature({\n        geometry: new Point(anchor),\n        [ANGLE_PROP]: angle,\n        [ANCHOR_KEY]: true,\n      })\n      this.overlay_.getSource().addFeature(this.anchorFeature_)\n    }\n  }\n\n  /**\n   * @private\n   */\n  createOrUpdateArrowFeature_ () {\n    const angle = this.getAngle()\n    const anchor = this.getAnchor()\n\n    if (!anchor) return\n\n    if (this.arrowFeature_) {\n      this.arrowFeature_.getGeometry().setCoordinates(anchor)\n      this.arrowFeature_.set(ANGLE_PROP, angle)\n    } else {\n      this.arrowFeature_ = new Feature({\n        geometry: new Point(anchor),\n        [ANGLE_PROP]: angle,\n        [ARROW_KEY]: true,\n      })\n      this.overlay_.getSource().addFeature(this.arrowFeature_)\n    }\n  }\n\n  /**\n   * @private\n   */\n  resetAngleAndAnchor_ () {\n    this.resetAngle_()\n    this.resetAnchor_()\n  }\n\n  /**\n   * @private\n   */\n  resetAngle_ () {\n    this.set(ANGLE_PROP, 0, true)\n    this.arrowFeature_ && this.arrowFeature_.set(ANGLE_PROP, this.getAngle())\n    this.anchorFeature_ && this.anchorFeature_.set(ANGLE_PROP, this.getAngle())\n  }\n\n  /**\n   * @private\n   */\n  resetAnchor_ () {\n    this.set(ANCHOR_PROP, getFeaturesCentroid(this.features_), true)\n\n    if (this.getAnchor()) {\n      this.arrowFeature_ && this.arrowFeature_.getGeometry().setCoordinates(this.getAnchor())\n      this.anchorFeature_ && this.anchorFeature_.getGeometry().setCoordinates(this.getAnchor())\n    }\n  }\n\n  /**\n   * @private\n   */\n  onFeatureAdd_ () {\n    this.resetAngleAndAnchor_()\n    this.createOrUpdateAnchorFeature_()\n    this.createOrUpdateArrowFeature_()\n  }\n\n  /**\n   * @private\n   */\n  onFeatureRemove_ () {\n    this.resetAngleAndAnchor_()\n\n    if (this.features_.getLength()) {\n      this.createOrUpdateAnchorFeature_()\n      this.createOrUpdateArrowFeature_()\n    } else {\n      this.overlay_.getSource().clear()\n      this.anchorFeature_ = this.arrowFeature_ = undefined\n    }\n  }\n\n  /**\n   * @private\n   */\n  onAngleChange_ ({oldValue}) {\n    this.features_.forEach(feature => feature.getGeometry().rotate(this.getAngle() - oldValue, this.getAnchor()))\n    this.arrowFeature_ && this.arrowFeature_.set(ANGLE_PROP, this.getAngle())\n    this.anchorFeature_ && this.anchorFeature_.set(ANGLE_PROP, this.getAngle())\n  }\n\n  /**\n   * @private\n   */\n  onAnchorChange_ () {\n    const anchor = this.getAnchor()\n\n    if (anchor) {\n      this.anchorFeature_ && this.anchorFeature_.getGeometry().setCoordinates(anchor)\n      this.arrowFeature_ && this.arrowFeature_.getGeometry().setCoordinates(anchor)\n    }\n  }\n\n  /**\n   * @param {Collection<Feature>} features\n   * @private\n   */\n  dispatchRotateStartEvent_ (features) {\n    this.dispatchEvent(\n      new RotateFeatureEvent(\n        RotateFeatureEventType.START,\n        features,\n        this.getAngle(),\n        this.getAnchor(),\n      ),\n    )\n  }\n\n  /**\n   * @param {Collection<Feature>} features\n   * @private\n   */\n  dispatchRotatingEvent_ (features) {\n    this.dispatchEvent(\n      new RotateFeatureEvent(\n        RotateFeatureEventType.ROTATING,\n        features,\n        this.getAngle(),\n        this.getAnchor(),\n      ),\n    )\n  }\n\n  /**\n   * @param {Collection<Feature>} features\n   * @private\n   */\n  dispatchRotateEndEvent_ (features) {\n    this.dispatchEvent(\n      new RotateFeatureEvent(\n        RotateFeatureEventType.END,\n        features,\n        this.getAngle(),\n        this.getAnchor(),\n      ),\n    )\n  }\n}\n\n/**\n * @param {MapBrowserEvent} evt Map browser event.\n * @return {boolean} `false` to stop event propagation.\n * @this {RotateFeatureInteraction}\n * @private\n */\n// function handleEvent (evt) {\n//   // disable selection of inner features\n//   const foundFeature = evt.map.forEachFeatureAtPixel(evt.pixel, identity)\n//   if (\n//     includes([ 'click', 'singleclick', 'dblclick' ], evt.type) &&\n//     includes([ this.anchorFeature_, this.arrowFeature_ ], foundFeature)\n//   ) {\n//     return false\n//   }\n//\n//   return this::baseHandleEvent(evt)\n// }\n\n/**\n * @param {MapBrowserEvent} evt Event.\n * @return {boolean}\n * @this {RotateFeatureInteraction}\n * @private\n */\nfunction handleDownEvent (evt) {\n  if (!mouseOnly(evt)) {\n    return false\n  }\n\n  if (mouseActionButton(evt) && this.condition_(evt)) {\n    // disable selection of inner features\n    const foundFeature = evt.map.forEachFeatureAtPixel(evt.pixel, identity)\n    if (\n      includes(['click', 'singleclick', 'dblclick'], evt.type) &&\n      includes([this.anchorFeature_, this.arrowFeature_], foundFeature)\n    ) {\n      return false\n    }\n    // handle click & drag on features for rotation\n    if (\n      foundFeature && !this.lastCoordinate_ &&\n      (\n        includes(this.features_.getArray(), foundFeature) ||\n        foundFeature === this.arrowFeature_\n      )\n    ) {\n      this.lastCoordinate_ = evt.coordinate\n\n      this::handleMoveEvent(evt)\n      this.dispatchRotateStartEvent_(this.features_)\n\n      return true\n    }\n    // handle click & drag on rotation anchor feature\n    else if (foundFeature && foundFeature === this.anchorFeature_ && this.allowAnchorMovement) {\n      this.anchorMoving_ = true\n      this::handleMoveEvent(evt)\n\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * @param {MapBrowserEvent} evt Event.\n * @return {boolean}\n * @this {RotateFeatureInteraction}\n * @private\n */\nfunction handleUpEvent (evt) {\n  // stop drag sequence of features\n  if (this.lastCoordinate_) {\n    this.lastCoordinate_ = undefined\n\n    this::handleMoveEvent(evt)\n    this.dispatchRotateEndEvent_(this.features_)\n\n    return true\n  }\n  // stop drag sequence of the anchors\n  else if (this.anchorMoving_) {\n    this.anchorMoving_ = false\n    this::handleMoveEvent(evt)\n\n    return true\n  }\n\n  return false\n}\n\n/**\n * @param {MapBrowserEvent} evt Event.\n * @return {boolean}\n * @this {RotateFeatureInteraction}\n * @private\n */\nfunction handleDragEvent ({coordinate}) {\n  const anchorCoordinate = this.anchorFeature_.getGeometry().getCoordinates()\n\n  // handle drag of features by angle\n  if (this.lastCoordinate_) {\n    // calculate vectors of last and current pointer positions\n    const lastVector = [\n      this.lastCoordinate_[0] - anchorCoordinate[0],\n      this.lastCoordinate_[1] - anchorCoordinate[1],\n    ]\n    const newVector = [\n      coordinate[0] - anchorCoordinate[0],\n      coordinate[1] - anchorCoordinate[1],\n    ]\n\n    // calculate angle between last and current vectors (positive angle counter-clockwise)\n    let angle = Math.atan2(\n      lastVector[0] * newVector[1] - newVector[0] * lastVector[1],\n      lastVector[0] * newVector[0] + lastVector[1] * newVector[1],\n    )\n\n    this.setAngle(this.getAngle() + angle)\n    this.dispatchRotatingEvent_(this.features_)\n\n    this.lastCoordinate_ = coordinate\n  }\n  // handle drag of the anchor\n  else if (this.anchorMoving_) {\n    this.setAnchor(coordinate)\n  }\n}\n\n/**\n * @param {MapBrowserEvent} evt Event.\n * @return {boolean}\n * @this {RotateFeatureInteraction}\n * @private\n */\nfunction handleMoveEvent ({map, pixel}) {\n  const elem = map.getTargetElement()\n  const foundFeature = map.forEachFeatureAtPixel(pixel, identity)\n\n  const setCursor = (cursor, vendor = false) => {\n    if (vendor) {\n      elem.style.cursor = '-webkit-' + cursor\n      elem.style.cursor = '-moz-' + cursor\n    }\n\n    elem.style.cursor = cursor\n  }\n\n  if (this.lastCoordinate_) {\n    this.previousCursor_ = elem.style.cursor\n    setCursor('grabbing', true)\n  } else if (\n    foundFeature &&\n    (\n      includes(this.features_.getArray(), foundFeature) ||\n      foundFeature === this.arrowFeature_\n    )\n  ) {\n    this.previousCursor_ = elem.style.cursor\n    setCursor('grab', true)\n  } else if ((foundFeature && foundFeature === this.anchorFeature_ && this.allowAnchorMovement) || this.anchorMoving_) {\n    this.previousCursor_ = elem.style.cursor\n    setCursor('crosshair')\n  } else {\n    setCursor(this.previousCursor_ || '')\n    this.previousCursor_ = undefined\n  }\n}\n\n/**\n * @returns {StyleFunction}\n * @private\n */\nfunction getDefaultStyle () {\n  const white = [255, 255, 255, 0.8]\n  const blue = [0, 153, 255, 0.8]\n  const transparent = [255, 255, 255, 0.01]\n  const width = 2\n\n  const styles = {\n    [ANCHOR_KEY]: [\n      new Style({\n        image: new RegularShape({\n          fill: new Fill({\n            color: [0, 153, 255, 0.8],\n          }),\n          stroke: new Stroke({\n            color: blue,\n            width: 1,\n          }),\n          radius: 4,\n          points: 6,\n        }),\n        zIndex: Infinity,\n      }),\n    ],\n    [ARROW_KEY]: [\n      new Style({\n        fill: new Fill({\n          color: transparent,\n        }),\n        stroke: new Stroke({\n          color: white,\n          width: width + 2,\n        }),\n        text: new Text({\n          font: '12px sans-serif',\n          offsetX: 20,\n          offsetY: -20,\n          fill: new Fill({\n            color: 'blue',\n          }),\n          stroke: new Stroke({\n            color: white,\n            width: width + 1,\n          }),\n        }),\n        zIndex: Infinity,\n      }),\n      new Style({\n        fill: new Fill({\n          color: transparent,\n        }),\n        stroke: new Stroke({\n          color: blue,\n          width,\n        }),\n        zIndex: Infinity,\n      }),\n    ],\n  }\n\n  return function (feature, resolution) {\n    let style\n    const angle = feature.get(ANGLE_PROP) || 0\n\n    switch (true) {\n      case feature.get(ANCHOR_KEY):\n        style = styles[ANCHOR_KEY]\n        style[0].getImage().setRotation(-angle)\n\n        return style\n      case feature.get(ARROW_KEY):\n        style = styles[ARROW_KEY]\n\n        const coordinates = feature.getGeometry().getCoordinates()\n        // generate arrow polygon\n        const geom = new Polygon([\n          [\n            [coordinates[0], coordinates[1] - 6 * resolution],\n            [coordinates[0] + 8 * resolution, coordinates[1] - 12 * resolution],\n            [coordinates[0], coordinates[1] + 30 * resolution],\n            [coordinates[0] - 8 * resolution, coordinates[1] - 12 * resolution],\n            [coordinates[0], coordinates[1] - 6 * resolution],\n          ],\n        ])\n\n        // and rotate it according to current angle\n        geom.rotate(angle, coordinates)\n        style[0].setGeometry(geom)\n        style[1].setGeometry(geom)\n        style[0].getText().setText(Math.round(-angle * 180 / Math.PI) + '°')\n\n        return style\n    }\n  }\n}\n\n/**\n * @param {Collection<Feature>|Array<Feature>} features\n * @returns {Extent | number[] | undefined}\n * @private\n */\nfunction getFeaturesExtent (features) {\n  features = features instanceof Collection ? features.getArray() : features\n  if (!features.length) return\n\n  return new GeometryCollection(features.map(feature => feature.getGeometry())).getExtent()\n}\n\n/**\n * @param {Collection<ol.Feature> | Array<Feature>} features\n * @return {Coordinate | number[] | undefined}\n */\nfunction getFeaturesCentroid (features) {\n  features = features instanceof Collection ? features.getArray() : features\n  if (!features.length) return\n\n  return getExtentCenter(getFeaturesExtent(features))\n}\n","/**\n * This file is part of ol-rotate-feature package.\n * @module ol-rotate-feature\n * @license MIT\n * @author Vladimir Vershinin\n */\nimport RotateFeatureInteraction from \"./interaction\"\n\n// for backward compatibility\nif (typeof window !== 'undefined' && window.ol && window.ol.interaction) {\n  window.ol.interaction.RotateFeature = RotateFeatureInteraction\n}\n\nexport default RotateFeatureInteraction\n"],"names":["obj","key","value","Object","defineProperty","enumerable","configurable","writable","_typeof","Symbol","iterator","module","constructor","prototype","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","protoProps","staticProps","_getPrototypeOf","o","setPrototypeOf","getPrototypeOf","__proto__","object","property","hasOwnProperty","call","_get","receiver","Reflect","get","base","superPropBase","desc","getOwnPropertyDescriptor","_setPrototypeOf","p","subClass","superClass","create","self","ReferenceError","assertThisInitialized","assert","condition","message","join","Error","identity","arg","includes","arr","indexOf","isArray","val","toString","RotateFeatureEventType","RotateFeatureEvent","type","features","angle","anchor","propagationStopped_","type_","features_","angle_","anchor_","this","ua","navigator","userAgent","toLowerCase","MAC","WEBKIT","RotateFeatureInteraction","options","handleDownEvent","handleUpEvent","handleDragEvent","handleMoveEvent","previousCursor_","undefined","anchorFeature_","arrowFeature_","lastCoordinate_","anchorMoving_","overlay_","VectorLayer","style","getDefaultStyle","source","VectorSource","Collection","condition_","always","allowAnchorMovement","setAnchor","getFeaturesCentroid","_this","setAngle","on","onFeatureAdd_","onFeatureRemove_","onAngleChange_","onAnchorChange_","createOrUpdateAnchorFeature_","createOrUpdateArrowFeature_","map","setMap","active","isNaN","parseFloat","set","getAngle","getAnchor","getGeometry","setCoordinates","Feature","geometry","Point","getSource","addFeature","resetAngle_","resetAnchor_","resetAngleAndAnchor_","getLength","clear","oldValue","forEach","feature","rotate","_this2","dispatchEvent","getMap","setActive","getActive","PointerInteraction","evt","mouseOnly","originalEvent","button","ctrlKey","foundFeature","forEachFeatureAtPixel","pixel","getArray","coordinate","dispatchRotateStartEvent_","dispatchRotateEndEvent_","anchorCoordinate","getCoordinates","lastVector","newVector","Math","atan2","dispatchRotatingEvent_","elem","getTargetElement","setCursor","cursor","vendor","white","blue","transparent","styles","Style","image","RegularShape","fill","Fill","color","stroke","Stroke","width","radius","points","zIndex","Infinity","text","Text","font","offsetX","offsetY","resolution","getImage","setRotation","coordinates","geom","Polygon","setGeometry","getText","setText","round","PI","getExtentCenter","GeometryCollection","getExtent","getFeaturesExtent","window","ol","interaction","RotateFeature"],"mappings":"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"}