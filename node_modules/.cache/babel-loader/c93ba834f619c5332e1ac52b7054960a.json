{"remainingRequest":"/Volumes/WD_Elements_25A1_Media/Google Drive/___Public/__2021-Hackathon-EOD/eodash-staging/app/node_modules/babel-loader/lib/index.js!/Volumes/WD_Elements_25A1_Media/Google Drive/___Public/__2021-Hackathon-EOD/eodash-staging/app/node_modules/cache-loader/dist/cjs.js??ref--0-0!/Volumes/WD_Elements_25A1_Media/Google Drive/___Public/__2021-Hackathon-EOD/eodash-staging/app/node_modules/vue-loader/lib/index.js??vue-loader-options!/Volumes/WD_Elements_25A1_Media/Google Drive/___Public/__2021-Hackathon-EOD/eodash-staging/app/src/components/IndicatorData.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Volumes/WD_Elements_25A1_Media/Google Drive/___Public/__2021-Hackathon-EOD/eodash-staging/app/src/components/IndicatorData.vue","mtime":1624532486000},{"path":"/Volumes/WD_Elements_25A1_Media/Google Drive/___Public/__2021-Hackathon-EOD/eodash-staging/app/node_modules/cache-loader/dist/cjs.js","mtime":1624878747000},{"path":"/Volumes/WD_Elements_25A1_Media/Google Drive/___Public/__2021-Hackathon-EOD/eodash-staging/app/node_modules/babel-loader/lib/index.js","mtime":1624878747000},{"path":"/Volumes/WD_Elements_25A1_Media/Google Drive/___Public/__2021-Hackathon-EOD/eodash-staging/app/node_modules/cache-loader/dist/cjs.js","mtime":1624878747000},{"path":"/Volumes/WD_Elements_25A1_Media/Google Drive/___Public/__2021-Hackathon-EOD/eodash-staging/app/node_modules/vue-loader/lib/index.js","mtime":1624878753000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:aW1wb3J0IF90b0NvbnN1bWFibGVBcnJheSBmcm9tICIvVm9sdW1lcy9XRF9FbGVtZW50c18yNUExX01lZGlhL0dvb2dsZSBEcml2ZS9fX19QdWJsaWMvX18yMDIxLUhhY2thdGhvbi1FT0QvZW9kYXNoLXN0YWdpbmcvYXBwL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b0NvbnN1bWFibGVBcnJheSI7CmltcG9ydCBfc2xpY2VkVG9BcnJheSBmcm9tICIvVm9sdW1lcy9XRF9FbGVtZW50c18yNUExX01lZGlhL0dvb2dsZSBEcml2ZS9fX19QdWJsaWMvX18yMDIxLUhhY2thdGhvbi1FT0QvZW9kYXNoLXN0YWdpbmcvYXBwL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zbGljZWRUb0FycmF5IjsKaW1wb3J0IF9vYmplY3RTcHJlYWQgZnJvbSAiL1ZvbHVtZXMvV0RfRWxlbWVudHNfMjVBMV9NZWRpYS9Hb29nbGUgRHJpdmUvX19fUHVibGljL19fMjAyMS1IYWNrYXRob24tRU9EL2VvZGFzaC1zdGFnaW5nL2FwcC9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0U3ByZWFkMiI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmluY2x1ZGVzLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnNldC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvci5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5tYXAuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLmZvci1lYWNoLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMubnVtYmVyLmNvbnN0cnVjdG9yLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMubnVtYmVyLmlzLW5hbi5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnNwbGl0LmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuam9pbi5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5rZXlzLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc29ydC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZyb20uanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maWx0ZXIuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5maW5kLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLmluY2x1ZGVzLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnJlcGxhY2UuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zbGljZS5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5lbnRyaWVzLmpzIjsKaW1wb3J0ICJjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmxhdC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmZ1bmN0aW9uLm5hbWUuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5udW1iZXIucGFyc2UtZmxvYXQuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5udW1iZXIudG8tZml4ZWQuanMiOwppbXBvcnQgImNvcmUtanMvbW9kdWxlcy9lcy5udW1iZXIuaXMtaW50ZWdlci5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zdGFydHMtd2l0aC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvbmNhdC5qcyI7CmltcG9ydCAiY29yZS1qcy9tb2R1bGVzL2VzLm1hdGgubG9nMTAuanMiOwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwovLwppbXBvcnQgeyBEYXRlVGltZSB9IGZyb20gJ2x1eG9uJzsKaW1wb3J0IHsgbWFwU3RhdGUgfSBmcm9tICd2dWV4JzsKaW1wb3J0IEJhckNoYXJ0IGZyb20gJ0AvY29tcG9uZW50cy9CYXJDaGFydC52dWUnOwppbXBvcnQgTGluZUNoYXJ0IGZyb20gJ0AvY29tcG9uZW50cy9MaW5lQ2hhcnQudnVlJzsKaW1wb3J0IE1hcENoYXJ0IGZyb20gJ0AvY29tcG9uZW50cy9NYXBDaGFydC52dWUnOwppbXBvcnQgTlVUUyBmcm9tICdAL2Fzc2V0cy9OVVRTX1JHXzAzTV8yMDE2XzQzMjZfRVNMMi1ERUwzLmpzb24nOwppbXBvcnQgbG9ja2Rvd25UaW1lcyBmcm9tICdAL2Fzc2V0cy9sb2NrZG93bl9kYXRhLmpzb24nOwppbXBvcnQgY291bnRyaWVzIGZyb20gJ0AvYXNzZXRzL2NvdW50cmllcy5qc29uJzsKZXhwb3J0IGRlZmF1bHQgewogIHByb3BzOiBbJ2N1cnJlbnRJbmRpY2F0b3InXSwKICBjb21wb25lbnRzOiB7CiAgICBCYXJDaGFydDogQmFyQ2hhcnQsCiAgICBMaW5lQ2hhcnQ6IExpbmVDaGFydCwKICAgIE1hcENoYXJ0OiBNYXBDaGFydAogIH0sCiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHsKICAgIHJldHVybiB7CiAgICAgIGRhdGFMYXllclRpbWU6IG51bGwsCiAgICAgIGRhdGFMYXllckluZGV4OiAwCiAgICB9OwogIH0sCiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHsKICAgIHZhciBkID0gdGhpcy5pbmRpY2F0b3JPYmplY3QudGltZVt0aGlzLmluZGljYXRvck9iamVjdC50aW1lLmxlbmd0aCAtIDFdOwogICAgdGhpcy5kYXRhTGF5ZXJUaW1lID0gZC50b0Zvcm1hdCgnZGQuIE1NTScpOwogIH0sCiAgY29tcHV0ZWQ6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgbWFwU3RhdGUoJ2NvbmZpZycsIFsnYXBwQ29uZmlnJywgJ2Jhc2VDb25maWcnXSkpLCB7fSwgewogICAgYXJyYXlPZk9iamVjdHM6IGZ1bmN0aW9uIGFycmF5T2ZPYmplY3RzKCkgewogICAgICB2YXIgaW5kaWNhdG9yID0gX29iamVjdFNwcmVhZCh7fSwgdGhpcy5pbmRpY2F0b3JPYmplY3QpOwoKICAgICAgdmFyIGluZGljYXRvckNvZGUgPSBpbmRpY2F0b3IuaW5kaWNhdG9yOwogICAgICB2YXIgc2VsZWN0aW9uT3B0aW9ucyA9IFtdOwoKICAgICAgaWYgKFsnRTEwYTMnLCAnRTEwYTgnXS5pbmNsdWRlcyhpbmRpY2F0b3JDb2RlKSkgewogICAgICAgIC8vIEZpbmQgYWxsIHVuaXF1ZSBkYXkvbW9udGggYXZhaWxhYmxlCiAgICAgICAgdmFyIHRpbWVzZXQgPSBuZXcgU2V0KGluZGljYXRvci50aW1lLm1hcChmdW5jdGlvbiAoZCkgewogICAgICAgICAgcmV0dXJuIGQudG9Gb3JtYXQoJ2RkLiBNTU0nKTsKICAgICAgICB9KSk7CiAgICAgICAgdGltZXNldC5mb3JFYWNoKGZ1bmN0aW9uICh0KSB7CiAgICAgICAgICBzZWxlY3Rpb25PcHRpb25zLnB1c2goewogICAgICAgICAgICB2YWx1ZTogdCwKICAgICAgICAgICAgbmFtZTogdAogICAgICAgICAgfSk7CiAgICAgICAgfSk7CiAgICAgIH0KCiAgICAgIHJldHVybiBzZWxlY3Rpb25PcHRpb25zOwogICAgfSwKICAgIGRhdGFjb2xsZWN0aW9uOiBmdW5jdGlvbiBkYXRhY29sbGVjdGlvbigpIHsKICAgICAgdmFyIF90aGlzID0gdGhpczsKCiAgICAgIHZhciBpbmRpY2F0b3IgPSBfb2JqZWN0U3ByZWFkKHt9LCB0aGlzLmluZGljYXRvck9iamVjdCk7CgogICAgICB2YXIgaW5kaWNhdG9yQ29kZSA9IGluZGljYXRvci5pbmRpY2F0b3I7CiAgICAgIHZhciBkYXRhQ29sbGVjdGlvbjsKICAgICAgdmFyIHJlZkNvbG9ycyA9IFsnIzIyYWE5OScsICcjYTM3JywgJyM0N2EnLCAnI2E2NycsICcjMjgzJywgJyNiYmInLCAnIzZjZScsICcjOTk0NDk5JywgJyNhYWFhMTEnLCAnIzY2MzNjYycsICcjZTY3MzAwJ107CgogICAgICBpZiAoaW5kaWNhdG9yKSB7CiAgICAgICAgKGZ1bmN0aW9uICgpIHsKICAgICAgICAgIHZhciBsYWJlbHMgPSBbXTsKICAgICAgICAgIHZhciBtZWFzdXJlbWVudCA9IGluZGljYXRvci5tZWFzdXJlbWVudDsKICAgICAgICAgIHZhciBjb2xvcnMgPSBbXTsKICAgICAgICAgIHZhciBkYXRhc2V0cyA9IFtdOwoKICAgICAgICAgIGlmIChbJ0UxMGExJywgJ0UxMGE1J10uaW5jbHVkZXMoaW5kaWNhdG9yQ29kZSkpIHsKICAgICAgICAgICAgdmFyIHJlZmVyZW5jZVZhbHVlID0gaW5kaWNhdG9yLnJlZmVyZW5jZVZhbHVlLm1hcChOdW1iZXIpOwoKICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRpY2F0b3IudGltZS5sZW5ndGg7IGkgKz0gMSkgewogICAgICAgICAgICAgIGlmICghTnVtYmVyLmlzTmFOKGluZGljYXRvci50aW1lW2ldLnRvTWlsbGlzKCkpKSB7CiAgICAgICAgICAgICAgICB2YXIgZCA9IGluZGljYXRvci50aW1lW2ldOwogICAgICAgICAgICAgICAgdmFyIGZvcm1hdHRlZERhdGUgPSBkLnRvRm9ybWF0KCdkZC4gTU1NJyk7CiAgICAgICAgICAgICAgICBsYWJlbHMucHVzaChmb3JtYXR0ZWREYXRlKTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgbGFiZWxzLnB1c2goaSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CgogICAgICAgICAgICB2YXIgbGFiZWxyZWYgPSAnMjAxOSc7CiAgICAgICAgICAgIHZhciBsYWJlbG1lYXMgPSAnMjAyMCc7CiAgICAgICAgICAgIGRhdGFzZXRzLnB1c2goewogICAgICAgICAgICAgIGluZExhYmVsczogQXJyYXkoaW5kaWNhdG9yLmluZGljYXRvclZhbHVlLmxlbmd0aCkuam9pbignLicpLnNwbGl0KCcuJyksCiAgICAgICAgICAgICAgbGFiZWw6IGxhYmVscmVmLAogICAgICAgICAgICAgIGRhdGE6IHJlZmVyZW5jZVZhbHVlLAogICAgICAgICAgICAgIGZpbGw6IGZhbHNlLAogICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ2dyZXknCiAgICAgICAgICAgIH0pOwogICAgICAgICAgICBkYXRhc2V0cy5wdXNoKHsKICAgICAgICAgICAgICBpbmRMYWJlbHM6IGluZGljYXRvci5pbmRpY2F0b3JWYWx1ZSwKICAgICAgICAgICAgICBsYWJlbDogbGFiZWxtZWFzLAogICAgICAgICAgICAgIGRhdGE6IG1lYXN1cmVtZW50LAogICAgICAgICAgICAgIGZpbGw6IGZhbHNlLAogICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ2JsYWNrJwogICAgICAgICAgICB9KTsKICAgICAgICAgIH0gZWxzZSBpZiAoWydFMTBhOSddLmluY2x1ZGVzKGluZGljYXRvckNvZGUpKSB7CiAgICAgICAgICAgIHZhciBjYXRlZ29yaWVzID0gWydOYXRpb25hbCBXb3JrZXJzJywgJ0ZvcmVpZ24gV29ya2VycycsICdVbmtub3duJ107CiAgICAgICAgICAgIGNhdGVnb3JpZXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5LCBpZHgpIHsKICAgICAgICAgICAgICB2YXIgZGF0YSA9IGluZGljYXRvci5tZWFzdXJlbWVudC5tYXAoZnVuY3Rpb24gKHJvdywgcm93SWR4KSB7CiAgICAgICAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICAgICAgICB0OiBpbmRpY2F0b3IudGltZVtyb3dJZHhdLAogICAgICAgICAgICAgICAgICB5OiByb3dbaWR4XQogICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICBkYXRhc2V0cy5wdXNoKHsKICAgICAgICAgICAgICAgIGxhYmVsOiBrZXksCiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLAogICAgICAgICAgICAgICAgZmlsbDogZmFsc2UsCiAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogcmVmQ29sb3JzW2lkeF0sCiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHJlZkNvbG9yc1tpZHhdLAogICAgICAgICAgICAgICAgY3ViaWNJbnRlcnBvbGF0aW9uTW9kZTogJ21vbm90b25lJywKICAgICAgICAgICAgICAgIGJvcmRlcldpZHRoOiAxLAogICAgICAgICAgICAgICAgcG9pbnRSYWRpdXM6IDIKICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9IGVsc2UgaWYgKFsnR0cnXS5pbmNsdWRlcyhpbmRpY2F0b3JDb2RlKSkgewogICAgICAgICAgICB2YXIgdmFscyA9IGluZGljYXRvci5WYWx1ZXM7CiAgICAgICAgICAgIHZhciBkYXRhc2V0c09iaiA9IHsKICAgICAgICAgICAgICBncm9jZXJ5OiBbXSwKICAgICAgICAgICAgICBwYXJrczogW10sCiAgICAgICAgICAgICAgcmVzaWRlbnRpYWw6IFtdLAogICAgICAgICAgICAgIHJldGFpbF9yZWNyZWF0aW9uOiBbXSwKICAgICAgICAgICAgICB0cmFuc2l0X3N0YXRpb25zOiBbXQogICAgICAgICAgICB9OwoKICAgICAgICAgICAgZm9yICh2YXIgZW50cnkgPSAwOyBlbnRyeSA8IHZhbHMubGVuZ3RoOyBlbnRyeSArPSAxKSB7CiAgICAgICAgICAgICAgdmFyIHQgPSBEYXRlVGltZS5mcm9tSVNPKHZhbHNbZW50cnldLmRhdGUpOwogICAgICAgICAgICAgIGRhdGFzZXRzT2JqLmdyb2NlcnkucHVzaCh7CiAgICAgICAgICAgICAgICB0OiB0LAogICAgICAgICAgICAgICAgeTogdmFsc1tlbnRyeV0uZ3JvY2VyeQogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIGRhdGFzZXRzT2JqLnBhcmtzLnB1c2goewogICAgICAgICAgICAgICAgdDogdCwKICAgICAgICAgICAgICAgIHk6IHZhbHNbZW50cnldLnBhcmtzCiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgZGF0YXNldHNPYmoucmVzaWRlbnRpYWwucHVzaCh7CiAgICAgICAgICAgICAgICB0OiB0LAogICAgICAgICAgICAgICAgeTogdmFsc1tlbnRyeV0ucmVzaWRlbnRpYWwKICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICBkYXRhc2V0c09iai5yZXRhaWxfcmVjcmVhdGlvbi5wdXNoKHsKICAgICAgICAgICAgICAgIHQ6IHQsCiAgICAgICAgICAgICAgICB5OiB2YWxzW2VudHJ5XS5yZXRhaWxfcmVjcmVhdGlvbgogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIGRhdGFzZXRzT2JqLnRyYW5zaXRfc3RhdGlvbnMucHVzaCh7CiAgICAgICAgICAgICAgICB0OiB0LAogICAgICAgICAgICAgICAgeTogdmFsc1tlbnRyeV0udHJhbnNpdF9zdGF0aW9ucwogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICB9CgogICAgICAgICAgICBPYmplY3Qua2V5cyhkYXRhc2V0c09iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5LCBpZHgpIHsKICAgICAgICAgICAgICBkYXRhc2V0cy5wdXNoKHsKICAgICAgICAgICAgICAgIGxhYmVsOiBrZXksCiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhc2V0c09ialtrZXldLAogICAgICAgICAgICAgICAgZmlsbDogZmFsc2UsCiAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogcmVmQ29sb3JzW2lkeF0sCiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHJlZkNvbG9yc1tpZHhdLAogICAgICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDEsCiAgICAgICAgICAgICAgICBwb2ludFJhZGl1czogMiwKICAgICAgICAgICAgICAgIGN1YmljSW50ZXJwb2xhdGlvbk1vZGU6ICdtb25vdG9uZScKICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9IGVsc2UgaWYgKFsnR1NBJ10uaW5jbHVkZXMoaW5kaWNhdG9yQ29kZSkpIHsKICAgICAgICAgICAgdmFyIF92YWxzID0gT2JqZWN0LmtleXMoaW5kaWNhdG9yLnZhbHVlcyk7CgogICAgICAgICAgICB2YXIgX2RhdGFzZXRzT2JqID0ge307CgogICAgICAgICAgICBmb3IgKHZhciBfZW50cnkgPSAwOyBfZW50cnkgPCBfdmFscy5sZW5ndGg7IF9lbnRyeSArPSAxKSB7CiAgICAgICAgICAgICAgX2RhdGFzZXRzT2JqW192YWxzW19lbnRyeV1dID0gW107CiAgICAgICAgICAgICAgdmFyIGN1cnJWYWxzID0gaW5kaWNhdG9yLnZhbHVlc1tfdmFsc1tfZW50cnldXS52YWx1ZXM7CgogICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBjdXJyVmFscy5sZW5ndGg7IF9pICs9IDEpIHsKICAgICAgICAgICAgICAgIF9kYXRhc2V0c09ialtfdmFsc1tfZW50cnldXS5wdXNoKHsKICAgICAgICAgICAgICAgICAgdDogRGF0ZVRpbWUuZnJvbUlTTyhjdXJyVmFsc1tfaV0udGltZXN0YW1wKSwKICAgICAgICAgICAgICAgICAgeTogTnVtYmVyKGN1cnJWYWxzW19pXS53YWl0aW5nX3RpbWUpCiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICB9IC8vIEl0IHNlZW1zIHNvbWUgdGltc3RhbXBzIGFyZSBtaXhlZCBpbiBvcmRlciBzbyBsZXQgdXMgc29ydCBieSBkYXRlCiAgICAgICAgICAgICAgLy8gdG8gZ2V0IG5pY2UgbGluZSBjb25uZWN0aW9ucyB0aHJvdWdoIHRoZSB0aW1lbGluZQoKCiAgICAgICAgICAgICAgX2RhdGFzZXRzT2JqW192YWxzW19lbnRyeV1dLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsKICAgICAgICAgICAgICAgIHJldHVybiBhLnQudG9NaWxsaXMoKSAtIGIudC50b01pbGxpcygpOwogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICB9CgogICAgICAgICAgICBPYmplY3Qua2V5cyhpbmRpY2F0b3IudmFsdWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXksIGlkeCkgewogICAgICAgICAgICAgIGRhdGFzZXRzLnB1c2goewogICAgICAgICAgICAgICAgbGFiZWw6IGtleSwKICAgICAgICAgICAgICAgIGRhdGE6IF9kYXRhc2V0c09ialtrZXldLAogICAgICAgICAgICAgICAgZmlsbDogZmFsc2UsCiAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogcmVmQ29sb3JzW2lkeF0sCiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHJlZkNvbG9yc1tpZHhdLAogICAgICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDEsCiAgICAgICAgICAgICAgICBwb2ludFJhZGl1czogMiwKICAgICAgICAgICAgICAgIGN1YmljSW50ZXJwb2xhdGlvbk1vZGU6ICdtb25vdG9uZScKICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9IGVsc2UgaWYgKFsnQ1YnXS5pbmNsdWRlcyhpbmRpY2F0b3JDb2RlKSkgewogICAgICAgICAgICB2YXIgX3ZhbHMyID0gaW5kaWNhdG9yLlZhbHVlczsKICAgICAgICAgICAgdmFyIF9kYXRhc2V0c09iajIgPSB7CiAgICAgICAgICAgICAgY29uZmlybWVkOiBbXQogICAgICAgICAgICB9OwoKICAgICAgICAgICAgZm9yICh2YXIgX2VudHJ5MiA9IDA7IF9lbnRyeTIgPCBfdmFsczIubGVuZ3RoOyBfZW50cnkyICs9IDEpIHsKICAgICAgICAgICAgICB2YXIgX3QgPSBEYXRlVGltZS5mcm9tSVNPKF92YWxzMltfZW50cnkyXS5kYXRlKTsKCiAgICAgICAgICAgICAgX2RhdGFzZXRzT2JqMi5jb25maXJtZWQucHVzaCh7CiAgICAgICAgICAgICAgICB0OiBfdCwKICAgICAgICAgICAgICAgIHk6IE51bWJlcihfdmFsczJbX2VudHJ5Ml0uY29uZmlybWVkKQogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICB9CgogICAgICAgICAgICBPYmplY3Qua2V5cyhfZGF0YXNldHNPYmoyKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXksIGlkeCkgewogICAgICAgICAgICAgIGRhdGFzZXRzLnB1c2goewogICAgICAgICAgICAgICAgbGFiZWw6IGtleSwKICAgICAgICAgICAgICAgIGRhdGE6IF9kYXRhc2V0c09iajJba2V5XSwKICAgICAgICAgICAgICAgIGZpbGw6IGZhbHNlLAogICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IHJlZkNvbG9yc1tpZHhdLAogICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiByZWZDb2xvcnNbaWR4XSwKICAgICAgICAgICAgICAgIGJvcmRlcldpZHRoOiAxLAogICAgICAgICAgICAgICAgcG9pbnRSYWRpdXM6IDIsCiAgICAgICAgICAgICAgICBjdWJpY0ludGVycG9sYXRpb25Nb2RlOiAnbW9ub3RvbmUnCiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgfSBlbHNlIGlmIChbJ09XJ10uaW5jbHVkZXMoaW5kaWNhdG9yQ29kZSkpIHsKICAgICAgICAgICAgdmFyIF92YWxzMyA9IGluZGljYXRvci5WYWx1ZXM7CiAgICAgICAgICAgIHZhciBwSSA9IFsndG90YWxfdmFjY2luYXRpb25zJywgJ3Blb3BsZV9mdWxseV92YWNjaW5hdGVkJywgJ2RhaWx5X3ZhY2NpbmF0aW9ucyddOwogICAgICAgICAgICB2YXIgX2RhdGFzZXRzT2JqMyA9IHt9OwoKICAgICAgICAgICAgZm9yICh2YXIgaWR4ID0gMDsgaWR4IDwgcEkubGVuZ3RoOyBpZHggKz0gMSkgewogICAgICAgICAgICAgIF9kYXRhc2V0c09iajNbcElbaWR4XV0gPSBbXTsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgZm9yICh2YXIgX2VudHJ5MyA9IDA7IF9lbnRyeTMgPCBfdmFsczMubGVuZ3RoOyBfZW50cnkzICs9IDEpIHsKICAgICAgICAgICAgICB2YXIgX3QyID0gRGF0ZVRpbWUuZnJvbUlTTyhfdmFsczNbX2VudHJ5M10uZGF0ZSk7CgogICAgICAgICAgICAgIGZvciAodmFyIF9pZHggPSAwOyBfaWR4IDwgcEkubGVuZ3RoOyBfaWR4ICs9IDEpIHsKICAgICAgICAgICAgICAgIF9kYXRhc2V0c09iajNbcElbX2lkeF1dLnB1c2goewogICAgICAgICAgICAgICAgICB0OiBfdDIsCiAgICAgICAgICAgICAgICAgIHk6IF92YWxzM1tfZW50cnkzXVtwSVtfaWR4XV0KICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQoKICAgICAgICAgICAgT2JqZWN0LmtleXMoX2RhdGFzZXRzT2JqMykuZm9yRWFjaChmdW5jdGlvbiAoa2V5LCBpZHgpIHsKICAgICAgICAgICAgICBkYXRhc2V0cy5wdXNoKHsKICAgICAgICAgICAgICAgIGxhYmVsOiBrZXksCiAgICAgICAgICAgICAgICBkYXRhOiBfZGF0YXNldHNPYmozW2tleV0sCiAgICAgICAgICAgICAgICBmaWxsOiBmYWxzZSwKICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiByZWZDb2xvcnNbaWR4XSwKICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogcmVmQ29sb3JzW2lkeF0sCiAgICAgICAgICAgICAgICBib3JkZXJXaWR0aDogMSwKICAgICAgICAgICAgICAgIHBvaW50UmFkaXVzOiAyLAogICAgICAgICAgICAgICAgY3ViaWNJbnRlcnBvbGF0aW9uTW9kZTogJ21vbm90b25lJwogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICB9KTsKICAgICAgICAgIH0gZWxzZSBpZiAoWydOM2InXS5pbmNsdWRlcyhpbmRpY2F0b3JDb2RlKSkgewogICAgICAgICAgICB2YXIgc2Vuc29ycyA9IEFycmF5LmZyb20obmV3IFNldChpbmRpY2F0b3IuZW9TZW5zb3IpKS5zb3J0KCk7CgogICAgICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChwcCkgewogICAgICAgICAgICAgIHZhciBwS2V5ID0gc2Vuc29yc1twcF07CiAgICAgICAgICAgICAgdmFyIGRhdGEgPSBpbmRpY2F0b3IudGltZS5tYXAoZnVuY3Rpb24gKGRhdGUsIGkpIHsKICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSBudWxsOwoKICAgICAgICAgICAgICAgIGlmIChpbmRpY2F0b3IuZW9TZW5zb3JbaV0gPT09IHBLZXkpIHsKICAgICAgICAgICAgICAgICAgb3V0cHV0ID0gewogICAgICAgICAgICAgICAgICAgIHQ6IGRhdGUsCiAgICAgICAgICAgICAgICAgICAgeTogbWVhc3VyZW1lbnRbaV0KICAgICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0OwogICAgICAgICAgICAgIH0pLmZpbHRlcihmdW5jdGlvbiAoZCkgewogICAgICAgICAgICAgICAgcmV0dXJuIGQgIT09IG51bGw7CiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgdmFyIGNvbG9yVXNlZCA9IHJlZkNvbG9yc1twcF07CgogICAgICAgICAgICAgIGlmIChfdGhpcy5pbmREZWZpbml0aW9uLnNlbnNvckNvbG9yTWFwICYmIF90aGlzLmluZERlZmluaXRpb24uc2Vuc29yQ29sb3JNYXBbcEtleV0pIHsKICAgICAgICAgICAgICAgIGNvbG9yVXNlZCA9IF90aGlzLmluZERlZmluaXRpb24uc2Vuc29yQ29sb3JNYXBbcEtleV07CiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICBkYXRhc2V0cy5wdXNoKHsKICAgICAgICAgICAgICAgIGxhYmVsOiBwS2V5LAogICAgICAgICAgICAgICAgZGF0YTogZGF0YSwKICAgICAgICAgICAgICAgIGZpbGw6IGZhbHNlLAogICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGNvbG9yVXNlZCwKICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogY29sb3JVc2VkLAogICAgICAgICAgICAgICAgY3ViaWNJbnRlcnBvbGF0aW9uTW9kZTogJ21vbm90b25lJwogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICB9OwoKICAgICAgICAgICAgZm9yICh2YXIgcHAgPSAwOyBwcCA8IHNlbnNvcnMubGVuZ3RoOyBwcCArPSAxKSB7CiAgICAgICAgICAgICAgX2xvb3AocHApOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgaWYgKFsnTjRjJ10uaW5jbHVkZXMoaW5kaWNhdG9yQ29kZSkpIHsKICAgICAgICAgICAgdmFyIG1lYXNEYXRhID0gaW5kaWNhdG9yLm1lYXN1cmVtZW50Lm1hcChOdW1iZXIpOwogICAgICAgICAgICBtZWFzRGF0YS5zaGlmdCgpOwogICAgICAgICAgICB2YXIgcmVmRGF0YSA9IGluZGljYXRvci5yZWZlcmVuY2VWYWx1ZS5tYXAoTnVtYmVyKTsKICAgICAgICAgICAgcmVmRGF0YS5zaGlmdCgpOwogICAgICAgICAgICBsYWJlbHMgPSBbaW5kaWNhdG9yLnJlZmVyZW5jZVRpbWVbMF0udG9JU09EYXRlKCksIGluZGljYXRvci50aW1lWzBdLnRvSVNPRGF0ZSgpLCBpbmRpY2F0b3IudGltZVs1XS50b0lTT0RhdGUoKV07CiAgICAgICAgICAgIGRhdGFzZXRzLnB1c2goewogICAgICAgICAgICAgIGxhYmVsOiAnbWV0YWxsaWMgd2FzdGUgYXJlYScsCiAgICAgICAgICAgICAgZGF0YTogW3JlZkRhdGFbMF0sIG1lYXNEYXRhWzBdLCBtZWFzRGF0YVs1XV0sCiAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiByZWZDb2xvcnNbMF0KICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIGRhdGFzZXRzLnB1c2goewogICAgICAgICAgICAgIGxhYmVsOiAnbWl4ZWQgd2FzdGUgYXJlYScsCiAgICAgICAgICAgICAgZGF0YTogW3JlZkRhdGFbMV0sIG1lYXNEYXRhWzFdLCBtZWFzRGF0YVs2XV0sCiAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiByZWZDb2xvcnNbMV0KICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIGRhdGFzZXRzLnB1c2goewogICAgICAgICAgICAgIGxhYmVsOiAncGxhc3RpYyB3YXN0ZSBhcmVhJywKICAgICAgICAgICAgICBkYXRhOiBbcmVmRGF0YVsyXSwgbWVhc0RhdGFbMl0sIG1lYXNEYXRhWzddXSwKICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHJlZkNvbG9yc1syXQogICAgICAgICAgICB9KTsKICAgICAgICAgICAgZGF0YXNldHMucHVzaCh7CiAgICAgICAgICAgICAgbGFiZWw6ICdzb2lsIHdhc3RlIGFyZWEnLAogICAgICAgICAgICAgIGRhdGE6IFtyZWZEYXRhWzNdLCBtZWFzRGF0YVszXSwgbWVhc0RhdGFbOF1dLAogICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogcmVmQ29sb3JzWzNdCiAgICAgICAgICAgIH0pOwogICAgICAgICAgfSBlbHNlIGlmIChbJ0UxMGEyJywgJ0UxMGE2JywgJ0UxMGE3JywgJ0U4JywgJ0UxM2UnLCAnRTEzZicsICdFMTNnJywgJ0UxM2gnLCAnRTEzaScsICdFMTNsJywgJ0UxM20nXS5pbmNsdWRlcyhpbmRpY2F0b3JDb2RlKSkgewogICAgICAgICAgICB2YXIgdW5pcXVlUmVmcyA9IFtdOwogICAgICAgICAgICB2YXIgdW5pcXVlTWVhcyA9IFtdOwoKICAgICAgICAgICAgdmFyIF9yZWZlcmVuY2VWYWx1ZSA9IGluZGljYXRvci5yZWZlcmVuY2VWYWx1ZS5tYXAoTnVtYmVyKTsKCiAgICAgICAgICAgIGluZGljYXRvci50aW1lLmZvckVhY2goZnVuY3Rpb24gKGRhdGUsIGkpIHsKICAgICAgICAgICAgICB2YXIgbWVhcyA9IHsKICAgICAgICAgICAgICAgIHQ6IGRhdGUuc2V0KHsKICAgICAgICAgICAgICAgICAgeWVhcjogMjAwMAogICAgICAgICAgICAgICAgfSksCiAgICAgICAgICAgICAgICB5OiBtZWFzdXJlbWVudFtpXQogICAgICAgICAgICAgIH07CgogICAgICAgICAgICAgIGlmICh0eXBlb2YgdW5pcXVlUmVmcy5maW5kKGZ1bmN0aW9uIChpdGVtKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbS50LmVxdWFscyhtZWFzLnQpOwogICAgICAgICAgICAgIH0pID09PSAndW5kZWZpbmVkJykgewogICAgICAgICAgICAgICAgdW5pcXVlTWVhcy5wdXNoKG1lYXMpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIGluZGljYXRvci5yZWZlcmVuY2VUaW1lLmZvckVhY2goZnVuY3Rpb24gKGRhdGUsIGkpIHsKICAgICAgICAgICAgICBpZiAoIVsnJywgJy8nXS5pbmNsdWRlcyhpbmRpY2F0b3IucmVmZXJlbmNlVmFsdWVbaV0pKSB7CiAgICAgICAgICAgICAgICB2YXIgcmVmID0gewogICAgICAgICAgICAgICAgICB0OiBkYXRlLnNldCh7CiAgICAgICAgICAgICAgICAgICAgeWVhcjogMjAwMAogICAgICAgICAgICAgICAgICB9KSwKICAgICAgICAgICAgICAgICAgeTogX3JlZmVyZW5jZVZhbHVlW2ldCiAgICAgICAgICAgICAgICB9OwoKICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdW5pcXVlUmVmcy5maW5kKGZ1bmN0aW9uIChpdGVtKSB7CiAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLnQuZXF1YWxzKHJlZi50KTsKICAgICAgICAgICAgICAgIH0pID09PSAndW5kZWZpbmVkJykgewogICAgICAgICAgICAgICAgICB1bmlxdWVSZWZzLnB1c2gocmVmKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0pOwogICAgICAgICAgICBkYXRhc2V0cy5wdXNoKHsKICAgICAgICAgICAgICBsYWJlbDogJzIwMjAnLAogICAgICAgICAgICAgIGRhdGE6IHVuaXF1ZU1lYXMsCiAgICAgICAgICAgICAgZmlsbDogZmFsc2UsCiAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IHJlZkNvbG9yc1sxXSwKICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHJlZkNvbG9yc1sxXSwKICAgICAgICAgICAgICBib3JkZXJXaWR0aDogMgogICAgICAgICAgICB9KTsKCiAgICAgICAgICAgIGlmICh1bmlxdWVSZWZzLmxlbmd0aCA+IDApIHsKICAgICAgICAgICAgICBkYXRhc2V0cy5wdXNoKHsKICAgICAgICAgICAgICAgIGxhYmVsOiAnMjAxOScsCiAgICAgICAgICAgICAgICBkYXRhOiB1bmlxdWVSZWZzLAogICAgICAgICAgICAgICAgZmlsbDogZmFsc2UsCiAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogcmVmQ29sb3JzWzBdLAogICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiByZWZDb2xvcnNbMF0sCiAgICAgICAgICAgICAgICBib3JkZXJXaWR0aDogMgogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICB9CiAgICAgICAgICB9IGVsc2UgaWYgKFsnRTEzbicsICdDMScsICdDMicsICdDMyddLmluY2x1ZGVzKGluZGljYXRvckNvZGUpKSB7CiAgICAgICAgICAgIC8vIEdyb3VwIGJ5IGluZGljYXRvciB2YWx1ZQogICAgICAgICAgICB2YXIgdHlwZXMgPSB7fTsKICAgICAgICAgICAgaW5kaWNhdG9yLmluZGljYXRvclZhbHVlLmZvckVhY2goZnVuY3Rpb24gKGluZCwgaWR4KSB7CiAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHR5cGVzKS5pbmNsdWRlcyhpbmQpKSB7CiAgICAgICAgICAgICAgICB0eXBlc1tpbmRdLnB1c2goewogICAgICAgICAgICAgICAgICB0OiBEYXRlVGltZS5mcm9tSVNPKGluZGljYXRvci50aW1lW2lkeF0pLAogICAgICAgICAgICAgICAgICB5OiBOdW1iZXIoaW5kaWNhdG9yLm1lYXN1cmVtZW50W2lkeF0pCiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgdHlwZXNbaW5kXSA9IFt7CiAgICAgICAgICAgICAgICAgIHQ6IERhdGVUaW1lLmZyb21JU08oaW5kaWNhdG9yLnRpbWVbaWR4XSksCiAgICAgICAgICAgICAgICAgIHk6IE51bWJlcihpbmRpY2F0b3IubWVhc3VyZW1lbnRbaWR4XSkKICAgICAgICAgICAgICAgIH1dOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIE9iamVjdC5rZXlzKHR5cGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXksIGkpIHsKICAgICAgICAgICAgICBkYXRhc2V0cy5wdXNoKHsKICAgICAgICAgICAgICAgIGxhYmVsOiBrZXksCiAgICAgICAgICAgICAgICBmaWxsOiBmYWxzZSwKICAgICAgICAgICAgICAgIGRhdGE6IHR5cGVzW2tleV0sCiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHJlZkNvbG9yc1tpXSwKICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiByZWZDb2xvcnNbaV0sCiAgICAgICAgICAgICAgICBib3JkZXJXaWR0aDogMgogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICB9KTsKICAgICAgICAgIH0gZWxzZSBpZiAoWydOMicsICdFMTBjJ10uaW5jbHVkZXMoaW5kaWNhdG9yQ29kZSkpIHsKICAgICAgICAgICAgLyogR3JvdXAgZGF0YSBieSB5ZWFyIGluIG1vbnRoIHNsaWNlcyAqLwogICAgICAgICAgICB2YXIgZGF0YSA9IGluZGljYXRvci50aW1lLm1hcChmdW5jdGlvbiAoZGF0ZSwgaSkgewogICAgICAgICAgICAgIGNvbG9ycy5wdXNoKF90aGlzLmdldEluZGljYXRvckNvbG9yKGluZGljYXRvci5jb2xvckNvZGVbaV0pKTsKICAgICAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICAgICAgdDogZGF0ZSwKICAgICAgICAgICAgICAgIHk6IG1lYXN1cmVtZW50W2ldCiAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIHZhciBkYXRhR3JvdXBzID0ge307CiAgICAgICAgICAgIHZhciBjb2xvckdyb3VwcyA9IHt9OwoKICAgICAgICAgICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgZGF0YS5sZW5ndGg7IF9pMiArPSAxKSB7CiAgICAgICAgICAgICAgdmFyIGN1cnJZZWFyID0gZGF0YVtfaTJdLnQueWVhcjsKCiAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRhR3JvdXBzLCBjdXJyWWVhcikpIHsKICAgICAgICAgICAgICAgIGRhdGFHcm91cHNbY3VyclllYXJdLnB1c2goewogICAgICAgICAgICAgICAgICB0OiBkYXRhW19pMl0udC5zZXQoewogICAgICAgICAgICAgICAgICAgIHllYXI6IDIwMDAKICAgICAgICAgICAgICAgICAgfSksCiAgICAgICAgICAgICAgICAgIHk6IFtkYXRhW19pMl0ueV0KICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgY29sb3JHcm91cHNbY3VyclllYXJdLnB1c2goY29sb3JzW19pMl0pOwogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBkYXRhR3JvdXBzW2N1cnJZZWFyXSA9IFt7CiAgICAgICAgICAgICAgICAgIHQ6IGRhdGFbX2kyXS50LnNldCh7CiAgICAgICAgICAgICAgICAgICAgeWVhcjogMjAwMAogICAgICAgICAgICAgICAgICB9KSwKICAgICAgICAgICAgICAgICAgeTogW2RhdGFbX2kyXS55XQogICAgICAgICAgICAgICAgfV07CiAgICAgICAgICAgICAgICBjb2xvckdyb3Vwc1tjdXJyWWVhcl0gPSBbY29sb3JzW19pMl1dOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQoKICAgICAgICAgICAgdmFyIHVuaXF1ZVllYXJzID0gT2JqZWN0LmtleXMoZGF0YUdyb3Vwcyk7CiAgICAgICAgICAgIHVuaXF1ZVllYXJzLnNvcnQoKTsKICAgICAgICAgICAgdmFyIHlMZW5ndGggPSB1bmlxdWVZZWFycy5sZW5ndGggLSAxOwogICAgICAgICAgICB1bmlxdWVZZWFycy5mb3JFYWNoKGZ1bmN0aW9uIChrZXksIGkpIHsKICAgICAgICAgICAgICBkYXRhc2V0cy5wdXNoKHsKICAgICAgICAgICAgICAgIC8vIGZpbGwgd2l0aCBlbXB0eSB2YWx1ZXMKICAgICAgICAgICAgICAgIGluZExhYmVsczogQXJyYXkoZGF0YUdyb3Vwc1trZXldLmxlbmd0aCkuam9pbignLicpLnNwbGl0KCcuJyksCiAgICAgICAgICAgICAgICBsYWJlbDoga2V5LAogICAgICAgICAgICAgICAgZmlsbDogZmFsc2UsCiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhR3JvdXBzW2tleV0sCiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHJlZkNvbG9yc1t5TGVuZ3RoIC0gaV0sCiAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogcmVmQ29sb3JzW3lMZW5ndGggLSBpXSwKICAgICAgICAgICAgICAgIGJvcmRlcldpZHRoOiAyCiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgfSBlbHNlIGlmIChbJ04xJ10uaW5jbHVkZXMoaW5kaWNhdG9yQ29kZSkpIHsKICAgICAgICAgICAgdmFyIHN0ZERldk1pbiA9IFtdOwogICAgICAgICAgICB2YXIgc3RkRGV2TWF4ID0gW107CiAgICAgICAgICAgIHZhciBtaW4gPSBbXTsKICAgICAgICAgICAgdmFyIG1heCA9IFtdOwogICAgICAgICAgICB2YXIgbWVkaWFuID0gW107CiAgICAgICAgICAgIHZhciBfZGF0YSA9IFtdOwogICAgICAgICAgICBpbmRpY2F0b3IucmVmZXJlbmNlVmFsdWUuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSwgaSkgewogICAgICAgICAgICAgIHZhciB0ID0gaW5kaWNhdG9yLnRpbWVbaV07CgogICAgICAgICAgICAgIF9kYXRhLnB1c2goewogICAgICAgICAgICAgICAgeTogbWVhc3VyZW1lbnRbaV0sCiAgICAgICAgICAgICAgICB0OiB0CiAgICAgICAgICAgICAgfSk7CgogICAgICAgICAgICAgIGlmICghTnVtYmVyLmlzTmFOKGl0ZW0pICYmICFbJ05hTicsICcvJ10uaW5jbHVkZXMoaXRlbSkpIHsKICAgICAgICAgICAgICAgIHZhciBvYmogPSBKU09OLnBhcnNlKGl0ZW0pOyAvLyBbbWVkaWFuLHN0ZCxtYXgsbWluLHBlcmNlbnRhZ2UgdmFsaWQgcGl4ZWxzXQoKICAgICAgICAgICAgICAgIG1lZGlhbi5wdXNoKHsKICAgICAgICAgICAgICAgICAgeTogb2JqWzBdLAogICAgICAgICAgICAgICAgICB0OiB0CiAgICAgICAgICAgICAgICB9KTsKCiAgICAgICAgICAgICAgICBpZiAob2JqWzFdICE9PSBudWxsKSB7CiAgICAgICAgICAgICAgICAgIHN0ZERldk1pbi5wdXNoKHsKICAgICAgICAgICAgICAgICAgICB5OiBtZWFzdXJlbWVudFtpXSAtIG9ialsxXSwKICAgICAgICAgICAgICAgICAgICB0OiB0CiAgICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgICBzdGREZXZNYXgucHVzaCh7CiAgICAgICAgICAgICAgICAgICAgeTogbWVhc3VyZW1lbnRbaV0gKyBvYmpbMV0sCiAgICAgICAgICAgICAgICAgICAgdDogdAogICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICBtYXgucHVzaCh7CiAgICAgICAgICAgICAgICAgIHk6IG9ialsyXSwKICAgICAgICAgICAgICAgICAgdDogdAogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICBtaW4ucHVzaCh7CiAgICAgICAgICAgICAgICAgIHk6IG9ialszXSwKICAgICAgICAgICAgICAgICAgdDogdAogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIG1lZGlhbi5wdXNoKHsKICAgICAgICAgICAgICAgICAgeTogTnVtYmVyLk5hTiwKICAgICAgICAgICAgICAgICAgdDogdAogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICBzdGREZXZNaW4ucHVzaCh7CiAgICAgICAgICAgICAgICAgIHk6IE51bWJlci5OYU4sCiAgICAgICAgICAgICAgICAgIHQ6IHQKICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgc3RkRGV2TWF4LnB1c2goewogICAgICAgICAgICAgICAgICB5OiBOdW1iZXIuTmFOLAogICAgICAgICAgICAgICAgICB0OiB0CiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIG1heC5wdXNoKHsKICAgICAgICAgICAgICAgICAgeTogTnVtYmVyLk5hTiwKICAgICAgICAgICAgICAgICAgdDogdAogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICBtaW4ucHVzaCh7CiAgICAgICAgICAgICAgICAgIHk6IE51bWJlci5OYU4sCiAgICAgICAgICAgICAgICAgIHQ6IHQKICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIGRhdGFzZXRzLnB1c2goewogICAgICAgICAgICAgIGxhYmVsOiBpbmRpY2F0b3IueUF4aXMsCiAgICAgICAgICAgICAgZGF0YTogX2RhdGEsCiAgICAgICAgICAgICAgZmlsbDogZmFsc2UsCiAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiByZWZDb2xvcnNbMF0sCiAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IHJlZkNvbG9yc1swXSwKICAgICAgICAgICAgICBzcGFuR2FwczogZmFsc2UsCiAgICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDIKICAgICAgICAgICAgfSk7IC8vIENoZWNrIGZvciBlbXB0eSBhcnJheSwgaWYgaXQgaXMgdGhlIGNhc2UgZG8gbm90IGluY2x1ZGUgZGF0YQoKICAgICAgICAgICAgaWYgKHR5cGVvZiBtZWRpYW4uZmluZChmdW5jdGlvbiAoYSkgewogICAgICAgICAgICAgIHJldHVybiBhLnkgIT09IG51bGw7CiAgICAgICAgICAgIH0pICE9PSAndW5kZWZpbmVkJykgewogICAgICAgICAgICAgIGRhdGFzZXRzLnB1c2goewogICAgICAgICAgICAgICAgbGFiZWw6ICdNZWRpYW4nLAogICAgICAgICAgICAgICAgZGF0YTogbWVkaWFuLAogICAgICAgICAgICAgICAgZmlsbDogZmFsc2UsCiAgICAgICAgICAgICAgICBwb2ludFJhZGl1czogMCwKICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiAnYmxhY2snLAogICAgICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDEsCiAgICAgICAgICAgICAgICBwb2ludFN0eWxlOiAnbGluZScsCiAgICAgICAgICAgICAgICBzcGFuR2FwczogZmFsc2UKICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgfSAvLyBDaGVjayBmb3IgZW1wdHkgYXJyYXksIGlmIGl0IGlzIHRoZSBjYXNlIGRvIG5vdCBpbmNsdWRlIGRhdGEKCgogICAgICAgICAgICBpZiAodHlwZW9mIG1pbi5maW5kKGZ1bmN0aW9uIChhKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGEueSAhPT0gbnVsbDsKICAgICAgICAgICAgfSkgIT09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgICAgICAgZGF0YXNldHMucHVzaCh7CiAgICAgICAgICAgICAgICBsYWJlbDogJ01pbicsCiAgICAgICAgICAgICAgICBkYXRhOiBtaW4sCiAgICAgICAgICAgICAgICBmaWxsOiBmYWxzZSwKICAgICAgICAgICAgICAgIHBvaW50UmFkaXVzOiAwLAogICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiByZWZDb2xvcnNbNF0sCiAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogcmVmQ29sb3JzWzRdLAogICAgICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDEsCiAgICAgICAgICAgICAgICBwb2ludFN0eWxlOiAnbGluZScsCiAgICAgICAgICAgICAgICBzcGFuR2FwczogZmFsc2UKICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgfSAvLyBDaGVjayBmb3IgZW1wdHkgYXJyYXksIGlmIGl0IGlzIHRoZSBjYXNlIGRvIG5vdCBpbmNsdWRlIGRhdGEKCgogICAgICAgICAgICBpZiAodHlwZW9mIG1heC5maW5kKGZ1bmN0aW9uIChhKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGEueSAhPT0gbnVsbDsKICAgICAgICAgICAgfSkgIT09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgICAgICAgZGF0YXNldHMucHVzaCh7CiAgICAgICAgICAgICAgICBsYWJlbDogJ01heCcsCiAgICAgICAgICAgICAgICBkYXRhOiBtYXgsCiAgICAgICAgICAgICAgICBmaWxsOiBmYWxzZSwKICAgICAgICAgICAgICAgIHBvaW50UmFkaXVzOiAwLAogICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiByZWZDb2xvcnNbMV0sCiAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogcmVmQ29sb3JzWzFdLAogICAgICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDEsCiAgICAgICAgICAgICAgICBwb2ludFN0eWxlOiAnbGluZScsCiAgICAgICAgICAgICAgICBzcGFuR2FwczogZmFsc2UKICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgfSAvLyBDaGVjayBmb3IgZW1wdHkgYXJyYXksIGlmIGl0IGlzIHRoZSBjYXNlIGRvIG5vdCBpbmNsdWRlIGRhdGEKCgogICAgICAgICAgICBpZiAodHlwZW9mIHN0ZERldk1heC5maW5kKGZ1bmN0aW9uIChhKSB7CiAgICAgICAgICAgICAgcmV0dXJuIGEueSAhPT0gbnVsbDsKICAgICAgICAgICAgfSkgIT09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgICAgICAgZGF0YXNldHMucHVzaCh7CiAgICAgICAgICAgICAgICBsYWJlbDogJ1N0YW5kYXJkIGRldmlhdGlvbiAoU1REKScsCiAgICAgICAgICAgICAgICBkYXRhOiBzdGREZXZNYXgsCiAgICAgICAgICAgICAgICBmaWxsOiAnKzEnLAogICAgICAgICAgICAgICAgcG9pbnRSYWRpdXM6IDAsCiAgICAgICAgICAgICAgICBzcGFuR2FwczogZmFsc2UsCiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDAuMSknLAogICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICdyZ2JhKDAsMCwwLDAuMCknLAogICAgICAgICAgICAgICAgcG9pbnRTdHlsZTogJ3JlY3QnCiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIH0gLy8gQ2hlY2sgZm9yIGVtcHR5IGFycmF5LCBpZiBpdCBpcyB0aGUgY2FzZSBkbyBub3QgaW5jbHVkZSBkYXRhCgoKICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGREZXZNaW4uZmluZChmdW5jdGlvbiAoYSkgewogICAgICAgICAgICAgIHJldHVybiBhLnkgIT09IG51bGw7CiAgICAgICAgICAgIH0pICE9PSAndW5kZWZpbmVkJykgewogICAgICAgICAgICAgIGRhdGFzZXRzLnB1c2goewogICAgICAgICAgICAgICAgbGFiZWw6ICdoaWRlXycsCiAgICAgICAgICAgICAgICBkYXRhOiBzdGREZXZNaW4sCiAgICAgICAgICAgICAgICBmaWxsOiAnLTEnLAogICAgICAgICAgICAgICAgcG9pbnRSYWRpdXM6IDAsCiAgICAgICAgICAgICAgICBzcGFuR2FwczogZmFsc2UsCiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDAuMCknLAogICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICdyZ2JhKDAsMCwwLDAuMCknLAogICAgICAgICAgICAgICAgcG9pbnRTdHlsZTogJ3JlY3QnCiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSBpZiAoWydOMyddLmluY2x1ZGVzKGluZGljYXRvckNvZGUpKSB7CiAgICAgICAgICAgIHZhciBfcmVmZXJlbmNlVmFsdWUyID0gW107CiAgICAgICAgICAgIHZhciBzdGREZXYgPSBbXTsKICAgICAgICAgICAgaW5kaWNhdG9yLnJlZmVyZW5jZVZhbHVlLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHsKICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc05hTihpdGVtKSAmJiAhWydOYU4nLCAnW05hTiBOYU5dJywgJy8nXS5pbmNsdWRlcyhpdGVtKSkgewogICAgICAgICAgICAgICAgdmFyIG9iaiA9IEpTT04ucGFyc2UoaXRlbS5yZXBsYWNlKC8sL2csICcuJykucmVwbGFjZSgnICcsICcsJykpOwoKICAgICAgICAgICAgICAgIGlmIChvYmpbMF0gIT09IC05OTkgJiYgb2JqWzFdICE9PSAtOTk5KSB7CiAgICAgICAgICAgICAgICAgIF9yZWZlcmVuY2VWYWx1ZTIucHVzaChvYmpbMF0pOwoKICAgICAgICAgICAgICAgICAgc3RkRGV2LnB1c2gob2JqWzFdKTsKICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgIF9yZWZlcmVuY2VWYWx1ZTIucHVzaChOdW1iZXIuTmFOKTsKCiAgICAgICAgICAgICAgICAgIHN0ZERldi5wdXNoKE51bWJlci5OYU4pOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBfcmVmZXJlbmNlVmFsdWUyLnB1c2goTnVtYmVyLk5hTik7CgogICAgICAgICAgICAgICAgc3RkRGV2LnB1c2goTnVtYmVyLk5hTik7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9KTsKCiAgICAgICAgICAgIHZhciBfc3RkRGV2TWF4ID0gc3RkRGV2Lm1hcChmdW5jdGlvbiAoZGV2LCBpKSB7CiAgICAgICAgICAgICAgcmV0dXJuIE51bWJlci5pc05hTihfcmVmZXJlbmNlVmFsdWUyW2ldKSA/IE51bWJlci5OYU4gOiBNYXRoLnBvdygxMCwgX3JlZmVyZW5jZVZhbHVlMltpXSArIGRldik7CiAgICAgICAgICAgIH0pOwoKICAgICAgICAgICAgdmFyIF9zdGREZXZNaW4gPSBzdGREZXYubWFwKGZ1bmN0aW9uIChkZXYsIGkpIHsKICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyLmlzTmFOKF9yZWZlcmVuY2VWYWx1ZTJbaV0pID8gTnVtYmVyLk5hTiA6IE1hdGgucG93KDEwLCBfcmVmZXJlbmNlVmFsdWUyW2ldIC0gZGV2KTsKICAgICAgICAgICAgfSk7CgogICAgICAgICAgICBfcmVmZXJlbmNlVmFsdWUyID0gX3JlZmVyZW5jZVZhbHVlMi5tYXAoZnVuY3Rpb24gKHZhbCkgewogICAgICAgICAgICAgIHJldHVybiBOdW1iZXIuaXNOYU4odmFsKSA/IE51bWJlci5OYU4gOiBNYXRoLnBvdygxMCwgdmFsKTsKICAgICAgICAgICAgfSk7CgogICAgICAgICAgICBmb3IgKHZhciBfaTMgPSAwOyBfaTMgPCBpbmRpY2F0b3IudGltZS5sZW5ndGg7IF9pMyArPSAxKSB7CiAgICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4oaW5kaWNhdG9yLnRpbWVbX2kzXS50b01pbGxpcygpKSkgewogICAgICAgICAgICAgICAgbGFiZWxzLnB1c2goaW5kaWNhdG9yLnRpbWVbX2kzXS50b0lTT0RhdGUoKSk7CiAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGxhYmVscy5wdXNoKF9pMyk7CiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICB2YXIgY29sb3JDb2RlID0gJyc7CgogICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaW5kaWNhdG9yLCAnY29sb3JDb2RlJykpIHsKICAgICAgICAgICAgICAgIGNvbG9yQ29kZSA9IGluZGljYXRvci5jb2xvckNvZGVbX2kzXTsKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIGNvbG9ycy5wdXNoKF90aGlzLmdldEluZGljYXRvckNvbG9yKGNvbG9yQ29kZSkpOwogICAgICAgICAgICB9CgogICAgICAgICAgICBkYXRhc2V0cy5wdXNoKHsKICAgICAgICAgICAgICBsYWJlbDogJ1dlZWtseSBjbGltYXRvbG9neSBvZiBjaGxvcm9waHlsbCBjb25jLiAoQ0hMX2NsaW0pIDIwMTctMjAxOScsCiAgICAgICAgICAgICAgZGF0YTogX3JlZmVyZW5jZVZhbHVlMiwKICAgICAgICAgICAgICBmaWxsOiBmYWxzZSwKICAgICAgICAgICAgICBwb2ludFJhZGl1czogMCwKICAgICAgICAgICAgICBib3JkZXJDb2xvcjogJ2JsYWNrJywKICAgICAgICAgICAgICBwb2ludFN0eWxlOiAnbGluZScsCiAgICAgICAgICAgICAgc3BhbkdhcHM6IGZhbHNlCiAgICAgICAgICAgIH0pOwogICAgICAgICAgICBkYXRhc2V0cy5wdXNoKHsKICAgICAgICAgICAgICBsYWJlbDogJ1N0YW5kYXJkIGRldmlhdGlvbiAoU1REKScsCiAgICAgICAgICAgICAgZGF0YTogX3N0ZERldk1heCwKICAgICAgICAgICAgICBmaWxsOiAnKzEnLAogICAgICAgICAgICAgIHBvaW50UmFkaXVzOiAwLAogICAgICAgICAgICAgIHNwYW5HYXBzOiBmYWxzZSwKICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDAuMSknLAogICAgICAgICAgICAgIGJvcmRlckNvbG9yOiAncmdiYSgwLDAsMCwwLjApJywKICAgICAgICAgICAgICBwb2ludFN0eWxlOiAncmVjdCcKICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIGRhdGFzZXRzLnB1c2goewogICAgICAgICAgICAgIGxhYmVsOiAnaGlkZV8nLAogICAgICAgICAgICAgIGRhdGE6IF9zdGREZXZNaW4sCiAgICAgICAgICAgICAgZmlsbDogJy0xJywKICAgICAgICAgICAgICBwb2ludFJhZGl1czogMCwKICAgICAgICAgICAgICBzcGFuR2FwczogZmFsc2UsCiAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLDAsMCwwLjApJywKICAgICAgICAgICAgICBib3JkZXJDb2xvcjogJ3JnYmEoMCwwLDAsMC4wKScsCiAgICAgICAgICAgICAgcG9pbnRTdHlsZTogJ3JlY3QnCiAgICAgICAgICAgIH0pOyAvLyBGaW5kIHVuaXF1ZSBpbmRpY2F0b3IgdmFsdWVzCgogICAgICAgICAgICB2YXIgaW5kaWNhdG9yVmFsdWVzID0ge307CiAgICAgICAgICAgIGluZGljYXRvci5pbmRpY2F0b3JWYWx1ZS5tYXAoZnVuY3Rpb24gKHZhbCwgaSkgewogICAgICAgICAgICAgIHZhciBrZXkgPSB2YWwudG9Mb3dlckNhc2UoKTsKICAgICAgICAgICAgICBrZXkgPSBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc2xpY2UoMSk7CgogICAgICAgICAgICAgIGlmICghWycnLCAnLyddLmluY2x1ZGVzKGtleSkgJiYgdHlwZW9mIGluZGljYXRvclZhbHVlc1trZXldID09PSAndW5kZWZpbmVkJykgewogICAgICAgICAgICAgICAgaW5kaWNhdG9yVmFsdWVzW2tleV0gPSBfdGhpcy5nZXRJbmRpY2F0b3JDb2xvcihpbmRpY2F0b3IuY29sb3JDb2RlW2ldKTsKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgICB9KTsKICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMoaW5kaWNhdG9yVmFsdWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7CiAgICAgICAgICAgICAgdmFyIF9yZWYyID0gX3NsaWNlZFRvQXJyYXkoX3JlZiwgMiksCiAgICAgICAgICAgICAgICAgIGtleSA9IF9yZWYyWzBdLAogICAgICAgICAgICAgICAgICB2YWx1ZSA9IF9yZWYyWzFdOwoKICAgICAgICAgICAgICB2YXIgY3Vyck1lYXMgPSBtZWFzdXJlbWVudC5tYXAoZnVuY3Rpb24gKHJvdywgaSkgewogICAgICAgICAgICAgICAgdmFyIHZhbCA9IHJvdzsKCiAgICAgICAgICAgICAgICBpZiAoaW5kaWNhdG9yLmluZGljYXRvclZhbHVlW2ldICE9PSBrZXkudG9VcHBlckNhc2UoKSkgewogICAgICAgICAgICAgICAgICB2YWwgPSBOYU47CiAgICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgICAgcmV0dXJuIHZhbDsKICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICBkYXRhc2V0cy5wdXNoKHsKICAgICAgICAgICAgICAgIGxhYmVsOiBrZXksCiAgICAgICAgICAgICAgICBkYXRhOiBjdXJyTWVhcy5tYXAoZnVuY3Rpb24gKHZhbCkgewogICAgICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyLmlzTmFOKHZhbCkgPyBOdW1iZXIuTmFOIDogTWF0aC5wb3coMTAsIHZhbCk7CiAgICAgICAgICAgICAgICB9KSwKICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdmFsdWUsCiAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogdmFsdWUsCiAgICAgICAgICAgICAgICBmaWxsOiBmYWxzZSwKICAgICAgICAgICAgICAgIHNob3dMaW5lOiBmYWxzZSwKICAgICAgICAgICAgICAgIHNwYW5HYXBzOiBmYWxzZQogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICB9KTsKICAgICAgICAgIH0gZWxzZSBpZiAoWydOMWEnLCAnTjFiJywgJ04xYycsICdOMWQnLCAnRTEyYiddLmluY2x1ZGVzKGluZGljYXRvckNvZGUpKSB7CiAgICAgICAgICAgIHZhciBtYXhSZWYgPSBbXTsKICAgICAgICAgICAgdmFyIG1pblJlZiA9IFtdOwogICAgICAgICAgICB2YXIgbWVhbjdkUmVmID0gW107CiAgICAgICAgICAgIHZhciBtZWFuN2QyMDIwID0gW107CiAgICAgICAgICAgIGluZGljYXRvci5yZWZlcmVuY2VWYWx1ZS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpKSB7CiAgICAgICAgICAgICAgdmFyIHQgPSBpbmRpY2F0b3IudGltZVtpXTsKCiAgICAgICAgICAgICAgaWYgKCFbJycsICcvJ10uaW5jbHVkZXMoaXRlbSkpIHsKICAgICAgICAgICAgICAgIHZhciBvYmogPSBpdGVtLnJlcGxhY2UoL1tbXF0gXS9nLCAnJykuc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gKHN0cikgewogICAgICAgICAgICAgICAgICByZXR1cm4gc3RyID09PSAnJyA/IE51bWJlci5OYU4gOiBOdW1iZXIoc3RyKTsKICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgbWF4UmVmLnB1c2goewogICAgICAgICAgICAgICAgICB5OiBvYmpbMF0sCiAgICAgICAgICAgICAgICAgIHQ6IHQKICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgbWluUmVmLnB1c2goewogICAgICAgICAgICAgICAgICB5OiBvYmpbMV0sCiAgICAgICAgICAgICAgICAgIHQ6IHQKICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgbWVhbjdkUmVmLnB1c2goewogICAgICAgICAgICAgICAgICB5OiBvYmpbMl0sCiAgICAgICAgICAgICAgICAgIHQ6IHQKICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgbWVhbjdkMjAyMC5wdXNoKHsKICAgICAgICAgICAgICAgICAgeTogb2JqWzNdLAogICAgICAgICAgICAgICAgICB0OiB0CiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgbWF4UmVmLnB1c2goewogICAgICAgICAgICAgICAgICB5OiBOdW1iZXIuTmFOLAogICAgICAgICAgICAgICAgICB0OiB0CiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIG1pblJlZi5wdXNoKHsKICAgICAgICAgICAgICAgICAgeTogTnVtYmVyLk5hTiwKICAgICAgICAgICAgICAgICAgdDogdAogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICBtZWFuN2RSZWYucHVzaCh7CiAgICAgICAgICAgICAgICAgIHk6IE51bWJlci5OYU4sCiAgICAgICAgICAgICAgICAgIHQ6IHQKICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgICAgbWVhbjdkMjAyMC5wdXNoKHsKICAgICAgICAgICAgICAgICAgeTogTnVtYmVyLk5hTiwKICAgICAgICAgICAgICAgICAgdDogdAogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9KTsKICAgICAgICAgICAgZGF0YXNldHMucHVzaCh7CiAgICAgICAgICAgICAgbGFiZWw6ICdWYWx1ZScsCiAgICAgICAgICAgICAgZGF0YTogbWVhc3VyZW1lbnQubWFwKGZ1bmN0aW9uIChtZWFzLCBpKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICAgICAgICB5OiBtZWFzLAogICAgICAgICAgICAgICAgICB0OiBpbmRpY2F0b3IudGltZVtpXQogICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICB9KSwKICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDI1NSwyNTUsMjU1LDAuMCknLAogICAgICAgICAgICAgIGJvcmRlckNvbG9yOiAncmVkJywKICAgICAgICAgICAgICBzcGFuR2FwczogZmFsc2UsCiAgICAgICAgICAgICAgcG9pbnRSYWRpdXM6IDAsCiAgICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDEuNQogICAgICAgICAgICB9KTsKICAgICAgICAgICAgZGF0YXNldHMucHVzaCh7CiAgICAgICAgICAgICAgbGFiZWw6ICc3LWRheSBtZWFuJywKICAgICAgICAgICAgICBkYXRhOiBtZWFuN2QyMDIwLAogICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMjU1LDI1NSwyNTUsMC4wKScsCiAgICAgICAgICAgICAgcG9pbnRSYWRpdXM6IDAsCiAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICdyZWQnLAogICAgICAgICAgICAgIHNwYW5HYXBzOiBmYWxzZSwKICAgICAgICAgICAgICBib3JkZXJEYXNoOiBbNiwgM10sCiAgICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDIKICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIGRhdGFzZXRzLnB1c2goewogICAgICAgICAgICAgIGxhYmVsOiAnMjAxNy0yMDE5IDdkIG1lYW4nLAogICAgICAgICAgICAgIGRhdGE6IG1lYW43ZFJlZiwKICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDI1NSwyNTUsMjU1LDAuMCknLAogICAgICAgICAgICAgIHBvaW50UmFkaXVzOiAwLAogICAgICAgICAgICAgIGJvcmRlckNvbG9yOiAnZ3JleScsCiAgICAgICAgICAgICAgc3BhbkdhcHM6IGZhbHNlLAogICAgICAgICAgICAgIGJvcmRlckRhc2g6IFs2LCAzXSwKICAgICAgICAgICAgICBib3JkZXJXaWR0aDogMgogICAgICAgICAgICB9KTsKICAgICAgICAgICAgZGF0YXNldHMucHVzaCh7CiAgICAgICAgICAgICAgbGFiZWw6ICcyMDE3LTIwMTkgcmFuZ2UnLAogICAgICAgICAgICAgIGRhdGE6IG1heFJlZiwKICAgICAgICAgICAgICBmaWxsOiA0LAogICAgICAgICAgICAgIHBvaW50UmFkaXVzOiAwLAogICAgICAgICAgICAgIHNwYW5HYXBzOiBmYWxzZSwKICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDAuMiknLAogICAgICAgICAgICAgIGJvcmRlckNvbG9yOiAncmdiYSgwLDAsMCwwLjApJywKICAgICAgICAgICAgICBwb2ludFN0eWxlOiAncmVjdCcKICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIGRhdGFzZXRzLnB1c2goewogICAgICAgICAgICAgIGxhYmVsOiAnaGlkZV8nLAogICAgICAgICAgICAgIGRhdGE6IG1pblJlZiwKICAgICAgICAgICAgICBmaWxsOiAzLAogICAgICAgICAgICAgIHBvaW50UmFkaXVzOiAwLAogICAgICAgICAgICAgIHNwYW5HYXBzOiBmYWxzZSwKICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDAuMCknLAogICAgICAgICAgICAgIGJvcmRlckNvbG9yOiAncmdiYSgwLDAsMCwwLjApJywKICAgICAgICAgICAgICBwb2ludFN0eWxlOiAncmVjdCcKICAgICAgICAgICAgfSk7IC8vIEZpbmQgdW5pcXVlIGluZGljYXRvciB2YWx1ZXMKCiAgICAgICAgICAgIHZhciBfaW5kaWNhdG9yVmFsdWVzID0ge307CiAgICAgICAgICAgIGluZGljYXRvci5pbmRpY2F0b3JWYWx1ZS5tYXAoZnVuY3Rpb24gKHZhbCwgaSkgewogICAgICAgICAgICAgIHZhciBrZXkgPSB2YWwudG9Mb3dlckNhc2UoKTsKICAgICAgICAgICAgICBrZXkgPSBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc2xpY2UoMSk7CgogICAgICAgICAgICAgIGlmICghWycnLCAnLyddLmluY2x1ZGVzKGtleSkgJiYgdHlwZW9mIF9pbmRpY2F0b3JWYWx1ZXNba2V5XSA9PT0gJ3VuZGVmaW5lZCcpIHsKICAgICAgICAgICAgICAgIF9pbmRpY2F0b3JWYWx1ZXNba2V5XSA9IF90aGlzLmdldEluZGljYXRvckNvbG9yKGluZGljYXRvci5jb2xvckNvZGVbaV0pOwogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgICBPYmplY3QuZW50cmllcyhfaW5kaWNhdG9yVmFsdWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmMykgewogICAgICAgICAgICAgIHZhciBfcmVmNCA9IF9zbGljZWRUb0FycmF5KF9yZWYzLCAyKSwKICAgICAgICAgICAgICAgICAga2V5ID0gX3JlZjRbMF0sCiAgICAgICAgICAgICAgICAgIHZhbHVlID0gX3JlZjRbMV07CgogICAgICAgICAgICAgIGRhdGFzZXRzLnB1c2goewogICAgICAgICAgICAgICAgbGFiZWw6IGtleSwKICAgICAgICAgICAgICAgIGRhdGE6IFtdLAogICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB2YWx1ZSwKICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiB2YWx1ZQogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICB9KTsKICAgICAgICAgIH0gZWxzZSBpZiAoWydFMTBhMycsICdFMTBhOCddLmluY2x1ZGVzKGluZGljYXRvckNvZGUpKSB7CiAgICAgICAgICAgIHZhciBudXRzRmVhdHVyZXMgPSBOVVRTLmZlYXR1cmVzOwogICAgICAgICAgICB2YXIgb3V0bGluZSA9IFtdOwogICAgICAgICAgICB2YXIgY3VycklEcyA9IFtdOwogICAgICAgICAgICB2YXIgZmVhdHVyZXMgPSBtZWFzdXJlbWVudC5tYXAoZnVuY3Rpb24gKG1lYXMsIGkpIHsKICAgICAgICAgICAgICAvLyBGaW5kIGNvcnJlY3QgTlVUUyBJRCBTaGFwZQogICAgICAgICAgICAgIHZhciBnZW9tID0gbnV0c0ZlYXR1cmVzLmZpbmQoZnVuY3Rpb24gKGYpIHsKICAgICAgICAgICAgICAgIHJldHVybiBmLnByb3BlcnRpZXMuTlVUU19JRCA9PT0gaW5kaWNhdG9yLnNpdGVOYW1lW2ldOwogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIHZhciBvdXRwdXQ7CgogICAgICAgICAgICAgIGlmIChnZW9tKSB7CiAgICAgICAgICAgICAgICBpZiAoY3VycklEcy5pbmRleE9mKGluZGljYXRvci5zaXRlTmFtZVtpXSkgPT09IC0xKSB7CiAgICAgICAgICAgICAgICAgIGN1cnJJRHMucHVzaChpbmRpY2F0b3Iuc2l0ZU5hbWVbaV0pOwogICAgICAgICAgICAgICAgICBvdXRsaW5lLnB1c2goewogICAgICAgICAgICAgICAgICAgIHR5cGU6ICdGZWF0dXJlJywKICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7fSwKICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeTogZ2VvbS5nZW9tZXRyeQogICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSBnZW9tLmdlb21ldHJ5LmNvb3JkaW5hdGVzOwogICAgICAgICAgICAgICAgdmFyIGxvbnMgPSBnZW9tLmdlb21ldHJ5LnR5cGUgPT09ICdQb2x5Z29uJyA/IGNvb3JkaW5hdGVzLmZsYXQoMSkubWFwKGZ1bmN0aW9uICh0dXBsZSkgewogICAgICAgICAgICAgICAgICByZXR1cm4gdHVwbGVbMF07CiAgICAgICAgICAgICAgICB9KSA6IGNvb3JkaW5hdGVzLmZsYXQoMikubWFwKGZ1bmN0aW9uICh0dXBsZSkgewogICAgICAgICAgICAgICAgICByZXR1cm4gdHVwbGVbMF07CiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIHZhciBsYXRzID0gZ2VvbS5nZW9tZXRyeS50eXBlID09PSAnUG9seWdvbicgPyBjb29yZGluYXRlcy5mbGF0KDEpLm1hcChmdW5jdGlvbiAodHVwbGUpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIHR1cGxlWzFdOwogICAgICAgICAgICAgICAgfSkgOiBjb29yZGluYXRlcy5mbGF0KDIpLm1hcChmdW5jdGlvbiAodHVwbGUpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIHR1cGxlWzFdOwogICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICB2YXIgbWluTGF0ID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgX3RvQ29uc3VtYWJsZUFycmF5KGxhdHMpKTsKICAgICAgICAgICAgICAgIHZhciBtaW5Mb24gPSBNYXRoLm1pbi5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkobG9ucykpOwogICAgICAgICAgICAgICAgdmFyIGNlbnRlclBvaW50ID0gewogICAgICAgICAgICAgICAgICBsYXQ6IG1pbkxhdCArIChNYXRoLm1heC5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkobGF0cykpIC0gbWluTGF0KSAvIDIsCiAgICAgICAgICAgICAgICAgIGxvbjogbWluTG9uICsgKE1hdGgubWF4LmFwcGx5KE1hdGgsIF90b0NvbnN1bWFibGVBcnJheShsb25zKSkgLSBtaW5Mb24pIC8gMgogICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgICAgIG91dHB1dCA9IHsKICAgICAgICAgICAgICAgICAgdHlwZTogJ0ZlYXR1cmUnLAogICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7fSwKICAgICAgICAgICAgICAgICAgZ2VvbWV0cnk6IGdlb20uZ2VvbWV0cnksCiAgICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnZGVzY3JpcHRpb24nLAogICAgICAgICAgICAgICAgICBsYXRpdHVkZTogY2VudGVyUG9pbnQubGF0LAogICAgICAgICAgICAgICAgICBsb25naXR1ZGU6IGNlbnRlclBvaW50LmxvbiwKICAgICAgICAgICAgICAgICAgbmFtZTogZ2VvbS5wcm9wZXJ0aWVzLk5VVFNfTkFNRSwKICAgICAgICAgICAgICAgICAgdGltZTogaW5kaWNhdG9yLnRpbWVbaV0sCiAgICAgICAgICAgICAgICAgIHZhbHVlOiBOdW1iZXIobWVhcyksCiAgICAgICAgICAgICAgICAgIHJlZmVyZW5jZVRpbWU6IGluZGljYXRvci5yZWZlcmVuY2VUaW1lW2ldLAogICAgICAgICAgICAgICAgICByZWZlcmVuY2VWYWx1ZTogaW5kaWNhdG9yLnJlZmVyZW5jZVZhbHVlW2ldLAogICAgICAgICAgICAgICAgICBjb2xvcjogaW5kaWNhdG9yLmNvbG9yQ29kZVtpXQogICAgICAgICAgICAgICAgfTsKCiAgICAgICAgICAgICAgICBpZiAoaW5kaWNhdG9yQ29kZSA9PT0gJ0UxMGE4JykgewogICAgICAgICAgICAgICAgICAvLyBTd2FwIHZhbHVlIHRvIGhhdmUgcmVmZXJlbmNlIHZhbHVlCiAgICAgICAgICAgICAgICAgIG91dHB1dC52YWx1ZSA9IE51bWJlcihpbmRpY2F0b3IucmVmZXJlbmNlVmFsdWVbaV0pOwogICAgICAgICAgICAgICAgICBvdXRwdXQucmVmZXJlbmNlVmFsdWUgPSBOdW1iZXIobWVhcyk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICByZXR1cm4gb3V0cHV0OwogICAgICAgICAgICB9KTsgLy8gRmlsdGVyIGJ5IHVuZGVmaW5lZCBhbmQgdGltZQoKICAgICAgICAgICAgZmVhdHVyZXMgPSBmZWF0dXJlcy5maWx0ZXIoZnVuY3Rpb24gKGQpIHsKICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIGQgIT09ICd1bmRlZmluZWQnOwogICAgICAgICAgICB9KTsKICAgICAgICAgICAgdmFyIGZpbHRlcmVkRmVhdHVyZXMgPSBmZWF0dXJlcy5maWx0ZXIoZnVuY3Rpb24gKGQpIHsKICAgICAgICAgICAgICB2YXIgaW5jbHVkZSA9IGZhbHNlOwoKICAgICAgICAgICAgICBpZiAoZC50aW1lIGluc3RhbmNlb2YgRGF0ZVRpbWUpIHsKICAgICAgICAgICAgICAgIGluY2x1ZGUgPSBkLnRpbWUudG9Gb3JtYXQoJ2RkLiBNTU0nKSA9PT0gX3RoaXMuZGF0YUxheWVyVGltZSAmJiAhTnVtYmVyLmlzTmFOKGQudmFsdWUpOwogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgcmV0dXJuIGluY2x1ZGU7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgICBsYWJlbHMgPSBmZWF0dXJlcy5tYXAoZnVuY3Rpb24gKGQpIHsKICAgICAgICAgICAgICByZXR1cm4gZC5uYW1lOwogICAgICAgICAgICB9KTsKICAgICAgICAgICAgZGF0YXNldHMucHVzaCh7CiAgICAgICAgICAgICAgb3V0bGluZTogb3V0bGluZSwKICAgICAgICAgICAgICBvdXRsaW5lQmFja2dyb3VuZENvbG9yOiBudWxsLAogICAgICAgICAgICAgIG91dGxpbmVCb3JkZXJDb2xvcjogJ2JsYWNrJywKICAgICAgICAgICAgICBvdXRsaW5lQm9yZGVyV2lkdGg6IDEsCiAgICAgICAgICAgICAgc2hvd091dGxpbmU6IHRydWUsCiAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBmaWx0ZXJlZEZlYXR1cmVzLm1hcChmdW5jdGlvbiAoZCkgewogICAgICAgICAgICAgICAgcmV0dXJuIGQuY29sb3I7CiAgICAgICAgICAgICAgfSksCiAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGZpbHRlcmVkRmVhdHVyZXMubWFwKGZ1bmN0aW9uIChkKSB7CiAgICAgICAgICAgICAgICByZXR1cm4gZC5jb2xvcjsKICAgICAgICAgICAgICB9KSwKICAgICAgICAgICAgICBib3JkZXJXaWR0aDogMywKICAgICAgICAgICAgICBkYXRhOiBmaWx0ZXJlZEZlYXR1cmVzLAogICAgICAgICAgICAgIGNsaXBNYXA6ICdpdGVtcycKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICB2YXIgX2RhdGEyID0gaW5kaWNhdG9yLnRpbWUubWFwKGZ1bmN0aW9uIChkYXRlLCBpKSB7CiAgICAgICAgICAgICAgY29sb3JzLnB1c2goX3RoaXMuZ2V0SW5kaWNhdG9yQ29sb3IoaW5kaWNhdG9yLmNvbG9yQ29kZVtpXSkpOwogICAgICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgICAgICB0OiBkYXRlLAogICAgICAgICAgICAgICAgeTogbWVhc3VyZW1lbnRbaV0KICAgICAgICAgICAgICB9OwogICAgICAgICAgICB9KTsKCiAgICAgICAgICAgIGRhdGFzZXRzLnB1c2goewogICAgICAgICAgICAgIGRhdGE6IF9kYXRhMiwKICAgICAgICAgICAgICBsYWJlbDogaW5kaWNhdG9yLnlBeGlzLAogICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogY29sb3JzLAogICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBjb2xvcnMKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9CgogICAgICAgICAgZGF0YUNvbGxlY3Rpb24gPSB7CiAgICAgICAgICAgIGxhYmVsczogbGFiZWxzLAogICAgICAgICAgICBkYXRhc2V0czogZGF0YXNldHMKICAgICAgICAgIH07CiAgICAgICAgfSkoKTsKICAgICAgfQoKICAgICAgcmV0dXJuIGRhdGFDb2xsZWN0aW9uOwogICAgfSwKICAgIGluZGljYXRvck9iamVjdDogZnVuY3Rpb24gaW5kaWNhdG9yT2JqZWN0KCkgewogICAgICByZXR1cm4gdGhpcy5jdXJyZW50SW5kaWNhdG9yIHx8IHRoaXMuJHN0b3JlLnN0YXRlLmluZGljYXRvcnMuY3VzdG9tQXJlYUluZGljYXRvciB8fCB0aGlzLiRzdG9yZS5zdGF0ZS5pbmRpY2F0b3JzLnNlbGVjdGVkSW5kaWNhdG9yOwogICAgfSwKICAgIGluZERlZmluaXRpb246IGZ1bmN0aW9uIGluZERlZmluaXRpb24oKSB7CiAgICAgIHJldHVybiB0aGlzLmJhc2VDb25maWcuaW5kaWNhdG9yc0RlZmluaXRpb25bdGhpcy5pbmRpY2F0b3JPYmplY3QuaW5kaWNhdG9yXTsKICAgIH0KICB9KSwKICBtZXRob2RzOiB7CiAgICBkYXRhTGF5ZXJUaW1lU2VsZWN0aW9uOiBmdW5jdGlvbiBkYXRhTGF5ZXJUaW1lU2VsZWN0aW9uKHBheWxvYWQpIHsKICAgICAgdGhpcy5kYXRhTGF5ZXJUaW1lID0gcGF5bG9hZDsKICAgICAgdmFyIG5ld0luZGV4ID0gdGhpcy5hcnJheU9mT2JqZWN0cy5tYXAoZnVuY3Rpb24gKGkpIHsKICAgICAgICByZXR1cm4gaS52YWx1ZTsKICAgICAgfSkuaW5kZXhPZih0aGlzLmRhdGFMYXllclRpbWUpOwogICAgICB0aGlzLmRhdGFMYXllckluZGV4ID0gbmV3SW5kZXg7CiAgICB9LAogICAgZGF0YUxheWVyUmVkdWNlOiBmdW5jdGlvbiBkYXRhTGF5ZXJSZWR1Y2UoKSB7CiAgICAgIHZhciBjdXJyZW50SW5kZXggPSB0aGlzLmFycmF5T2ZPYmplY3RzLm1hcChmdW5jdGlvbiAoaSkgewogICAgICAgIHJldHVybiBpLnZhbHVlOwogICAgICB9KS5pbmRleE9mKHRoaXMuZGF0YUxheWVyVGltZSk7CiAgICAgIHRoaXMuZGF0YUxheWVySW5kZXggPSBjdXJyZW50SW5kZXggLSAxOwogICAgICB0aGlzLmRhdGFMYXllclRpbWVTZWxlY3Rpb24odGhpcy5hcnJheU9mT2JqZWN0c1tjdXJyZW50SW5kZXggLSAxXS52YWx1ZSk7CiAgICB9LAogICAgZGF0YUxheWVySW5jcmVhc2U6IGZ1bmN0aW9uIGRhdGFMYXllckluY3JlYXNlKCkgewogICAgICB2YXIgY3VycmVudEluZGV4ID0gdGhpcy5hcnJheU9mT2JqZWN0cy5tYXAoZnVuY3Rpb24gKGkpIHsKICAgICAgICByZXR1cm4gaS52YWx1ZTsKICAgICAgfSkuaW5kZXhPZih0aGlzLmRhdGFMYXllclRpbWUpOwogICAgICB0aGlzLmRhdGFMYXllckluZGV4ID0gY3VycmVudEluZGV4ICsgMTsKICAgICAgdGhpcy5kYXRhTGF5ZXJUaW1lU2VsZWN0aW9uKHRoaXMuYXJyYXlPZk9iamVjdHNbY3VycmVudEluZGV4ICsgMV0udmFsdWUpOwogICAgfSwKICAgIGZvcm1hdE51bVJlZjogZnVuY3Rpb24gZm9ybWF0TnVtUmVmKG51bSkgewogICAgICB2YXIgbWF4RGVjaW1hbHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDM7CiAgICAgIHJldHVybiBOdW1iZXIucGFyc2VGbG9hdChudW0udG9GaXhlZChtYXhEZWNpbWFscykpOwogICAgfSwKICAgIHJvdW5kVmFsdWVJbmQ6IGZ1bmN0aW9uIHJvdW5kVmFsdWVJbmQodmFsKSB7CiAgICAgIGlmICh0aGlzLmluZERlZmluaXRpb24ubWF4RGVjaW1hbHMgPT09IC0xKSB7CiAgICAgICAgcmV0dXJuIHZhbDsKICAgICAgfQoKICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIodGhpcy5pbmREZWZpbml0aW9uLm1heERlY2ltYWxzKSkgewogICAgICAgIHJldHVybiB0aGlzLmZvcm1hdE51bVJlZih2YWwsIHRoaXMuaW5kRGVmaW5pdGlvbi5tYXhEZWNpbWFscyk7CiAgICAgIH0gLy8gdXNlIGRlZmF1bHQKCgogICAgICByZXR1cm4gdGhpcy5mb3JtYXROdW1SZWYodmFsLCAyKTsKICAgIH0sCiAgICBnZXRNaW5NYXhEYXRlOiBmdW5jdGlvbiBnZXRNaW5NYXhEYXRlKHRpbWVEYXRhKSB7CiAgICAgIHZhciB0aW1lTWluID0gTWF0aC5taW4uYXBwbHkobnVsbCwgdGltZURhdGEubWFwKGZ1bmN0aW9uIChkKSB7CiAgICAgICAgcmV0dXJuIGQudG9NaWxsaXMoKTsKICAgICAgfSkpOwogICAgICB2YXIgdGltZU1heCA9IE1hdGgubWF4LmFwcGx5KG51bGwsIHRpbWVEYXRhLm1hcChmdW5jdGlvbiAoZCkgewogICAgICAgIHJldHVybiBkLnRvTWlsbGlzKCk7CiAgICAgIH0pKTsKICAgICAgdmFyIGJ1ZmZlciA9ICh0aW1lTWF4IC0gdGltZU1pbikgLyB0aW1lRGF0YS5sZW5ndGg7CiAgICAgIHRpbWVNaW4gLT0gYnVmZmVyOwogICAgICB0aW1lTWF4ICs9IGJ1ZmZlcjsKICAgICAgcmV0dXJuIFt0aW1lTWluLCB0aW1lTWF4XTsKICAgIH0sCiAgICBjaGFydE9wdGlvbnM6IGZ1bmN0aW9uIGNoYXJ0T3B0aW9ucygpIHsKICAgICAgdmFyIF90aGlzMiA9IHRoaXM7CgogICAgICB2YXIgaW5kaWNhdG9yQ29kZSA9IHRoaXMuaW5kaWNhdG9yT2JqZWN0LmluZGljYXRvcjsKICAgICAgdmFyIHJlZmVyZW5jZSA9IE51bWJlci5wYXJzZUZsb2F0KHRoaXMuaW5kaWNhdG9yT2JqZWN0LnJlZmVyZW5jZVZhbHVlKTsKICAgICAgdmFyIHRpbWVNaW5NYXggPSB0aGlzLmdldE1pbk1heERhdGUodGhpcy5pbmRpY2F0b3JPYmplY3QudGltZSk7CiAgICAgIHZhciBhbm5vdGF0aW9ucyA9IFtdOwogICAgICB2YXIgbG93ID0gMDsKICAgICAgdmFyIGhpZ2ggPSAwOwogICAgICB2YXIgZGVmYXVsdEFubm90YXRpb25TZXR0aW5ncyA9IHsKICAgICAgICB0eXBlOiAnbGluZScsCiAgICAgICAgbW9kZTogJ2hvcml6b250YWwnLAogICAgICAgIHNjYWxlSUQ6ICd5LWF4aXMtMCcsCiAgICAgICAgYm9yZGVyQ29sb3I6ICdyZ2JhKDAsIDAsIDI1NSwgMC41KScsCiAgICAgICAgYm9yZGVyV2lkdGg6IDIsCiAgICAgICAgYm9yZGVyRGFzaDogWzIsIDNdLAogICAgICAgIHNjYWxlczogewogICAgICAgICAgeEF4ZXM6IFt7CiAgICAgICAgICAgIHR5cGU6ICd0aW1lJywKICAgICAgICAgICAgdGltZTogewogICAgICAgICAgICAgIHVuaXQ6ICdtb250aCcKICAgICAgICAgICAgfQogICAgICAgICAgfV0KICAgICAgICB9LAogICAgICAgIGxhYmVsOiB7CiAgICAgICAgICBlbmFibGVkOiB0cnVlLAogICAgICAgICAgZm9udFN0eWxlOiAnbm9ybWFsJywKICAgICAgICAgIHBhZGRpbmdYOiAyLAogICAgICAgICAgcGFkZGluZ1k6IDIsCiAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNyknLAogICAgICAgICAgZm9udENvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjgpJwogICAgICAgIH0KICAgICAgfTsKCiAgICAgIGlmICghTnVtYmVyLmlzTmFOKHJlZmVyZW5jZSkgJiYgIVsnRTEwYTEnLCAnRTEwYTInLCAnRTEwYTUnLCAnRTEwYTYnLCAnRTEwYTcnLCAnRTEwYTknLCAnTjRjJywgJ0U4JywgJ0UxM2UnLCAnRTEzZicsICdFMTNnJywgJ0UxM2gnLCAnRTEzaScsICdFMTNsJywgJ0UxM20nLCAnRTEyYycsICdFMTJkJ10uaW5jbHVkZXMoaW5kaWNhdG9yQ29kZSkpIHsKICAgICAgICBhbm5vdGF0aW9ucy5wdXNoKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdEFubm90YXRpb25TZXR0aW5ncyksIHt9LCB7CiAgICAgICAgICBsYWJlbDogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0QW5ub3RhdGlvblNldHRpbmdzLmxhYmVsKSwge30sIHsKICAgICAgICAgICAgY29udGVudDogInJlZmVyZW5jZTogIi5jb25jYXQodGhpcy5mb3JtYXROdW1SZWYocmVmZXJlbmNlKSkKICAgICAgICAgIH0pLAogICAgICAgICAgdmFsdWU6IHJlZmVyZW5jZQogICAgICAgIH0pKTsKICAgICAgfQoKICAgICAgaWYgKFsnRTQnXS5pbmNsdWRlcyhpbmRpY2F0b3JDb2RlKSkgewogICAgICAgIGxvdyA9IDAuMiAqIHJlZmVyZW5jZTsKICAgICAgICBhbm5vdGF0aW9ucy5wdXNoKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdEFubm90YXRpb25TZXR0aW5ncyksIHt9LCB7CiAgICAgICAgICBib3JkZXJDb2xvcjogJ3JnYmEoNTAsIDI1MiwgMCwgMC41KScsCiAgICAgICAgICB2YWx1ZTogbG93LAogICAgICAgICAgbGFiZWw6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdEFubm90YXRpb25TZXR0aW5ncy5sYWJlbCksIHt9LCB7CiAgICAgICAgICAgIGNvbnRlbnQ6ICJvbi9vZmY6ICIuY29uY2F0KHRoaXMuZm9ybWF0TnVtUmVmKGxvdykpCiAgICAgICAgICB9KQogICAgICAgIH0pKTsKICAgICAgfSBlbHNlIGlmIChbJ0UxMScsICdFMWEnLCAnRTEnLCAnRTInLCAnRTJfUzInLCAnRTFhX1MyJywgJ0UxX1MyJ10uaW5jbHVkZXMoaW5kaWNhdG9yQ29kZSkpIHsKICAgICAgICBpZiAoaW5kaWNhdG9yQ29kZSA9PT0gJ0UxMScpIHsKICAgICAgICAgIGxvdyA9IDAuMyAqIHJlZmVyZW5jZTsKICAgICAgICAgIGhpZ2ggPSAwLjcgKiByZWZlcmVuY2U7CiAgICAgICAgfSBlbHNlIGlmIChbJ0UxYScsICdFMScsICdFMicsICdFMl9TMicsICdFMWFfUzInLCAnRTFfUzInXS5pbmNsdWRlcyhpbmRpY2F0b3JDb2RlKSkgewogICAgICAgICAgbG93ID0gMC43ICogcmVmZXJlbmNlOwogICAgICAgICAgaGlnaCA9IDEuMyAqIHJlZmVyZW5jZTsKICAgICAgICB9CgogICAgICAgIGFubm90YXRpb25zLnB1c2goX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0QW5ub3RhdGlvblNldHRpbmdzKSwge30sIHsKICAgICAgICAgIHZhbHVlOiBsb3csCiAgICAgICAgICBsYWJlbDogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0QW5ub3RhdGlvblNldHRpbmdzLmxhYmVsKSwge30sIHsKICAgICAgICAgICAgY29udGVudDogImxvdzogIi5jb25jYXQodGhpcy5mb3JtYXROdW1SZWYobG93KSkKICAgICAgICAgIH0pCiAgICAgICAgfSkpOwogICAgICAgIGFubm90YXRpb25zLnB1c2goX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBkZWZhdWx0QW5ub3RhdGlvblNldHRpbmdzKSwge30sIHsKICAgICAgICAgIHZhbHVlOiBoaWdoLAogICAgICAgICAgbGFiZWw6IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgZGVmYXVsdEFubm90YXRpb25TZXR0aW5ncy5sYWJlbCksIHt9LCB7CiAgICAgICAgICAgIGNvbnRlbnQ6ICJoaWdoOiAiLmNvbmNhdCh0aGlzLmZvcm1hdE51bVJlZihoaWdoKSkKICAgICAgICAgIH0pCiAgICAgICAgfSkpOwogICAgICB9IC8vIEludHJvZHVjZSBiYWNrZ3JvdW5kIGFyZWEgYW5ub3RhdGlvbnMgZm9yIGxvY2tkb3duIHRpbWVzLCBkb2VzIG5vdAogICAgICAvLyB3b3JrIGZvciBhbGwgY2hhcnQgdHlwZXMsIHNvIHdlIG1ha2Ugc3VyZSBpdCBpcyBub3QgYW55IG9mIHRob3NlIGNoYXJ0cwoKCiAgICAgIGlmICghWydFMTBhMycsICdFMTBhOCcsICdOMicsICdFMTJjJywgJ0UxMmQnLCAnR1NBJ10uaW5jbHVkZXMoaW5kaWNhdG9yQ29kZSkpIHsKICAgICAgICAvLyBGaW5kIGNvdW50cnkgYmFzZWQgb24gYWxwaGEtMyBjb2RlCiAgICAgICAgdmFyIGN1cnJDb3VudHJ5ID0gY291bnRyaWVzLmZlYXR1cmVzLmZpbmQoZnVuY3Rpb24gKGNudHIpIHsKICAgICAgICAgIHJldHVybiBjbnRyLnByb3BlcnRpZXMuYWxwaGEyID09PSBfdGhpczIuaW5kaWNhdG9yT2JqZWN0LmNvdW50cnk7CiAgICAgICAgfSk7CgogICAgICAgIGlmICh0eXBlb2YgY3VyckNvdW50cnkgIT09ICd1bmRlZmluZWQnICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChsb2NrZG93blRpbWVzLCBjdXJyQ291bnRyeS5pZCkpIHsKICAgICAgICAgIHZhciBsY2tUcyA9IGxvY2tkb3duVGltZXNbY3VyckNvdW50cnkuaWRdWydDN19SZXN0cmljdGlvbnMgb24gaW50ZXJuYWwgbW92ZW1lbnQnXTsKCiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxja1RzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgIHZhciBhcmVhQ29sb3IgPSAncmdiYSgwLCAwLCAwLCAwLjApJzsKCiAgICAgICAgICAgIGlmIChsY2tUc1tpXS52YWx1ZSA9PT0gMSkgewogICAgICAgICAgICAgIGFyZWFDb2xvciA9ICdyZ2JhKDIwNCwgMTQzLCAxNDMsIDAuMjQpJzsKICAgICAgICAgICAgfSBlbHNlIGlmIChsY2tUc1tpXS52YWx1ZSA9PT0gMikgewogICAgICAgICAgICAgIGFyZWFDb2xvciA9ICdyZ2JhKDIwNywgMTA5LCAxMDksIDAuNTQpJzsKICAgICAgICAgICAgfSAvLyBXZSBhbHNvIGhhdmUgc3BlY2lhbCBkYXRlIGhhbmRsaW5nIGZvciBzb21lIGNoYXJ0IHR5cGVzIGFzIHdlCiAgICAgICAgICAgIC8vIHNpbXVsYXRlIHllYXIgYWdub3N0aWMgcmVuZGVyaW5nLCBzbyB3ZSBjb252ZXJ0IGFsbCBkYXRlcyB0bwogICAgICAgICAgICAvLyBvbmUgeWVhcgoKCiAgICAgICAgICAgIHZhciBzdGFydCA9IERhdGVUaW1lLmZyb21JU08obGNrVHNbaV0uc3RhcnQpOwogICAgICAgICAgICB2YXIgZW5kID0gRGF0ZVRpbWUuZnJvbUlTTyhsY2tUc1tpXS5lbmQpOwoKICAgICAgICAgICAgaWYgKFsnRTEwYTInLCAnRTEwYTYnLCAnRTEwYTcnLCAnRTEwYycsICdFOCcsICdFMTNlJywgJ0UxM2YnLCAnRTEzZycsICdFMTNoJywgJ0UxM2knLCAnRTEzbCcsICdFMTNtJ10uaW5jbHVkZXMoaW5kaWNhdG9yQ29kZSkpIHsKICAgICAgICAgICAgICBzdGFydCA9IHN0YXJ0LnNldCh7CiAgICAgICAgICAgICAgICB5ZWFyOiAyMDAwCiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgZW5kID0gZW5kLnNldCh7CiAgICAgICAgICAgICAgICB5ZWFyOiAyMDAwCiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIGlmIChsY2tUc1tpXS52YWx1ZSAhPT0gMCkgewogICAgICAgICAgICAgIGFubm90YXRpb25zLnB1c2goewogICAgICAgICAgICAgICAgZHJhd1RpbWU6ICdiZWZvcmVEYXRhc2V0c0RyYXcnLAogICAgICAgICAgICAgICAgdHlwZTogJ2JveCcsCiAgICAgICAgICAgICAgICB4U2NhbGVJRDogJ3gtYXhpcy0wJywKICAgICAgICAgICAgICAgIHhNaW46IHN0YXJ0LnRvSVNPRGF0ZSgpLAogICAgICAgICAgICAgICAgeE1heDogZW5kLnRvSVNPRGF0ZSgpLAogICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGFyZWFDb2xvciwKICAgICAgICAgICAgICAgIGJvcmRlcldpZHRoOiAwLAogICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBhcmVhQ29sb3IKICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQoKICAgICAgdmFyIHhBeGVzID0ge307CgogICAgICBpZiAoIVsnRTEwYTEnLCAnRTEwYTInLCAnRTEwYTMnLCAnRTEwYTUnLCAnRTEwYTYnLCAnRTEwYTcnLCAnRTEwYTgnLCAnRTEwYycsICdFMTJjJywgJ0UxMmQnLCAnTjInXS5pbmNsdWRlcyhpbmRpY2F0b3JDb2RlKSkgewogICAgICAgIHhBeGVzID0gW3sKICAgICAgICAgIHR5cGU6ICd0aW1lJywKICAgICAgICAgIHRpbWU6IHsKICAgICAgICAgICAgdW5pdDogJ3dlZWsnCiAgICAgICAgICB9LAogICAgICAgICAgdGlja3M6IHsKICAgICAgICAgICAgbWluOiB0aW1lTWluTWF4WzBdLAogICAgICAgICAgICBtYXg6IHRpbWVNaW5NYXhbMV0KICAgICAgICAgIH0sCiAgICAgICAgICBiYXJUaGlja25lc3M6ICdmbGV4JwogICAgICAgIH1dOwoKICAgICAgICBpZiAoIVsnTjMnLCAnTjNiJ10uaW5jbHVkZXMoaW5kaWNhdG9yQ29kZSkpIHsKICAgICAgICAgIHhBeGVzWzBdLmRpc3RyaWJ1dGlvbiA9ICdzZXJpZXMnOwogICAgICAgIH0KICAgICAgfQoKICAgICAgaWYgKFsnRTEwYTInLCAnRTEwYTYnLCAnRTEwYTcnLCAnRTEwYycsICdFOCcsICdFMTNlJywgJ0UxM2YnLCAnRTEzZycsICdFMTNoJywgJ0UxM2knLCAnRTEzbCcsICdFMTNtJ10uaW5jbHVkZXMoaW5kaWNhdG9yQ29kZSkpIHsKICAgICAgICAvKiBSZWNhbGN1bGF0ZSB0byBnZXQgbWluIG1heCBtb250aHMgaW4gZGF0YSBjb252ZXJ0ZWQgdG8gb25lIHllYXIgKi8KICAgICAgICB0aW1lTWluTWF4ID0gdGhpcy5nZXRNaW5NYXhEYXRlKHRoaXMuaW5kaWNhdG9yT2JqZWN0LnRpbWUubWFwKGZ1bmN0aW9uIChkYXRlKSB7CiAgICAgICAgICByZXR1cm4gZGF0ZS5zZXQoewogICAgICAgICAgICB5ZWFyOiAyMDAwCiAgICAgICAgICB9KTsKICAgICAgICB9KSk7CiAgICAgICAgLyogQ2hlY2sgYWxzbyBmb3IgcmVmZXJlbmNlIHRpbWUgKi8KCiAgICAgICAgdmFyIHJlZlRpbWVNaW5NYXggPSB0aGlzLmdldE1pbk1heERhdGUodGhpcy5pbmRpY2F0b3JPYmplY3QucmVmZXJlbmNlVGltZS5tYXAoZnVuY3Rpb24gKGRhdGUpIHsKICAgICAgICAgIHJldHVybiBkYXRlLnNldCh7CiAgICAgICAgICAgIHllYXI6IDIwMDAKICAgICAgICAgIH0pOwogICAgICAgIH0pKTsKICAgICAgICB4QXhlcyA9IFt7CiAgICAgICAgICB0eXBlOiAndGltZScsCiAgICAgICAgICB0aW1lOiB7CiAgICAgICAgICAgIHVuaXQ6ICdtb250aCcsCiAgICAgICAgICAgIGRpc3BsYXlGb3JtYXRzOiB7CiAgICAgICAgICAgICAgbW9udGg6ICdNTU0nCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHRvb2x0aXBGb3JtYXQ6ICdkZC4gTU1NJwogICAgICAgICAgfSwKICAgICAgICAgIHRpY2tzOiB7CiAgICAgICAgICAgIG1pbjogdGltZU1pbk1heFswXSA8IHJlZlRpbWVNaW5NYXhbMF0gPyB0aW1lTWluTWF4WzBdIDogcmVmVGltZU1pbk1heFswXSwKICAgICAgICAgICAgbWF4OiB0aW1lTWluTWF4WzFdID4gcmVmVGltZU1pbk1heFsxXSA/IHRpbWVNaW5NYXhbMV0gOiByZWZUaW1lTWluTWF4WzFdCiAgICAgICAgICB9CiAgICAgICAgfV07CiAgICAgIH0KCiAgICAgIGlmIChbJ04yJ10uaW5jbHVkZXMoaW5kaWNhdG9yQ29kZSkpIHsKICAgICAgICB0aW1lTWluTWF4ID0gdGhpcy5nZXRNaW5NYXhEYXRlKHRoaXMuaW5kaWNhdG9yT2JqZWN0LnRpbWUubWFwKGZ1bmN0aW9uIChkYXRlKSB7CiAgICAgICAgICByZXR1cm4gZGF0ZS5zZXQoewogICAgICAgICAgICB5ZWFyOiAyMDAwCiAgICAgICAgICB9KTsKICAgICAgICB9KSk7CiAgICAgICAgeEF4ZXMgPSBbewogICAgICAgICAgdHlwZTogJ3RpbWUnLAogICAgICAgICAgdGltZTogewogICAgICAgICAgICB1bml0OiAnbW9udGgnLAogICAgICAgICAgICBkaXNwbGF5Rm9ybWF0czogewogICAgICAgICAgICAgIG1vbnRoOiAnTU1NJwogICAgICAgICAgICB9LAogICAgICAgICAgICB0b29sdGlwRm9ybWF0OiAnZGQuIE1NTScKICAgICAgICAgIH0sCiAgICAgICAgICBkaXN0cmlidXRpb246ICdzZXJpZXMnLAogICAgICAgICAgdGlja3M6IHsKICAgICAgICAgICAgbWluOiB0aW1lTWluTWF4WzBdLAogICAgICAgICAgICBtYXg6IHRpbWVNaW5NYXhbMV0KICAgICAgICAgIH0KICAgICAgICB9XTsKICAgICAgfQoKICAgICAgaWYgKFsnRTEyYycsICdFMTJkJ10uaW5jbHVkZXMoaW5kaWNhdG9yQ29kZSkpIHsKICAgICAgICB4QXhlcyA9IFt7CiAgICAgICAgICB0eXBlOiAndGltZScsCiAgICAgICAgICB0aW1lOiB7CiAgICAgICAgICAgIHVuaXQ6ICd5ZWFyJywKICAgICAgICAgICAgZGlzcGxheUZvcm1hdHM6IHsKICAgICAgICAgICAgICB5ZWFyOiAneXl5eScKICAgICAgICAgICAgfSwKICAgICAgICAgICAgdG9vbHRpcEZvcm1hdDogJ3l5eXktTU0tZGQgLSB5eXl5LTA2LTMwJwogICAgICAgICAgfSwKICAgICAgICAgIGRpc3RyaWJ1dGlvbjogJ3NlcmllcycsCiAgICAgICAgICB0aWNrczogewogICAgICAgICAgICBtaW46IHRpbWVNaW5NYXhbMF0sCiAgICAgICAgICAgIG1heDogdGltZU1pbk1heFsxXQogICAgICAgICAgfQogICAgICAgIH1dOwogICAgICB9CgogICAgICBpZiAoWydFMTNkJywgJ0UxM24nLCAnQzEnLCAnQzInLCAnQzMnXS5pbmNsdWRlcyhpbmRpY2F0b3JDb2RlKSkgewogICAgICAgIHhBeGVzID0gW3sKICAgICAgICAgIHR5cGU6ICd0aW1lJywKICAgICAgICAgIHRpbWU6IHsKICAgICAgICAgICAgdW5pdDogJ21vbnRoJywKICAgICAgICAgICAgZGlzcGxheUZvcm1hdHM6IHsKICAgICAgICAgICAgICBtb250aDogJ01NTSB5eScKICAgICAgICAgICAgfSwKICAgICAgICAgICAgdG9vbHRpcEZvcm1hdDogJ01NTSB5eXl5JwogICAgICAgICAgfSwKICAgICAgICAgIGRpc3RyaWJ1dGlvbjogJ3NlcmllcycsCiAgICAgICAgICB0aWNrczogewogICAgICAgICAgICBtaW46IHRpbWVNaW5NYXhbMF0sCiAgICAgICAgICAgIG1heDogdGltZU1pbk1heFsxXQogICAgICAgICAgfQogICAgICAgIH1dOwogICAgICB9CgogICAgICB2YXIgcGx1Z2lucyA9IHsKICAgICAgICBkYXRhbGFiZWxzOiB7CiAgICAgICAgICBkaXNwbGF5OiBmYWxzZQogICAgICAgIH0KICAgICAgfTsKICAgICAgdmFyIHlBeGVzID0gW3sKICAgICAgICBzY2FsZUxhYmVsOiB7CiAgICAgICAgICBkaXNwbGF5OiB0cnVlLAogICAgICAgICAgbGFiZWxTdHJpbmc6IHRoaXMuaW5kaWNhdG9yT2JqZWN0LnlBeGlzLAogICAgICAgICAgcGFkZGluZzogMgogICAgICAgIH0sCiAgICAgICAgdGlja3M6IHsKICAgICAgICAgIGxpbmVIZWlnaHQ6IDEsCiAgICAgICAgICBzdWdnZXN0ZWRNaW46IE1hdGgubWluLmFwcGx5KE1hdGgsIF90b0NvbnN1bWFibGVBcnJheSh0aGlzLmluZGljYXRvck9iamVjdC5tZWFzdXJlbWVudC5maWx0ZXIoZnVuY3Rpb24gKGQpIHsKICAgICAgICAgICAgcmV0dXJuICFOdW1iZXIuaXNOYU4oZCk7CiAgICAgICAgICB9KSkpIC0gMSwKICAgICAgICAgIHN1Z2dlc3RlZE1heDogTWF0aC5tYXguYXBwbHkoTWF0aCwgX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMuaW5kaWNhdG9yT2JqZWN0Lm1lYXN1cmVtZW50LmZpbHRlcihmdW5jdGlvbiAoZCkgewogICAgICAgICAgICByZXR1cm4gIU51bWJlci5pc05hTihkKTsKICAgICAgICAgIH0pKSkgKyAxCiAgICAgICAgfQogICAgICB9XTsgLy8gVGhpcyBpbmRpY2F0b3IgaGFzIGFuIGFycmF5IG9mIHZhbHVlcyBzbyB3ZSBuZWVkIHRvIGNhbGN1bGF0ZSBtaW4vbWF4CiAgICAgIC8vIGRpZmZlcmVudAoKICAgICAgaWYgKFsnRTEwYTknXS5pbmNsdWRlcyhpbmRpY2F0b3JDb2RlKSkgewogICAgICAgIHZhciBtZWFzRmxhdCA9IHRoaXMuaW5kaWNhdG9yT2JqZWN0Lm1lYXN1cmVtZW50LmZsYXQoKTsKICAgICAgICB5QXhlc1swXS50aWNrcy5zdWdnZXN0ZWRNaW4gPSBNYXRoLm1pbi5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkobWVhc0ZsYXQpKTsKICAgICAgICB5QXhlc1swXS50aWNrcy5zdWdnZXN0ZWRNYXggPSBNYXRoLm1heC5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkobWVhc0ZsYXQpKTsKICAgICAgfQoKICAgICAgdmFyIGxlZ2VuZCA9IHsKICAgICAgICBsYWJlbHM6IHsKICAgICAgICAgIGdlbmVyYXRlTGFiZWxzOiBmdW5jdGlvbiBnZW5lcmF0ZUxhYmVscyhjaGFydCkgewogICAgICAgICAgICB2YXIgZGF0YXNldHMgPSBjaGFydC5kYXRhLmRhdGFzZXRzOwogICAgICAgICAgICB2YXIgbGFiZWxzID0gY2hhcnQubGVnZW5kLm9wdGlvbnMubGFiZWxzOwogICAgICAgICAgICB2YXIgdXNlUG9pbnRTdHlsZSA9IGxhYmVscy51c2VQb2ludFN0eWxlOwogICAgICAgICAgICB2YXIgb3ZlcnJpZGVTdHlsZSA9IGxhYmVscy5wb2ludFN0eWxlOwoKICAgICAgICAgICAgdmFyIGxhYmVsU2V0ID0gY2hhcnQuX2dldFNvcnRlZERhdGFzZXRNZXRhcygpOwoKICAgICAgICAgICAgbGFiZWxTZXQgPSBsYWJlbFNldC5maWx0ZXIoZnVuY3Rpb24gKG1ldGEpIHsKICAgICAgICAgICAgICB2YXIgaW5jbHVkZUxhYmVsID0gZmFsc2U7CgogICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGF0YXNldHNbbWV0YS5pbmRleF0sICdsYWJlbCcpKSB7CiAgICAgICAgICAgICAgICBpbmNsdWRlTGFiZWwgPSAhZGF0YXNldHNbbWV0YS5pbmRleF0ubGFiZWwuc3RhcnRzV2l0aCgnaGlkZV8nKTsKICAgICAgICAgICAgICB9CgogICAgICAgICAgICAgIHJldHVybiBpbmNsdWRlTGFiZWw7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgICB2YXIgbGFiZWxPYmplY3RzID0gbGFiZWxTZXQubWFwKGZ1bmN0aW9uIChtZXRhKSB7CiAgICAgICAgICAgICAgdmFyIHN0eWxlID0gbWV0YS5jb250cm9sbGVyLmdldFN0eWxlKHVzZVBvaW50U3R5bGUgPyAwIDogdW5kZWZpbmVkKTsKICAgICAgICAgICAgICB2YXIgYm9yZGVyV2lkdGggPSAyOwogICAgICAgICAgICAgIHZhciBoaWRkZW4gPSBmYWxzZTsKCiAgICAgICAgICAgICAgaWYgKG1ldGEuaGlkZGVuID09PSB0cnVlKSB7CiAgICAgICAgICAgICAgICBoaWRkZW4gPSB0cnVlOwogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgICAgIHRleHQ6IGRhdGFzZXRzW21ldGEuaW5kZXhdLmxhYmVsLAogICAgICAgICAgICAgICAgZmlsbFN0eWxlOiBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IsCiAgICAgICAgICAgICAgICBoaWRkZW46IGhpZGRlbiwKICAgICAgICAgICAgICAgIGxpbmVDYXA6IHN0eWxlLmJvcmRlckNhcFN0eWxlLAogICAgICAgICAgICAgICAgbGluZURhc2g6IHN0eWxlLmJvcmRlckRhc2gsCiAgICAgICAgICAgICAgICBsaW5lRGFzaE9mZnNldDogc3R5bGUuYm9yZGVyRGFzaE9mZnNldCwKICAgICAgICAgICAgICAgIGxpbmVKb2luOiBzdHlsZS5ib3JkZXJKb2luU3R5bGUsCiAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IGJvcmRlcldpZHRoLAogICAgICAgICAgICAgICAgc3Ryb2tlU3R5bGU6IHN0eWxlLmJvcmRlckNvbG9yLAogICAgICAgICAgICAgICAgcG9pbnRTdHlsZTogb3ZlcnJpZGVTdHlsZSB8fCBzdHlsZS5wb2ludFN0eWxlLAogICAgICAgICAgICAgICAgcm90YXRpb246IHN0eWxlLnJvdGF0aW9uLAogICAgICAgICAgICAgICAgLy8gQmVsb3cgaXMgZXh0cmEgZGF0YSB1c2VkIGZvciB0b2dnbGluZyB0aGUgZGF0YXNldHMKICAgICAgICAgICAgICAgIGRhdGFzZXRJbmRleDogbWV0YS5pbmRleAogICAgICAgICAgICAgIH07CiAgICAgICAgICAgIH0sIF90aGlzMik7IC8vIE5vdyB3ZSBhZGQgb3VyIGRlZmF1bHQgMiBsb2NrZG93biBsYWJlbHMgYnV0IHdlIGV4Y2x1ZGUgaW5kaWNhdG9ycwogICAgICAgICAgICAvLyB3aGVyZSBpdCBpcyBub3QgYXBwbGljYWJsZQoKICAgICAgICAgICAgaWYgKCFbJ0UxMGExJywgJ0UxMGE1JywgJ0UxMGE4JywgJ04yJywgJ040YycsICdFMTJjJywgJ0UxMmQnLCAnR1NBJywgJ04xJ10uaW5jbHVkZXMoX3RoaXMyLmluZGljYXRvck9iamVjdC5pbmRpY2F0b3IpKSB7CiAgICAgICAgICAgICAgbGFiZWxPYmplY3RzLnB1c2goewogICAgICAgICAgICAgICAgdGV4dDogJ0xvdyBSZXN0cmljdGlvbnMnLAogICAgICAgICAgICAgICAgZmlsbFN0eWxlOiAncmdiYSgyMDQsIDE0MywgMTQzLCAwLjI0KScsCiAgICAgICAgICAgICAgICBoaWRkZW46IGZhbHNlLAogICAgICAgICAgICAgICAgbGluZVdpZHRoOiAwLAogICAgICAgICAgICAgICAgZGF0YXNldEluZGV4OiAtMQogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIGxhYmVsT2JqZWN0cy5wdXNoKHsKICAgICAgICAgICAgICAgIHRleHQ6ICdIaWdoIFJlc3RyaWN0aW9ucycsCiAgICAgICAgICAgICAgICBmaWxsU3R5bGU6ICdyZ2JhKDIwNywgMTA5LCAxMDksIDAuNTQpJywKICAgICAgICAgICAgICAgIGhpZGRlbjogZmFsc2UsCiAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IDAsCiAgICAgICAgICAgICAgICBkYXRhc2V0SW5kZXg6IC0xCiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIH0KCiAgICAgICAgICAgIHJldHVybiBsYWJlbE9iamVjdHM7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9OwoKICAgICAgaWYgKFsnTjRjJ10uaW5jbHVkZXMoaW5kaWNhdG9yQ29kZSkpIHsKICAgICAgICB4QXhlcyA9IFt7CiAgICAgICAgICBzdGFja2VkOiB0cnVlCiAgICAgICAgfV07CiAgICAgICAgeUF4ZXNbMF0uc3RhY2tlZCA9IHRydWU7CiAgICAgICAgeUF4ZXNbMF0udGlja3MuYmVnaW5BdFplcm8gPSB0cnVlOwogICAgICAgIHlBeGVzWzBdLnRpY2tzLnN1Z2dlc3RlZE1pbiA9IE1hdGgubWluLmFwcGx5KE1hdGgsIF90b0NvbnN1bWFibGVBcnJheSh0aGlzLmluZGljYXRvck9iamVjdC5tZWFzdXJlbWVudC5maWx0ZXIoZnVuY3Rpb24gKGQpIHsKICAgICAgICAgIHJldHVybiAhTnVtYmVyLmlzTmFOKGQpOwogICAgICAgIH0pKSk7CiAgICAgICAgeUF4ZXNbMF0udGlja3Muc3VnZ2VzdGVkTWF4ID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMuaW5kaWNhdG9yT2JqZWN0Lm1lYXN1cmVtZW50LmZpbHRlcihmdW5jdGlvbiAoZCkgewogICAgICAgICAgcmV0dXJuICFOdW1iZXIuaXNOYU4oZCk7CiAgICAgICAgfSkpKTsKICAgICAgfQoKICAgICAgaWYgKFsnRTEyYiddLmluY2x1ZGVzKGluZGljYXRvckNvZGUpKSB7CiAgICAgICAgLy8gdXBkYXRlIHVzZWQgeWF4aXMgY2hhcnQgbWF4IHRvIGJlIG1heCB2YWx1ZQogICAgICAgIHlBeGVzWzBdLnRpY2tzLnN1Z2dlc3RlZE1heCA9IE1hdGgubWF4LmFwcGx5KE1hdGgsIF90b0NvbnN1bWFibGVBcnJheSh0aGlzLmluZGljYXRvck9iamVjdC5tZWFzdXJlbWVudC5maWx0ZXIoZnVuY3Rpb24gKGQpIHsKICAgICAgICAgIHJldHVybiAhTnVtYmVyLmlzTmFOKGQpOwogICAgICAgIH0pKSk7CiAgICAgIH0KCiAgICAgIGlmIChbJ0UxMmInLCAnRTFhJywgJ0UxJywgJ0UyJywgJ0UyX1MyJywgJ0UxYV9TMicsICdFMV9TMicsICdFMTNkJ10uaW5jbHVkZXMoaW5kaWNhdG9yQ29kZSkpIHsKICAgICAgICAvLyB1cGRhdGUgdXNlZCB5YXhpcyBjaGFydCBtaW4gdG8gYmUgbWluIHZhbHVlCiAgICAgICAgeUF4ZXNbMF0udGlja3Muc3VnZ2VzdGVkTWluID0gTWF0aC5taW4uYXBwbHkoTWF0aCwgX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMuaW5kaWNhdG9yT2JqZWN0Lm1lYXN1cmVtZW50LmZpbHRlcihmdW5jdGlvbiAoZCkgewogICAgICAgICAgcmV0dXJuICFOdW1iZXIuaXNOYU4oZCk7CiAgICAgICAgfSkpKTsKICAgICAgfQoKICAgICAgaWYgKFsnQ1YnLCAnT1cnXS5pbmNsdWRlcyhpbmRpY2F0b3JDb2RlKSkgewogICAgICAgIHlBeGVzWzBdLnRpY2tzLmJlZ2luQXRaZXJvID0gdHJ1ZTsKICAgICAgICB5QXhlc1swXS50aWNrcyA9IHsKICAgICAgICAgIGxpbmVIZWlnaHQ6IDEsCiAgICAgICAgICBzdWdnZXN0ZWRNaW46IE1hdGgubWluLmFwcGx5KE1hdGgsIF90b0NvbnN1bWFibGVBcnJheSh0aGlzLmluZGljYXRvck9iamVjdC5tZWFzdXJlbWVudC5maWx0ZXIoZnVuY3Rpb24gKGQpIHsKICAgICAgICAgICAgcmV0dXJuICFOdW1iZXIuaXNOYU4oZCk7CiAgICAgICAgICB9KSkpLAogICAgICAgICAgc3VnZ2VzdGVkTWF4OiBNYXRoLm1heC5hcHBseShNYXRoLCBfdG9Db25zdW1hYmxlQXJyYXkodGhpcy5pbmRpY2F0b3JPYmplY3QubWVhc3VyZW1lbnQuZmlsdGVyKGZ1bmN0aW9uIChkKSB7CiAgICAgICAgICAgIHJldHVybiAhTnVtYmVyLmlzTmFOKGQpOwogICAgICAgICAgfSkpKQogICAgICAgIH07CiAgICAgIH0KCiAgICAgIGlmIChbJ0UxMGExJywgJ0UxMGE1J10uaW5jbHVkZXMoaW5kaWNhdG9yQ29kZSkpIHsKICAgICAgICB5QXhlc1swXS50aWNrcy5iZWdpbkF0WmVybyA9IHRydWU7CiAgICAgICAgcGx1Z2lucyA9IHsKICAgICAgICAgIGRhdGFsYWJlbHM6IHsKICAgICAgICAgICAgbGFiZWxzOiB7CiAgICAgICAgICAgICAgdmFsdWU6IHsKICAgICAgICAgICAgICAgIGFuY2hvcjogJ2VuZCcsCiAgICAgICAgICAgICAgICBhbGlnbjogJ2VuZCcsCiAgICAgICAgICAgICAgICBvZmZzZXQ6IDEwLAogICAgICAgICAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbiBmb3JtYXR0ZXIodmFsdWUsIGNvbnRleHQpIHsKICAgICAgICAgICAgICAgICAgdmFyIGxhYmVsUmVzID0gJyc7CiAgICAgICAgICAgICAgICAgIHZhciBwZXJjZW50YWdlID0gY29udGV4dC5jaGFydC5kYXRhLmRhdGFzZXRzW2NvbnRleHQuZGF0YXNldEluZGV4XS5pbmRMYWJlbHNbY29udGV4dC5kYXRhSW5kZXhdOwoKICAgICAgICAgICAgICAgICAgaWYgKCFbJycsICcvJ10uaW5jbHVkZXMocGVyY2VudGFnZSkpIHsKICAgICAgICAgICAgICAgICAgICB2YXIgcGVyY1ZhbCA9IE51bWJlcigocGVyY2VudGFnZSAqIDEwMCkudG9QcmVjaXNpb24oNCkpOwoKICAgICAgICAgICAgICAgICAgICBpZiAocGVyY1ZhbCA+IDApIHsKICAgICAgICAgICAgICAgICAgICAgIGxhYmVsUmVzID0gIisiLmNvbmNhdChwZXJjVmFsLCAiJSIpOwogICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICBsYWJlbFJlcyA9ICIiLmNvbmNhdChwZXJjVmFsLCAiJSIpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsUmVzOwogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgIGNvbG9yOiBmdW5jdGlvbiBjb2xvcihjb250ZXh0KSB7CiAgICAgICAgICAgICAgICAgIHZhciBjb2xvciA9ICdyZWQnOwoKICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuY2hhcnQuZGF0YS5kYXRhc2V0c1tjb250ZXh0LmRhdGFzZXRJbmRleF0uaW5kTGFiZWxzW2NvbnRleHQuZGF0YUluZGV4XSA+IDApIHsKICAgICAgICAgICAgICAgICAgICBjb2xvciA9ICdncmVlbic7CiAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgIHJldHVybiBjb2xvcjsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgIHRpdGxlOiB7CiAgICAgICAgICAgICAgICBjb2xvcjogJ2JsYWNrJywKICAgICAgICAgICAgICAgIGFuY2hvcjogJ2VuZCcsCiAgICAgICAgICAgICAgICBhbGlnbjogJ2VuZCcsCiAgICAgICAgICAgICAgICBvZmZzZXQ6IC02LAogICAgICAgICAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbiBmb3JtYXR0ZXIodmFsdWUpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvRml4ZWQoMSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfTsKICAgICAgfQoKICAgICAgaWYgKFsnRTgnXS5pbmNsdWRlcyhpbmRpY2F0b3JDb2RlKSkgewogICAgICAgIHlBeGVzWzBdLnRpY2tzLnN1Z2dlc3RlZE1pbiA9IE1hdGgubWluLmFwcGx5KE1hdGgsIF90b0NvbnN1bWFibGVBcnJheSh0aGlzLmluZGljYXRvck9iamVjdC5tZWFzdXJlbWVudC5maWx0ZXIoZnVuY3Rpb24gKGQpIHsKICAgICAgICAgIHJldHVybiAhTnVtYmVyLmlzTmFOKGQpOwogICAgICAgIH0pKSk7CiAgICAgICAgeUF4ZXNbMF0udGlja3Muc3VnZ2VzdGVkTWF4ID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMuaW5kaWNhdG9yT2JqZWN0Lm1lYXN1cmVtZW50LmZpbHRlcihmdW5jdGlvbiAoZCkgewogICAgICAgICAgcmV0dXJuICFOdW1iZXIuaXNOYU4oZCk7CiAgICAgICAgfSkpKTsKICAgICAgfQoKICAgICAgaWYgKFsnRTknXS5pbmNsdWRlcyhpbmRpY2F0b3JDb2RlKSkgewogICAgICAgIHlBeGVzWzBdLnRpY2tzLnN1Z2dlc3RlZE1pbiA9IDA7CiAgICAgICAgeUF4ZXNbMF0udGlja3Muc3VnZ2VzdGVkTWF4ID0gTWF0aC5tYXguYXBwbHkoTWF0aCwgX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMuaW5kaWNhdG9yT2JqZWN0Lm1lYXN1cmVtZW50LmZpbHRlcihmdW5jdGlvbiAoZCkgewogICAgICAgICAgcmV0dXJuICFOdW1iZXIuaXNOYU4oZCk7CiAgICAgICAgfSkpKTsKICAgICAgfQoKICAgICAgaWYgKFsnRTEwYTYnLCAnRTEwYTcnXS5pbmNsdWRlcyhpbmRpY2F0b3JDb2RlKSkgewogICAgICAgIHlBeGVzWzBdLnRpY2tzLmJlZ2luQXRaZXJvID0gdHJ1ZTsKICAgICAgICBwbHVnaW5zID0gewogICAgICAgICAgZGF0YWxhYmVsczogewogICAgICAgICAgICBsYWJlbHM6IHsKICAgICAgICAgICAgICB0aXRsZTogewogICAgICAgICAgICAgICAgY29sb3I6IGZ1bmN0aW9uIGNvbG9yKGNvbnRleHQpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRleHQuZGF0YXNldC5iYWNrZ3JvdW5kQ29sb3I7CiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgZm9udDogewogICAgICAgICAgICAgICAgICBzaXplOiAxMAogICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgIGFuY2hvcjogJ2VuZCcsCiAgICAgICAgICAgICAgICBhbGlnbjogJ2VuZCcsCiAgICAgICAgICAgICAgICBvZmZzZXQ6IGZ1bmN0aW9uIG9mZnNldChjb250ZXh0KSB7CiAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LmNoYXJ0LmRhdGEuZGF0YXNldHMubGVuZ3RoID09PSAyKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuZGF0YXNldEluZGV4ID09PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc05hTihjb250ZXh0LmNoYXJ0LmRhdGEuZGF0YXNldHNbMV0uZGF0YVtjb250ZXh0LmRhdGFJbmRleF0ueSkgJiYgY29udGV4dC5jaGFydC5kYXRhLmRhdGFzZXRzWzBdLmRhdGFbY29udGV4dC5kYXRhSW5kZXhdLnkgPiBjb250ZXh0LmNoYXJ0LmRhdGEuZGF0YXNldHNbMV0uZGF0YVtjb250ZXh0LmRhdGFJbmRleF0ueSkgewogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDsKICAgICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTI4OwogICAgICAgICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4oY29udGV4dC5jaGFydC5kYXRhLmRhdGFzZXRzWzBdLmRhdGFbY29udGV4dC5kYXRhSW5kZXhdLnkpICYmIGNvbnRleHQuY2hhcnQuZGF0YS5kYXRhc2V0c1swXS5kYXRhW2NvbnRleHQuZGF0YUluZGV4XS55ID4gY29udGV4dC5jaGFydC5kYXRhLmRhdGFzZXRzWzFdLmRhdGFbY29udGV4dC5kYXRhSW5kZXhdLnkpIHsKICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAtMjg7CiAgICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDsKICAgICAgICAgICAgICAgICAgfQoKICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgZm9ybWF0dGVyOiBmdW5jdGlvbiBmb3JtYXR0ZXIodmFsdWUpIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuICIiLmNvbmNhdCh2YWx1ZS55LnRvRml4ZWQoMSksICIlIik7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfTsKICAgICAgfQoKICAgICAgaWYgKFsnTjInLCAnRTEyYycsICdFMTJkJ10uaW5jbHVkZXMoaW5kaWNhdG9yQ29kZSkpIHsKICAgICAgICB5QXhlc1swXS50aWNrcy5iZWdpbkF0WmVybyA9IHRydWU7CiAgICAgIH0KCiAgICAgIGlmIChbJ0UxMGEzJywgJ0UxMGE4J10uaW5jbHVkZXMoaW5kaWNhdG9yQ29kZSkpIHsKICAgICAgICB5QXhlc1swXS50aWNrcyA9IHsKICAgICAgICAgIHN1Z2dlc3RlZE1pbjogTnVtYmVyLk5hTiwKICAgICAgICAgIHN1Z2dlc3RlZE1heDogTnVtYmVyLk5hTiwKICAgICAgICAgIHBhZGRpbmc6IC0yMAogICAgICAgIH07CiAgICAgIH0KCiAgICAgIGlmIChbJ0UxMGMnLCAnRTEwYTInLCAnRTEwYTYnLCAnRTEwYTcnXS5pbmNsdWRlcyhpbmRpY2F0b3JDb2RlKSkgewogICAgICAgIHlBeGVzWzBdLnRpY2tzLnN1Z2dlc3RlZE1pbiArPSAxOwogICAgICAgIHlBeGVzWzBdLnRpY2tzLnN1Z2dlc3RlZE1heCAtPSAxOwogICAgICB9CgogICAgICBpZiAoWydOMyddLmluY2x1ZGVzKGluZGljYXRvckNvZGUpKSB7CiAgICAgICAgeUF4ZXNbMF0udHlwZSA9ICdteUxvZ1NjYWxlJzsKCiAgICAgICAgaWYgKHRoaXMuaW5kaWNhdG9yT2JqZWN0LmFvaUlEID09PSAnRVMxOScpIHsKICAgICAgICAgIHlBeGVzWzBdLm1pbiA9IDAuMDI7CiAgICAgICAgICB5QXhlc1swXS5tYXggPSAxOwogICAgICAgIH0KCiAgICAgICAgeUF4ZXNbMF0udGlja3MgPSB7CiAgICAgICAgICBjYWxsYmFjazogZnVuY3Rpb24gY2FsbGJhY2soKSB7CiAgICAgICAgICAgIHZhciBfQ2hhcnQkVGlja3MkZm9ybWF0dGU7CgogICAgICAgICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHsKICAgICAgICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldOwogICAgICAgICAgICB9CgogICAgICAgICAgICB2YXIgdmFsdWUgPSAoX0NoYXJ0JFRpY2tzJGZvcm1hdHRlID0gQ2hhcnQuVGlja3MuZm9ybWF0dGVycy5sb2dhcml0aG1pYykuY2FsbC5hcHBseShfQ2hhcnQkVGlja3MkZm9ybWF0dGUsIFtfdGhpczJdLmNvbmNhdChhcmdzKSk7CgogICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoKSB7CiAgICAgICAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSkudG9Mb2NhbGVTdHJpbmcoKTsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgcmV0dXJuIHZhbHVlOwogICAgICAgICAgfQogICAgICAgIH07CiAgICAgICAgbGVnZW5kLmxhYmVscy51c2VQb2ludFN0eWxlID0gdHJ1ZTsKICAgICAgICBsZWdlbmQubGFiZWxzLmJveFdpZHRoID0gNTsKCiAgICAgICAgbGVnZW5kLm9uQ2xpY2sgPSBmdW5jdGlvbiBvbkNsaWNrKGUsIGxlZ2VuZEl0ZW0pIHsKICAgICAgICAgIGlmIChsZWdlbmRJdGVtLnRleHQgPT09ICdTdGFuZGFyZCBkZXZpYXRpb24gKFNURCknKSB7CiAgICAgICAgICAgIHZhciBtYXN0ZXJJbmRleCA9IGxlZ2VuZEl0ZW0uZGF0YXNldEluZGV4OwogICAgICAgICAgICB2YXIgc2xhdmVJbmRleCA9IDM7CiAgICAgICAgICAgIHZhciBjaSA9IHRoaXMuY2hhcnQ7CiAgICAgICAgICAgIHZhciBtYXN0ZXJNZXRhID0gY2kuZ2V0RGF0YXNldE1ldGEobWFzdGVySW5kZXgpOwogICAgICAgICAgICB2YXIgbWV0YSA9IGNpLmdldERhdGFzZXRNZXRhKHNsYXZlSW5kZXgpOwoKICAgICAgICAgICAgaWYgKG1hc3Rlck1ldGEuaGlkZGVuID09PSBudWxsKSB7CiAgICAgICAgICAgICAgbWFzdGVyTWV0YS5oaWRkZW4gPSB0cnVlOwogICAgICAgICAgICAgIG1ldGEuaGlkZGVuID0gdHJ1ZTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBtYXN0ZXJNZXRhLmhpZGRlbiA9ICFtYXN0ZXJNZXRhLmhpZGRlbjsKICAgICAgICAgICAgICBtZXRhLmhpZGRlbiA9ICFtZXRhLmhpZGRlbjsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgY2kudXBkYXRlKCk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBDaGFydC5kZWZhdWx0cy5nbG9iYWwubGVnZW5kLm9uQ2xpY2suY2FsbCh0aGlzLCBlLCBsZWdlbmRJdGVtKTsKICAgICAgICAgIH0KICAgICAgICB9OwogICAgICB9CgogICAgICB2YXIgZGVmYXVsdFNldHRpbmdzID0gewogICAgICAgIHJlc3BvbnNpdmU6IHRydWUsCiAgICAgICAgbWFpbnRhaW5Bc3BlY3RSYXRpbzogZmFsc2UsCiAgICAgICAgcGx1Z2luczogcGx1Z2lucywKICAgICAgICBsZWdlbmQ6IGxlZ2VuZCwKICAgICAgICBzY2FsZXM6IHsKICAgICAgICAgIHhBeGVzOiB4QXhlcywKICAgICAgICAgIHlBeGVzOiB5QXhlcwogICAgICAgIH0sCiAgICAgICAgcGFuOiB7CiAgICAgICAgICBlbmFibGVkOiB0cnVlLAogICAgICAgICAgbW9kZTogJ3gnCiAgICAgICAgfSwKICAgICAgICB6b29tOiB7CiAgICAgICAgICBlbmFibGVkOiB0cnVlLAogICAgICAgICAgbW9kZTogJ3gnCiAgICAgICAgfSwKICAgICAgICB0b29sdGlwczogewogICAgICAgICAgY2FsbGJhY2tzOiB7CiAgICAgICAgICAgIGxhYmVsOiBmdW5jdGlvbiAoY29udGV4dCwgZGF0YSkgewogICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUKICAgICAgICAgICAgICB2YXIgbGFiZWwgPSBkYXRhLmRhdGFzZXRzW2NvbnRleHQuZGF0YXNldEluZGV4XS5sYWJlbCB8fCAnJzsKCiAgICAgICAgICAgICAgaWYgKGxhYmVsKSB7CiAgICAgICAgICAgICAgICBsYWJlbCArPSAnOiAnOwogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgbGFiZWwgKz0gdGhpcy5yb3VuZFZhbHVlSW5kKE51bWJlcihjb250ZXh0LnZhbHVlKSk7CiAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsOwogICAgICAgICAgICB9LmJpbmQodGhpcykKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH07CgogICAgICBpZiAoWydOMyddLmluY2x1ZGVzKGluZGljYXRvckNvZGUpKSB7CiAgICAgICAgZGVmYXVsdFNldHRpbmdzLnRvb2x0aXBzID0gewogICAgICAgICAgY2FsbGJhY2tzOiB7CiAgICAgICAgICAgIGxhYmVsOiBmdW5jdGlvbiBsYWJlbChjb250ZXh0KSB7CiAgICAgICAgICAgICAgdmFyIGRhdGFzZXRzID0gX3RoaXMyLmRhdGFjb2xsZWN0aW9uLmRhdGFzZXRzOwogICAgICAgICAgICAgIHZhciB2YWwgPSBkYXRhc2V0c1tjb250ZXh0LmRhdGFzZXRJbmRleF0uZGF0YVtjb250ZXh0LmluZGV4XTsKICAgICAgICAgICAgICByZXR1cm4gIlZhbHVlIChMb2cxMCk6ICIuY29uY2F0KE1hdGgubG9nMTAodmFsKS50b1ByZWNpc2lvbig0KSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICB9OwogICAgICB9CgogICAgICBpZiAoWydFMTBhMyddLmluY2x1ZGVzKGluZGljYXRvckNvZGUpKSB7CiAgICAgICAgZGVmYXVsdFNldHRpbmdzLmdlbyA9IHsKICAgICAgICAgIHJhZGl1c1NjYWxlOiB7CiAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsCiAgICAgICAgICAgIHNpemU6IFsxLCAyMF0KICAgICAgICAgIH0KICAgICAgICB9OwogICAgICAgIGRlZmF1bHRTZXR0aW5ncy5zY2FsZSA9IHsKICAgICAgICAgIHByb2plY3Rpb246ICdtZXJjYXRvcicKICAgICAgICB9OwogICAgICAgIGRlZmF1bHRTZXR0aW5ncy5wYW4ubW9kZSA9ICd4eSc7CiAgICAgICAgZGVmYXVsdFNldHRpbmdzLnpvb20ubW9kZSA9ICd4eSc7CiAgICAgICAgZGVmYXVsdFNldHRpbmdzLmxlZ2VuZC5kaXNwbGF5ID0gZmFsc2U7CiAgICAgICAgZGVmYXVsdFNldHRpbmdzLnRvb2x0aXBzID0gewogICAgICAgICAgY2FsbGJhY2tzOiB7CiAgICAgICAgICAgIGxhYmVsOiBmdW5jdGlvbiBsYWJlbChjb250ZXh0KSB7CiAgICAgICAgICAgICAgdmFyIGRhdGFzZXRzID0gX3RoaXMyLmRhdGFjb2xsZWN0aW9uLmRhdGFzZXRzOwogICAgICAgICAgICAgIHZhciBvYmogPSBkYXRhc2V0c1tjb250ZXh0LmRhdGFzZXRJbmRleF0uZGF0YVtjb250ZXh0LmluZGV4XTsKICAgICAgICAgICAgICByZXR1cm4gb2JqLm5hbWU7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGZvb3RlcjogZnVuY3Rpb24gZm9vdGVyKGNvbnRleHQpIHsKICAgICAgICAgICAgICB2YXIgZGF0YXNldHMgPSBfdGhpczIuZGF0YWNvbGxlY3Rpb24uZGF0YXNldHM7CiAgICAgICAgICAgICAgdmFyIG9iaiA9IGRhdGFzZXRzW2NvbnRleHRbMF0uZGF0YXNldEluZGV4XS5kYXRhW2NvbnRleHRbMF0uaW5kZXhdOwogICAgICAgICAgICAgIHZhciByZWZUID0gb2JqLnJlZmVyZW5jZVRpbWU7CiAgICAgICAgICAgICAgdmFyIHJlZlYgPSBOdW1iZXIob2JqLnJlZmVyZW5jZVZhbHVlKTsKICAgICAgICAgICAgICB2YXIgbGFiZWxPdXRwdXQgPSBbIiIuY29uY2F0KG9iai50aW1lLnRvSVNPRGF0ZSgpLCAiOiAgIikuY29uY2F0KG9iai52YWx1ZS50b1ByZWNpc2lvbig0KSksICIiLmNvbmNhdChyZWZULnRvSVNPRGF0ZSgpLCAiOiAgIikuY29uY2F0KHJlZlYudG9QcmVjaXNpb24oNCkpXTsKCiAgICAgICAgICAgICAgaWYgKHJlZlYgIT09IDApIHsKICAgICAgICAgICAgICAgIGxhYmVsT3V0cHV0LnB1c2goIiIuY29uY2F0KCgob2JqLnZhbHVlIC0gcmVmVikgLyByZWZWICogMTAwKS50b1ByZWNpc2lvbigyKSwgIiAlIikpOwogICAgICAgICAgICAgIH0KCiAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsT3V0cHV0OwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfTsKICAgICAgfQoKICAgICAgaWYgKFsnRTEwYTgnXS5pbmNsdWRlcyhpbmRpY2F0b3JDb2RlKSkgewogICAgICAgIGRlZmF1bHRTZXR0aW5ncy5nZW8gPSB7CiAgICAgICAgICByYWRpdXNTY2FsZTogewogICAgICAgICAgICBkaXNwbGF5OiB0cnVlLAogICAgICAgICAgICByYW5nZTogWzUsIDI1XSwKICAgICAgICAgICAgdGlja3M6IHsKICAgICAgICAgICAgICBtYXg6IDIwMDAwMDAKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH07CiAgICAgICAgZGVmYXVsdFNldHRpbmdzLnNjYWxlID0gewogICAgICAgICAgcHJvamVjdGlvbjogJ21lcmNhdG9yJywKICAgICAgICAgIG1heDogMjAKICAgICAgICB9OwogICAgICAgIGRlZmF1bHRTZXR0aW5ncy5wYW4ubW9kZSA9ICd4eSc7CiAgICAgICAgZGVmYXVsdFNldHRpbmdzLnpvb20ubW9kZSA9ICd4eSc7CiAgICAgICAgZGVmYXVsdFNldHRpbmdzLmxlZ2VuZC5kaXNwbGF5ID0gZmFsc2U7CiAgICAgICAgZGVmYXVsdFNldHRpbmdzLnRvb2x0aXBzID0gewogICAgICAgICAgY2FsbGJhY2tzOiB7CiAgICAgICAgICAgIGxhYmVsOiBmdW5jdGlvbiBsYWJlbChjb250ZXh0KSB7CiAgICAgICAgICAgICAgdmFyIGRhdGFzZXRzID0gX3RoaXMyLmRhdGFjb2xsZWN0aW9uLmRhdGFzZXRzOwogICAgICAgICAgICAgIHZhciBvYmogPSBkYXRhc2V0c1tjb250ZXh0LmRhdGFzZXRJbmRleF0uZGF0YVtjb250ZXh0LmluZGV4XTsKICAgICAgICAgICAgICByZXR1cm4gb2JqLm5hbWU7CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIGZvb3RlcjogZnVuY3Rpb24gZm9vdGVyKGNvbnRleHQpIHsKICAgICAgICAgICAgICB2YXIgZGF0YXNldHMgPSBfdGhpczIuZGF0YWNvbGxlY3Rpb24uZGF0YXNldHM7CiAgICAgICAgICAgICAgdmFyIG9iaiA9IGRhdGFzZXRzW2NvbnRleHRbMF0uZGF0YXNldEluZGV4XS5kYXRhW2NvbnRleHRbMF0uaW5kZXhdOwogICAgICAgICAgICAgIHZhciByZWZWID0gTnVtYmVyKG9iai5yZWZlcmVuY2VWYWx1ZSk7CiAgICAgICAgICAgICAgdmFyIGxhYmVsT3V0cHV0ID0gWyIiLmNvbmNhdChvYmoudGltZS50b0lTT0RhdGUoKSwgIjoiKSwgIiIuY29uY2F0KHJlZlYudG9QcmVjaXNpb24oNCksICIgJSBoYXJ2ZXN0ZWQiKSwgIiIuY29uY2F0KCgxMDAgLSByZWZWKS50b1ByZWNpc2lvbig0KSwgIiAlIG5vdCBoYXJ2ZXN0ZWQiKSwgIk1heC4gYXJlYTogIi5jb25jYXQob2JqLnZhbHVlLCAiIGhhIildOwogICAgICAgICAgICAgIHJldHVybiBsYWJlbE91dHB1dDsKICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIH07CiAgICAgIH0KCiAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGRlZmF1bHRTZXR0aW5ncyksIHt9LCB7CiAgICAgICAgYW5ub3RhdGlvbjogewogICAgICAgICAgYW5ub3RhdGlvbnM6IGFubm90YXRpb25zCiAgICAgICAgfQogICAgICB9KTsKICAgIH0KICB9Cn07"},{"version":3,"sources":["IndicatorData.vue"],"names":[],"mappings":"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","sourcesContent":["<template>\n  <div style=\"width: 100%; height: 100%;\"\n    v-if=\"!['E10a2', 'E10a3', 'E10a6', 'E10a7', 'E10a8', 'E10a9',\n      'E10c', 'N1', 'N3', 'N3b', 'E8',\n      'E13e', 'E13f', 'E13g', 'E13h', 'E13i', 'E13l', 'E13m',\n      'N1a', 'N1b', 'N1c', 'N1d', 'E12b', 'GG', 'GSA', 'CV', 'OW']\n      .includes(indicatorObject.indicator)\">\n      <bar-chart v-if='datacollection'\n        id=\"chart\"\n        class=\"fill-height\"\n        :width=\"null\"\n        :height=\"null\"\n        :chart-data='datacollection'\n        :options='chartOptions()'></bar-chart>\n  </div>\n  <div style=\"width: 100%; height: 100%;\"\n    v-else-if=\"['E10a3', 'E10a8'].includes(indicatorObject.indicator)\">\n      <map-chart\n        id=\"chart\"\n        class=\"fill-height\"\n        :width=\"null\"\n        :height=\"null\"\n        :chart-data='datacollection'\n        :options='chartOptions()'>\n      </map-chart>\n      <img v-if=\"indicatorObject.indicator=='E10a3'\"\n        :src=\"require('@/assets/E10a3_label.jpg')\" alt=\"color legend\"\n        style=\"position: absolute; width: 200px; z-index: 0;\n        top: 0px; right: 0px;\"/>\n      <img v-else\n        :src=\"require('@/assets/E10a8_label.jpg')\" alt=\"color legend\"\n        style=\"position: absolute; width: 150px; z-index: 0;\n        top: 0px; right: 0px;\"/>\n      <v-row\n        class=\"justify-center align-center timeSelection mr-6 ml-0\"\n        style=\"position: absolute; bottom: 0px; z-index: 1000;\n          width: auto; max-width: 100%;left:-45px;\"\n      >\n        <v-col cols=\"6\">\n          <v-select\n            outlined dense autofocus hide-details\n            :prepend-inner-icon=\"(arrayOfObjects && dataLayerTime) && (arrayOfObjects\n              .map((i) => i.value)\n              .indexOf(dataLayerTime) > 0\n                ? 'mdi-arrow-left-drop-circle'\n                : 'mdi-asterisk')\"\n            :append-icon=\"(arrayOfObjects && dataLayerTime) && (arrayOfObjects\n              .map((i) => i.value)\n              .indexOf(dataLayerTime) < arrayOfObjects.length - 1\n                ? 'mdi-arrow-right-drop-circle'\n                : 'mdi-asterisk')\"\n            menu-props=\"auto\"\n            :items=\"arrayOfObjects\"\n            item-value=\"value\"\n            item-text=\"name\"\n            v-model=\"dataLayerTime\"\n            @change=\"dataLayerTimeSelection\"\n            @click:prepend-inner=\"dataLayerReduce\"\n            @click:append=\"dataLayerIncrease\">\n          </v-select>\n        </v-col>\n      </v-row>\n  </div>\n  <div style=\"width: 100%; height: 100%;\" v-else>\n    <line-chart v-if='datacollection'\n      id=\"chart\"\n      class=\"fill-height\"\n      :width=\"null\"\n      :height=\"null\"\n      :chart-data='datacollection'\n      :options='chartOptions()'></line-chart>\n  </div>\n</template>\n\n<script>\nimport { DateTime } from 'luxon';\nimport {\n  mapState,\n} from 'vuex';\nimport BarChart from '@/components/BarChart.vue';\nimport LineChart from '@/components/LineChart.vue';\nimport MapChart from '@/components/MapChart.vue';\nimport NUTS from '@/assets/NUTS_RG_03M_2016_4326_ESL2-DEL3.json';\nimport lockdownTimes from '@/assets/lockdown_data.json';\nimport countries from '@/assets/countries.json';\n\nexport default {\n  props: [\n    'currentIndicator',\n  ],\n  components: {\n    BarChart,\n    LineChart,\n    MapChart,\n  },\n  data() {\n    return {\n      dataLayerTime: null,\n      dataLayerIndex: 0,\n    };\n  },\n  mounted() {\n    const d = this.indicatorObject.time[this.indicatorObject.time.length - 1];\n    this.dataLayerTime = d.toFormat('dd. MMM');\n  },\n  computed: {\n    ...mapState('config', ['appConfig', 'baseConfig']),\n    arrayOfObjects() {\n      const indicator = { ...this.indicatorObject };\n      const indicatorCode = indicator.indicator;\n      const selectionOptions = [];\n      if (['E10a3', 'E10a8'].includes(indicatorCode)) {\n        // Find all unique day/month available\n        const timeset = new Set(\n          indicator.time.map((d) => d.toFormat('dd. MMM')),\n        );\n        timeset.forEach((t) => {\n          selectionOptions.push({\n            value: t,\n            name: t,\n          });\n        });\n      }\n      return selectionOptions;\n    },\n    datacollection() {\n      const indicator = { ...this.indicatorObject };\n      const indicatorCode = indicator.indicator;\n      let dataCollection;\n      const refColors = [\n        '#22aa99', '#a37', '#47a', '#a67', '#283', '#bbb',\n        '#6ce', '#994499', '#aaaa11', '#6633cc', '#e67300',\n      ];\n      if (indicator) {\n        let labels = [];\n        const { measurement } = indicator;\n        const colors = [];\n        const datasets = [];\n        if (['E10a1', 'E10a5'].includes(indicatorCode)) {\n          const referenceValue = indicator.referenceValue.map(Number);\n          for (let i = 0; i < indicator.time.length; i += 1) {\n            if (!Number.isNaN(indicator.time[i].toMillis())) {\n              const d = indicator.time[i];\n              const formattedDate = d.toFormat('dd. MMM');\n              labels.push(formattedDate);\n            } else {\n              labels.push(i);\n            }\n          }\n          const labelref = '2019';\n          const labelmeas = '2020';\n          datasets.push({\n            indLabels: Array(indicator.indicatorValue.length).join('.').split('.'),\n            label: labelref,\n            data: referenceValue,\n            fill: false,\n            backgroundColor: 'grey',\n          });\n          datasets.push({\n            indLabels: indicator.indicatorValue,\n            label: labelmeas,\n            data: measurement,\n            fill: false,\n            backgroundColor: 'black',\n          });\n        } else if (['E10a9'].includes(indicatorCode)) {\n          const categories = [\n            'National Workers',\n            'Foreign Workers',\n            'Unknown',\n          ];\n          categories.forEach((key, idx) => {\n            const data = indicator.measurement.map((row, rowIdx) => ({\n              t: indicator.time[rowIdx],\n              y: row[idx],\n            }));\n            datasets.push({\n              label: key,\n              data,\n              fill: false,\n              borderColor: refColors[idx],\n              backgroundColor: refColors[idx],\n              cubicInterpolationMode: 'monotone',\n              borderWidth: 1,\n              pointRadius: 2,\n            });\n          });\n        } else if (['GG'].includes(indicatorCode)) {\n          const vals = indicator.Values;\n          const datasetsObj = {\n            grocery: [],\n            parks: [],\n            residential: [],\n            retail_recreation: [],\n            transit_stations: [],\n          };\n          for (let entry = 0; entry < vals.length; entry += 1) {\n            const t = DateTime.fromISO(vals[entry].date);\n            datasetsObj.grocery.push({ t, y: vals[entry].grocery });\n            datasetsObj.parks.push({ t, y: vals[entry].parks });\n            datasetsObj.residential.push({ t, y: vals[entry].residential });\n            datasetsObj.retail_recreation.push({ t, y: vals[entry].retail_recreation });\n            datasetsObj.transit_stations.push({ t, y: vals[entry].transit_stations });\n          }\n          Object.keys(datasetsObj).forEach((key, idx) => {\n            datasets.push({\n              label: key,\n              data: datasetsObj[key],\n              fill: false,\n              borderColor: refColors[idx],\n              backgroundColor: refColors[idx],\n              borderWidth: 1,\n              pointRadius: 2,\n              cubicInterpolationMode: 'monotone',\n            });\n          });\n        } else if (['GSA'].includes(indicatorCode)) {\n          const vals = Object.keys(indicator.values);\n          const datasetsObj = {};\n          for (let entry = 0; entry < vals.length; entry += 1) {\n            datasetsObj[vals[entry]] = [];\n            const currVals = indicator.values[vals[entry]].values;\n            for (let i = 0; i < currVals.length; i += 1) {\n              datasetsObj[vals[entry]].push({\n                t: DateTime.fromISO(currVals[i].timestamp),\n                y: Number(currVals[i].waiting_time),\n              });\n            }\n            // It seems some timstamps are mixed in order so let us sort by date\n            // to get nice line connections through the timeline\n            datasetsObj[vals[entry]].sort((a, b) => a.t.toMillis() - b.t.toMillis());\n          }\n          Object.keys(indicator.values).forEach((key, idx) => {\n            datasets.push({\n              label: key,\n              data: datasetsObj[key],\n              fill: false,\n              borderColor: refColors[idx],\n              backgroundColor: refColors[idx],\n              borderWidth: 1,\n              pointRadius: 2,\n              cubicInterpolationMode: 'monotone',\n            });\n          });\n        } else if (['CV'].includes(indicatorCode)) {\n          const vals = indicator.Values;\n          const datasetsObj = {\n            confirmed: [],\n          };\n          for (let entry = 0; entry < vals.length; entry += 1) {\n            const t = DateTime.fromISO(vals[entry].date);\n            datasetsObj.confirmed.push({ t, y: Number(vals[entry].confirmed) });\n          }\n          Object.keys(datasetsObj).forEach((key, idx) => {\n            datasets.push({\n              label: key,\n              data: datasetsObj[key],\n              fill: false,\n              borderColor: refColors[idx],\n              backgroundColor: refColors[idx],\n              borderWidth: 1,\n              pointRadius: 2,\n              cubicInterpolationMode: 'monotone',\n            });\n          });\n        } else if (['OW'].includes(indicatorCode)) {\n          const vals = indicator.Values;\n          const pI = [\n            'total_vaccinations', 'people_fully_vaccinated',\n            'daily_vaccinations',\n          ];\n          const datasetsObj = {};\n          for (let idx = 0; idx < pI.length; idx += 1) {\n            datasetsObj[pI[idx]] = [];\n          }\n          for (let entry = 0; entry < vals.length; entry += 1) {\n            const t = DateTime.fromISO(vals[entry].date);\n            for (let idx = 0; idx < pI.length; idx += 1) {\n              datasetsObj[pI[idx]].push({ t, y: vals[entry][pI[idx]] });\n            }\n          }\n          Object.keys(datasetsObj).forEach((key, idx) => {\n            datasets.push({\n              label: key,\n              data: datasetsObj[key],\n              fill: false,\n              borderColor: refColors[idx],\n              backgroundColor: refColors[idx],\n              borderWidth: 1,\n              pointRadius: 2,\n              cubicInterpolationMode: 'monotone',\n            });\n          });\n        } else if (['N3b'].includes(indicatorCode)) {\n          const sensors = Array.from(new Set(indicator.eoSensor)).sort();\n          for (let pp = 0; pp < sensors.length; pp += 1) {\n            const pKey = sensors[pp];\n            const data = indicator.time.map((date, i) => {\n              let output = null;\n              if (indicator.eoSensor[i] === pKey) {\n                output = { t: date, y: measurement[i] };\n              }\n              return output;\n            }).filter((d) => d !== null);\n            let colorUsed = refColors[pp];\n            if (this.indDefinition.sensorColorMap && this.indDefinition.sensorColorMap[pKey]) {\n              colorUsed = this.indDefinition.sensorColorMap[pKey];\n            }\n            datasets.push({\n              label: pKey,\n              data,\n              fill: false,\n              borderColor: colorUsed,\n              backgroundColor: colorUsed,\n              cubicInterpolationMode: 'monotone',\n            });\n          }\n        } else if (['N4c'].includes(indicatorCode)) {\n          const measData = indicator.measurement.map(Number);\n          measData.shift();\n          const refData = indicator.referenceValue.map(Number);\n          refData.shift();\n\n          labels = [\n            indicator.referenceTime[0].toISODate(),\n            indicator.time[0].toISODate(),\n            indicator.time[5].toISODate(),\n          ];\n\n          datasets.push({\n            label: 'metallic waste area',\n            data: [refData[0], measData[0], measData[5]],\n            backgroundColor: refColors[0],\n          });\n          datasets.push({\n            label: 'mixed waste area',\n            data: [refData[1], measData[1], measData[6]],\n            backgroundColor: refColors[1],\n          });\n          datasets.push({\n            label: 'plastic waste area',\n            data: [refData[2], measData[2], measData[7]],\n            backgroundColor: refColors[2],\n          });\n          datasets.push({\n            label: 'soil waste area',\n            data: [refData[3], measData[3], measData[8]],\n            backgroundColor: refColors[3],\n          });\n        } else if (['E10a2', 'E10a6', 'E10a7', 'E8', 'E13e', 'E13f', 'E13g', 'E13h', 'E13i', 'E13l', 'E13m'].includes(indicatorCode)) {\n          const uniqueRefs = [];\n          const uniqueMeas = [];\n          const referenceValue = indicator.referenceValue.map(Number);\n          indicator.time.forEach((date, i) => {\n            const meas = { t: date.set({ year: 2000 }), y: measurement[i] };\n            if (typeof uniqueRefs.find((item) => item.t.equals(meas.t)) === 'undefined') {\n              uniqueMeas.push(meas);\n            }\n          });\n          indicator.referenceTime.forEach((date, i) => {\n            if (!['', '/'].includes(indicator.referenceValue[i])) {\n              const ref = { t: date.set({ year: 2000 }), y: referenceValue[i] };\n              if (typeof uniqueRefs.find((item) => item.t.equals(ref.t)) === 'undefined') {\n                uniqueRefs.push(ref);\n              }\n            }\n          });\n          datasets.push({\n            label: '2020',\n            data: uniqueMeas,\n            fill: false,\n            borderColor: refColors[1],\n            backgroundColor: refColors[1],\n            borderWidth: 2,\n          });\n          if (uniqueRefs.length > 0) {\n            datasets.push({\n              label: '2019',\n              data: uniqueRefs,\n              fill: false,\n              borderColor: refColors[0],\n              backgroundColor: refColors[0],\n              borderWidth: 2,\n            });\n          }\n        } else if (['E13n', 'C1', 'C2', 'C3'].includes(indicatorCode)) {\n          // Group by indicator value\n          const types = {};\n          indicator.indicatorValue.forEach((ind, idx) => {\n            if (Object.keys(types).includes(ind)) {\n              types[ind].push({\n                t: DateTime.fromISO(indicator.time[idx]),\n                y: Number(indicator.measurement[idx]),\n              });\n            } else {\n              types[ind] = [{\n                t: DateTime.fromISO(indicator.time[idx]),\n                y: Number(indicator.measurement[idx]),\n              }];\n            }\n          });\n          Object.keys(types).forEach((key, i) => {\n            datasets.push({\n              label: key,\n              fill: false,\n              data: types[key],\n              backgroundColor: refColors[i],\n              borderColor: refColors[i],\n              borderWidth: 2,\n            });\n          });\n        } else if (['N2', 'E10c'].includes(indicatorCode)) {\n          /* Group data by year in month slices */\n          const data = indicator.time.map((date, i) => {\n            colors.push(this.getIndicatorColor(indicator.colorCode[i]));\n            return { t: date, y: measurement[i] };\n          });\n          const dataGroups = {};\n          const colorGroups = {};\n          for (let i = 0; i < data.length; i += 1) {\n            const currYear = data[i].t.year;\n            if (Object.prototype.hasOwnProperty.call(dataGroups, currYear)) {\n              dataGroups[currYear].push({\n                t: data[i].t.set({ year: 2000 }),\n                y: [data[i].y],\n              });\n              colorGroups[currYear].push(colors[i]);\n            } else {\n              dataGroups[currYear] = [{\n                t: data[i].t.set({ year: 2000 }),\n                y: [data[i].y],\n              }];\n              colorGroups[currYear] = [colors[i]];\n            }\n          }\n          const uniqueYears = Object.keys(dataGroups);\n          uniqueYears.sort();\n          const yLength = uniqueYears.length - 1;\n          uniqueYears.forEach((key, i) => {\n            datasets.push({\n              // fill with empty values\n              indLabels: Array(dataGroups[key].length).join('.').split('.'),\n              label: key,\n              fill: false,\n              data: dataGroups[key],\n              backgroundColor: refColors[yLength - i],\n              borderColor: refColors[yLength - i],\n              borderWidth: 2,\n            });\n          });\n        } else if (['N1'].includes(indicatorCode)) {\n          const stdDevMin = [];\n          const stdDevMax = [];\n          const min = [];\n          const max = [];\n          const median = [];\n          const data = [];\n          indicator.referenceValue.forEach((item, i) => {\n            const t = indicator.time[i];\n            data.push({ y: measurement[i], t });\n            if (!Number.isNaN(item) && !['NaN', '/'].includes(item)) {\n              const obj = JSON.parse(item);\n              // [median,std,max,min,percentage valid pixels]\n              median.push({ y: obj[0], t });\n              if (obj[1] !== null) {\n                stdDevMin.push({ y: measurement[i] - obj[1], t });\n                stdDevMax.push({ y: measurement[i] + obj[1], t });\n              }\n              max.push({ y: obj[2], t });\n              min.push({ y: obj[3], t });\n            } else {\n              median.push({ y: Number.NaN, t });\n              stdDevMin.push({ y: Number.NaN, t });\n              stdDevMax.push({ y: Number.NaN, t });\n              max.push({ y: Number.NaN, t });\n              min.push({ y: Number.NaN, t });\n            }\n          });\n          datasets.push({\n            label: indicator.yAxis,\n            data,\n            fill: false,\n            backgroundColor: refColors[0],\n            borderColor: refColors[0],\n            spanGaps: false,\n            borderWidth: 2,\n          });\n          // Check for empty array, if it is the case do not include data\n          if (typeof (median.find((a) => a.y !== null)) !== 'undefined') {\n            datasets.push({\n              label: 'Median',\n              data: median,\n              fill: false,\n              pointRadius: 0,\n              borderColor: 'black',\n              borderWidth: 1,\n              pointStyle: 'line',\n              spanGaps: false,\n            });\n          }\n          // Check for empty array, if it is the case do not include data\n          if (typeof (min.find((a) => a.y !== null)) !== 'undefined') {\n            datasets.push({\n              label: 'Min',\n              data: min,\n              fill: false,\n              pointRadius: 0,\n              backgroundColor: refColors[4],\n              borderColor: refColors[4],\n              borderWidth: 1,\n              pointStyle: 'line',\n              spanGaps: false,\n            });\n          }\n          // Check for empty array, if it is the case do not include data\n          if (typeof (max.find((a) => a.y !== null)) !== 'undefined') {\n            datasets.push({\n              label: 'Max',\n              data: max,\n              fill: false,\n              pointRadius: 0,\n              backgroundColor: refColors[1],\n              borderColor: refColors[1],\n              borderWidth: 1,\n              pointStyle: 'line',\n              spanGaps: false,\n            });\n          }\n          // Check for empty array, if it is the case do not include data\n          if (typeof (stdDevMax.find((a) => a.y !== null)) !== 'undefined') {\n            datasets.push({\n              label: 'Standard deviation (STD)',\n              data: stdDevMax,\n              fill: '+1',\n              pointRadius: 0,\n              spanGaps: false,\n              backgroundColor: 'rgba(0,0,0,0.1)',\n              borderColor: 'rgba(0,0,0,0.0)',\n              pointStyle: 'rect',\n            });\n          }\n          // Check for empty array, if it is the case do not include data\n          if (typeof (stdDevMin.find((a) => a.y !== null)) !== 'undefined') {\n            datasets.push({\n              label: 'hide_',\n              data: stdDevMin,\n              fill: '-1',\n              pointRadius: 0,\n              spanGaps: false,\n              backgroundColor: 'rgba(0,0,0,0.0)',\n              borderColor: 'rgba(0,0,0,0.0)',\n              pointStyle: 'rect',\n            });\n          }\n        } else if (['N3'].includes(indicatorCode)) {\n          let referenceValue = [];\n          const stdDev = [];\n          indicator.referenceValue.forEach((item) => {\n            if (!Number.isNaN(item) && !['NaN', '[NaN NaN]', '/'].includes(item)) {\n              const obj = JSON.parse(item.replace(/,/g, '.').replace(' ', ','));\n              if (obj[0] !== -999 && obj[1] !== -999) {\n                referenceValue.push(obj[0]);\n                stdDev.push(obj[1]);\n              } else {\n                referenceValue.push(Number.NaN);\n                stdDev.push(Number.NaN);\n              }\n            } else {\n              referenceValue.push(Number.NaN);\n              stdDev.push(Number.NaN);\n            }\n          });\n\n          const stdDevMax = stdDev.map((dev, i) => (\n            Number.isNaN(referenceValue[i])\n              ? Number.NaN\n              : (10 ** (referenceValue[i] + dev))\n          ));\n          const stdDevMin = stdDev.map((dev, i) => (\n            Number.isNaN(referenceValue[i])\n              ? Number.NaN\n              : (10 ** (referenceValue[i] - dev))\n          ));\n\n          referenceValue = referenceValue.map((val) => (\n            Number.isNaN(val) ? Number.NaN : (10 ** val)\n          ));\n\n          for (let i = 0; i < indicator.time.length; i += 1) {\n            if (!Number.isNaN(indicator.time[i].toMillis())) {\n              labels.push(indicator.time[i].toISODate());\n            } else {\n              labels.push(i);\n            }\n            let colorCode = '';\n            if (Object.prototype.hasOwnProperty.call(indicator, 'colorCode')) {\n              colorCode = indicator.colorCode[i];\n            }\n            colors.push(this.getIndicatorColor(colorCode));\n          }\n\n          datasets.push({\n            label: 'Weekly climatology of chlorophyll conc. (CHL_clim) 2017-2019',\n            data: referenceValue,\n            fill: false,\n            pointRadius: 0,\n            borderColor: 'black',\n            pointStyle: 'line',\n            spanGaps: false,\n          });\n          datasets.push({\n            label: 'Standard deviation (STD)',\n            data: stdDevMax,\n            fill: '+1',\n            pointRadius: 0,\n            spanGaps: false,\n            backgroundColor: 'rgba(0,0,0,0.1)',\n            borderColor: 'rgba(0,0,0,0.0)',\n            pointStyle: 'rect',\n          });\n          datasets.push({\n            label: 'hide_',\n            data: stdDevMin,\n            fill: '-1',\n            pointRadius: 0,\n            spanGaps: false,\n            backgroundColor: 'rgba(0,0,0,0.0)',\n            borderColor: 'rgba(0,0,0,0.0)',\n            pointStyle: 'rect',\n          });\n\n          // Find unique indicator values\n          const indicatorValues = {};\n          indicator.indicatorValue.map((val, i) => {\n            let key = val.toLowerCase();\n            key = key.charAt(0).toUpperCase() + key.slice(1);\n            if (!['', '/'].includes(key) && typeof indicatorValues[key] === 'undefined') {\n              indicatorValues[key] = this.getIndicatorColor(\n                indicator.colorCode[i],\n              );\n            }\n            return null;\n          });\n\n          Object.entries(indicatorValues).forEach(([key, value]) => {\n            const currMeas = measurement.map((row, i) => {\n              let val = row;\n              if (indicator.indicatorValue[i] !== key.toUpperCase()) {\n                val = NaN;\n              }\n              return val;\n            });\n            datasets.push({\n              label: key,\n              data: currMeas.map((val) => (\n                Number.isNaN(val) ? Number.NaN : (10 ** val)\n              )),\n              backgroundColor: value,\n              borderColor: value,\n              fill: false,\n              showLine: false,\n              spanGaps: false,\n            });\n          });\n        } else if (['N1a', 'N1b', 'N1c', 'N1d', 'E12b'].includes(indicatorCode)) {\n          const maxRef = [];\n          const minRef = [];\n          const mean7dRef = [];\n          const mean7d2020 = [];\n          indicator.referenceValue.forEach((item, i) => {\n            const t = indicator.time[i];\n            if (!['', '/'].includes(item)) {\n              const obj = item.replace(/[[\\] ]/g, '').split(',')\n                .map((str) => (str === '' ? Number.NaN : Number(str)));\n              maxRef.push({ y: obj[0], t });\n              minRef.push({ y: obj[1], t });\n              mean7dRef.push({ y: obj[2], t });\n              mean7d2020.push({ y: obj[3], t });\n            } else {\n              maxRef.push({ y: Number.NaN, t });\n              minRef.push({ y: Number.NaN, t });\n              mean7dRef.push({ y: Number.NaN, t });\n              mean7d2020.push({ y: Number.NaN, t });\n            }\n          });\n\n          datasets.push({\n            label: 'Value',\n            data: measurement.map((meas, i) => ({ y: meas, t: indicator.time[i] })),\n            backgroundColor: 'rgba(255,255,255,0.0)',\n            borderColor: 'red',\n            spanGaps: false,\n            pointRadius: 0,\n            borderWidth: 1.5,\n          });\n          datasets.push({\n            label: '7-day mean',\n            data: mean7d2020,\n            backgroundColor: 'rgba(255,255,255,0.0)',\n            pointRadius: 0,\n            borderColor: 'red',\n            spanGaps: false,\n            borderDash: [6, 3],\n            borderWidth: 2,\n          });\n          datasets.push({\n            label: '2017-2019 7d mean',\n            data: mean7dRef,\n            backgroundColor: 'rgba(255,255,255,0.0)',\n            pointRadius: 0,\n            borderColor: 'grey',\n            spanGaps: false,\n            borderDash: [6, 3],\n            borderWidth: 2,\n          });\n          datasets.push({\n            label: '2017-2019 range',\n            data: maxRef,\n            fill: 4,\n            pointRadius: 0,\n            spanGaps: false,\n            backgroundColor: 'rgba(0,0,0,0.2)',\n            borderColor: 'rgba(0,0,0,0.0)',\n            pointStyle: 'rect',\n          });\n          datasets.push({\n            label: 'hide_',\n            data: minRef,\n            fill: 3,\n            pointRadius: 0,\n            spanGaps: false,\n            backgroundColor: 'rgba(0,0,0,0.0)',\n            borderColor: 'rgba(0,0,0,0.0)',\n            pointStyle: 'rect',\n          });\n\n          // Find unique indicator values\n          const indicatorValues = {};\n          indicator.indicatorValue.map((val, i) => {\n            let key = val.toLowerCase();\n            key = key.charAt(0).toUpperCase() + key.slice(1);\n            if (!['', '/'].includes(key) && typeof indicatorValues[key] === 'undefined') {\n              indicatorValues[key] = this.getIndicatorColor(\n                indicator.colorCode[i],\n              );\n            }\n            return null;\n          });\n\n          Object.entries(indicatorValues).forEach(([key, value]) => {\n            datasets.push({\n              label: key,\n              data: [],\n              backgroundColor: value,\n              borderColor: value,\n            });\n          });\n        } else if (['E10a3', 'E10a8'].includes(indicatorCode)) {\n          const nutsFeatures = NUTS.features;\n          const outline = [];\n          const currIDs = [];\n          let features = measurement.map((meas, i) => {\n            // Find correct NUTS ID Shape\n            const geom = nutsFeatures.find((f) => (\n              f.properties.NUTS_ID === indicator.siteName[i]));\n            let output;\n            if (geom) {\n              if (currIDs.indexOf(indicator.siteName[i]) === -1) {\n                currIDs.push(indicator.siteName[i]);\n                outline.push({\n                  type: 'Feature',\n                  properties: {},\n                  geometry: geom.geometry,\n                });\n              }\n              const { coordinates } = geom.geometry;\n              const lons = (geom.geometry.type === 'Polygon') ? coordinates.flat(1).map((tuple) => tuple[0]) : coordinates.flat(2).map((tuple) => tuple[0]);\n              const lats = (geom.geometry.type === 'Polygon') ? coordinates.flat(1).map((tuple) => tuple[1]) : coordinates.flat(2).map((tuple) => tuple[1]);\n              const minLat = Math.min(...lats);\n              const minLon = Math.min(...lons);\n              const centerPoint = {\n                lat: minLat + (Math.max(...lats) - minLat) / 2,\n                lon: minLon + (Math.max(...lons) - minLon) / 2,\n              };\n              output = {\n                type: 'Feature',\n                properties: {},\n                geometry: geom.geometry,\n                description: 'description',\n                latitude: centerPoint.lat,\n                longitude: centerPoint.lon,\n                name: geom.properties.NUTS_NAME,\n                time: indicator.time[i],\n                value: Number(meas),\n                referenceTime: indicator.referenceTime[i],\n                referenceValue: indicator.referenceValue[i],\n                color: indicator.colorCode[i],\n              };\n              if (indicatorCode === 'E10a8') {\n                // Swap value to have reference value\n                output.value = Number(indicator.referenceValue[i]);\n                output.referenceValue = Number(meas);\n              }\n            }\n            return output;\n          });\n\n          // Filter by undefined and time\n          features = features.filter((d) => (\n            typeof d !== 'undefined'));\n\n          const filteredFeatures = features.filter((d) => {\n            let include = false;\n            if (d.time instanceof DateTime) {\n              include = d.time.toFormat('dd. MMM') === this.dataLayerTime\n                && !Number.isNaN(d.value);\n            }\n            return include;\n          });\n\n          labels = features.map((d) => d.name);\n          datasets.push({\n            outline,\n            outlineBackgroundColor: null,\n            outlineBorderColor: 'black',\n            outlineBorderWidth: 1,\n            showOutline: true,\n            backgroundColor: filteredFeatures.map((d) => d.color),\n            borderColor: filteredFeatures.map((d) => d.color),\n            borderWidth: 3,\n            data: filteredFeatures,\n            clipMap: 'items',\n          });\n        } else {\n          const data = indicator.time.map((date, i) => {\n            colors.push(this.getIndicatorColor(indicator.colorCode[i]));\n            return { t: date, y: measurement[i] };\n          });\n          datasets.push({\n            data,\n            label: indicator.yAxis,\n            backgroundColor: colors,\n            borderColor: colors,\n          });\n        }\n        dataCollection = {\n          labels,\n          datasets,\n        };\n      }\n      return dataCollection;\n    },\n    indicatorObject() {\n      return this.currentIndicator\n        || this.$store.state.indicators.customAreaIndicator\n        || this.$store.state.indicators.selectedIndicator;\n    },\n    indDefinition() {\n      return this.baseConfig.indicatorsDefinition[this.indicatorObject.indicator];\n    },\n  },\n  methods: {\n    dataLayerTimeSelection(payload) {\n      this.dataLayerTime = payload;\n      const newIndex = this.arrayOfObjects\n        .map((i) => i.value)\n        .indexOf(this.dataLayerTime);\n      this.dataLayerIndex = newIndex;\n    },\n    dataLayerReduce() {\n      const currentIndex = this.arrayOfObjects\n        .map((i) => i.value)\n        .indexOf(this.dataLayerTime);\n      this.dataLayerIndex = currentIndex - 1;\n      this.dataLayerTimeSelection(this.arrayOfObjects[currentIndex - 1].value);\n    },\n    dataLayerIncrease() {\n      const currentIndex = this.arrayOfObjects\n        .map((i) => i.value)\n        .indexOf(this.dataLayerTime);\n      this.dataLayerIndex = currentIndex + 1;\n      this.dataLayerTimeSelection(this.arrayOfObjects[currentIndex + 1].value);\n    },\n    formatNumRef(num, maxDecimals = 3) {\n      return Number.parseFloat(num.toFixed(maxDecimals));\n    },\n    roundValueInd(val) {\n      if (this.indDefinition.maxDecimals === -1) {\n        return val;\n      }\n      if (Number.isInteger(this.indDefinition.maxDecimals)) {\n        return this.formatNumRef(val, this.indDefinition.maxDecimals);\n      }\n      // use default\n      return this.formatNumRef(val, 2);\n    },\n    getMinMaxDate(timeData) {\n      let timeMin = Math.min.apply(null, timeData.map((d) => d.toMillis()));\n      let timeMax = Math.max.apply(null, timeData.map((d) => d.toMillis()));\n      const buffer = (timeMax - timeMin) / timeData.length;\n      timeMin -= buffer;\n      timeMax += buffer;\n      return [timeMin, timeMax];\n    },\n    chartOptions() {\n      const indicatorCode = this.indicatorObject.indicator;\n      const reference = Number.parseFloat(this.indicatorObject.referenceValue);\n      let timeMinMax = this.getMinMaxDate(this.indicatorObject.time);\n      const annotations = [];\n      let low = 0;\n      let high = 0;\n      const defaultAnnotationSettings = {\n        type: 'line',\n        mode: 'horizontal',\n        scaleID: 'y-axis-0',\n        borderColor: 'rgba(0, 0, 255, 0.5)',\n        borderWidth: 2,\n        borderDash: [2, 3],\n        scales: {\n          xAxes: [{\n            type: 'time',\n            time: {\n              unit: 'month',\n            },\n          }],\n        },\n        label: {\n          enabled: true,\n          fontStyle: 'normal',\n          paddingX: 2,\n          paddingY: 2,\n          backgroundColor: 'rgba(255, 255, 255, 0.7)',\n          fontColor: 'rgba(0, 0, 0, 0.8)',\n        },\n      };\n      if (!Number.isNaN(reference)\n        && !['E10a1', 'E10a2', 'E10a5', 'E10a6', 'E10a7', 'E10a9', 'N4c', 'E8', 'E13e', 'E13f', 'E13g', 'E13h', 'E13i', 'E13l', 'E13m', 'E12c', 'E12d']\n          .includes(indicatorCode)) {\n        annotations.push({\n          ...defaultAnnotationSettings,\n          label: {\n            ...defaultAnnotationSettings.label,\n            content: `reference: ${this.formatNumRef(reference)}`,\n          },\n          value: reference,\n        });\n      }\n      if (['E4'].includes(indicatorCode)) {\n        low = 0.2 * reference;\n        annotations.push({\n          ...defaultAnnotationSettings,\n          borderColor: 'rgba(50, 252, 0, 0.5)',\n          value: low,\n          label: {\n            ...defaultAnnotationSettings.label,\n            content: `on/off: ${this.formatNumRef(low)}`,\n          },\n        });\n      } else if (['E11', 'E1a', 'E1', 'E2', 'E2_S2', 'E1a_S2', 'E1_S2'].includes(indicatorCode)) {\n        if (indicatorCode === 'E11') {\n          low = 0.3 * reference;\n          high = 0.7 * reference;\n        } else if (['E1a', 'E1', 'E2', 'E2_S2', 'E1a_S2', 'E1_S2'].includes(indicatorCode)) {\n          low = 0.7 * reference;\n          high = 1.3 * reference;\n        }\n        annotations.push({\n          ...defaultAnnotationSettings,\n          value: low,\n          label: {\n            ...defaultAnnotationSettings.label,\n            content: `low: ${this.formatNumRef(low)}`,\n          },\n        });\n        annotations.push({\n          ...defaultAnnotationSettings,\n          value: high,\n          label: {\n            ...defaultAnnotationSettings.label,\n            content: `high: ${this.formatNumRef(high)}`,\n          },\n        });\n      }\n\n      // Introduce background area annotations for lockdown times, does not\n      // work for all chart types, so we make sure it is not any of those charts\n      if (!['E10a3', 'E10a8', 'N2', 'E12c', 'E12d', 'GSA'].includes(indicatorCode)) {\n        // Find country based on alpha-3 code\n        const currCountry = countries.features.find(\n          (cntr) => cntr.properties.alpha2 === this.indicatorObject.country,\n        );\n        if (typeof currCountry !== 'undefined'\n          && Object.prototype.hasOwnProperty.call(lockdownTimes, currCountry.id)) {\n          const lckTs = lockdownTimes[currCountry.id]['C7_Restrictions on internal movement'];\n          for (let i = 0; i < lckTs.length; i++) {\n            let areaColor = 'rgba(0, 0, 0, 0.0)';\n            if (lckTs[i].value === 1) {\n              areaColor = 'rgba(204, 143, 143, 0.24)';\n            } else if (lckTs[i].value === 2) {\n              areaColor = 'rgba(207, 109, 109, 0.54)';\n            }\n            // We also have special date handling for some chart types as we\n            // simulate year agnostic rendering, so we convert all dates to\n            // one year\n            let start = DateTime.fromISO(lckTs[i].start);\n            let end = DateTime.fromISO(lckTs[i].end);\n            if (['E10a2', 'E10a6', 'E10a7', 'E10c', 'E8', 'E13e', 'E13f', 'E13g', 'E13h', 'E13i', 'E13l', 'E13m'].includes(indicatorCode)) {\n              start = start.set({ year: 2000 });\n              end = end.set({ year: 2000 });\n            }\n            if (lckTs[i].value !== 0) {\n              annotations.push({\n                drawTime: 'beforeDatasetsDraw',\n                type: 'box',\n                xScaleID: 'x-axis-0',\n                xMin: start.toISODate(),\n                xMax: end.toISODate(),\n                borderColor: areaColor,\n                borderWidth: 0,\n                backgroundColor: areaColor,\n              });\n            }\n          }\n        }\n      }\n\n      let xAxes = {};\n      if (!['E10a1', 'E10a2', 'E10a3', 'E10a5', 'E10a6', 'E10a7', 'E10a8', 'E10c', 'E12c', 'E12d', 'N2'].includes(indicatorCode)) {\n        xAxes = [{\n          type: 'time',\n          time: {\n            unit: 'week',\n          },\n          ticks: {\n            min: timeMinMax[0],\n            max: timeMinMax[1],\n          },\n          barThickness: 'flex',\n        }];\n        if (!['N3', 'N3b'].includes(indicatorCode)) {\n          xAxes[0].distribution = 'series';\n        }\n      }\n\n      if (['E10a2', 'E10a6', 'E10a7', 'E10c', 'E8', 'E13e', 'E13f', 'E13g', 'E13h', 'E13i', 'E13l', 'E13m'].includes(indicatorCode)) {\n        /* Recalculate to get min max months in data converted to one year */\n        timeMinMax = this.getMinMaxDate(\n          this.indicatorObject.time.map((date) => (\n            date.set({ year: 2000 })\n          )),\n        );\n        /* Check also for reference time */\n        const refTimeMinMax = this.getMinMaxDate(\n          this.indicatorObject.referenceTime.map((date) => (\n            date.set({ year: 2000 })\n          )),\n        );\n        xAxes = [{\n          type: 'time',\n          time: {\n            unit: 'month',\n            displayFormats: {\n              month: 'MMM',\n            },\n            tooltipFormat: 'dd. MMM',\n          },\n          ticks: {\n            min: (timeMinMax[0] < refTimeMinMax[0]) ? timeMinMax[0] : refTimeMinMax[0],\n            max: (timeMinMax[1] > refTimeMinMax[1]) ? timeMinMax[1] : refTimeMinMax[1],\n          },\n        }];\n      }\n\n      if (['N2'].includes(indicatorCode)) {\n        timeMinMax = this.getMinMaxDate(\n          this.indicatorObject.time.map((date) => (\n            date.set({ year: 2000 })\n          )),\n        );\n        xAxes = [{\n          type: 'time',\n          time: {\n            unit: 'month',\n            displayFormats: {\n              month: 'MMM',\n            },\n            tooltipFormat: 'dd. MMM',\n          },\n          distribution: 'series',\n          ticks: {\n            min: timeMinMax[0],\n            max: timeMinMax[1],\n          },\n        }];\n      }\n\n      if (['E12c', 'E12d'].includes(indicatorCode)) {\n        xAxes = [{\n          type: 'time',\n          time: {\n            unit: 'year',\n            displayFormats: {\n              year: 'yyyy',\n            },\n            tooltipFormat: 'yyyy-MM-dd - yyyy-06-30',\n          },\n          distribution: 'series',\n          ticks: {\n            min: timeMinMax[0],\n            max: timeMinMax[1],\n          },\n        }];\n      }\n\n      if (['E13d', 'E13n', 'C1', 'C2', 'C3'].includes(indicatorCode)) {\n        xAxes = [{\n          type: 'time',\n          time: {\n            unit: 'month',\n            displayFormats: {\n              month: 'MMM yy',\n            },\n            tooltipFormat: 'MMM yyyy',\n          },\n          distribution: 'series',\n          ticks: {\n            min: timeMinMax[0],\n            max: timeMinMax[1],\n          },\n        }];\n      }\n\n\n      let plugins = {\n        datalabels: {\n          display: false,\n        },\n      };\n\n      const yAxes = [{\n        scaleLabel: {\n          display: true,\n          labelString: this.indicatorObject.yAxis,\n          padding: 2,\n        },\n        ticks: {\n          lineHeight: 1,\n          suggestedMin: Math.min(\n            ...this.indicatorObject.measurement\n              .filter((d) => !Number.isNaN(d)),\n          ) - 1,\n          suggestedMax: Math.max(\n            ...this.indicatorObject.measurement\n              .filter((d) => !Number.isNaN(d)),\n          ) + 1,\n        },\n      }];\n\n      // This indicator has an array of values so we need to calculate min/max\n      // different\n      if (['E10a9'].includes(indicatorCode)) {\n        const measFlat = this.indicatorObject.measurement.flat();\n        yAxes[0].ticks.suggestedMin = Math.min(...measFlat);\n        yAxes[0].ticks.suggestedMax = Math.max(...measFlat);\n      }\n\n      const legend = {\n        labels: {\n          generateLabels: (chart) => {\n            const { datasets } = chart.data;\n            const { labels } = chart.legend.options;\n            const { usePointStyle } = labels;\n            const overrideStyle = labels.pointStyle;\n            let labelSet = chart._getSortedDatasetMetas();\n            labelSet = labelSet.filter((meta) => {\n              let includeLabel = false;\n              if (Object.prototype.hasOwnProperty.call(datasets[meta.index], 'label')) {\n                includeLabel = !datasets[meta.index].label.startsWith('hide_');\n              }\n              return includeLabel;\n            });\n            const labelObjects = labelSet.map((meta) => {\n              const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\n              const borderWidth = 2;\n              let hidden = false;\n              if (meta.hidden === true) {\n                hidden = true;\n              }\n              return {\n                text: datasets[meta.index].label,\n                fillStyle: style.backgroundColor,\n                hidden,\n                lineCap: style.borderCapStyle,\n                lineDash: style.borderDash,\n                lineDashOffset: style.borderDashOffset,\n                lineJoin: style.borderJoinStyle,\n                lineWidth: borderWidth,\n                strokeStyle: style.borderColor,\n                pointStyle: overrideStyle || style.pointStyle,\n                rotation: style.rotation,\n                // Below is extra data used for toggling the datasets\n                datasetIndex: meta.index,\n              };\n            }, this);\n            // Now we add our default 2 lockdown labels but we exclude indicators\n            // where it is not applicable\n            if (!['E10a1', 'E10a5', 'E10a8', 'N2', 'N4c', 'E12c', 'E12d', 'GSA', 'N1']\n              .includes(this.indicatorObject.indicator)) {\n              labelObjects.push({\n                text: 'Low Restrictions',\n                fillStyle: 'rgba(204, 143, 143, 0.24)',\n                hidden: false,\n                lineWidth: 0,\n                datasetIndex: -1,\n              });\n              labelObjects.push({\n                text: 'High Restrictions',\n                fillStyle: 'rgba(207, 109, 109, 0.54)',\n                hidden: false,\n                lineWidth: 0,\n                datasetIndex: -1,\n              });\n            }\n            return labelObjects;\n          },\n        },\n      };\n\n      if (['N4c'].includes(indicatorCode)) {\n        xAxes = [{\n          stacked: true,\n        }];\n        yAxes[0].stacked = true;\n        yAxes[0].ticks.beginAtZero = true;\n        yAxes[0].ticks.suggestedMin = Math.min(\n          ...this.indicatorObject.measurement\n            .filter((d) => !Number.isNaN(d)),\n        );\n        yAxes[0].ticks.suggestedMax = Math.max(\n          ...this.indicatorObject.measurement\n            .filter((d) => !Number.isNaN(d)),\n        );\n      }\n\n      if (['E12b'].includes(indicatorCode)) {\n        // update used yaxis chart max to be max value\n        yAxes[0].ticks.suggestedMax = Math.max(\n          ...this.indicatorObject.measurement\n            .filter((d) => !Number.isNaN(d)),\n        );\n      }\n\n      if (['E12b', 'E1a', 'E1', 'E2', 'E2_S2', 'E1a_S2', 'E1_S2', 'E13d'].includes(indicatorCode)) {\n      // update used yaxis chart min to be min value\n        yAxes[0].ticks.suggestedMin = Math.min(\n          ...this.indicatorObject.measurement\n            .filter((d) => !Number.isNaN(d)),\n        );\n      }\n      if (['CV', 'OW'].includes(indicatorCode)) {\n        yAxes[0].ticks.beginAtZero = true;\n        yAxes[0].ticks = {\n          lineHeight: 1,\n          suggestedMin: Math.min(\n            ...this.indicatorObject.measurement\n              .filter((d) => !Number.isNaN(d)),\n          ),\n          suggestedMax: Math.max(\n            ...this.indicatorObject.measurement\n              .filter((d) => !Number.isNaN(d)),\n          ),\n        };\n      }\n\n      if (['E10a1', 'E10a5'].includes(indicatorCode)) {\n        yAxes[0].ticks.beginAtZero = true;\n        plugins = {\n          datalabels: {\n            labels: {\n              value: {\n                anchor: 'end',\n                align: 'end',\n                offset: 10,\n                formatter: (value, context) => {\n                  let labelRes = '';\n                  const percentage = context.chart.data.datasets[context.datasetIndex]\n                    .indLabels[context.dataIndex];\n                  if (!['', '/'].includes(percentage)) {\n                    const percVal = Number((percentage * 100).toPrecision(4));\n                    if (percVal > 0) {\n                      labelRes = `+${percVal}%`;\n                    } else {\n                      labelRes = `${percVal}%`;\n                    }\n                  }\n                  return labelRes;\n                },\n                color: (context) => {\n                  let color = 'red';\n                  if (context.chart.data.datasets[context.datasetIndex]\n                    .indLabels[context.dataIndex] > 0) {\n                    color = 'green';\n                  }\n                  return color;\n                },\n              },\n              title: {\n                color: 'black',\n                anchor: 'end',\n                align: 'end',\n                offset: -6,\n                formatter: (value) => value.toFixed(1),\n              },\n            },\n          },\n        };\n      }\n      if (['E8'].includes(indicatorCode)) {\n        yAxes[0].ticks.suggestedMin = Math.min(\n          ...this.indicatorObject.measurement\n            .filter((d) => !Number.isNaN(d)),\n        );\n        yAxes[0].ticks.suggestedMax = Math.max(\n          ...this.indicatorObject.measurement\n            .filter((d) => !Number.isNaN(d)),\n        );\n      }\n      if (['E9'].includes(indicatorCode)) {\n        yAxes[0].ticks.suggestedMin = 0;\n        yAxes[0].ticks.suggestedMax = Math.max(\n          ...this.indicatorObject.measurement\n            .filter((d) => !Number.isNaN(d)),\n        );\n      }\n      if (['E10a6', 'E10a7'].includes(indicatorCode)) {\n        yAxes[0].ticks.beginAtZero = true;\n        plugins = {\n          datalabels: {\n            labels: {\n              title: {\n                color: (context) => context.dataset.backgroundColor,\n                font: {\n                  size: 10,\n                },\n                anchor: 'end',\n                align: 'end',\n                offset: (context) => {\n                  if (context.chart.data.datasets.length === 2) {\n                    if (context.datasetIndex === 0) {\n                      if (!Number.isNaN(context.chart.data.datasets[1].data[context.dataIndex].y)\n                        && context.chart.data.datasets[0].data[context.dataIndex].y\n                        > context.chart.data.datasets[1].data[context.dataIndex].y) {\n                        return 0;\n                      }\n                      return -28;\n                    }\n                    if (!Number.isNaN(context.chart.data.datasets[0].data[context.dataIndex].y)\n                      && context.chart.data.datasets[0].data[context.dataIndex].y\n                      > context.chart.data.datasets[1].data[context.dataIndex].y) {\n                      return -28;\n                    }\n                    return 0;\n                  }\n                  return 0;\n                },\n                formatter: (value) => `${value.y.toFixed(1)}%`,\n              },\n            },\n          },\n        };\n      }\n\n      if (['N2', 'E12c', 'E12d'].includes(indicatorCode)) {\n        yAxes[0].ticks.beginAtZero = true;\n      }\n\n      if (['E10a3', 'E10a8'].includes(indicatorCode)) {\n        yAxes[0].ticks = {\n          suggestedMin: Number.NaN,\n          suggestedMax: Number.NaN,\n          padding: -20,\n        };\n      }\n      if (['E10c', 'E10a2', 'E10a6', 'E10a7'].includes(indicatorCode)) {\n        yAxes[0].ticks.suggestedMin += 1;\n        yAxes[0].ticks.suggestedMax -= 1;\n      }\n\n      if (['N3'].includes(indicatorCode)) {\n        yAxes[0].type = 'myLogScale';\n        if (this.indicatorObject.aoiID === 'ES19') {\n          yAxes[0].min = 0.02;\n          yAxes[0].max = 1;\n        }\n        yAxes[0].ticks = {\n          callback: (...args) => {\n            const value = Chart.Ticks.formatters.logarithmic.call(this, ...args);\n            if (value.length) {\n              return Number(value).toLocaleString();\n            }\n            return value;\n          },\n        };\n        legend.labels.usePointStyle = true;\n        legend.labels.boxWidth = 5;\n        legend.onClick = function onClick(e, legendItem) {\n          if (legendItem.text === 'Standard deviation (STD)') {\n            const masterIndex = legendItem.datasetIndex;\n            const slaveIndex = 3;\n            const ci = this.chart;\n            const masterMeta = ci.getDatasetMeta(masterIndex);\n            const meta = ci.getDatasetMeta(slaveIndex);\n            if (masterMeta.hidden === null) {\n              masterMeta.hidden = true;\n              meta.hidden = true;\n            } else {\n              masterMeta.hidden = !masterMeta.hidden;\n              meta.hidden = !meta.hidden;\n            }\n            ci.update();\n          } else {\n            Chart.defaults.global.legend.onClick.call(this, e, legendItem);\n          }\n        };\n      }\n\n      const defaultSettings = {\n        responsive: true,\n        maintainAspectRatio: false,\n        plugins,\n        legend,\n        scales: {\n          xAxes,\n          yAxes,\n        },\n        pan: {\n          enabled: true,\n          mode: 'x',\n        },\n        zoom: {\n          enabled: true,\n          mode: 'x',\n        },\n        tooltips: {\n          callbacks: {\n            label: function (context, data) { // eslint-disable-line\n              let label = data.datasets[context.datasetIndex].label || '';\n              if (label) {\n                label += ': ';\n              }\n              label += this.roundValueInd(Number(context.value));\n              return label;\n            }.bind(this),\n          },\n        },\n      };\n\n      if (['N3'].includes(indicatorCode)) {\n        defaultSettings.tooltips = {\n          callbacks: {\n            label: (context) => {\n              const { datasets } = this.datacollection;\n              const val = datasets[context.datasetIndex].data[context.index];\n              return `Value (Log10): ${Math.log10(val).toPrecision(4)}`;\n            },\n          },\n        };\n      }\n\n      if (['E10a3'].includes(indicatorCode)) {\n        defaultSettings.geo = {\n          radiusScale: {\n            display: true,\n            size: [1, 20],\n          },\n        };\n\n        defaultSettings.scale = {\n          projection: 'mercator',\n        };\n\n        defaultSettings.pan.mode = 'xy';\n        defaultSettings.zoom.mode = 'xy';\n        defaultSettings.legend.display = false;\n\n        defaultSettings.tooltips = {\n          callbacks: {\n            label: (context) => {\n              const { datasets } = this.datacollection;\n              const obj = datasets[context.datasetIndex].data[context.index];\n              return obj.name;\n            },\n            footer: (context) => {\n              const { datasets } = this.datacollection;\n              const obj = datasets[context[0].datasetIndex].data[context[0].index];\n              const refT = obj.referenceTime;\n              const refV = Number(obj.referenceValue);\n              const labelOutput = [\n                `${obj.time.toISODate()}:  ${obj.value.toPrecision(4)}`,\n                `${refT.toISODate()}:  ${refV.toPrecision(4)}`,\n              ];\n              if (refV !== 0) {\n                labelOutput.push(\n                  `${(((obj.value - refV) / refV) * 100).toPrecision(2)} %`,\n                );\n              }\n              return labelOutput;\n            },\n          },\n        };\n      }\n\n      if (['E10a8'].includes(indicatorCode)) {\n        defaultSettings.geo = {\n          radiusScale: {\n            display: true,\n            range: [5, 25],\n            ticks: {\n              max: 2000000,\n            },\n          },\n        };\n\n        defaultSettings.scale = {\n          projection: 'mercator',\n          max: 20,\n        };\n\n        defaultSettings.pan.mode = 'xy';\n        defaultSettings.zoom.mode = 'xy';\n        defaultSettings.legend.display = false;\n\n        defaultSettings.tooltips = {\n          callbacks: {\n            label: (context) => {\n              const { datasets } = this.datacollection;\n              const obj = datasets[context.datasetIndex].data[context.index];\n              return obj.name;\n            },\n            footer: (context) => {\n              const { datasets } = this.datacollection;\n              const obj = datasets[context[0].datasetIndex].data[context[0].index];\n              const refV = Number(obj.referenceValue);\n              const labelOutput = [\n                `${obj.time.toISODate()}:`,\n                `${(refV).toPrecision(4)} % harvested`,\n                `${(100 - refV).toPrecision(4)} % not harvested`,\n                `Max. area: ${obj.value} ha`,\n              ];\n              return labelOutput;\n            },\n          },\n        };\n      }\n\n      return {\n        ...defaultSettings,\n        annotation: {\n          annotations,\n        },\n      };\n    },\n  },\n};\n</script>\n\n<style lang=\"scss\" scoped>\n.md-body {\n  font-size: small;\n}\n::v-deep .mdi-asterisk {\n  visibility: hidden;\n}\n</style>\n"],"sourceRoot":"src/components"}]}