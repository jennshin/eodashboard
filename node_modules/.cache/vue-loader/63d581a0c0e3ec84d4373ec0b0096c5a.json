{"remainingRequest":"/Volumes/WD_Elements_25A1_Media/Google Drive/___Public/__2021-Hackathon-EOD/eodash-staging/app/node_modules/vue-loader/lib/index.js??vue-loader-options!/Volumes/WD_Elements_25A1_Media/Google Drive/___Public/__2021-Hackathon-EOD/eodash-staging/app/src/components/Map.vue?vue&type=style&index=0&id=3074bd5c&lang=scss&scoped=true&","dependencies":[{"path":"/Volumes/WD_Elements_25A1_Media/Google Drive/___Public/__2021-Hackathon-EOD/eodash-staging/app/src/components/Map.vue","mtime":1624532486000},{"path":"/Volumes/WD_Elements_25A1_Media/Google Drive/___Public/__2021-Hackathon-EOD/eodash-staging/app/node_modules/css-loader/dist/cjs.js","mtime":1624878752000},{"path":"/Volumes/WD_Elements_25A1_Media/Google Drive/___Public/__2021-Hackathon-EOD/eodash-staging/app/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":1624878753000},{"path":"/Volumes/WD_Elements_25A1_Media/Google Drive/___Public/__2021-Hackathon-EOD/eodash-staging/app/node_modules/postcss-loader/src/index.js","mtime":1624878752000},{"path":"/Volumes/WD_Elements_25A1_Media/Google Drive/___Public/__2021-Hackathon-EOD/eodash-staging/app/node_modules/sass-loader/dist/cjs.js","mtime":1624878756000},{"path":"/Volumes/WD_Elements_25A1_Media/Google Drive/___Public/__2021-Hackathon-EOD/eodash-staging/app/node_modules/cache-loader/dist/cjs.js","mtime":1624878747000},{"path":"/Volumes/WD_Elements_25A1_Media/Google Drive/___Public/__2021-Hackathon-EOD/eodash-staging/app/node_modules/vue-loader/lib/index.js","mtime":1624878753000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgo6OnYtZGVlcCAubGVhZmxldC10b29sdGlwLXRvcCB7CiAgYmFja2dyb3VuZDogIzAwMDAwMDk5OwogIGJvcmRlci1yYWRpdXM6IDNweDsKICBjb2xvcjogI2ZmZjsKICBwb2ludGVyLWV2ZW50czogbm9uZTsKICB3aGl0ZS1zcGFjZTogbm93cmFwOwogIGJvcmRlcjogbm9uZTsKICAmOmJlZm9yZSB7CiAgICBib3JkZXItdG9wLWNvbG9yOiAjMDAwMDAwOTk7CiAgfQp9Cjo6di1kZWVwIC5tYXJrZXItY2x1c3RlciB7CiAgLy8gVE8tRE8gZmluZCBhIHdheSBob3cgdG8gZ2V0IHRoZSBwcmltYXJ5IGNvbG9yIGludG8gdGhpcwogIC8vIGJhY2tncm91bmQtY29sb3I6IHJnYmEodmFyKC0tcHJpbWFyeS1sZXNzKSk7CiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgjMDAzMjQ3LCAwLjUpOwogIGRpdiB7CiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS12LXByaW1hcnktYmFzZSk7CiAgICBzcGFuIHsKICAgICAgY29sb3I6IHdoaXRlOwogICAgfQogICAgJi5tYXJrZXItY2x1c3Rlci1zZWxlY3RlZCB7CiAgICAgIG1hcmdpbi1sZWZ0OiAzcHg7CiAgICAgIG1hcmdpbi10b3A6IDNweDsKICAgICAgd2lkdGg6IDM4cHg7CiAgICAgIGhlaWdodDogMzhweDsKICAgICAgYm9yZGVyLXJhZGl1czogMTlweDsKICAgICAgJiBzcGFuIHsKICAgICAgICBsaW5lLWhlaWdodDogMzhweDsKICAgICAgICBmb250LXNpemU6IDE0cHg7CiAgICAgIH0KICAgIH0KICB9CiAgJi5tYXJrZXItY2x1c3Rlci1zZWxlY3RlZCB7CiAgICBib3JkZXI6IDJweCB2YXIoLS12LXByaW1hcnktYmFzZSkgZGFzaGVkOwogIH0KfQo6OnYtZGVlcCAubGVhZmxldC1jb250cm9sLWF0dHJpYnV0aW9uOmFjdGl2ZSA6bm90KC5hdHRyaWJ1dGlvbi1pY29uKSwKOjp2LWRlZXAgLmxlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbjpob3ZlciA6bm90KC5hdHRyaWJ1dGlvbi1pY29uKSwKOjp2LWRlZXAgLmxlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbiAuYXR0cmlidXRpb24taWNvbiB7CiAgZGlzcGxheTogaW5saW5lLWJsb2NrOwp9Cjo6di1kZWVwIC5sZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb24gOm5vdCguYXR0cmlidXRpb24taWNvbiksCjo6di1kZWVwIC5sZWFmbGV0LWNvbnRyb2wtYXR0cmlidXRpb246YWN0aXZlIC5hdHRyaWJ1dGlvbi1pY29uLAo6OnYtZGVlcCAubGVhZmxldC1jb250cm9sLWF0dHJpYnV0aW9uOmhvdmVyIC5hdHRyaWJ1dGlvbi1pY29uIHsKICBkaXNwbGF5OiBub25lOwp9Cjo6di1kZWVwIC5hdHRyaWJ1dGlvbi1pY29uIHsKICBmb250LXNpemU6IDEuMmVtOwogIG1hcmdpbjogMXB4Owp9Cjo6di1kZWVwIC5sZWFmbGV0LWNvbnRyb2wtbW91c2Vwb3NpdGlvbiB7CiAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjgpOwogIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoLThweCwgMzJweCwgMCk7CiAgcGFkZGluZzogMnB4IDRweDsKfQo6OnYtZGVlcCAubGVhZmxldC1iYXIgYSwgOjp2LWRlZXAgLmxlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbiB7CiAgY29sb3I6IHZhcigtLXYtcHJpbWFyeS1iYXNlKSAhaW1wb3J0YW50Owp9Cjo6di1kZWVwIC5sZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLXRvZ2dsZSB7CiAgYmFja2dyb3VuZC1pbWFnZTogbm9uZTsKICBzdmcgewogICAgd2lkdGg6IDEwMCU7CiAgICBoZWlnaHQ6IDEwMCU7CiAgfQp9Cg=="},{"version":3,"sources":["Map.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"Map.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <l-map\n    ref=\"map\"\n    style=\"height: 100%; width: 100%; background: #cad2d3; z-index: 1\"\n    :options=\"defaultMapOptions\"\n    :zoom=\"zoom\"\n    :center=\"center\"\n    :maxZoom=\"maxMapZoom\"\n    :minMapZoom=\"minMapZoom\"\n    @update:zoom=\"zoomUpdated\"\n    @update:center=\"centerUpdated\"\n    @update:bounds=\"boundsUpdated\"\n  >\n    <l-control-attribution position=\"bottomright\" prefix=''></l-control-attribution>\n    <l-control-layers position=\"topright\"></l-control-layers>\n    <l-control-zoom position=\"topright\"></l-control-zoom>\n    <LTileLayer\n      v-for=\"layer in baseLayers.filter(b => b.protocol === 'xyz')\"\n      :key=\"layer.name\"\n      v-bind=\"layer\"\n      layer-type=\"base\"\n      :opacity=\"opacityTerrain[zoom]\"\n      :options=\"layerOptions(null, layer)\"\n    >\n    </LTileLayer>\n    <LWMSTileLayer\n      v-for=\"layer in baseLayers.filter(b => b.protocol === 'WMS')\"\n      :key=\"layer.name\"\n      v-bind=\"layer\"\n      :options=\"layerOptions(null, layer)\"\n      layer-type=\"base\"\n    >\n    </LWMSTileLayer>\n    <l-geo-json\n    :geojson=\"countriesJson\"\n    :optionsStyle=\"countriesStyle\"\n    name=\"Country vectors\"\n    layer-type=\"overlay\"\n    >\n    </l-geo-json>\n    <l-geo-json\n    ref=\"subaoiLayer\"\n    :geojson=\"subAoi\"\n    :optionsStyle=\"subAoiStyle\">\n    </l-geo-json>\n    <LTileLayer\n      v-for=\"layer in overlayLayers.filter(b => b.protocol === 'xyz')\"\n      :key=\"layer.name\"\n      v-bind=\"layer\"\n      layer-type=\"overlay\"\n      :opacity=\"opacityOverlay[zoom]\"\n      :options=\"layerOptions(null, layer)\"\n    >\n    </LTileLayer>\n    <LWMSTileLayer\n      v-for=\"layer in overlayLayers.filter(b => b.protocol === 'WMS')\"\n      v-bind=\"layer\"\n      :key=\"layer.name\"\n      :options=\"layerOptions(null, layer)\"\n      :opacity=\"opacityOverlay[zoom]\"\n      layer-type=\"overlay\"\n    >\n    </LWMSTileLayer>\n    <l-marker-cluster ref=\"clusterLayer\" :options=\"clusterOptions\">\n      <l-marker v-for=\"(feature) in getGroupedFeatures.filter((f) => f.latlng)\"\n        :key=\"feature.id\"\n        ref=\"markers\"\n        :lat-lng=\"feature.latlng\"\n        :name='`${getLocationCode(feature.properties.indicatorObject)}`'\n        @click=\"selectIndicator(feature)\"\n      >\n        <l-icon\n          :icon-anchor=\"currentSelected === getLocationCode(feature.properties.indicatorObject)\n            ? [18, 18]\n            : [14, 14]\"\n          style=\"outline: none;\"\n        >\n          <div\n            :style=\"`display: flex; align-items: center;\n              justify-content: center;\n              border-radius: 50%;\n              border: 2px ${currentSelected ===\n                getLocationCode(feature.properties.indicatorObject)\n                  ? 'dashed var(--v-primary-base)'\n                  : 'solid white'};\n              width: ${currentSelected ===\n                getLocationCode(feature.properties.indicatorObject) ? '36px' : '28px'};\n              height: ${currentSelected ===\n                getLocationCode(feature.properties.indicatorObject) ? '36px' : '28px'};\n              background-color: ${getColor(feature.properties.indicatorObject)}`\"\n          >\n              <v-icon\n                color=\"white\"\n                class=\"pa-1\"\n                icon-url=\"/test\"\n                :small=\"currentSelected !== getLocationCode(feature.properties.indicatorObject)\"\n              >\n                {{ baseConfig.indicatorClassesIcons[baseConfig\n                    .indicatorsDefinition[feature.properties.indicatorObject.indicator].class]\n                    ? baseConfig.indicatorClassesIcons[baseConfig\n                      .indicatorsDefinition[feature.properties.indicatorObject.indicator].class]\n                    : 'mdi-lightbulb-on-outline'}}\n              </v-icon>\n          </div>\n        </l-icon>\n        <l-tooltip class=\"tooltip text-center\" :options=\"{ direction: 'top' }\">\n          <p class=\"ma-0\">\n            <strong>{{ feature.properties.indicatorObject.city }}</strong>\n          </p>\n            <p class=\"ma-0\" v-if=\"baseConfig.indicatorsDefinition[\n              feature.properties.indicatorObject.indicator\n              ].indicatorOverwrite\">\n              <strong>{{ baseConfig.indicatorsDefinition[\n                feature.properties.indicatorObject.indicator\n              ].indicatorOverwrite}}\n              </strong>\n            </p>\n            <p class=\"ma-0\" v-else>\n              <strong>{{ feature.properties.indicatorObject.description }}</strong>\n            </p>\n            <p\n              class=\"ma-0\"\n            >\n              {{ formatLabel(feature) }}\n            </p>\n        </l-tooltip>\n      </l-marker>\n    </l-marker-cluster>\n  </l-map>\n</template>\n\n<script>\nimport {\n  mapGetters,\n  mapState,\n} from 'vuex';\n\nimport {\n  geoJson, Point, DivIcon, featureGroup,\n} from 'leaflet';\nimport {\n  LMap, LTileLayer, LWMSTileLayer, LGeoJson, LMarker, LIcon, LTooltip,\n  LControlLayers, LControlAttribution, LControlZoom,\n} from 'vue2-leaflet';\nimport Vue2LeafletMarkerCluster from 'vue2-leaflet-markercluster';\nimport 'leaflet/dist/leaflet.css';\nimport 'leaflet.markercluster/dist/MarkerCluster.css'; // eslint-disable-line import/no-extraneous-dependencies\nimport 'leaflet.markercluster/dist/MarkerCluster.Default.css'; // eslint-disable-line import/no-extraneous-dependencies\nimport 'leaflet-mouse-position';\n\nimport countries from '@/assets/countries.json';\n\nexport default {\n  components: {\n    LMap,\n    LTileLayer,\n    LWMSTileLayer,\n    LGeoJson,\n    LMarker,\n    LIcon,\n    LTooltip,\n    LControlLayers,\n    LControlAttribution,\n    LControlZoom,\n    'l-marker-cluster': Vue2LeafletMarkerCluster,\n  },\n  data() {\n    return {\n      map: null,\n      minMapZoom: 3,\n      zoom: 3,\n      maxMapZoom: 14,\n      center: [55, 10],\n      bounds: null,\n      currentSelected: null,\n      currentSelectedIndex: null,\n      subAoi: null,\n      defaultMapOptions: {\n        attributionControl: false,\n        zoomControl: false,\n      },\n      opacityTerrain: [1],\n      opacityOverlay: [0, 0, 0, 0, 0, 0, 0.4, 0.4, 0.8, 0.8, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9, 0.9],\n      opacityCountries: [1, 1, 1, 1, 0.7, 0.7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    };\n  },\n  computed: {\n    ...mapGetters('features', ['getGroupedFeatures']),\n    ...mapState('config', ['appConfig', 'baseConfig']),\n    baseLayers() {\n      return this.baseConfig.baseLayersLeftMap;\n    },\n    overlayLayers() {\n      return this.baseConfig.overlayLayersLeftMap;\n    },\n    countriesJson() {\n      return countries;\n    },\n    clusterOptions() {\n      return {\n        maxClusterRadius: 40,\n        animate: false,\n        // zoomToBoundsOnClick: false,\n        iconCreateFunction: function (cluster) { // eslint-disable-line func-names\n          // left as default\n          let selCluster = null;\n          if (this.currentSelected !== null && this.$refs.clusterLayer) {\n            const selectedMarker = this.$refs.markers.find(\n              (item) => item.name === this.currentSelected,\n            );\n            if (selectedMarker) {\n              selCluster = this.$refs.clusterLayer.mapObject.getVisibleParent(\n                selectedMarker.mapObject,\n              );\n            }\n          }\n          // modified selected cluster style\n          const sel = selCluster !== null ? cluster._leaflet_id === selCluster._leaflet_id : false;\n          const selectedClass = sel ? ' marker-cluster-selected' : '';\n          let iconSize = null;\n          if (sel) {\n            iconSize = new Point(48, 48);\n          } else {\n            iconSize = new Point(40, 40);\n          }\n          const childCount = cluster.getChildCount();\n          return new DivIcon({\n            html: `<div class=\"${selectedClass}\"><span>${childCount}</span></div>`,\n            className: `marker-cluster ${selectedClass}`,\n            iconSize,\n          });\n        }.bind(this),\n        polygonOptions: {\n          fillColor: this.$vuetify.theme.themes.light.primary,\n          color: this.$vuetify.theme.themes.light.primary,\n          weight: 0.5,\n          opacity: 1,\n          fillOpacity: 0.3,\n          dashArray: 4,\n        },\n      };\n    },\n    indicatorsDefinition: () => this.baseConfig.indicatorsDefinition,\n    countriesStyle() {\n      return {\n        color: '#a2a2a2',\n        weight: 1,\n        fillColor: '#fff',\n        opacity: this.opacityCountries[this.zoom],\n        fillOpacity: this.opacityCountries[this.zoom],\n      };\n    },\n    subAoiStyle() {\n      let currentIndicator;\n      let fillColor;\n      if (this.$store.state.indicators.selectedIndicator) {\n        currentIndicator = this.$store.state.indicators.selectedIndicator;\n        fillColor = this.getColor(currentIndicator);\n      } else {\n        fillColor = this.getIndicatorColor('');\n      }\n      return {\n        color: '#fff',\n        weight: 1,\n        fillColor,\n        opacity: 1,\n        fillOpacity: 0.5,\n      };\n    },\n  },\n  mounted() {\n    this.$nextTick(() => {\n      const layerButton = document.querySelector('.leaflet-control-layers-toggle');\n      layerButton.innerHTML = `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\" fill=\"${this.appConfig.branding.primaryColor}\" width=\"32px\" height=\"32px\"><path d=\"M0 0h24v24H0z\" fill=\"none\"/><path d=\"M11.99 18.54l-7.37-5.73L3 14.07l9 7 9-7-1.63-1.27-7.38 5.74zM12 16l7.36-5.73L21 9l-9-7-9 7 1.63 1.27L12 16z\"/></svg>`;\n\n      this.map = this.$refs.map.mapObject;\n\n      this.$refs.subaoiLayer.mapObject.bindTooltip('Reference area', {\n        direction: 'top',\n      });\n\n      // update leaflet controls\n      L.control.mousePosition({ // eslint-disable-line no-undef\n        emptyString: '',\n        formatter: (lon, lat) => `${lon.toFixed(3)}, ${lat.toFixed(3)}`,\n        position: 'bottomright',\n      }).addTo(this.map);\n      // hide attribution under icon\n      this.map.attributionControl._update = function () { // eslint-disable-line\n        const attribs = [];\n        const kk = Object.keys(this._attributions);\n        for (let i = 0; i < kk.length; i += 1) {\n          if (this._attributions[kk[i]]) {\n            attribs.push(kk[i]);\n          }\n        }\n        const prefixAndAttribs = [];\n        if (this.options.prefix) {\n          prefixAndAttribs.push(this.options.prefix);\n        }\n        if (attribs.length) {\n          prefixAndAttribs.push(attribs.join(', '));\n        }\n        this._container.innerHTML = `<div class='attribution-body'>${prefixAndAttribs.join(' | ')}</div><div class='attribution-icon'>â„¹</div>`;\n      };\n      this.map.attributionControl._update();\n      this.onResize();\n    });\n    this.$store.subscribe((mutation) => {\n      if (mutation.type === 'indicators/INDICATOR_LOAD_FINISHED') {\n        if (mutation.payload !== null && mutation.payload.aoi !== null) {\n          this.currentSelected = this.getLocationCode(mutation.payload);\n          if (mutation.payload.subAoi) {\n            this.subAoi = mutation.payload.subAoi;\n          }\n        } else {\n          this.currentSelected = null;\n          this.subAoi = {\n            type: 'FeatureCollection',\n            features: [],\n          };\n        }\n        this.resetClusterLayer();\n      } else if (mutation.type === 'features/SET_FEATURE_FILTER') {\n        if (Object.keys(mutation.payload).includes('includeArchived') && Object.keys(mutation.payload).length === 1) {\n          return;\n        }\n\n        const features = this.getGroupedFeatures;\n        const featuresOnMap = features.filter((f) => f.latlng);\n        if (featuresOnMap.length > 0) {\n          const maxZoomFit = 8;\n          if (featuresOnMap.length === 1 && featuresOnMap[0].properties.indicatorObject.subAoi\n          && featuresOnMap[0].properties.indicatorObject.subAoi.features.length > 0) {\n            this.$nextTick(() => {\n              const bounds = geoJson(\n                featuresOnMap[0].properties.indicatorObject.subAoi,\n              ).getBounds();\n              this.map.fitBounds(bounds, {\n                padding: [25, 25],\n              });\n            });\n          } else {\n            this.$nextTick(() => {\n              const markers = this.$refs.markers.map((component) => component.mapObject);\n              const dummyFtrGroup = featureGroup(markers);\n              this.map.fitBounds(dummyFtrGroup.getBounds(), {\n                padding: [25, 25],\n                maxZoom: maxZoomFit,\n              });\n            });\n          }\n        }\n      }\n    });\n  },\n  methods: {\n    selectIndicator(feature) {\n      const { indicatorObject } = feature.properties;\n      if (!indicatorObject.dummyFeature) {\n        this.$store.commit('indicators/SET_SELECTED_INDICATOR', indicatorObject);\n        const query = { ...this.$route.query };\n        delete query.sensor;\n        this.$router.replace({ query }).catch(() => {});\n      }\n    },\n    getColor(indObj) {\n      let colorCode;\n      if (indObj) {\n        if (indObj.updateFrequency && indObj.updateFrequency.toLowerCase() === 'archived') {\n          colorCode = 'grey';\n        } else if (Object.prototype.hasOwnProperty.call(indObj, 'lastColorCode')\n          && !['', '/'].includes(indObj.lastColorCode)) {\n          colorCode = indObj.lastColorCode;\n        } else if (Object.prototype.hasOwnProperty.call(indObj, 'indicator')\n          && ['N1', 'N1a', 'N1b', 'N3b', 'E10a3', 'E10a8', 'E10a9', 'E12b', 'C1', 'C2', 'C3']\n            .includes(indObj.indicator)) {\n          colorCode = 'BLUE';\n        }\n      }\n      return this.getIndicatorColor(colorCode);\n    },\n    formatLabel(feature) {\n      let label = '(coming soon)';\n      if (feature) {\n        const { indicatorObject } = feature.properties;\n        if (Object.prototype.hasOwnProperty.call(indicatorObject, 'lastIndicatorValue') || Object.prototype.hasOwnProperty.call(indicatorObject, 'lastMeasurement')) {\n          label = 'Latest value: ';\n          const indVal = indicatorObject.lastIndicatorValue !== '' ? indicatorObject.lastIndicatorValue : indicatorObject.lastMeasurement;\n          if (['E10a1', 'E10a5'].includes(indicatorObject.indicator)) {\n            const percVal = Number((indVal * 100).toPrecision(4));\n            if (percVal > 0) {\n              label += `+${percVal}%`;\n            } else {\n              label += `${percVal}%`;\n            }\n          } else if (['E10a3', 'E10a8', 'E10a9', 'N4c'].includes(indicatorObject.indicator)) {\n            label += 'multiple';\n          } else if (['E10a6', 'E10a7'].includes(indicatorObject.indicator)) {\n            const newIndVal = Number(indicatorObject.lastMeasurement).toPrecision(4);\n            label += `${newIndVal}%`;\n          } else if (['N1', 'N3b', 'N1b', 'E12b', 'C1', 'C2', 'C3'].includes(indicatorObject.indicator)) {\n            label = '';\n          } else if (indVal === null) {\n            label = null;\n          } else {\n            label += indVal;\n          }\n        }\n\n        // Overwrite label if archived\n        if (indicatorObject.updateFrequency && indicatorObject.updateFrequency.toLowerCase() === 'archived') {\n          label = 'Archived';\n        }\n      }\n\n      return label;\n    },\n    resetClusterLayer() {\n      if (this.$refs.clusterLayer) {\n        this.$refs.clusterLayer.mapObject.refreshClusters();\n      }\n    },\n    zoomUpdated(zoom) {\n      this.zoom = zoom;\n      this.onResize();\n      this.$nextTick(() => {\n        this.resetClusterLayer();\n      });\n    },\n    centerUpdated(center) {\n      this.center = center;\n      this.onResize();\n      this.$nextTick(() => {\n        this.resetClusterLayer();\n      });\n    },\n    boundsUpdated(bounds) {\n      this.bounds = bounds;\n      this.onResize();\n    },\n    onResize() {\n      // to fix panel size for reference image window\n      if (this.map) {\n        this.map._onResize();\n      }\n    },\n    layerOptions(time, sourceOptionsObj) {\n      const additionalSettings = {\n        minZoom: sourceOptionsObj.minZoom,\n        maxZoom: sourceOptionsObj.maxZoom,\n        minNativeZoom: sourceOptionsObj.minNativeZoom,\n        maxNativeZoom: sourceOptionsObj.maxNativeZoom,\n      };\n      if (time !== null) {\n        // time as is gets automatically injected to WMS query OR xyz url {time} template\n        additionalSettings.time = sourceOptionsObj.dateFormatFunction\n          ? sourceOptionsObj.dateFormatFunction(time)\n          : time;\n      }\n      return additionalSettings;\n    },\n  },\n};\n</script>\n\n<style lang=\"scss\" scoped>\n::v-deep .leaflet-tooltip-top {\n  background: #00000099;\n  border-radius: 3px;\n  color: #fff;\n  pointer-events: none;\n  white-space: nowrap;\n  border: none;\n  &:before {\n    border-top-color: #00000099;\n  }\n}\n::v-deep .marker-cluster {\n  // TO-DO find a way how to get the primary color into this\n  // background-color: rgba(var(--primary-less));\n  background-color: rgba(#003247, 0.5);\n  div {\n    background-color: var(--v-primary-base);\n    span {\n      color: white;\n    }\n    &.marker-cluster-selected {\n      margin-left: 3px;\n      margin-top: 3px;\n      width: 38px;\n      height: 38px;\n      border-radius: 19px;\n      & span {\n        line-height: 38px;\n        font-size: 14px;\n      }\n    }\n  }\n  &.marker-cluster-selected {\n    border: 2px var(--v-primary-base) dashed;\n  }\n}\n::v-deep .leaflet-control-attribution:active :not(.attribution-icon),\n::v-deep .leaflet-control-attribution:hover :not(.attribution-icon),\n::v-deep .leaflet-control-attribution .attribution-icon {\n  display: inline-block;\n}\n::v-deep .leaflet-control-attribution :not(.attribution-icon),\n::v-deep .leaflet-control-attribution:active .attribution-icon,\n::v-deep .leaflet-control-attribution:hover .attribution-icon {\n  display: none;\n}\n::v-deep .attribution-icon {\n  font-size: 1.2em;\n  margin: 1px;\n}\n::v-deep .leaflet-control-mouseposition {\n  background-color: rgba(255, 255, 255, 0.8);\n  transform: translate3d(-8px, 32px, 0);\n  padding: 2px 4px;\n}\n::v-deep .leaflet-bar a, ::v-deep .leaflet-control-attribution {\n  color: var(--v-primary-base) !important;\n}\n::v-deep .leaflet-control-layers-toggle {\n  background-image: none;\n  svg {\n    width: 100%;\n    height: 100%;\n  }\n}\n</style>\n"]}]}