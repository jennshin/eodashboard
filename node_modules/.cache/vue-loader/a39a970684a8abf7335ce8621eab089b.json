{"remainingRequest":"/Volumes/WD_Elements_25A1_Media/Google Drive/_Github/github_upload/eodashboard/app/node_modules/vue-loader/lib/index.js??vue-loader-options!/Volumes/WD_Elements_25A1_Media/Google Drive/_Github/github_upload/eodashboard/app/src/components/IndicatorData.vue?vue&type=style&index=0&id=5fbbb1d9&lang=scss&scoped=true&","dependencies":[{"path":"/Volumes/WD_Elements_25A1_Media/Google Drive/_Github/github_upload/eodashboard/app/src/components/IndicatorData.vue","mtime":1624532486000},{"path":"/Volumes/WD_Elements_25A1_Media/Google Drive/_Github/github_upload/eodashboard/app/node_modules/css-loader/dist/cjs.js","mtime":1624878752000},{"path":"/Volumes/WD_Elements_25A1_Media/Google Drive/_Github/github_upload/eodashboard/app/node_modules/vue-loader/lib/loaders/stylePostLoader.js","mtime":1624878753000},{"path":"/Volumes/WD_Elements_25A1_Media/Google Drive/_Github/github_upload/eodashboard/app/node_modules/postcss-loader/src/index.js","mtime":1624878752000},{"path":"/Volumes/WD_Elements_25A1_Media/Google Drive/_Github/github_upload/eodashboard/app/node_modules/sass-loader/dist/cjs.js","mtime":1624878756000},{"path":"/Volumes/WD_Elements_25A1_Media/Google Drive/_Github/github_upload/eodashboard/app/node_modules/cache-loader/dist/cjs.js","mtime":1624878747000},{"path":"/Volumes/WD_Elements_25A1_Media/Google Drive/_Github/github_upload/eodashboard/app/node_modules/vue-loader/lib/index.js","mtime":1624878753000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:CgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCi5tZC1ib2R5IHsKICBmb250LXNpemU6IHNtYWxsOwp9Cjo6di1kZWVwIC5tZGktYXN0ZXJpc2sgewogIHZpc2liaWxpdHk6IGhpZGRlbjsKfQo="},{"version":3,"sources":["IndicatorData.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+hDA;AACA;AACA;AACA;AACA;AACA","file":"IndicatorData.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div style=\"width: 100%; height: 100%;\"\n    v-if=\"!['E10a2', 'E10a3', 'E10a6', 'E10a7', 'E10a8', 'E10a9',\n      'E10c', 'N1', 'N3', 'N3b', 'E8',\n      'E13e', 'E13f', 'E13g', 'E13h', 'E13i', 'E13l', 'E13m',\n      'N1a', 'N1b', 'N1c', 'N1d', 'E12b', 'GG', 'GSA', 'CV', 'OW']\n      .includes(indicatorObject.indicator)\">\n      <bar-chart v-if='datacollection'\n        id=\"chart\"\n        class=\"fill-height\"\n        :width=\"null\"\n        :height=\"null\"\n        :chart-data='datacollection'\n        :options='chartOptions()'></bar-chart>\n  </div>\n  <div style=\"width: 100%; height: 100%;\"\n    v-else-if=\"['E10a3', 'E10a8'].includes(indicatorObject.indicator)\">\n      <map-chart\n        id=\"chart\"\n        class=\"fill-height\"\n        :width=\"null\"\n        :height=\"null\"\n        :chart-data='datacollection'\n        :options='chartOptions()'>\n      </map-chart>\n      <img v-if=\"indicatorObject.indicator=='E10a3'\"\n        :src=\"require('@/assets/E10a3_label.jpg')\" alt=\"color legend\"\n        style=\"position: absolute; width: 200px; z-index: 0;\n        top: 0px; right: 0px;\"/>\n      <img v-else\n        :src=\"require('@/assets/E10a8_label.jpg')\" alt=\"color legend\"\n        style=\"position: absolute; width: 150px; z-index: 0;\n        top: 0px; right: 0px;\"/>\n      <v-row\n        class=\"justify-center align-center timeSelection mr-6 ml-0\"\n        style=\"position: absolute; bottom: 0px; z-index: 1000;\n          width: auto; max-width: 100%;left:-45px;\"\n      >\n        <v-col cols=\"6\">\n          <v-select\n            outlined dense autofocus hide-details\n            :prepend-inner-icon=\"(arrayOfObjects && dataLayerTime) && (arrayOfObjects\n              .map((i) => i.value)\n              .indexOf(dataLayerTime) > 0\n                ? 'mdi-arrow-left-drop-circle'\n                : 'mdi-asterisk')\"\n            :append-icon=\"(arrayOfObjects && dataLayerTime) && (arrayOfObjects\n              .map((i) => i.value)\n              .indexOf(dataLayerTime) < arrayOfObjects.length - 1\n                ? 'mdi-arrow-right-drop-circle'\n                : 'mdi-asterisk')\"\n            menu-props=\"auto\"\n            :items=\"arrayOfObjects\"\n            item-value=\"value\"\n            item-text=\"name\"\n            v-model=\"dataLayerTime\"\n            @change=\"dataLayerTimeSelection\"\n            @click:prepend-inner=\"dataLayerReduce\"\n            @click:append=\"dataLayerIncrease\">\n          </v-select>\n        </v-col>\n      </v-row>\n  </div>\n  <div style=\"width: 100%; height: 100%;\" v-else>\n    <line-chart v-if='datacollection'\n      id=\"chart\"\n      class=\"fill-height\"\n      :width=\"null\"\n      :height=\"null\"\n      :chart-data='datacollection'\n      :options='chartOptions()'></line-chart>\n  </div>\n</template>\n\n<script>\nimport { DateTime } from 'luxon';\nimport {\n  mapState,\n} from 'vuex';\nimport BarChart from '@/components/BarChart.vue';\nimport LineChart from '@/components/LineChart.vue';\nimport MapChart from '@/components/MapChart.vue';\nimport NUTS from '@/assets/NUTS_RG_03M_2016_4326_ESL2-DEL3.json';\nimport lockdownTimes from '@/assets/lockdown_data.json';\nimport countries from '@/assets/countries.json';\n\nexport default {\n  props: [\n    'currentIndicator',\n  ],\n  components: {\n    BarChart,\n    LineChart,\n    MapChart,\n  },\n  data() {\n    return {\n      dataLayerTime: null,\n      dataLayerIndex: 0,\n    };\n  },\n  mounted() {\n    const d = this.indicatorObject.time[this.indicatorObject.time.length - 1];\n    this.dataLayerTime = d.toFormat('dd. MMM');\n  },\n  computed: {\n    ...mapState('config', ['appConfig', 'baseConfig']),\n    arrayOfObjects() {\n      const indicator = { ...this.indicatorObject };\n      const indicatorCode = indicator.indicator;\n      const selectionOptions = [];\n      if (['E10a3', 'E10a8'].includes(indicatorCode)) {\n        // Find all unique day/month available\n        const timeset = new Set(\n          indicator.time.map((d) => d.toFormat('dd. MMM')),\n        );\n        timeset.forEach((t) => {\n          selectionOptions.push({\n            value: t,\n            name: t,\n          });\n        });\n      }\n      return selectionOptions;\n    },\n    datacollection() {\n      const indicator = { ...this.indicatorObject };\n      const indicatorCode = indicator.indicator;\n      let dataCollection;\n      const refColors = [\n        '#22aa99', '#a37', '#47a', '#a67', '#283', '#bbb',\n        '#6ce', '#994499', '#aaaa11', '#6633cc', '#e67300',\n      ];\n      if (indicator) {\n        let labels = [];\n        const { measurement } = indicator;\n        const colors = [];\n        const datasets = [];\n        if (['E10a1', 'E10a5'].includes(indicatorCode)) {\n          const referenceValue = indicator.referenceValue.map(Number);\n          for (let i = 0; i < indicator.time.length; i += 1) {\n            if (!Number.isNaN(indicator.time[i].toMillis())) {\n              const d = indicator.time[i];\n              const formattedDate = d.toFormat('dd. MMM');\n              labels.push(formattedDate);\n            } else {\n              labels.push(i);\n            }\n          }\n          const labelref = '2019';\n          const labelmeas = '2020';\n          datasets.push({\n            indLabels: Array(indicator.indicatorValue.length).join('.').split('.'),\n            label: labelref,\n            data: referenceValue,\n            fill: false,\n            backgroundColor: 'grey',\n          });\n          datasets.push({\n            indLabels: indicator.indicatorValue,\n            label: labelmeas,\n            data: measurement,\n            fill: false,\n            backgroundColor: 'black',\n          });\n        } else if (['E10a9'].includes(indicatorCode)) {\n          const categories = [\n            'National Workers',\n            'Foreign Workers',\n            'Unknown',\n          ];\n          categories.forEach((key, idx) => {\n            const data = indicator.measurement.map((row, rowIdx) => ({\n              t: indicator.time[rowIdx],\n              y: row[idx],\n            }));\n            datasets.push({\n              label: key,\n              data,\n              fill: false,\n              borderColor: refColors[idx],\n              backgroundColor: refColors[idx],\n              cubicInterpolationMode: 'monotone',\n              borderWidth: 1,\n              pointRadius: 2,\n            });\n          });\n        } else if (['GG'].includes(indicatorCode)) {\n          const vals = indicator.Values;\n          const datasetsObj = {\n            grocery: [],\n            parks: [],\n            residential: [],\n            retail_recreation: [],\n            transit_stations: [],\n          };\n          for (let entry = 0; entry < vals.length; entry += 1) {\n            const t = DateTime.fromISO(vals[entry].date);\n            datasetsObj.grocery.push({ t, y: vals[entry].grocery });\n            datasetsObj.parks.push({ t, y: vals[entry].parks });\n            datasetsObj.residential.push({ t, y: vals[entry].residential });\n            datasetsObj.retail_recreation.push({ t, y: vals[entry].retail_recreation });\n            datasetsObj.transit_stations.push({ t, y: vals[entry].transit_stations });\n          }\n          Object.keys(datasetsObj).forEach((key, idx) => {\n            datasets.push({\n              label: key,\n              data: datasetsObj[key],\n              fill: false,\n              borderColor: refColors[idx],\n              backgroundColor: refColors[idx],\n              borderWidth: 1,\n              pointRadius: 2,\n              cubicInterpolationMode: 'monotone',\n            });\n          });\n        } else if (['GSA'].includes(indicatorCode)) {\n          const vals = Object.keys(indicator.values);\n          const datasetsObj = {};\n          for (let entry = 0; entry < vals.length; entry += 1) {\n            datasetsObj[vals[entry]] = [];\n            const currVals = indicator.values[vals[entry]].values;\n            for (let i = 0; i < currVals.length; i += 1) {\n              datasetsObj[vals[entry]].push({\n                t: DateTime.fromISO(currVals[i].timestamp),\n                y: Number(currVals[i].waiting_time),\n              });\n            }\n            // It seems some timstamps are mixed in order so let us sort by date\n            // to get nice line connections through the timeline\n            datasetsObj[vals[entry]].sort((a, b) => a.t.toMillis() - b.t.toMillis());\n          }\n          Object.keys(indicator.values).forEach((key, idx) => {\n            datasets.push({\n              label: key,\n              data: datasetsObj[key],\n              fill: false,\n              borderColor: refColors[idx],\n              backgroundColor: refColors[idx],\n              borderWidth: 1,\n              pointRadius: 2,\n              cubicInterpolationMode: 'monotone',\n            });\n          });\n        } else if (['CV'].includes(indicatorCode)) {\n          const vals = indicator.Values;\n          const datasetsObj = {\n            confirmed: [],\n          };\n          for (let entry = 0; entry < vals.length; entry += 1) {\n            const t = DateTime.fromISO(vals[entry].date);\n            datasetsObj.confirmed.push({ t, y: Number(vals[entry].confirmed) });\n          }\n          Object.keys(datasetsObj).forEach((key, idx) => {\n            datasets.push({\n              label: key,\n              data: datasetsObj[key],\n              fill: false,\n              borderColor: refColors[idx],\n              backgroundColor: refColors[idx],\n              borderWidth: 1,\n              pointRadius: 2,\n              cubicInterpolationMode: 'monotone',\n            });\n          });\n        } else if (['OW'].includes(indicatorCode)) {\n          const vals = indicator.Values;\n          const pI = [\n            'total_vaccinations', 'people_fully_vaccinated',\n            'daily_vaccinations',\n          ];\n          const datasetsObj = {};\n          for (let idx = 0; idx < pI.length; idx += 1) {\n            datasetsObj[pI[idx]] = [];\n          }\n          for (let entry = 0; entry < vals.length; entry += 1) {\n            const t = DateTime.fromISO(vals[entry].date);\n            for (let idx = 0; idx < pI.length; idx += 1) {\n              datasetsObj[pI[idx]].push({ t, y: vals[entry][pI[idx]] });\n            }\n          }\n          Object.keys(datasetsObj).forEach((key, idx) => {\n            datasets.push({\n              label: key,\n              data: datasetsObj[key],\n              fill: false,\n              borderColor: refColors[idx],\n              backgroundColor: refColors[idx],\n              borderWidth: 1,\n              pointRadius: 2,\n              cubicInterpolationMode: 'monotone',\n            });\n          });\n        } else if (['N3b'].includes(indicatorCode)) {\n          const sensors = Array.from(new Set(indicator.eoSensor)).sort();\n          for (let pp = 0; pp < sensors.length; pp += 1) {\n            const pKey = sensors[pp];\n            const data = indicator.time.map((date, i) => {\n              let output = null;\n              if (indicator.eoSensor[i] === pKey) {\n                output = { t: date, y: measurement[i] };\n              }\n              return output;\n            }).filter((d) => d !== null);\n            let colorUsed = refColors[pp];\n            if (this.indDefinition.sensorColorMap && this.indDefinition.sensorColorMap[pKey]) {\n              colorUsed = this.indDefinition.sensorColorMap[pKey];\n            }\n            datasets.push({\n              label: pKey,\n              data,\n              fill: false,\n              borderColor: colorUsed,\n              backgroundColor: colorUsed,\n              cubicInterpolationMode: 'monotone',\n            });\n          }\n        } else if (['N4c'].includes(indicatorCode)) {\n          const measData = indicator.measurement.map(Number);\n          measData.shift();\n          const refData = indicator.referenceValue.map(Number);\n          refData.shift();\n\n          labels = [\n            indicator.referenceTime[0].toISODate(),\n            indicator.time[0].toISODate(),\n            indicator.time[5].toISODate(),\n          ];\n\n          datasets.push({\n            label: 'metallic waste area',\n            data: [refData[0], measData[0], measData[5]],\n            backgroundColor: refColors[0],\n          });\n          datasets.push({\n            label: 'mixed waste area',\n            data: [refData[1], measData[1], measData[6]],\n            backgroundColor: refColors[1],\n          });\n          datasets.push({\n            label: 'plastic waste area',\n            data: [refData[2], measData[2], measData[7]],\n            backgroundColor: refColors[2],\n          });\n          datasets.push({\n            label: 'soil waste area',\n            data: [refData[3], measData[3], measData[8]],\n            backgroundColor: refColors[3],\n          });\n        } else if (['E10a2', 'E10a6', 'E10a7', 'E8', 'E13e', 'E13f', 'E13g', 'E13h', 'E13i', 'E13l', 'E13m'].includes(indicatorCode)) {\n          const uniqueRefs = [];\n          const uniqueMeas = [];\n          const referenceValue = indicator.referenceValue.map(Number);\n          indicator.time.forEach((date, i) => {\n            const meas = { t: date.set({ year: 2000 }), y: measurement[i] };\n            if (typeof uniqueRefs.find((item) => item.t.equals(meas.t)) === 'undefined') {\n              uniqueMeas.push(meas);\n            }\n          });\n          indicator.referenceTime.forEach((date, i) => {\n            if (!['', '/'].includes(indicator.referenceValue[i])) {\n              const ref = { t: date.set({ year: 2000 }), y: referenceValue[i] };\n              if (typeof uniqueRefs.find((item) => item.t.equals(ref.t)) === 'undefined') {\n                uniqueRefs.push(ref);\n              }\n            }\n          });\n          datasets.push({\n            label: '2020',\n            data: uniqueMeas,\n            fill: false,\n            borderColor: refColors[1],\n            backgroundColor: refColors[1],\n            borderWidth: 2,\n          });\n          if (uniqueRefs.length > 0) {\n            datasets.push({\n              label: '2019',\n              data: uniqueRefs,\n              fill: false,\n              borderColor: refColors[0],\n              backgroundColor: refColors[0],\n              borderWidth: 2,\n            });\n          }\n        } else if (['E13n', 'C1', 'C2', 'C3'].includes(indicatorCode)) {\n          // Group by indicator value\n          const types = {};\n          indicator.indicatorValue.forEach((ind, idx) => {\n            if (Object.keys(types).includes(ind)) {\n              types[ind].push({\n                t: DateTime.fromISO(indicator.time[idx]),\n                y: Number(indicator.measurement[idx]),\n              });\n            } else {\n              types[ind] = [{\n                t: DateTime.fromISO(indicator.time[idx]),\n                y: Number(indicator.measurement[idx]),\n              }];\n            }\n          });\n          Object.keys(types).forEach((key, i) => {\n            datasets.push({\n              label: key,\n              fill: false,\n              data: types[key],\n              backgroundColor: refColors[i],\n              borderColor: refColors[i],\n              borderWidth: 2,\n            });\n          });\n        } else if (['N2', 'E10c'].includes(indicatorCode)) {\n          /* Group data by year in month slices */\n          const data = indicator.time.map((date, i) => {\n            colors.push(this.getIndicatorColor(indicator.colorCode[i]));\n            return { t: date, y: measurement[i] };\n          });\n          const dataGroups = {};\n          const colorGroups = {};\n          for (let i = 0; i < data.length; i += 1) {\n            const currYear = data[i].t.year;\n            if (Object.prototype.hasOwnProperty.call(dataGroups, currYear)) {\n              dataGroups[currYear].push({\n                t: data[i].t.set({ year: 2000 }),\n                y: [data[i].y],\n              });\n              colorGroups[currYear].push(colors[i]);\n            } else {\n              dataGroups[currYear] = [{\n                t: data[i].t.set({ year: 2000 }),\n                y: [data[i].y],\n              }];\n              colorGroups[currYear] = [colors[i]];\n            }\n          }\n          const uniqueYears = Object.keys(dataGroups);\n          uniqueYears.sort();\n          const yLength = uniqueYears.length - 1;\n          uniqueYears.forEach((key, i) => {\n            datasets.push({\n              // fill with empty values\n              indLabels: Array(dataGroups[key].length).join('.').split('.'),\n              label: key,\n              fill: false,\n              data: dataGroups[key],\n              backgroundColor: refColors[yLength - i],\n              borderColor: refColors[yLength - i],\n              borderWidth: 2,\n            });\n          });\n        } else if (['N1'].includes(indicatorCode)) {\n          const stdDevMin = [];\n          const stdDevMax = [];\n          const min = [];\n          const max = [];\n          const median = [];\n          const data = [];\n          indicator.referenceValue.forEach((item, i) => {\n            const t = indicator.time[i];\n            data.push({ y: measurement[i], t });\n            if (!Number.isNaN(item) && !['NaN', '/'].includes(item)) {\n              const obj = JSON.parse(item);\n              // [median,std,max,min,percentage valid pixels]\n              median.push({ y: obj[0], t });\n              if (obj[1] !== null) {\n                stdDevMin.push({ y: measurement[i] - obj[1], t });\n                stdDevMax.push({ y: measurement[i] + obj[1], t });\n              }\n              max.push({ y: obj[2], t });\n              min.push({ y: obj[3], t });\n            } else {\n              median.push({ y: Number.NaN, t });\n              stdDevMin.push({ y: Number.NaN, t });\n              stdDevMax.push({ y: Number.NaN, t });\n              max.push({ y: Number.NaN, t });\n              min.push({ y: Number.NaN, t });\n            }\n          });\n          datasets.push({\n            label: indicator.yAxis,\n            data,\n            fill: false,\n            backgroundColor: refColors[0],\n            borderColor: refColors[0],\n            spanGaps: false,\n            borderWidth: 2,\n          });\n          // Check for empty array, if it is the case do not include data\n          if (typeof (median.find((a) => a.y !== null)) !== 'undefined') {\n            datasets.push({\n              label: 'Median',\n              data: median,\n              fill: false,\n              pointRadius: 0,\n              borderColor: 'black',\n              borderWidth: 1,\n              pointStyle: 'line',\n              spanGaps: false,\n            });\n          }\n          // Check for empty array, if it is the case do not include data\n          if (typeof (min.find((a) => a.y !== null)) !== 'undefined') {\n            datasets.push({\n              label: 'Min',\n              data: min,\n              fill: false,\n              pointRadius: 0,\n              backgroundColor: refColors[4],\n              borderColor: refColors[4],\n              borderWidth: 1,\n              pointStyle: 'line',\n              spanGaps: false,\n            });\n          }\n          // Check for empty array, if it is the case do not include data\n          if (typeof (max.find((a) => a.y !== null)) !== 'undefined') {\n            datasets.push({\n              label: 'Max',\n              data: max,\n              fill: false,\n              pointRadius: 0,\n              backgroundColor: refColors[1],\n              borderColor: refColors[1],\n              borderWidth: 1,\n              pointStyle: 'line',\n              spanGaps: false,\n            });\n          }\n          // Check for empty array, if it is the case do not include data\n          if (typeof (stdDevMax.find((a) => a.y !== null)) !== 'undefined') {\n            datasets.push({\n              label: 'Standard deviation (STD)',\n              data: stdDevMax,\n              fill: '+1',\n              pointRadius: 0,\n              spanGaps: false,\n              backgroundColor: 'rgba(0,0,0,0.1)',\n              borderColor: 'rgba(0,0,0,0.0)',\n              pointStyle: 'rect',\n            });\n          }\n          // Check for empty array, if it is the case do not include data\n          if (typeof (stdDevMin.find((a) => a.y !== null)) !== 'undefined') {\n            datasets.push({\n              label: 'hide_',\n              data: stdDevMin,\n              fill: '-1',\n              pointRadius: 0,\n              spanGaps: false,\n              backgroundColor: 'rgba(0,0,0,0.0)',\n              borderColor: 'rgba(0,0,0,0.0)',\n              pointStyle: 'rect',\n            });\n          }\n        } else if (['N3'].includes(indicatorCode)) {\n          let referenceValue = [];\n          const stdDev = [];\n          indicator.referenceValue.forEach((item) => {\n            if (!Number.isNaN(item) && !['NaN', '[NaN NaN]', '/'].includes(item)) {\n              const obj = JSON.parse(item.replace(/,/g, '.').replace(' ', ','));\n              if (obj[0] !== -999 && obj[1] !== -999) {\n                referenceValue.push(obj[0]);\n                stdDev.push(obj[1]);\n              } else {\n                referenceValue.push(Number.NaN);\n                stdDev.push(Number.NaN);\n              }\n            } else {\n              referenceValue.push(Number.NaN);\n              stdDev.push(Number.NaN);\n            }\n          });\n\n          const stdDevMax = stdDev.map((dev, i) => (\n            Number.isNaN(referenceValue[i])\n              ? Number.NaN\n              : (10 ** (referenceValue[i] + dev))\n          ));\n          const stdDevMin = stdDev.map((dev, i) => (\n            Number.isNaN(referenceValue[i])\n              ? Number.NaN\n              : (10 ** (referenceValue[i] - dev))\n          ));\n\n          referenceValue = referenceValue.map((val) => (\n            Number.isNaN(val) ? Number.NaN : (10 ** val)\n          ));\n\n          for (let i = 0; i < indicator.time.length; i += 1) {\n            if (!Number.isNaN(indicator.time[i].toMillis())) {\n              labels.push(indicator.time[i].toISODate());\n            } else {\n              labels.push(i);\n            }\n            let colorCode = '';\n            if (Object.prototype.hasOwnProperty.call(indicator, 'colorCode')) {\n              colorCode = indicator.colorCode[i];\n            }\n            colors.push(this.getIndicatorColor(colorCode));\n          }\n\n          datasets.push({\n            label: 'Weekly climatology of chlorophyll conc. (CHL_clim) 2017-2019',\n            data: referenceValue,\n            fill: false,\n            pointRadius: 0,\n            borderColor: 'black',\n            pointStyle: 'line',\n            spanGaps: false,\n          });\n          datasets.push({\n            label: 'Standard deviation (STD)',\n            data: stdDevMax,\n            fill: '+1',\n            pointRadius: 0,\n            spanGaps: false,\n            backgroundColor: 'rgba(0,0,0,0.1)',\n            borderColor: 'rgba(0,0,0,0.0)',\n            pointStyle: 'rect',\n          });\n          datasets.push({\n            label: 'hide_',\n            data: stdDevMin,\n            fill: '-1',\n            pointRadius: 0,\n            spanGaps: false,\n            backgroundColor: 'rgba(0,0,0,0.0)',\n            borderColor: 'rgba(0,0,0,0.0)',\n            pointStyle: 'rect',\n          });\n\n          // Find unique indicator values\n          const indicatorValues = {};\n          indicator.indicatorValue.map((val, i) => {\n            let key = val.toLowerCase();\n            key = key.charAt(0).toUpperCase() + key.slice(1);\n            if (!['', '/'].includes(key) && typeof indicatorValues[key] === 'undefined') {\n              indicatorValues[key] = this.getIndicatorColor(\n                indicator.colorCode[i],\n              );\n            }\n            return null;\n          });\n\n          Object.entries(indicatorValues).forEach(([key, value]) => {\n            const currMeas = measurement.map((row, i) => {\n              let val = row;\n              if (indicator.indicatorValue[i] !== key.toUpperCase()) {\n                val = NaN;\n              }\n              return val;\n            });\n            datasets.push({\n              label: key,\n              data: currMeas.map((val) => (\n                Number.isNaN(val) ? Number.NaN : (10 ** val)\n              )),\n              backgroundColor: value,\n              borderColor: value,\n              fill: false,\n              showLine: false,\n              spanGaps: false,\n            });\n          });\n        } else if (['N1a', 'N1b', 'N1c', 'N1d', 'E12b'].includes(indicatorCode)) {\n          const maxRef = [];\n          const minRef = [];\n          const mean7dRef = [];\n          const mean7d2020 = [];\n          indicator.referenceValue.forEach((item, i) => {\n            const t = indicator.time[i];\n            if (!['', '/'].includes(item)) {\n              const obj = item.replace(/[[\\] ]/g, '').split(',')\n                .map((str) => (str === '' ? Number.NaN : Number(str)));\n              maxRef.push({ y: obj[0], t });\n              minRef.push({ y: obj[1], t });\n              mean7dRef.push({ y: obj[2], t });\n              mean7d2020.push({ y: obj[3], t });\n            } else {\n              maxRef.push({ y: Number.NaN, t });\n              minRef.push({ y: Number.NaN, t });\n              mean7dRef.push({ y: Number.NaN, t });\n              mean7d2020.push({ y: Number.NaN, t });\n            }\n          });\n\n          datasets.push({\n            label: 'Value',\n            data: measurement.map((meas, i) => ({ y: meas, t: indicator.time[i] })),\n            backgroundColor: 'rgba(255,255,255,0.0)',\n            borderColor: 'red',\n            spanGaps: false,\n            pointRadius: 0,\n            borderWidth: 1.5,\n          });\n          datasets.push({\n            label: '7-day mean',\n            data: mean7d2020,\n            backgroundColor: 'rgba(255,255,255,0.0)',\n            pointRadius: 0,\n            borderColor: 'red',\n            spanGaps: false,\n            borderDash: [6, 3],\n            borderWidth: 2,\n          });\n          datasets.push({\n            label: '2017-2019 7d mean',\n            data: mean7dRef,\n            backgroundColor: 'rgba(255,255,255,0.0)',\n            pointRadius: 0,\n            borderColor: 'grey',\n            spanGaps: false,\n            borderDash: [6, 3],\n            borderWidth: 2,\n          });\n          datasets.push({\n            label: '2017-2019 range',\n            data: maxRef,\n            fill: 4,\n            pointRadius: 0,\n            spanGaps: false,\n            backgroundColor: 'rgba(0,0,0,0.2)',\n            borderColor: 'rgba(0,0,0,0.0)',\n            pointStyle: 'rect',\n          });\n          datasets.push({\n            label: 'hide_',\n            data: minRef,\n            fill: 3,\n            pointRadius: 0,\n            spanGaps: false,\n            backgroundColor: 'rgba(0,0,0,0.0)',\n            borderColor: 'rgba(0,0,0,0.0)',\n            pointStyle: 'rect',\n          });\n\n          // Find unique indicator values\n          const indicatorValues = {};\n          indicator.indicatorValue.map((val, i) => {\n            let key = val.toLowerCase();\n            key = key.charAt(0).toUpperCase() + key.slice(1);\n            if (!['', '/'].includes(key) && typeof indicatorValues[key] === 'undefined') {\n              indicatorValues[key] = this.getIndicatorColor(\n                indicator.colorCode[i],\n              );\n            }\n            return null;\n          });\n\n          Object.entries(indicatorValues).forEach(([key, value]) => {\n            datasets.push({\n              label: key,\n              data: [],\n              backgroundColor: value,\n              borderColor: value,\n            });\n          });\n        } else if (['E10a3', 'E10a8'].includes(indicatorCode)) {\n          const nutsFeatures = NUTS.features;\n          const outline = [];\n          const currIDs = [];\n          let features = measurement.map((meas, i) => {\n            // Find correct NUTS ID Shape\n            const geom = nutsFeatures.find((f) => (\n              f.properties.NUTS_ID === indicator.siteName[i]));\n            let output;\n            if (geom) {\n              if (currIDs.indexOf(indicator.siteName[i]) === -1) {\n                currIDs.push(indicator.siteName[i]);\n                outline.push({\n                  type: 'Feature',\n                  properties: {},\n                  geometry: geom.geometry,\n                });\n              }\n              const { coordinates } = geom.geometry;\n              const lons = (geom.geometry.type === 'Polygon') ? coordinates.flat(1).map((tuple) => tuple[0]) : coordinates.flat(2).map((tuple) => tuple[0]);\n              const lats = (geom.geometry.type === 'Polygon') ? coordinates.flat(1).map((tuple) => tuple[1]) : coordinates.flat(2).map((tuple) => tuple[1]);\n              const minLat = Math.min(...lats);\n              const minLon = Math.min(...lons);\n              const centerPoint = {\n                lat: minLat + (Math.max(...lats) - minLat) / 2,\n                lon: minLon + (Math.max(...lons) - minLon) / 2,\n              };\n              output = {\n                type: 'Feature',\n                properties: {},\n                geometry: geom.geometry,\n                description: 'description',\n                latitude: centerPoint.lat,\n                longitude: centerPoint.lon,\n                name: geom.properties.NUTS_NAME,\n                time: indicator.time[i],\n                value: Number(meas),\n                referenceTime: indicator.referenceTime[i],\n                referenceValue: indicator.referenceValue[i],\n                color: indicator.colorCode[i],\n              };\n              if (indicatorCode === 'E10a8') {\n                // Swap value to have reference value\n                output.value = Number(indicator.referenceValue[i]);\n                output.referenceValue = Number(meas);\n              }\n            }\n            return output;\n          });\n\n          // Filter by undefined and time\n          features = features.filter((d) => (\n            typeof d !== 'undefined'));\n\n          const filteredFeatures = features.filter((d) => {\n            let include = false;\n            if (d.time instanceof DateTime) {\n              include = d.time.toFormat('dd. MMM') === this.dataLayerTime\n                && !Number.isNaN(d.value);\n            }\n            return include;\n          });\n\n          labels = features.map((d) => d.name);\n          datasets.push({\n            outline,\n            outlineBackgroundColor: null,\n            outlineBorderColor: 'black',\n            outlineBorderWidth: 1,\n            showOutline: true,\n            backgroundColor: filteredFeatures.map((d) => d.color),\n            borderColor: filteredFeatures.map((d) => d.color),\n            borderWidth: 3,\n            data: filteredFeatures,\n            clipMap: 'items',\n          });\n        } else {\n          const data = indicator.time.map((date, i) => {\n            colors.push(this.getIndicatorColor(indicator.colorCode[i]));\n            return { t: date, y: measurement[i] };\n          });\n          datasets.push({\n            data,\n            label: indicator.yAxis,\n            backgroundColor: colors,\n            borderColor: colors,\n          });\n        }\n        dataCollection = {\n          labels,\n          datasets,\n        };\n      }\n      return dataCollection;\n    },\n    indicatorObject() {\n      return this.currentIndicator\n        || this.$store.state.indicators.customAreaIndicator\n        || this.$store.state.indicators.selectedIndicator;\n    },\n    indDefinition() {\n      return this.baseConfig.indicatorsDefinition[this.indicatorObject.indicator];\n    },\n  },\n  methods: {\n    dataLayerTimeSelection(payload) {\n      this.dataLayerTime = payload;\n      const newIndex = this.arrayOfObjects\n        .map((i) => i.value)\n        .indexOf(this.dataLayerTime);\n      this.dataLayerIndex = newIndex;\n    },\n    dataLayerReduce() {\n      const currentIndex = this.arrayOfObjects\n        .map((i) => i.value)\n        .indexOf(this.dataLayerTime);\n      this.dataLayerIndex = currentIndex - 1;\n      this.dataLayerTimeSelection(this.arrayOfObjects[currentIndex - 1].value);\n    },\n    dataLayerIncrease() {\n      const currentIndex = this.arrayOfObjects\n        .map((i) => i.value)\n        .indexOf(this.dataLayerTime);\n      this.dataLayerIndex = currentIndex + 1;\n      this.dataLayerTimeSelection(this.arrayOfObjects[currentIndex + 1].value);\n    },\n    formatNumRef(num, maxDecimals = 3) {\n      return Number.parseFloat(num.toFixed(maxDecimals));\n    },\n    roundValueInd(val) {\n      if (this.indDefinition.maxDecimals === -1) {\n        return val;\n      }\n      if (Number.isInteger(this.indDefinition.maxDecimals)) {\n        return this.formatNumRef(val, this.indDefinition.maxDecimals);\n      }\n      // use default\n      return this.formatNumRef(val, 2);\n    },\n    getMinMaxDate(timeData) {\n      let timeMin = Math.min.apply(null, timeData.map((d) => d.toMillis()));\n      let timeMax = Math.max.apply(null, timeData.map((d) => d.toMillis()));\n      const buffer = (timeMax - timeMin) / timeData.length;\n      timeMin -= buffer;\n      timeMax += buffer;\n      return [timeMin, timeMax];\n    },\n    chartOptions() {\n      const indicatorCode = this.indicatorObject.indicator;\n      const reference = Number.parseFloat(this.indicatorObject.referenceValue);\n      let timeMinMax = this.getMinMaxDate(this.indicatorObject.time);\n      const annotations = [];\n      let low = 0;\n      let high = 0;\n      const defaultAnnotationSettings = {\n        type: 'line',\n        mode: 'horizontal',\n        scaleID: 'y-axis-0',\n        borderColor: 'rgba(0, 0, 255, 0.5)',\n        borderWidth: 2,\n        borderDash: [2, 3],\n        scales: {\n          xAxes: [{\n            type: 'time',\n            time: {\n              unit: 'month',\n            },\n          }],\n        },\n        label: {\n          enabled: true,\n          fontStyle: 'normal',\n          paddingX: 2,\n          paddingY: 2,\n          backgroundColor: 'rgba(255, 255, 255, 0.7)',\n          fontColor: 'rgba(0, 0, 0, 0.8)',\n        },\n      };\n      if (!Number.isNaN(reference)\n        && !['E10a1', 'E10a2', 'E10a5', 'E10a6', 'E10a7', 'E10a9', 'N4c', 'E8', 'E13e', 'E13f', 'E13g', 'E13h', 'E13i', 'E13l', 'E13m', 'E12c', 'E12d']\n          .includes(indicatorCode)) {\n        annotations.push({\n          ...defaultAnnotationSettings,\n          label: {\n            ...defaultAnnotationSettings.label,\n            content: `reference: ${this.formatNumRef(reference)}`,\n          },\n          value: reference,\n        });\n      }\n      if (['E4'].includes(indicatorCode)) {\n        low = 0.2 * reference;\n        annotations.push({\n          ...defaultAnnotationSettings,\n          borderColor: 'rgba(50, 252, 0, 0.5)',\n          value: low,\n          label: {\n            ...defaultAnnotationSettings.label,\n            content: `on/off: ${this.formatNumRef(low)}`,\n          },\n        });\n      } else if (['E11', 'E1a', 'E1', 'E2', 'E2_S2', 'E1a_S2', 'E1_S2'].includes(indicatorCode)) {\n        if (indicatorCode === 'E11') {\n          low = 0.3 * reference;\n          high = 0.7 * reference;\n        } else if (['E1a', 'E1', 'E2', 'E2_S2', 'E1a_S2', 'E1_S2'].includes(indicatorCode)) {\n          low = 0.7 * reference;\n          high = 1.3 * reference;\n        }\n        annotations.push({\n          ...defaultAnnotationSettings,\n          value: low,\n          label: {\n            ...defaultAnnotationSettings.label,\n            content: `low: ${this.formatNumRef(low)}`,\n          },\n        });\n        annotations.push({\n          ...defaultAnnotationSettings,\n          value: high,\n          label: {\n            ...defaultAnnotationSettings.label,\n            content: `high: ${this.formatNumRef(high)}`,\n          },\n        });\n      }\n\n      // Introduce background area annotations for lockdown times, does not\n      // work for all chart types, so we make sure it is not any of those charts\n      if (!['E10a3', 'E10a8', 'N2', 'E12c', 'E12d', 'GSA'].includes(indicatorCode)) {\n        // Find country based on alpha-3 code\n        const currCountry = countries.features.find(\n          (cntr) => cntr.properties.alpha2 === this.indicatorObject.country,\n        );\n        if (typeof currCountry !== 'undefined'\n          && Object.prototype.hasOwnProperty.call(lockdownTimes, currCountry.id)) {\n          const lckTs = lockdownTimes[currCountry.id]['C7_Restrictions on internal movement'];\n          for (let i = 0; i < lckTs.length; i++) {\n            let areaColor = 'rgba(0, 0, 0, 0.0)';\n            if (lckTs[i].value === 1) {\n              areaColor = 'rgba(204, 143, 143, 0.24)';\n            } else if (lckTs[i].value === 2) {\n              areaColor = 'rgba(207, 109, 109, 0.54)';\n            }\n            // We also have special date handling for some chart types as we\n            // simulate year agnostic rendering, so we convert all dates to\n            // one year\n            let start = DateTime.fromISO(lckTs[i].start);\n            let end = DateTime.fromISO(lckTs[i].end);\n            if (['E10a2', 'E10a6', 'E10a7', 'E10c', 'E8', 'E13e', 'E13f', 'E13g', 'E13h', 'E13i', 'E13l', 'E13m'].includes(indicatorCode)) {\n              start = start.set({ year: 2000 });\n              end = end.set({ year: 2000 });\n            }\n            if (lckTs[i].value !== 0) {\n              annotations.push({\n                drawTime: 'beforeDatasetsDraw',\n                type: 'box',\n                xScaleID: 'x-axis-0',\n                xMin: start.toISODate(),\n                xMax: end.toISODate(),\n                borderColor: areaColor,\n                borderWidth: 0,\n                backgroundColor: areaColor,\n              });\n            }\n          }\n        }\n      }\n\n      let xAxes = {};\n      if (!['E10a1', 'E10a2', 'E10a3', 'E10a5', 'E10a6', 'E10a7', 'E10a8', 'E10c', 'E12c', 'E12d', 'N2'].includes(indicatorCode)) {\n        xAxes = [{\n          type: 'time',\n          time: {\n            unit: 'week',\n          },\n          ticks: {\n            min: timeMinMax[0],\n            max: timeMinMax[1],\n          },\n          barThickness: 'flex',\n        }];\n        if (!['N3', 'N3b'].includes(indicatorCode)) {\n          xAxes[0].distribution = 'series';\n        }\n      }\n\n      if (['E10a2', 'E10a6', 'E10a7', 'E10c', 'E8', 'E13e', 'E13f', 'E13g', 'E13h', 'E13i', 'E13l', 'E13m'].includes(indicatorCode)) {\n        /* Recalculate to get min max months in data converted to one year */\n        timeMinMax = this.getMinMaxDate(\n          this.indicatorObject.time.map((date) => (\n            date.set({ year: 2000 })\n          )),\n        );\n        /* Check also for reference time */\n        const refTimeMinMax = this.getMinMaxDate(\n          this.indicatorObject.referenceTime.map((date) => (\n            date.set({ year: 2000 })\n          )),\n        );\n        xAxes = [{\n          type: 'time',\n          time: {\n            unit: 'month',\n            displayFormats: {\n              month: 'MMM',\n            },\n            tooltipFormat: 'dd. MMM',\n          },\n          ticks: {\n            min: (timeMinMax[0] < refTimeMinMax[0]) ? timeMinMax[0] : refTimeMinMax[0],\n            max: (timeMinMax[1] > refTimeMinMax[1]) ? timeMinMax[1] : refTimeMinMax[1],\n          },\n        }];\n      }\n\n      if (['N2'].includes(indicatorCode)) {\n        timeMinMax = this.getMinMaxDate(\n          this.indicatorObject.time.map((date) => (\n            date.set({ year: 2000 })\n          )),\n        );\n        xAxes = [{\n          type: 'time',\n          time: {\n            unit: 'month',\n            displayFormats: {\n              month: 'MMM',\n            },\n            tooltipFormat: 'dd. MMM',\n          },\n          distribution: 'series',\n          ticks: {\n            min: timeMinMax[0],\n            max: timeMinMax[1],\n          },\n        }];\n      }\n\n      if (['E12c', 'E12d'].includes(indicatorCode)) {\n        xAxes = [{\n          type: 'time',\n          time: {\n            unit: 'year',\n            displayFormats: {\n              year: 'yyyy',\n            },\n            tooltipFormat: 'yyyy-MM-dd - yyyy-06-30',\n          },\n          distribution: 'series',\n          ticks: {\n            min: timeMinMax[0],\n            max: timeMinMax[1],\n          },\n        }];\n      }\n\n      if (['E13d', 'E13n', 'C1', 'C2', 'C3'].includes(indicatorCode)) {\n        xAxes = [{\n          type: 'time',\n          time: {\n            unit: 'month',\n            displayFormats: {\n              month: 'MMM yy',\n            },\n            tooltipFormat: 'MMM yyyy',\n          },\n          distribution: 'series',\n          ticks: {\n            min: timeMinMax[0],\n            max: timeMinMax[1],\n          },\n        }];\n      }\n\n\n      let plugins = {\n        datalabels: {\n          display: false,\n        },\n      };\n\n      const yAxes = [{\n        scaleLabel: {\n          display: true,\n          labelString: this.indicatorObject.yAxis,\n          padding: 2,\n        },\n        ticks: {\n          lineHeight: 1,\n          suggestedMin: Math.min(\n            ...this.indicatorObject.measurement\n              .filter((d) => !Number.isNaN(d)),\n          ) - 1,\n          suggestedMax: Math.max(\n            ...this.indicatorObject.measurement\n              .filter((d) => !Number.isNaN(d)),\n          ) + 1,\n        },\n      }];\n\n      // This indicator has an array of values so we need to calculate min/max\n      // different\n      if (['E10a9'].includes(indicatorCode)) {\n        const measFlat = this.indicatorObject.measurement.flat();\n        yAxes[0].ticks.suggestedMin = Math.min(...measFlat);\n        yAxes[0].ticks.suggestedMax = Math.max(...measFlat);\n      }\n\n      const legend = {\n        labels: {\n          generateLabels: (chart) => {\n            const { datasets } = chart.data;\n            const { labels } = chart.legend.options;\n            const { usePointStyle } = labels;\n            const overrideStyle = labels.pointStyle;\n            let labelSet = chart._getSortedDatasetMetas();\n            labelSet = labelSet.filter((meta) => {\n              let includeLabel = false;\n              if (Object.prototype.hasOwnProperty.call(datasets[meta.index], 'label')) {\n                includeLabel = !datasets[meta.index].label.startsWith('hide_');\n              }\n              return includeLabel;\n            });\n            const labelObjects = labelSet.map((meta) => {\n              const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\n              const borderWidth = 2;\n              let hidden = false;\n              if (meta.hidden === true) {\n                hidden = true;\n              }\n              return {\n                text: datasets[meta.index].label,\n                fillStyle: style.backgroundColor,\n                hidden,\n                lineCap: style.borderCapStyle,\n                lineDash: style.borderDash,\n                lineDashOffset: style.borderDashOffset,\n                lineJoin: style.borderJoinStyle,\n                lineWidth: borderWidth,\n                strokeStyle: style.borderColor,\n                pointStyle: overrideStyle || style.pointStyle,\n                rotation: style.rotation,\n                // Below is extra data used for toggling the datasets\n                datasetIndex: meta.index,\n              };\n            }, this);\n            // Now we add our default 2 lockdown labels but we exclude indicators\n            // where it is not applicable\n            if (!['E10a1', 'E10a5', 'E10a8', 'N2', 'N4c', 'E12c', 'E12d', 'GSA', 'N1']\n              .includes(this.indicatorObject.indicator)) {\n              labelObjects.push({\n                text: 'Low Restrictions',\n                fillStyle: 'rgba(204, 143, 143, 0.24)',\n                hidden: false,\n                lineWidth: 0,\n                datasetIndex: -1,\n              });\n              labelObjects.push({\n                text: 'High Restrictions',\n                fillStyle: 'rgba(207, 109, 109, 0.54)',\n                hidden: false,\n                lineWidth: 0,\n                datasetIndex: -1,\n              });\n            }\n            return labelObjects;\n          },\n        },\n      };\n\n      if (['N4c'].includes(indicatorCode)) {\n        xAxes = [{\n          stacked: true,\n        }];\n        yAxes[0].stacked = true;\n        yAxes[0].ticks.beginAtZero = true;\n        yAxes[0].ticks.suggestedMin = Math.min(\n          ...this.indicatorObject.measurement\n            .filter((d) => !Number.isNaN(d)),\n        );\n        yAxes[0].ticks.suggestedMax = Math.max(\n          ...this.indicatorObject.measurement\n            .filter((d) => !Number.isNaN(d)),\n        );\n      }\n\n      if (['E12b'].includes(indicatorCode)) {\n        // update used yaxis chart max to be max value\n        yAxes[0].ticks.suggestedMax = Math.max(\n          ...this.indicatorObject.measurement\n            .filter((d) => !Number.isNaN(d)),\n        );\n      }\n\n      if (['E12b', 'E1a', 'E1', 'E2', 'E2_S2', 'E1a_S2', 'E1_S2', 'E13d'].includes(indicatorCode)) {\n      // update used yaxis chart min to be min value\n        yAxes[0].ticks.suggestedMin = Math.min(\n          ...this.indicatorObject.measurement\n            .filter((d) => !Number.isNaN(d)),\n        );\n      }\n      if (['CV', 'OW'].includes(indicatorCode)) {\n        yAxes[0].ticks.beginAtZero = true;\n        yAxes[0].ticks = {\n          lineHeight: 1,\n          suggestedMin: Math.min(\n            ...this.indicatorObject.measurement\n              .filter((d) => !Number.isNaN(d)),\n          ),\n          suggestedMax: Math.max(\n            ...this.indicatorObject.measurement\n              .filter((d) => !Number.isNaN(d)),\n          ),\n        };\n      }\n\n      if (['E10a1', 'E10a5'].includes(indicatorCode)) {\n        yAxes[0].ticks.beginAtZero = true;\n        plugins = {\n          datalabels: {\n            labels: {\n              value: {\n                anchor: 'end',\n                align: 'end',\n                offset: 10,\n                formatter: (value, context) => {\n                  let labelRes = '';\n                  const percentage = context.chart.data.datasets[context.datasetIndex]\n                    .indLabels[context.dataIndex];\n                  if (!['', '/'].includes(percentage)) {\n                    const percVal = Number((percentage * 100).toPrecision(4));\n                    if (percVal > 0) {\n                      labelRes = `+${percVal}%`;\n                    } else {\n                      labelRes = `${percVal}%`;\n                    }\n                  }\n                  return labelRes;\n                },\n                color: (context) => {\n                  let color = 'red';\n                  if (context.chart.data.datasets[context.datasetIndex]\n                    .indLabels[context.dataIndex] > 0) {\n                    color = 'green';\n                  }\n                  return color;\n                },\n              },\n              title: {\n                color: 'black',\n                anchor: 'end',\n                align: 'end',\n                offset: -6,\n                formatter: (value) => value.toFixed(1),\n              },\n            },\n          },\n        };\n      }\n      if (['E8'].includes(indicatorCode)) {\n        yAxes[0].ticks.suggestedMin = Math.min(\n          ...this.indicatorObject.measurement\n            .filter((d) => !Number.isNaN(d)),\n        );\n        yAxes[0].ticks.suggestedMax = Math.max(\n          ...this.indicatorObject.measurement\n            .filter((d) => !Number.isNaN(d)),\n        );\n      }\n      if (['E9'].includes(indicatorCode)) {\n        yAxes[0].ticks.suggestedMin = 0;\n        yAxes[0].ticks.suggestedMax = Math.max(\n          ...this.indicatorObject.measurement\n            .filter((d) => !Number.isNaN(d)),\n        );\n      }\n      if (['E10a6', 'E10a7'].includes(indicatorCode)) {\n        yAxes[0].ticks.beginAtZero = true;\n        plugins = {\n          datalabels: {\n            labels: {\n              title: {\n                color: (context) => context.dataset.backgroundColor,\n                font: {\n                  size: 10,\n                },\n                anchor: 'end',\n                align: 'end',\n                offset: (context) => {\n                  if (context.chart.data.datasets.length === 2) {\n                    if (context.datasetIndex === 0) {\n                      if (!Number.isNaN(context.chart.data.datasets[1].data[context.dataIndex].y)\n                        && context.chart.data.datasets[0].data[context.dataIndex].y\n                        > context.chart.data.datasets[1].data[context.dataIndex].y) {\n                        return 0;\n                      }\n                      return -28;\n                    }\n                    if (!Number.isNaN(context.chart.data.datasets[0].data[context.dataIndex].y)\n                      && context.chart.data.datasets[0].data[context.dataIndex].y\n                      > context.chart.data.datasets[1].data[context.dataIndex].y) {\n                      return -28;\n                    }\n                    return 0;\n                  }\n                  return 0;\n                },\n                formatter: (value) => `${value.y.toFixed(1)}%`,\n              },\n            },\n          },\n        };\n      }\n\n      if (['N2', 'E12c', 'E12d'].includes(indicatorCode)) {\n        yAxes[0].ticks.beginAtZero = true;\n      }\n\n      if (['E10a3', 'E10a8'].includes(indicatorCode)) {\n        yAxes[0].ticks = {\n          suggestedMin: Number.NaN,\n          suggestedMax: Number.NaN,\n          padding: -20,\n        };\n      }\n      if (['E10c', 'E10a2', 'E10a6', 'E10a7'].includes(indicatorCode)) {\n        yAxes[0].ticks.suggestedMin += 1;\n        yAxes[0].ticks.suggestedMax -= 1;\n      }\n\n      if (['N3'].includes(indicatorCode)) {\n        yAxes[0].type = 'myLogScale';\n        if (this.indicatorObject.aoiID === 'ES19') {\n          yAxes[0].min = 0.02;\n          yAxes[0].max = 1;\n        }\n        yAxes[0].ticks = {\n          callback: (...args) => {\n            const value = Chart.Ticks.formatters.logarithmic.call(this, ...args);\n            if (value.length) {\n              return Number(value).toLocaleString();\n            }\n            return value;\n          },\n        };\n        legend.labels.usePointStyle = true;\n        legend.labels.boxWidth = 5;\n        legend.onClick = function onClick(e, legendItem) {\n          if (legendItem.text === 'Standard deviation (STD)') {\n            const masterIndex = legendItem.datasetIndex;\n            const slaveIndex = 3;\n            const ci = this.chart;\n            const masterMeta = ci.getDatasetMeta(masterIndex);\n            const meta = ci.getDatasetMeta(slaveIndex);\n            if (masterMeta.hidden === null) {\n              masterMeta.hidden = true;\n              meta.hidden = true;\n            } else {\n              masterMeta.hidden = !masterMeta.hidden;\n              meta.hidden = !meta.hidden;\n            }\n            ci.update();\n          } else {\n            Chart.defaults.global.legend.onClick.call(this, e, legendItem);\n          }\n        };\n      }\n\n      const defaultSettings = {\n        responsive: true,\n        maintainAspectRatio: false,\n        plugins,\n        legend,\n        scales: {\n          xAxes,\n          yAxes,\n        },\n        pan: {\n          enabled: true,\n          mode: 'x',\n        },\n        zoom: {\n          enabled: true,\n          mode: 'x',\n        },\n        tooltips: {\n          callbacks: {\n            label: function (context, data) { // eslint-disable-line\n              let label = data.datasets[context.datasetIndex].label || '';\n              if (label) {\n                label += ': ';\n              }\n              label += this.roundValueInd(Number(context.value));\n              return label;\n            }.bind(this),\n          },\n        },\n      };\n\n      if (['N3'].includes(indicatorCode)) {\n        defaultSettings.tooltips = {\n          callbacks: {\n            label: (context) => {\n              const { datasets } = this.datacollection;\n              const val = datasets[context.datasetIndex].data[context.index];\n              return `Value (Log10): ${Math.log10(val).toPrecision(4)}`;\n            },\n          },\n        };\n      }\n\n      if (['E10a3'].includes(indicatorCode)) {\n        defaultSettings.geo = {\n          radiusScale: {\n            display: true,\n            size: [1, 20],\n          },\n        };\n\n        defaultSettings.scale = {\n          projection: 'mercator',\n        };\n\n        defaultSettings.pan.mode = 'xy';\n        defaultSettings.zoom.mode = 'xy';\n        defaultSettings.legend.display = false;\n\n        defaultSettings.tooltips = {\n          callbacks: {\n            label: (context) => {\n              const { datasets } = this.datacollection;\n              const obj = datasets[context.datasetIndex].data[context.index];\n              return obj.name;\n            },\n            footer: (context) => {\n              const { datasets } = this.datacollection;\n              const obj = datasets[context[0].datasetIndex].data[context[0].index];\n              const refT = obj.referenceTime;\n              const refV = Number(obj.referenceValue);\n              const labelOutput = [\n                `${obj.time.toISODate()}:  ${obj.value.toPrecision(4)}`,\n                `${refT.toISODate()}:  ${refV.toPrecision(4)}`,\n              ];\n              if (refV !== 0) {\n                labelOutput.push(\n                  `${(((obj.value - refV) / refV) * 100).toPrecision(2)} %`,\n                );\n              }\n              return labelOutput;\n            },\n          },\n        };\n      }\n\n      if (['E10a8'].includes(indicatorCode)) {\n        defaultSettings.geo = {\n          radiusScale: {\n            display: true,\n            range: [5, 25],\n            ticks: {\n              max: 2000000,\n            },\n          },\n        };\n\n        defaultSettings.scale = {\n          projection: 'mercator',\n          max: 20,\n        };\n\n        defaultSettings.pan.mode = 'xy';\n        defaultSettings.zoom.mode = 'xy';\n        defaultSettings.legend.display = false;\n\n        defaultSettings.tooltips = {\n          callbacks: {\n            label: (context) => {\n              const { datasets } = this.datacollection;\n              const obj = datasets[context.datasetIndex].data[context.index];\n              return obj.name;\n            },\n            footer: (context) => {\n              const { datasets } = this.datacollection;\n              const obj = datasets[context[0].datasetIndex].data[context[0].index];\n              const refV = Number(obj.referenceValue);\n              const labelOutput = [\n                `${obj.time.toISODate()}:`,\n                `${(refV).toPrecision(4)} % harvested`,\n                `${(100 - refV).toPrecision(4)} % not harvested`,\n                `Max. area: ${obj.value} ha`,\n              ];\n              return labelOutput;\n            },\n          },\n        };\n      }\n\n      return {\n        ...defaultSettings,\n        annotation: {\n          annotations,\n        },\n      };\n    },\n  },\n};\n</script>\n\n<style lang=\"scss\" scoped>\n.md-body {\n  font-size: small;\n}\n::v-deep .mdi-asterisk {\n  visibility: hidden;\n}\n</style>\n"]}]}