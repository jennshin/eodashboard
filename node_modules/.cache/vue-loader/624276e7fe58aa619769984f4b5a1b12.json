{"remainingRequest":"/Users/8ps/Downloads/eodash-staging/app/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/8ps/Downloads/eodash-staging/app/src/components/IndicatorData.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/8ps/Downloads/eodash-staging/app/src/components/IndicatorData.vue","mtime":1624532486000},{"path":"/Users/8ps/Downloads/eodash-staging/app/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/8ps/Downloads/eodash-staging/app/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/8ps/Downloads/eodash-staging/app/node_modules/vuetify-loader/lib/loader.js","mtime":1574476662000},{"path":"/Users/8ps/Downloads/eodash-staging/app/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/8ps/Downloads/eodash-staging/app/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCB7IERhdGVUaW1lIH0gZnJvbSAnbHV4b24nOwppbXBvcnQgewogIG1hcFN0YXRlLAp9IGZyb20gJ3Z1ZXgnOwppbXBvcnQgQmFyQ2hhcnQgZnJvbSAnQC9jb21wb25lbnRzL0JhckNoYXJ0LnZ1ZSc7CmltcG9ydCBMaW5lQ2hhcnQgZnJvbSAnQC9jb21wb25lbnRzL0xpbmVDaGFydC52dWUnOwppbXBvcnQgTWFwQ2hhcnQgZnJvbSAnQC9jb21wb25lbnRzL01hcENoYXJ0LnZ1ZSc7CmltcG9ydCBOVVRTIGZyb20gJ0AvYXNzZXRzL05VVFNfUkdfMDNNXzIwMTZfNDMyNl9FU0wyLURFTDMuanNvbic7CmltcG9ydCBsb2NrZG93blRpbWVzIGZyb20gJ0AvYXNzZXRzL2xvY2tkb3duX2RhdGEuanNvbic7CmltcG9ydCBjb3VudHJpZXMgZnJvbSAnQC9hc3NldHMvY291bnRyaWVzLmpzb24nOwoKZXhwb3J0IGRlZmF1bHQgewogIHByb3BzOiBbCiAgICAnY3VycmVudEluZGljYXRvcicsCiAgXSwKICBjb21wb25lbnRzOiB7CiAgICBCYXJDaGFydCwKICAgIExpbmVDaGFydCwKICAgIE1hcENoYXJ0LAogIH0sCiAgZGF0YSgpIHsKICAgIHJldHVybiB7CiAgICAgIGRhdGFMYXllclRpbWU6IG51bGwsCiAgICAgIGRhdGFMYXllckluZGV4OiAwLAogICAgfTsKICB9LAogIG1vdW50ZWQoKSB7CiAgICBjb25zdCBkID0gdGhpcy5pbmRpY2F0b3JPYmplY3QudGltZVt0aGlzLmluZGljYXRvck9iamVjdC50aW1lLmxlbmd0aCAtIDFdOwogICAgdGhpcy5kYXRhTGF5ZXJUaW1lID0gZC50b0Zvcm1hdCgnZGQuIE1NTScpOwogIH0sCiAgY29tcHV0ZWQ6IHsKICAgIC4uLm1hcFN0YXRlKCdjb25maWcnLCBbJ2FwcENvbmZpZycsICdiYXNlQ29uZmlnJ10pLAogICAgYXJyYXlPZk9iamVjdHMoKSB7CiAgICAgIGNvbnN0IGluZGljYXRvciA9IHsgLi4udGhpcy5pbmRpY2F0b3JPYmplY3QgfTsKICAgICAgY29uc3QgaW5kaWNhdG9yQ29kZSA9IGluZGljYXRvci5pbmRpY2F0b3I7CiAgICAgIGNvbnN0IHNlbGVjdGlvbk9wdGlvbnMgPSBbXTsKICAgICAgaWYgKFsnRTEwYTMnLCAnRTEwYTgnXS5pbmNsdWRlcyhpbmRpY2F0b3JDb2RlKSkgewogICAgICAgIC8vIEZpbmQgYWxsIHVuaXF1ZSBkYXkvbW9udGggYXZhaWxhYmxlCiAgICAgICAgY29uc3QgdGltZXNldCA9IG5ldyBTZXQoCiAgICAgICAgICBpbmRpY2F0b3IudGltZS5tYXAoKGQpID0+IGQudG9Gb3JtYXQoJ2RkLiBNTU0nKSksCiAgICAgICAgKTsKICAgICAgICB0aW1lc2V0LmZvckVhY2goKHQpID0+IHsKICAgICAgICAgIHNlbGVjdGlvbk9wdGlvbnMucHVzaCh7CiAgICAgICAgICAgIHZhbHVlOiB0LAogICAgICAgICAgICBuYW1lOiB0LAogICAgICAgICAgfSk7CiAgICAgICAgfSk7CiAgICAgIH0KICAgICAgcmV0dXJuIHNlbGVjdGlvbk9wdGlvbnM7CiAgICB9LAogICAgZGF0YWNvbGxlY3Rpb24oKSB7CiAgICAgIGNvbnN0IGluZGljYXRvciA9IHsgLi4udGhpcy5pbmRpY2F0b3JPYmplY3QgfTsKICAgICAgY29uc3QgaW5kaWNhdG9yQ29kZSA9IGluZGljYXRvci5pbmRpY2F0b3I7CiAgICAgIGxldCBkYXRhQ29sbGVjdGlvbjsKICAgICAgY29uc3QgcmVmQ29sb3JzID0gWwogICAgICAgICcjMjJhYTk5JywgJyNhMzcnLCAnIzQ3YScsICcjYTY3JywgJyMyODMnLCAnI2JiYicsCiAgICAgICAgJyM2Y2UnLCAnIzk5NDQ5OScsICcjYWFhYTExJywgJyM2NjMzY2MnLCAnI2U2NzMwMCcsCiAgICAgIF07CiAgICAgIGlmIChpbmRpY2F0b3IpIHsKICAgICAgICBsZXQgbGFiZWxzID0gW107CiAgICAgICAgY29uc3QgeyBtZWFzdXJlbWVudCB9ID0gaW5kaWNhdG9yOwogICAgICAgIGNvbnN0IGNvbG9ycyA9IFtdOwogICAgICAgIGNvbnN0IGRhdGFzZXRzID0gW107CiAgICAgICAgaWYgKFsnRTEwYTEnLCAnRTEwYTUnXS5pbmNsdWRlcyhpbmRpY2F0b3JDb2RlKSkgewogICAgICAgICAgY29uc3QgcmVmZXJlbmNlVmFsdWUgPSBpbmRpY2F0b3IucmVmZXJlbmNlVmFsdWUubWFwKE51bWJlcik7CiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGljYXRvci50aW1lLmxlbmd0aDsgaSArPSAxKSB7CiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzTmFOKGluZGljYXRvci50aW1lW2ldLnRvTWlsbGlzKCkpKSB7CiAgICAgICAgICAgICAgY29uc3QgZCA9IGluZGljYXRvci50aW1lW2ldOwogICAgICAgICAgICAgIGNvbnN0IGZvcm1hdHRlZERhdGUgPSBkLnRvRm9ybWF0KCdkZC4gTU1NJyk7CiAgICAgICAgICAgICAgbGFiZWxzLnB1c2goZm9ybWF0dGVkRGF0ZSk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgbGFiZWxzLnB1c2goaSk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGNvbnN0IGxhYmVscmVmID0gJzIwMTknOwogICAgICAgICAgY29uc3QgbGFiZWxtZWFzID0gJzIwMjAnOwogICAgICAgICAgZGF0YXNldHMucHVzaCh7CiAgICAgICAgICAgIGluZExhYmVsczogQXJyYXkoaW5kaWNhdG9yLmluZGljYXRvclZhbHVlLmxlbmd0aCkuam9pbignLicpLnNwbGl0KCcuJyksCiAgICAgICAgICAgIGxhYmVsOiBsYWJlbHJlZiwKICAgICAgICAgICAgZGF0YTogcmVmZXJlbmNlVmFsdWUsCiAgICAgICAgICAgIGZpbGw6IGZhbHNlLAogICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdncmV5JywKICAgICAgICAgIH0pOwogICAgICAgICAgZGF0YXNldHMucHVzaCh7CiAgICAgICAgICAgIGluZExhYmVsczogaW5kaWNhdG9yLmluZGljYXRvclZhbHVlLAogICAgICAgICAgICBsYWJlbDogbGFiZWxtZWFzLAogICAgICAgICAgICBkYXRhOiBtZWFzdXJlbWVudCwKICAgICAgICAgICAgZmlsbDogZmFsc2UsCiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ2JsYWNrJywKICAgICAgICAgIH0pOwogICAgICAgIH0gZWxzZSBpZiAoWydFMTBhOSddLmluY2x1ZGVzKGluZGljYXRvckNvZGUpKSB7CiAgICAgICAgICBjb25zdCBjYXRlZ29yaWVzID0gWwogICAgICAgICAgICAnTmF0aW9uYWwgV29ya2VycycsCiAgICAgICAgICAgICdGb3JlaWduIFdvcmtlcnMnLAogICAgICAgICAgICAnVW5rbm93bicsCiAgICAgICAgICBdOwogICAgICAgICAgY2F0ZWdvcmllcy5mb3JFYWNoKChrZXksIGlkeCkgPT4gewogICAgICAgICAgICBjb25zdCBkYXRhID0gaW5kaWNhdG9yLm1lYXN1cmVtZW50Lm1hcCgocm93LCByb3dJZHgpID0+ICh7CiAgICAgICAgICAgICAgdDogaW5kaWNhdG9yLnRpbWVbcm93SWR4XSwKICAgICAgICAgICAgICB5OiByb3dbaWR4XSwKICAgICAgICAgICAgfSkpOwogICAgICAgICAgICBkYXRhc2V0cy5wdXNoKHsKICAgICAgICAgICAgICBsYWJlbDoga2V5LAogICAgICAgICAgICAgIGRhdGEsCiAgICAgICAgICAgICAgZmlsbDogZmFsc2UsCiAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IHJlZkNvbG9yc1tpZHhdLAogICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogcmVmQ29sb3JzW2lkeF0sCiAgICAgICAgICAgICAgY3ViaWNJbnRlcnBvbGF0aW9uTW9kZTogJ21vbm90b25lJywKICAgICAgICAgICAgICBib3JkZXJXaWR0aDogMSwKICAgICAgICAgICAgICBwb2ludFJhZGl1czogMiwKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9KTsKICAgICAgICB9IGVsc2UgaWYgKFsnR0cnXS5pbmNsdWRlcyhpbmRpY2F0b3JDb2RlKSkgewogICAgICAgICAgY29uc3QgdmFscyA9IGluZGljYXRvci5WYWx1ZXM7CiAgICAgICAgICBjb25zdCBkYXRhc2V0c09iaiA9IHsKICAgICAgICAgICAgZ3JvY2VyeTogW10sCiAgICAgICAgICAgIHBhcmtzOiBbXSwKICAgICAgICAgICAgcmVzaWRlbnRpYWw6IFtdLAogICAgICAgICAgICByZXRhaWxfcmVjcmVhdGlvbjogW10sCiAgICAgICAgICAgIHRyYW5zaXRfc3RhdGlvbnM6IFtdLAogICAgICAgICAgfTsKICAgICAgICAgIGZvciAobGV0IGVudHJ5ID0gMDsgZW50cnkgPCB2YWxzLmxlbmd0aDsgZW50cnkgKz0gMSkgewogICAgICAgICAgICBjb25zdCB0ID0gRGF0ZVRpbWUuZnJvbUlTTyh2YWxzW2VudHJ5XS5kYXRlKTsKICAgICAgICAgICAgZGF0YXNldHNPYmouZ3JvY2VyeS5wdXNoKHsgdCwgeTogdmFsc1tlbnRyeV0uZ3JvY2VyeSB9KTsKICAgICAgICAgICAgZGF0YXNldHNPYmoucGFya3MucHVzaCh7IHQsIHk6IHZhbHNbZW50cnldLnBhcmtzIH0pOwogICAgICAgICAgICBkYXRhc2V0c09iai5yZXNpZGVudGlhbC5wdXNoKHsgdCwgeTogdmFsc1tlbnRyeV0ucmVzaWRlbnRpYWwgfSk7CiAgICAgICAgICAgIGRhdGFzZXRzT2JqLnJldGFpbF9yZWNyZWF0aW9uLnB1c2goeyB0LCB5OiB2YWxzW2VudHJ5XS5yZXRhaWxfcmVjcmVhdGlvbiB9KTsKICAgICAgICAgICAgZGF0YXNldHNPYmoudHJhbnNpdF9zdGF0aW9ucy5wdXNoKHsgdCwgeTogdmFsc1tlbnRyeV0udHJhbnNpdF9zdGF0aW9ucyB9KTsKICAgICAgICAgIH0KICAgICAgICAgIE9iamVjdC5rZXlzKGRhdGFzZXRzT2JqKS5mb3JFYWNoKChrZXksIGlkeCkgPT4gewogICAgICAgICAgICBkYXRhc2V0cy5wdXNoKHsKICAgICAgICAgICAgICBsYWJlbDoga2V5LAogICAgICAgICAgICAgIGRhdGE6IGRhdGFzZXRzT2JqW2tleV0sCiAgICAgICAgICAgICAgZmlsbDogZmFsc2UsCiAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IHJlZkNvbG9yc1tpZHhdLAogICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogcmVmQ29sb3JzW2lkeF0sCiAgICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDEsCiAgICAgICAgICAgICAgcG9pbnRSYWRpdXM6IDIsCiAgICAgICAgICAgICAgY3ViaWNJbnRlcnBvbGF0aW9uTW9kZTogJ21vbm90b25lJywKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9KTsKICAgICAgICB9IGVsc2UgaWYgKFsnR1NBJ10uaW5jbHVkZXMoaW5kaWNhdG9yQ29kZSkpIHsKICAgICAgICAgIGNvbnN0IHZhbHMgPSBPYmplY3Qua2V5cyhpbmRpY2F0b3IudmFsdWVzKTsKICAgICAgICAgIGNvbnN0IGRhdGFzZXRzT2JqID0ge307CiAgICAgICAgICBmb3IgKGxldCBlbnRyeSA9IDA7IGVudHJ5IDwgdmFscy5sZW5ndGg7IGVudHJ5ICs9IDEpIHsKICAgICAgICAgICAgZGF0YXNldHNPYmpbdmFsc1tlbnRyeV1dID0gW107CiAgICAgICAgICAgIGNvbnN0IGN1cnJWYWxzID0gaW5kaWNhdG9yLnZhbHVlc1t2YWxzW2VudHJ5XV0udmFsdWVzOwogICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1cnJWYWxzLmxlbmd0aDsgaSArPSAxKSB7CiAgICAgICAgICAgICAgZGF0YXNldHNPYmpbdmFsc1tlbnRyeV1dLnB1c2goewogICAgICAgICAgICAgICAgdDogRGF0ZVRpbWUuZnJvbUlTTyhjdXJyVmFsc1tpXS50aW1lc3RhbXApLAogICAgICAgICAgICAgICAgeTogTnVtYmVyKGN1cnJWYWxzW2ldLndhaXRpbmdfdGltZSksCiAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgLy8gSXQgc2VlbXMgc29tZSB0aW1zdGFtcHMgYXJlIG1peGVkIGluIG9yZGVyIHNvIGxldCB1cyBzb3J0IGJ5IGRhdGUKICAgICAgICAgICAgLy8gdG8gZ2V0IG5pY2UgbGluZSBjb25uZWN0aW9ucyB0aHJvdWdoIHRoZSB0aW1lbGluZQogICAgICAgICAgICBkYXRhc2V0c09ialt2YWxzW2VudHJ5XV0uc29ydCgoYSwgYikgPT4gYS50LnRvTWlsbGlzKCkgLSBiLnQudG9NaWxsaXMoKSk7CiAgICAgICAgICB9CiAgICAgICAgICBPYmplY3Qua2V5cyhpbmRpY2F0b3IudmFsdWVzKS5mb3JFYWNoKChrZXksIGlkeCkgPT4gewogICAgICAgICAgICBkYXRhc2V0cy5wdXNoKHsKICAgICAgICAgICAgICBsYWJlbDoga2V5LAogICAgICAgICAgICAgIGRhdGE6IGRhdGFzZXRzT2JqW2tleV0sCiAgICAgICAgICAgICAgZmlsbDogZmFsc2UsCiAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IHJlZkNvbG9yc1tpZHhdLAogICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogcmVmQ29sb3JzW2lkeF0sCiAgICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDEsCiAgICAgICAgICAgICAgcG9pbnRSYWRpdXM6IDIsCiAgICAgICAgICAgICAgY3ViaWNJbnRlcnBvbGF0aW9uTW9kZTogJ21vbm90b25lJywKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9KTsKICAgICAgICB9IGVsc2UgaWYgKFsnQ1YnXS5pbmNsdWRlcyhpbmRpY2F0b3JDb2RlKSkgewogICAgICAgICAgY29uc3QgdmFscyA9IGluZGljYXRvci5WYWx1ZXM7CiAgICAgICAgICBjb25zdCBkYXRhc2V0c09iaiA9IHsKICAgICAgICAgICAgY29uZmlybWVkOiBbXSwKICAgICAgICAgIH07CiAgICAgICAgICBmb3IgKGxldCBlbnRyeSA9IDA7IGVudHJ5IDwgdmFscy5sZW5ndGg7IGVudHJ5ICs9IDEpIHsKICAgICAgICAgICAgY29uc3QgdCA9IERhdGVUaW1lLmZyb21JU08odmFsc1tlbnRyeV0uZGF0ZSk7CiAgICAgICAgICAgIGRhdGFzZXRzT2JqLmNvbmZpcm1lZC5wdXNoKHsgdCwgeTogTnVtYmVyKHZhbHNbZW50cnldLmNvbmZpcm1lZCkgfSk7CiAgICAgICAgICB9CiAgICAgICAgICBPYmplY3Qua2V5cyhkYXRhc2V0c09iaikuZm9yRWFjaCgoa2V5LCBpZHgpID0+IHsKICAgICAgICAgICAgZGF0YXNldHMucHVzaCh7CiAgICAgICAgICAgICAgbGFiZWw6IGtleSwKICAgICAgICAgICAgICBkYXRhOiBkYXRhc2V0c09ialtrZXldLAogICAgICAgICAgICAgIGZpbGw6IGZhbHNlLAogICAgICAgICAgICAgIGJvcmRlckNvbG9yOiByZWZDb2xvcnNbaWR4XSwKICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHJlZkNvbG9yc1tpZHhdLAogICAgICAgICAgICAgIGJvcmRlcldpZHRoOiAxLAogICAgICAgICAgICAgIHBvaW50UmFkaXVzOiAyLAogICAgICAgICAgICAgIGN1YmljSW50ZXJwb2xhdGlvbk1vZGU6ICdtb25vdG9uZScsCiAgICAgICAgICAgIH0pOwogICAgICAgICAgfSk7CiAgICAgICAgfSBlbHNlIGlmIChbJ09XJ10uaW5jbHVkZXMoaW5kaWNhdG9yQ29kZSkpIHsKICAgICAgICAgIGNvbnN0IHZhbHMgPSBpbmRpY2F0b3IuVmFsdWVzOwogICAgICAgICAgY29uc3QgcEkgPSBbCiAgICAgICAgICAgICd0b3RhbF92YWNjaW5hdGlvbnMnLCAncGVvcGxlX2Z1bGx5X3ZhY2NpbmF0ZWQnLAogICAgICAgICAgICAnZGFpbHlfdmFjY2luYXRpb25zJywKICAgICAgICAgIF07CiAgICAgICAgICBjb25zdCBkYXRhc2V0c09iaiA9IHt9OwogICAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgcEkubGVuZ3RoOyBpZHggKz0gMSkgewogICAgICAgICAgICBkYXRhc2V0c09ialtwSVtpZHhdXSA9IFtdOwogICAgICAgICAgfQogICAgICAgICAgZm9yIChsZXQgZW50cnkgPSAwOyBlbnRyeSA8IHZhbHMubGVuZ3RoOyBlbnRyeSArPSAxKSB7CiAgICAgICAgICAgIGNvbnN0IHQgPSBEYXRlVGltZS5mcm9tSVNPKHZhbHNbZW50cnldLmRhdGUpOwogICAgICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBwSS5sZW5ndGg7IGlkeCArPSAxKSB7CiAgICAgICAgICAgICAgZGF0YXNldHNPYmpbcElbaWR4XV0ucHVzaCh7IHQsIHk6IHZhbHNbZW50cnldW3BJW2lkeF1dIH0pOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgICBPYmplY3Qua2V5cyhkYXRhc2V0c09iaikuZm9yRWFjaCgoa2V5LCBpZHgpID0+IHsKICAgICAgICAgICAgZGF0YXNldHMucHVzaCh7CiAgICAgICAgICAgICAgbGFiZWw6IGtleSwKICAgICAgICAgICAgICBkYXRhOiBkYXRhc2V0c09ialtrZXldLAogICAgICAgICAgICAgIGZpbGw6IGZhbHNlLAogICAgICAgICAgICAgIGJvcmRlckNvbG9yOiByZWZDb2xvcnNbaWR4XSwKICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHJlZkNvbG9yc1tpZHhdLAogICAgICAgICAgICAgIGJvcmRlcldpZHRoOiAxLAogICAgICAgICAgICAgIHBvaW50UmFkaXVzOiAyLAogICAgICAgICAgICAgIGN1YmljSW50ZXJwb2xhdGlvbk1vZGU6ICdtb25vdG9uZScsCiAgICAgICAgICAgIH0pOwogICAgICAgICAgfSk7CiAgICAgICAgfSBlbHNlIGlmIChbJ04zYiddLmluY2x1ZGVzKGluZGljYXRvckNvZGUpKSB7CiAgICAgICAgICBjb25zdCBzZW5zb3JzID0gQXJyYXkuZnJvbShuZXcgU2V0KGluZGljYXRvci5lb1NlbnNvcikpLnNvcnQoKTsKICAgICAgICAgIGZvciAobGV0IHBwID0gMDsgcHAgPCBzZW5zb3JzLmxlbmd0aDsgcHAgKz0gMSkgewogICAgICAgICAgICBjb25zdCBwS2V5ID0gc2Vuc29yc1twcF07CiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBpbmRpY2F0b3IudGltZS5tYXAoKGRhdGUsIGkpID0+IHsKICAgICAgICAgICAgICBsZXQgb3V0cHV0ID0gbnVsbDsKICAgICAgICAgICAgICBpZiAoaW5kaWNhdG9yLmVvU2Vuc29yW2ldID09PSBwS2V5KSB7CiAgICAgICAgICAgICAgICBvdXRwdXQgPSB7IHQ6IGRhdGUsIHk6IG1lYXN1cmVtZW50W2ldIH07CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7CiAgICAgICAgICAgIH0pLmZpbHRlcigoZCkgPT4gZCAhPT0gbnVsbCk7CiAgICAgICAgICAgIGxldCBjb2xvclVzZWQgPSByZWZDb2xvcnNbcHBdOwogICAgICAgICAgICBpZiAodGhpcy5pbmREZWZpbml0aW9uLnNlbnNvckNvbG9yTWFwICYmIHRoaXMuaW5kRGVmaW5pdGlvbi5zZW5zb3JDb2xvck1hcFtwS2V5XSkgewogICAgICAgICAgICAgIGNvbG9yVXNlZCA9IHRoaXMuaW5kRGVmaW5pdGlvbi5zZW5zb3JDb2xvck1hcFtwS2V5XTsKICAgICAgICAgICAgfQogICAgICAgICAgICBkYXRhc2V0cy5wdXNoKHsKICAgICAgICAgICAgICBsYWJlbDogcEtleSwKICAgICAgICAgICAgICBkYXRhLAogICAgICAgICAgICAgIGZpbGw6IGZhbHNlLAogICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBjb2xvclVzZWQsCiAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjb2xvclVzZWQsCiAgICAgICAgICAgICAgY3ViaWNJbnRlcnBvbGF0aW9uTW9kZTogJ21vbm90b25lJywKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIGlmIChbJ040YyddLmluY2x1ZGVzKGluZGljYXRvckNvZGUpKSB7CiAgICAgICAgICBjb25zdCBtZWFzRGF0YSA9IGluZGljYXRvci5tZWFzdXJlbWVudC5tYXAoTnVtYmVyKTsKICAgICAgICAgIG1lYXNEYXRhLnNoaWZ0KCk7CiAgICAgICAgICBjb25zdCByZWZEYXRhID0gaW5kaWNhdG9yLnJlZmVyZW5jZVZhbHVlLm1hcChOdW1iZXIpOwogICAgICAgICAgcmVmRGF0YS5zaGlmdCgpOwoKICAgICAgICAgIGxhYmVscyA9IFsKICAgICAgICAgICAgaW5kaWNhdG9yLnJlZmVyZW5jZVRpbWVbMF0udG9JU09EYXRlKCksCiAgICAgICAgICAgIGluZGljYXRvci50aW1lWzBdLnRvSVNPRGF0ZSgpLAogICAgICAgICAgICBpbmRpY2F0b3IudGltZVs1XS50b0lTT0RhdGUoKSwKICAgICAgICAgIF07CgogICAgICAgICAgZGF0YXNldHMucHVzaCh7CiAgICAgICAgICAgIGxhYmVsOiAnbWV0YWxsaWMgd2FzdGUgYXJlYScsCiAgICAgICAgICAgIGRhdGE6IFtyZWZEYXRhWzBdLCBtZWFzRGF0YVswXSwgbWVhc0RhdGFbNV1dLAogICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHJlZkNvbG9yc1swXSwKICAgICAgICAgIH0pOwogICAgICAgICAgZGF0YXNldHMucHVzaCh7CiAgICAgICAgICAgIGxhYmVsOiAnbWl4ZWQgd2FzdGUgYXJlYScsCiAgICAgICAgICAgIGRhdGE6IFtyZWZEYXRhWzFdLCBtZWFzRGF0YVsxXSwgbWVhc0RhdGFbNl1dLAogICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHJlZkNvbG9yc1sxXSwKICAgICAgICAgIH0pOwogICAgICAgICAgZGF0YXNldHMucHVzaCh7CiAgICAgICAgICAgIGxhYmVsOiAncGxhc3RpYyB3YXN0ZSBhcmVhJywKICAgICAgICAgICAgZGF0YTogW3JlZkRhdGFbMl0sIG1lYXNEYXRhWzJdLCBtZWFzRGF0YVs3XV0sCiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogcmVmQ29sb3JzWzJdLAogICAgICAgICAgfSk7CiAgICAgICAgICBkYXRhc2V0cy5wdXNoKHsKICAgICAgICAgICAgbGFiZWw6ICdzb2lsIHdhc3RlIGFyZWEnLAogICAgICAgICAgICBkYXRhOiBbcmVmRGF0YVszXSwgbWVhc0RhdGFbM10sIG1lYXNEYXRhWzhdXSwKICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiByZWZDb2xvcnNbM10sCiAgICAgICAgICB9KTsKICAgICAgICB9IGVsc2UgaWYgKFsnRTEwYTInLCAnRTEwYTYnLCAnRTEwYTcnLCAnRTgnLCAnRTEzZScsICdFMTNmJywgJ0UxM2cnLCAnRTEzaCcsICdFMTNpJywgJ0UxM2wnLCAnRTEzbSddLmluY2x1ZGVzKGluZGljYXRvckNvZGUpKSB7CiAgICAgICAgICBjb25zdCB1bmlxdWVSZWZzID0gW107CiAgICAgICAgICBjb25zdCB1bmlxdWVNZWFzID0gW107CiAgICAgICAgICBjb25zdCByZWZlcmVuY2VWYWx1ZSA9IGluZGljYXRvci5yZWZlcmVuY2VWYWx1ZS5tYXAoTnVtYmVyKTsKICAgICAgICAgIGluZGljYXRvci50aW1lLmZvckVhY2goKGRhdGUsIGkpID0+IHsKICAgICAgICAgICAgY29uc3QgbWVhcyA9IHsgdDogZGF0ZS5zZXQoeyB5ZWFyOiAyMDAwIH0pLCB5OiBtZWFzdXJlbWVudFtpXSB9OwogICAgICAgICAgICBpZiAodHlwZW9mIHVuaXF1ZVJlZnMuZmluZCgoaXRlbSkgPT4gaXRlbS50LmVxdWFscyhtZWFzLnQpKSA9PT0gJ3VuZGVmaW5lZCcpIHsKICAgICAgICAgICAgICB1bmlxdWVNZWFzLnB1c2gobWVhcyk7CiAgICAgICAgICAgIH0KICAgICAgICAgIH0pOwogICAgICAgICAgaW5kaWNhdG9yLnJlZmVyZW5jZVRpbWUuZm9yRWFjaCgoZGF0ZSwgaSkgPT4gewogICAgICAgICAgICBpZiAoIVsnJywgJy8nXS5pbmNsdWRlcyhpbmRpY2F0b3IucmVmZXJlbmNlVmFsdWVbaV0pKSB7CiAgICAgICAgICAgICAgY29uc3QgcmVmID0geyB0OiBkYXRlLnNldCh7IHllYXI6IDIwMDAgfSksIHk6IHJlZmVyZW5jZVZhbHVlW2ldIH07CiAgICAgICAgICAgICAgaWYgKHR5cGVvZiB1bmlxdWVSZWZzLmZpbmQoKGl0ZW0pID0+IGl0ZW0udC5lcXVhbHMocmVmLnQpKSA9PT0gJ3VuZGVmaW5lZCcpIHsKICAgICAgICAgICAgICAgIHVuaXF1ZVJlZnMucHVzaChyZWYpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfSk7CiAgICAgICAgICBkYXRhc2V0cy5wdXNoKHsKICAgICAgICAgICAgbGFiZWw6ICcyMDIwJywKICAgICAgICAgICAgZGF0YTogdW5pcXVlTWVhcywKICAgICAgICAgICAgZmlsbDogZmFsc2UsCiAgICAgICAgICAgIGJvcmRlckNvbG9yOiByZWZDb2xvcnNbMV0sCiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogcmVmQ29sb3JzWzFdLAogICAgICAgICAgICBib3JkZXJXaWR0aDogMiwKICAgICAgICAgIH0pOwogICAgICAgICAgaWYgKHVuaXF1ZVJlZnMubGVuZ3RoID4gMCkgewogICAgICAgICAgICBkYXRhc2V0cy5wdXNoKHsKICAgICAgICAgICAgICBsYWJlbDogJzIwMTknLAogICAgICAgICAgICAgIGRhdGE6IHVuaXF1ZVJlZnMsCiAgICAgICAgICAgICAgZmlsbDogZmFsc2UsCiAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IHJlZkNvbG9yc1swXSwKICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHJlZkNvbG9yc1swXSwKICAgICAgICAgICAgICBib3JkZXJXaWR0aDogMiwKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIGlmIChbJ0UxM24nLCAnQzEnLCAnQzInLCAnQzMnXS5pbmNsdWRlcyhpbmRpY2F0b3JDb2RlKSkgewogICAgICAgICAgLy8gR3JvdXAgYnkgaW5kaWNhdG9yIHZhbHVlCiAgICAgICAgICBjb25zdCB0eXBlcyA9IHt9OwogICAgICAgICAgaW5kaWNhdG9yLmluZGljYXRvclZhbHVlLmZvckVhY2goKGluZCwgaWR4KSA9PiB7CiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyh0eXBlcykuaW5jbHVkZXMoaW5kKSkgewogICAgICAgICAgICAgIHR5cGVzW2luZF0ucHVzaCh7CiAgICAgICAgICAgICAgICB0OiBEYXRlVGltZS5mcm9tSVNPKGluZGljYXRvci50aW1lW2lkeF0pLAogICAgICAgICAgICAgICAgeTogTnVtYmVyKGluZGljYXRvci5tZWFzdXJlbWVudFtpZHhdKSwKICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICB0eXBlc1tpbmRdID0gW3sKICAgICAgICAgICAgICAgIHQ6IERhdGVUaW1lLmZyb21JU08oaW5kaWNhdG9yLnRpbWVbaWR4XSksCiAgICAgICAgICAgICAgICB5OiBOdW1iZXIoaW5kaWNhdG9yLm1lYXN1cmVtZW50W2lkeF0pLAogICAgICAgICAgICAgIH1dOwogICAgICAgICAgICB9CiAgICAgICAgICB9KTsKICAgICAgICAgIE9iamVjdC5rZXlzKHR5cGVzKS5mb3JFYWNoKChrZXksIGkpID0+IHsKICAgICAgICAgICAgZGF0YXNldHMucHVzaCh7CiAgICAgICAgICAgICAgbGFiZWw6IGtleSwKICAgICAgICAgICAgICBmaWxsOiBmYWxzZSwKICAgICAgICAgICAgICBkYXRhOiB0eXBlc1trZXldLAogICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogcmVmQ29sb3JzW2ldLAogICAgICAgICAgICAgIGJvcmRlckNvbG9yOiByZWZDb2xvcnNbaV0sCiAgICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDIsCiAgICAgICAgICAgIH0pOwogICAgICAgICAgfSk7CiAgICAgICAgfSBlbHNlIGlmIChbJ04yJywgJ0UxMGMnXS5pbmNsdWRlcyhpbmRpY2F0b3JDb2RlKSkgewogICAgICAgICAgLyogR3JvdXAgZGF0YSBieSB5ZWFyIGluIG1vbnRoIHNsaWNlcyAqLwogICAgICAgICAgY29uc3QgZGF0YSA9IGluZGljYXRvci50aW1lLm1hcCgoZGF0ZSwgaSkgPT4gewogICAgICAgICAgICBjb2xvcnMucHVzaCh0aGlzLmdldEluZGljYXRvckNvbG9yKGluZGljYXRvci5jb2xvckNvZGVbaV0pKTsKICAgICAgICAgICAgcmV0dXJuIHsgdDogZGF0ZSwgeTogbWVhc3VyZW1lbnRbaV0gfTsKICAgICAgICAgIH0pOwogICAgICAgICAgY29uc3QgZGF0YUdyb3VwcyA9IHt9OwogICAgICAgICAgY29uc3QgY29sb3JHcm91cHMgPSB7fTsKICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gMSkgewogICAgICAgICAgICBjb25zdCBjdXJyWWVhciA9IGRhdGFbaV0udC55ZWFyOwogICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGFHcm91cHMsIGN1cnJZZWFyKSkgewogICAgICAgICAgICAgIGRhdGFHcm91cHNbY3VyclllYXJdLnB1c2goewogICAgICAgICAgICAgICAgdDogZGF0YVtpXS50LnNldCh7IHllYXI6IDIwMDAgfSksCiAgICAgICAgICAgICAgICB5OiBbZGF0YVtpXS55XSwKICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICBjb2xvckdyb3Vwc1tjdXJyWWVhcl0ucHVzaChjb2xvcnNbaV0pOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgIGRhdGFHcm91cHNbY3VyclllYXJdID0gW3sKICAgICAgICAgICAgICAgIHQ6IGRhdGFbaV0udC5zZXQoeyB5ZWFyOiAyMDAwIH0pLAogICAgICAgICAgICAgICAgeTogW2RhdGFbaV0ueV0sCiAgICAgICAgICAgICAgfV07CiAgICAgICAgICAgICAgY29sb3JHcm91cHNbY3VyclllYXJdID0gW2NvbG9yc1tpXV07CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICAgIGNvbnN0IHVuaXF1ZVllYXJzID0gT2JqZWN0LmtleXMoZGF0YUdyb3Vwcyk7CiAgICAgICAgICB1bmlxdWVZZWFycy5zb3J0KCk7CiAgICAgICAgICBjb25zdCB5TGVuZ3RoID0gdW5pcXVlWWVhcnMubGVuZ3RoIC0gMTsKICAgICAgICAgIHVuaXF1ZVllYXJzLmZvckVhY2goKGtleSwgaSkgPT4gewogICAgICAgICAgICBkYXRhc2V0cy5wdXNoKHsKICAgICAgICAgICAgICAvLyBmaWxsIHdpdGggZW1wdHkgdmFsdWVzCiAgICAgICAgICAgICAgaW5kTGFiZWxzOiBBcnJheShkYXRhR3JvdXBzW2tleV0ubGVuZ3RoKS5qb2luKCcuJykuc3BsaXQoJy4nKSwKICAgICAgICAgICAgICBsYWJlbDoga2V5LAogICAgICAgICAgICAgIGZpbGw6IGZhbHNlLAogICAgICAgICAgICAgIGRhdGE6IGRhdGFHcm91cHNba2V5XSwKICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHJlZkNvbG9yc1t5TGVuZ3RoIC0gaV0sCiAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IHJlZkNvbG9yc1t5TGVuZ3RoIC0gaV0sCiAgICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDIsCiAgICAgICAgICAgIH0pOwogICAgICAgICAgfSk7CiAgICAgICAgfSBlbHNlIGlmIChbJ04xJ10uaW5jbHVkZXMoaW5kaWNhdG9yQ29kZSkpIHsKICAgICAgICAgIGNvbnN0IHN0ZERldk1pbiA9IFtdOwogICAgICAgICAgY29uc3Qgc3RkRGV2TWF4ID0gW107CiAgICAgICAgICBjb25zdCBtaW4gPSBbXTsKICAgICAgICAgIGNvbnN0IG1heCA9IFtdOwogICAgICAgICAgY29uc3QgbWVkaWFuID0gW107CiAgICAgICAgICBjb25zdCBkYXRhID0gW107CiAgICAgICAgICBpbmRpY2F0b3IucmVmZXJlbmNlVmFsdWUuZm9yRWFjaCgoaXRlbSwgaSkgPT4gewogICAgICAgICAgICBjb25zdCB0ID0gaW5kaWNhdG9yLnRpbWVbaV07CiAgICAgICAgICAgIGRhdGEucHVzaCh7IHk6IG1lYXN1cmVtZW50W2ldLCB0IH0pOwogICAgICAgICAgICBpZiAoIU51bWJlci5pc05hTihpdGVtKSAmJiAhWydOYU4nLCAnLyddLmluY2x1ZGVzKGl0ZW0pKSB7CiAgICAgICAgICAgICAgY29uc3Qgb2JqID0gSlNPTi5wYXJzZShpdGVtKTsKICAgICAgICAgICAgICAvLyBbbWVkaWFuLHN0ZCxtYXgsbWluLHBlcmNlbnRhZ2UgdmFsaWQgcGl4ZWxzXQogICAgICAgICAgICAgIG1lZGlhbi5wdXNoKHsgeTogb2JqWzBdLCB0IH0pOwogICAgICAgICAgICAgIGlmIChvYmpbMV0gIT09IG51bGwpIHsKICAgICAgICAgICAgICAgIHN0ZERldk1pbi5wdXNoKHsgeTogbWVhc3VyZW1lbnRbaV0gLSBvYmpbMV0sIHQgfSk7CiAgICAgICAgICAgICAgICBzdGREZXZNYXgucHVzaCh7IHk6IG1lYXN1cmVtZW50W2ldICsgb2JqWzFdLCB0IH0pOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBtYXgucHVzaCh7IHk6IG9ialsyXSwgdCB9KTsKICAgICAgICAgICAgICBtaW4ucHVzaCh7IHk6IG9ialszXSwgdCB9KTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBtZWRpYW4ucHVzaCh7IHk6IE51bWJlci5OYU4sIHQgfSk7CiAgICAgICAgICAgICAgc3RkRGV2TWluLnB1c2goeyB5OiBOdW1iZXIuTmFOLCB0IH0pOwogICAgICAgICAgICAgIHN0ZERldk1heC5wdXNoKHsgeTogTnVtYmVyLk5hTiwgdCB9KTsKICAgICAgICAgICAgICBtYXgucHVzaCh7IHk6IE51bWJlci5OYU4sIHQgfSk7CiAgICAgICAgICAgICAgbWluLnB1c2goeyB5OiBOdW1iZXIuTmFOLCB0IH0pOwogICAgICAgICAgICB9CiAgICAgICAgICB9KTsKICAgICAgICAgIGRhdGFzZXRzLnB1c2goewogICAgICAgICAgICBsYWJlbDogaW5kaWNhdG9yLnlBeGlzLAogICAgICAgICAgICBkYXRhLAogICAgICAgICAgICBmaWxsOiBmYWxzZSwKICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiByZWZDb2xvcnNbMF0sCiAgICAgICAgICAgIGJvcmRlckNvbG9yOiByZWZDb2xvcnNbMF0sCiAgICAgICAgICAgIHNwYW5HYXBzOiBmYWxzZSwKICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDIsCiAgICAgICAgICB9KTsKICAgICAgICAgIC8vIENoZWNrIGZvciBlbXB0eSBhcnJheSwgaWYgaXQgaXMgdGhlIGNhc2UgZG8gbm90IGluY2x1ZGUgZGF0YQogICAgICAgICAgaWYgKHR5cGVvZiAobWVkaWFuLmZpbmQoKGEpID0+IGEueSAhPT0gbnVsbCkpICE9PSAndW5kZWZpbmVkJykgewogICAgICAgICAgICBkYXRhc2V0cy5wdXNoKHsKICAgICAgICAgICAgICBsYWJlbDogJ01lZGlhbicsCiAgICAgICAgICAgICAgZGF0YTogbWVkaWFuLAogICAgICAgICAgICAgIGZpbGw6IGZhbHNlLAogICAgICAgICAgICAgIHBvaW50UmFkaXVzOiAwLAogICAgICAgICAgICAgIGJvcmRlckNvbG9yOiAnYmxhY2snLAogICAgICAgICAgICAgIGJvcmRlcldpZHRoOiAxLAogICAgICAgICAgICAgIHBvaW50U3R5bGU6ICdsaW5lJywKICAgICAgICAgICAgICBzcGFuR2FwczogZmFsc2UsCiAgICAgICAgICAgIH0pOwogICAgICAgICAgfQogICAgICAgICAgLy8gQ2hlY2sgZm9yIGVtcHR5IGFycmF5LCBpZiBpdCBpcyB0aGUgY2FzZSBkbyBub3QgaW5jbHVkZSBkYXRhCiAgICAgICAgICBpZiAodHlwZW9mIChtaW4uZmluZCgoYSkgPT4gYS55ICE9PSBudWxsKSkgIT09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgICAgIGRhdGFzZXRzLnB1c2goewogICAgICAgICAgICAgIGxhYmVsOiAnTWluJywKICAgICAgICAgICAgICBkYXRhOiBtaW4sCiAgICAgICAgICAgICAgZmlsbDogZmFsc2UsCiAgICAgICAgICAgICAgcG9pbnRSYWRpdXM6IDAsCiAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiByZWZDb2xvcnNbNF0sCiAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IHJlZkNvbG9yc1s0XSwKICAgICAgICAgICAgICBib3JkZXJXaWR0aDogMSwKICAgICAgICAgICAgICBwb2ludFN0eWxlOiAnbGluZScsCiAgICAgICAgICAgICAgc3BhbkdhcHM6IGZhbHNlLAogICAgICAgICAgICB9KTsKICAgICAgICAgIH0KICAgICAgICAgIC8vIENoZWNrIGZvciBlbXB0eSBhcnJheSwgaWYgaXQgaXMgdGhlIGNhc2UgZG8gbm90IGluY2x1ZGUgZGF0YQogICAgICAgICAgaWYgKHR5cGVvZiAobWF4LmZpbmQoKGEpID0+IGEueSAhPT0gbnVsbCkpICE9PSAndW5kZWZpbmVkJykgewogICAgICAgICAgICBkYXRhc2V0cy5wdXNoKHsKICAgICAgICAgICAgICBsYWJlbDogJ01heCcsCiAgICAgICAgICAgICAgZGF0YTogbWF4LAogICAgICAgICAgICAgIGZpbGw6IGZhbHNlLAogICAgICAgICAgICAgIHBvaW50UmFkaXVzOiAwLAogICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogcmVmQ29sb3JzWzFdLAogICAgICAgICAgICAgIGJvcmRlckNvbG9yOiByZWZDb2xvcnNbMV0sCiAgICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDEsCiAgICAgICAgICAgICAgcG9pbnRTdHlsZTogJ2xpbmUnLAogICAgICAgICAgICAgIHNwYW5HYXBzOiBmYWxzZSwKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9CiAgICAgICAgICAvLyBDaGVjayBmb3IgZW1wdHkgYXJyYXksIGlmIGl0IGlzIHRoZSBjYXNlIGRvIG5vdCBpbmNsdWRlIGRhdGEKICAgICAgICAgIGlmICh0eXBlb2YgKHN0ZERldk1heC5maW5kKChhKSA9PiBhLnkgIT09IG51bGwpKSAhPT0gJ3VuZGVmaW5lZCcpIHsKICAgICAgICAgICAgZGF0YXNldHMucHVzaCh7CiAgICAgICAgICAgICAgbGFiZWw6ICdTdGFuZGFyZCBkZXZpYXRpb24gKFNURCknLAogICAgICAgICAgICAgIGRhdGE6IHN0ZERldk1heCwKICAgICAgICAgICAgICBmaWxsOiAnKzEnLAogICAgICAgICAgICAgIHBvaW50UmFkaXVzOiAwLAogICAgICAgICAgICAgIHNwYW5HYXBzOiBmYWxzZSwKICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDAuMSknLAogICAgICAgICAgICAgIGJvcmRlckNvbG9yOiAncmdiYSgwLDAsMCwwLjApJywKICAgICAgICAgICAgICBwb2ludFN0eWxlOiAncmVjdCcsCiAgICAgICAgICAgIH0pOwogICAgICAgICAgfQogICAgICAgICAgLy8gQ2hlY2sgZm9yIGVtcHR5IGFycmF5LCBpZiBpdCBpcyB0aGUgY2FzZSBkbyBub3QgaW5jbHVkZSBkYXRhCiAgICAgICAgICBpZiAodHlwZW9mIChzdGREZXZNaW4uZmluZCgoYSkgPT4gYS55ICE9PSBudWxsKSkgIT09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgICAgIGRhdGFzZXRzLnB1c2goewogICAgICAgICAgICAgIGxhYmVsOiAnaGlkZV8nLAogICAgICAgICAgICAgIGRhdGE6IHN0ZERldk1pbiwKICAgICAgICAgICAgICBmaWxsOiAnLTEnLAogICAgICAgICAgICAgIHBvaW50UmFkaXVzOiAwLAogICAgICAgICAgICAgIHNwYW5HYXBzOiBmYWxzZSwKICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDAuMCknLAogICAgICAgICAgICAgIGJvcmRlckNvbG9yOiAncmdiYSgwLDAsMCwwLjApJywKICAgICAgICAgICAgICBwb2ludFN0eWxlOiAncmVjdCcsCiAgICAgICAgICAgIH0pOwogICAgICAgICAgfQogICAgICAgIH0gZWxzZSBpZiAoWydOMyddLmluY2x1ZGVzKGluZGljYXRvckNvZGUpKSB7CiAgICAgICAgICBsZXQgcmVmZXJlbmNlVmFsdWUgPSBbXTsKICAgICAgICAgIGNvbnN0IHN0ZERldiA9IFtdOwogICAgICAgICAgaW5kaWNhdG9yLnJlZmVyZW5jZVZhbHVlLmZvckVhY2goKGl0ZW0pID0+IHsKICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4oaXRlbSkgJiYgIVsnTmFOJywgJ1tOYU4gTmFOXScsICcvJ10uaW5jbHVkZXMoaXRlbSkpIHsKICAgICAgICAgICAgICBjb25zdCBvYmogPSBKU09OLnBhcnNlKGl0ZW0ucmVwbGFjZSgvLC9nLCAnLicpLnJlcGxhY2UoJyAnLCAnLCcpKTsKICAgICAgICAgICAgICBpZiAob2JqWzBdICE9PSAtOTk5ICYmIG9ialsxXSAhPT0gLTk5OSkgewogICAgICAgICAgICAgICAgcmVmZXJlbmNlVmFsdWUucHVzaChvYmpbMF0pOwogICAgICAgICAgICAgICAgc3RkRGV2LnB1c2gob2JqWzFdKTsKICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgcmVmZXJlbmNlVmFsdWUucHVzaChOdW1iZXIuTmFOKTsKICAgICAgICAgICAgICAgIHN0ZERldi5wdXNoKE51bWJlci5OYU4pOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICByZWZlcmVuY2VWYWx1ZS5wdXNoKE51bWJlci5OYU4pOwogICAgICAgICAgICAgIHN0ZERldi5wdXNoKE51bWJlci5OYU4pOwogICAgICAgICAgICB9CiAgICAgICAgICB9KTsKCiAgICAgICAgICBjb25zdCBzdGREZXZNYXggPSBzdGREZXYubWFwKChkZXYsIGkpID0+ICgKICAgICAgICAgICAgTnVtYmVyLmlzTmFOKHJlZmVyZW5jZVZhbHVlW2ldKQogICAgICAgICAgICAgID8gTnVtYmVyLk5hTgogICAgICAgICAgICAgIDogKDEwICoqIChyZWZlcmVuY2VWYWx1ZVtpXSArIGRldikpCiAgICAgICAgICApKTsKICAgICAgICAgIGNvbnN0IHN0ZERldk1pbiA9IHN0ZERldi5tYXAoKGRldiwgaSkgPT4gKAogICAgICAgICAgICBOdW1iZXIuaXNOYU4ocmVmZXJlbmNlVmFsdWVbaV0pCiAgICAgICAgICAgICAgPyBOdW1iZXIuTmFOCiAgICAgICAgICAgICAgOiAoMTAgKiogKHJlZmVyZW5jZVZhbHVlW2ldIC0gZGV2KSkKICAgICAgICAgICkpOwoKICAgICAgICAgIHJlZmVyZW5jZVZhbHVlID0gcmVmZXJlbmNlVmFsdWUubWFwKCh2YWwpID0+ICgKICAgICAgICAgICAgTnVtYmVyLmlzTmFOKHZhbCkgPyBOdW1iZXIuTmFOIDogKDEwICoqIHZhbCkKICAgICAgICAgICkpOwoKICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kaWNhdG9yLnRpbWUubGVuZ3RoOyBpICs9IDEpIHsKICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4oaW5kaWNhdG9yLnRpbWVbaV0udG9NaWxsaXMoKSkpIHsKICAgICAgICAgICAgICBsYWJlbHMucHVzaChpbmRpY2F0b3IudGltZVtpXS50b0lTT0RhdGUoKSk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgbGFiZWxzLnB1c2goaSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgbGV0IGNvbG9yQ29kZSA9ICcnOwogICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGluZGljYXRvciwgJ2NvbG9yQ29kZScpKSB7CiAgICAgICAgICAgICAgY29sb3JDb2RlID0gaW5kaWNhdG9yLmNvbG9yQ29kZVtpXTsKICAgICAgICAgICAgfQogICAgICAgICAgICBjb2xvcnMucHVzaCh0aGlzLmdldEluZGljYXRvckNvbG9yKGNvbG9yQ29kZSkpOwogICAgICAgICAgfQoKICAgICAgICAgIGRhdGFzZXRzLnB1c2goewogICAgICAgICAgICBsYWJlbDogJ1dlZWtseSBjbGltYXRvbG9neSBvZiBjaGxvcm9waHlsbCBjb25jLiAoQ0hMX2NsaW0pIDIwMTctMjAxOScsCiAgICAgICAgICAgIGRhdGE6IHJlZmVyZW5jZVZhbHVlLAogICAgICAgICAgICBmaWxsOiBmYWxzZSwKICAgICAgICAgICAgcG9pbnRSYWRpdXM6IDAsCiAgICAgICAgICAgIGJvcmRlckNvbG9yOiAnYmxhY2snLAogICAgICAgICAgICBwb2ludFN0eWxlOiAnbGluZScsCiAgICAgICAgICAgIHNwYW5HYXBzOiBmYWxzZSwKICAgICAgICAgIH0pOwogICAgICAgICAgZGF0YXNldHMucHVzaCh7CiAgICAgICAgICAgIGxhYmVsOiAnU3RhbmRhcmQgZGV2aWF0aW9uIChTVEQpJywKICAgICAgICAgICAgZGF0YTogc3RkRGV2TWF4LAogICAgICAgICAgICBmaWxsOiAnKzEnLAogICAgICAgICAgICBwb2ludFJhZGl1czogMCwKICAgICAgICAgICAgc3BhbkdhcHM6IGZhbHNlLAogICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDAsMCwwLDAuMSknLAogICAgICAgICAgICBib3JkZXJDb2xvcjogJ3JnYmEoMCwwLDAsMC4wKScsCiAgICAgICAgICAgIHBvaW50U3R5bGU6ICdyZWN0JywKICAgICAgICAgIH0pOwogICAgICAgICAgZGF0YXNldHMucHVzaCh7CiAgICAgICAgICAgIGxhYmVsOiAnaGlkZV8nLAogICAgICAgICAgICBkYXRhOiBzdGREZXZNaW4sCiAgICAgICAgICAgIGZpbGw6ICctMScsCiAgICAgICAgICAgIHBvaW50UmFkaXVzOiAwLAogICAgICAgICAgICBzcGFuR2FwczogZmFsc2UsCiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMC4wKScsCiAgICAgICAgICAgIGJvcmRlckNvbG9yOiAncmdiYSgwLDAsMCwwLjApJywKICAgICAgICAgICAgcG9pbnRTdHlsZTogJ3JlY3QnLAogICAgICAgICAgfSk7CgogICAgICAgICAgLy8gRmluZCB1bmlxdWUgaW5kaWNhdG9yIHZhbHVlcwogICAgICAgICAgY29uc3QgaW5kaWNhdG9yVmFsdWVzID0ge307CiAgICAgICAgICBpbmRpY2F0b3IuaW5kaWNhdG9yVmFsdWUubWFwKCh2YWwsIGkpID0+IHsKICAgICAgICAgICAgbGV0IGtleSA9IHZhbC50b0xvd2VyQ2FzZSgpOwogICAgICAgICAgICBrZXkgPSBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc2xpY2UoMSk7CiAgICAgICAgICAgIGlmICghWycnLCAnLyddLmluY2x1ZGVzKGtleSkgJiYgdHlwZW9mIGluZGljYXRvclZhbHVlc1trZXldID09PSAndW5kZWZpbmVkJykgewogICAgICAgICAgICAgIGluZGljYXRvclZhbHVlc1trZXldID0gdGhpcy5nZXRJbmRpY2F0b3JDb2xvcigKICAgICAgICAgICAgICAgIGluZGljYXRvci5jb2xvckNvZGVbaV0sCiAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgfQogICAgICAgICAgICByZXR1cm4gbnVsbDsKICAgICAgICAgIH0pOwoKICAgICAgICAgIE9iamVjdC5lbnRyaWVzKGluZGljYXRvclZhbHVlcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7CiAgICAgICAgICAgIGNvbnN0IGN1cnJNZWFzID0gbWVhc3VyZW1lbnQubWFwKChyb3csIGkpID0+IHsKICAgICAgICAgICAgICBsZXQgdmFsID0gcm93OwogICAgICAgICAgICAgIGlmIChpbmRpY2F0b3IuaW5kaWNhdG9yVmFsdWVbaV0gIT09IGtleS50b1VwcGVyQ2FzZSgpKSB7CiAgICAgICAgICAgICAgICB2YWwgPSBOYU47CiAgICAgICAgICAgICAgfQogICAgICAgICAgICAgIHJldHVybiB2YWw7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgICBkYXRhc2V0cy5wdXNoKHsKICAgICAgICAgICAgICBsYWJlbDoga2V5LAogICAgICAgICAgICAgIGRhdGE6IGN1cnJNZWFzLm1hcCgodmFsKSA9PiAoCiAgICAgICAgICAgICAgICBOdW1iZXIuaXNOYU4odmFsKSA/IE51bWJlci5OYU4gOiAoMTAgKiogdmFsKQogICAgICAgICAgICAgICkpLAogICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdmFsdWUsCiAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6IHZhbHVlLAogICAgICAgICAgICAgIGZpbGw6IGZhbHNlLAogICAgICAgICAgICAgIHNob3dMaW5lOiBmYWxzZSwKICAgICAgICAgICAgICBzcGFuR2FwczogZmFsc2UsCiAgICAgICAgICAgIH0pOwogICAgICAgICAgfSk7CiAgICAgICAgfSBlbHNlIGlmIChbJ04xYScsICdOMWInLCAnTjFjJywgJ04xZCcsICdFMTJiJ10uaW5jbHVkZXMoaW5kaWNhdG9yQ29kZSkpIHsKICAgICAgICAgIGNvbnN0IG1heFJlZiA9IFtdOwogICAgICAgICAgY29uc3QgbWluUmVmID0gW107CiAgICAgICAgICBjb25zdCBtZWFuN2RSZWYgPSBbXTsKICAgICAgICAgIGNvbnN0IG1lYW43ZDIwMjAgPSBbXTsKICAgICAgICAgIGluZGljYXRvci5yZWZlcmVuY2VWYWx1ZS5mb3JFYWNoKChpdGVtLCBpKSA9PiB7CiAgICAgICAgICAgIGNvbnN0IHQgPSBpbmRpY2F0b3IudGltZVtpXTsKICAgICAgICAgICAgaWYgKCFbJycsICcvJ10uaW5jbHVkZXMoaXRlbSkpIHsKICAgICAgICAgICAgICBjb25zdCBvYmogPSBpdGVtLnJlcGxhY2UoL1tbXF0gXS9nLCAnJykuc3BsaXQoJywnKQogICAgICAgICAgICAgICAgLm1hcCgoc3RyKSA9PiAoc3RyID09PSAnJyA/IE51bWJlci5OYU4gOiBOdW1iZXIoc3RyKSkpOwogICAgICAgICAgICAgIG1heFJlZi5wdXNoKHsgeTogb2JqWzBdLCB0IH0pOwogICAgICAgICAgICAgIG1pblJlZi5wdXNoKHsgeTogb2JqWzFdLCB0IH0pOwogICAgICAgICAgICAgIG1lYW43ZFJlZi5wdXNoKHsgeTogb2JqWzJdLCB0IH0pOwogICAgICAgICAgICAgIG1lYW43ZDIwMjAucHVzaCh7IHk6IG9ialszXSwgdCB9KTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICBtYXhSZWYucHVzaCh7IHk6IE51bWJlci5OYU4sIHQgfSk7CiAgICAgICAgICAgICAgbWluUmVmLnB1c2goeyB5OiBOdW1iZXIuTmFOLCB0IH0pOwogICAgICAgICAgICAgIG1lYW43ZFJlZi5wdXNoKHsgeTogTnVtYmVyLk5hTiwgdCB9KTsKICAgICAgICAgICAgICBtZWFuN2QyMDIwLnB1c2goeyB5OiBOdW1iZXIuTmFOLCB0IH0pOwogICAgICAgICAgICB9CiAgICAgICAgICB9KTsKCiAgICAgICAgICBkYXRhc2V0cy5wdXNoKHsKICAgICAgICAgICAgbGFiZWw6ICdWYWx1ZScsCiAgICAgICAgICAgIGRhdGE6IG1lYXN1cmVtZW50Lm1hcCgobWVhcywgaSkgPT4gKHsgeTogbWVhcywgdDogaW5kaWNhdG9yLnRpbWVbaV0gfSkpLAogICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDI1NSwyNTUsMjU1LDAuMCknLAogICAgICAgICAgICBib3JkZXJDb2xvcjogJ3JlZCcsCiAgICAgICAgICAgIHNwYW5HYXBzOiBmYWxzZSwKICAgICAgICAgICAgcG9pbnRSYWRpdXM6IDAsCiAgICAgICAgICAgIGJvcmRlcldpZHRoOiAxLjUsCiAgICAgICAgICB9KTsKICAgICAgICAgIGRhdGFzZXRzLnB1c2goewogICAgICAgICAgICBsYWJlbDogJzctZGF5IG1lYW4nLAogICAgICAgICAgICBkYXRhOiBtZWFuN2QyMDIwLAogICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDI1NSwyNTUsMjU1LDAuMCknLAogICAgICAgICAgICBwb2ludFJhZGl1czogMCwKICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICdyZWQnLAogICAgICAgICAgICBzcGFuR2FwczogZmFsc2UsCiAgICAgICAgICAgIGJvcmRlckRhc2g6IFs2LCAzXSwKICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDIsCiAgICAgICAgICB9KTsKICAgICAgICAgIGRhdGFzZXRzLnB1c2goewogICAgICAgICAgICBsYWJlbDogJzIwMTctMjAxOSA3ZCBtZWFuJywKICAgICAgICAgICAgZGF0YTogbWVhbjdkUmVmLAogICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdyZ2JhKDI1NSwyNTUsMjU1LDAuMCknLAogICAgICAgICAgICBwb2ludFJhZGl1czogMCwKICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICdncmV5JywKICAgICAgICAgICAgc3BhbkdhcHM6IGZhbHNlLAogICAgICAgICAgICBib3JkZXJEYXNoOiBbNiwgM10sCiAgICAgICAgICAgIGJvcmRlcldpZHRoOiAyLAogICAgICAgICAgfSk7CiAgICAgICAgICBkYXRhc2V0cy5wdXNoKHsKICAgICAgICAgICAgbGFiZWw6ICcyMDE3LTIwMTkgcmFuZ2UnLAogICAgICAgICAgICBkYXRhOiBtYXhSZWYsCiAgICAgICAgICAgIGZpbGw6IDQsCiAgICAgICAgICAgIHBvaW50UmFkaXVzOiAwLAogICAgICAgICAgICBzcGFuR2FwczogZmFsc2UsCiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3JnYmEoMCwwLDAsMC4yKScsCiAgICAgICAgICAgIGJvcmRlckNvbG9yOiAncmdiYSgwLDAsMCwwLjApJywKICAgICAgICAgICAgcG9pbnRTdHlsZTogJ3JlY3QnLAogICAgICAgICAgfSk7CiAgICAgICAgICBkYXRhc2V0cy5wdXNoKHsKICAgICAgICAgICAgbGFiZWw6ICdoaWRlXycsCiAgICAgICAgICAgIGRhdGE6IG1pblJlZiwKICAgICAgICAgICAgZmlsbDogMywKICAgICAgICAgICAgcG9pbnRSYWRpdXM6IDAsCiAgICAgICAgICAgIHNwYW5HYXBzOiBmYWxzZSwKICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLDAsMCwwLjApJywKICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICdyZ2JhKDAsMCwwLDAuMCknLAogICAgICAgICAgICBwb2ludFN0eWxlOiAncmVjdCcsCiAgICAgICAgICB9KTsKCiAgICAgICAgICAvLyBGaW5kIHVuaXF1ZSBpbmRpY2F0b3IgdmFsdWVzCiAgICAgICAgICBjb25zdCBpbmRpY2F0b3JWYWx1ZXMgPSB7fTsKICAgICAgICAgIGluZGljYXRvci5pbmRpY2F0b3JWYWx1ZS5tYXAoKHZhbCwgaSkgPT4gewogICAgICAgICAgICBsZXQga2V5ID0gdmFsLnRvTG93ZXJDYXNlKCk7CiAgICAgICAgICAgIGtleSA9IGtleS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleS5zbGljZSgxKTsKICAgICAgICAgICAgaWYgKCFbJycsICcvJ10uaW5jbHVkZXMoa2V5KSAmJiB0eXBlb2YgaW5kaWNhdG9yVmFsdWVzW2tleV0gPT09ICd1bmRlZmluZWQnKSB7CiAgICAgICAgICAgICAgaW5kaWNhdG9yVmFsdWVzW2tleV0gPSB0aGlzLmdldEluZGljYXRvckNvbG9yKAogICAgICAgICAgICAgICAgaW5kaWNhdG9yLmNvbG9yQ29kZVtpXSwKICAgICAgICAgICAgICApOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBudWxsOwogICAgICAgICAgfSk7CgogICAgICAgICAgT2JqZWN0LmVudHJpZXMoaW5kaWNhdG9yVmFsdWVzKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHsKICAgICAgICAgICAgZGF0YXNldHMucHVzaCh7CiAgICAgICAgICAgICAgbGFiZWw6IGtleSwKICAgICAgICAgICAgICBkYXRhOiBbXSwKICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHZhbHVlLAogICAgICAgICAgICAgIGJvcmRlckNvbG9yOiB2YWx1ZSwKICAgICAgICAgICAgfSk7CiAgICAgICAgICB9KTsKICAgICAgICB9IGVsc2UgaWYgKFsnRTEwYTMnLCAnRTEwYTgnXS5pbmNsdWRlcyhpbmRpY2F0b3JDb2RlKSkgewogICAgICAgICAgY29uc3QgbnV0c0ZlYXR1cmVzID0gTlVUUy5mZWF0dXJlczsKICAgICAgICAgIGNvbnN0IG91dGxpbmUgPSBbXTsKICAgICAgICAgIGNvbnN0IGN1cnJJRHMgPSBbXTsKICAgICAgICAgIGxldCBmZWF0dXJlcyA9IG1lYXN1cmVtZW50Lm1hcCgobWVhcywgaSkgPT4gewogICAgICAgICAgICAvLyBGaW5kIGNvcnJlY3QgTlVUUyBJRCBTaGFwZQogICAgICAgICAgICBjb25zdCBnZW9tID0gbnV0c0ZlYXR1cmVzLmZpbmQoKGYpID0+ICgKICAgICAgICAgICAgICBmLnByb3BlcnRpZXMuTlVUU19JRCA9PT0gaW5kaWNhdG9yLnNpdGVOYW1lW2ldKSk7CiAgICAgICAgICAgIGxldCBvdXRwdXQ7CiAgICAgICAgICAgIGlmIChnZW9tKSB7CiAgICAgICAgICAgICAgaWYgKGN1cnJJRHMuaW5kZXhPZihpbmRpY2F0b3Iuc2l0ZU5hbWVbaV0pID09PSAtMSkgewogICAgICAgICAgICAgICAgY3VycklEcy5wdXNoKGluZGljYXRvci5zaXRlTmFtZVtpXSk7CiAgICAgICAgICAgICAgICBvdXRsaW5lLnB1c2goewogICAgICAgICAgICAgICAgICB0eXBlOiAnRmVhdHVyZScsCiAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHt9LAogICAgICAgICAgICAgICAgICBnZW9tZXRyeTogZ2VvbS5nZW9tZXRyeSwKICAgICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICBjb25zdCB7IGNvb3JkaW5hdGVzIH0gPSBnZW9tLmdlb21ldHJ5OwogICAgICAgICAgICAgIGNvbnN0IGxvbnMgPSAoZ2VvbS5nZW9tZXRyeS50eXBlID09PSAnUG9seWdvbicpID8gY29vcmRpbmF0ZXMuZmxhdCgxKS5tYXAoKHR1cGxlKSA9PiB0dXBsZVswXSkgOiBjb29yZGluYXRlcy5mbGF0KDIpLm1hcCgodHVwbGUpID0+IHR1cGxlWzBdKTsKICAgICAgICAgICAgICBjb25zdCBsYXRzID0gKGdlb20uZ2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nKSA/IGNvb3JkaW5hdGVzLmZsYXQoMSkubWFwKCh0dXBsZSkgPT4gdHVwbGVbMV0pIDogY29vcmRpbmF0ZXMuZmxhdCgyKS5tYXAoKHR1cGxlKSA9PiB0dXBsZVsxXSk7CiAgICAgICAgICAgICAgY29uc3QgbWluTGF0ID0gTWF0aC5taW4oLi4ubGF0cyk7CiAgICAgICAgICAgICAgY29uc3QgbWluTG9uID0gTWF0aC5taW4oLi4ubG9ucyk7CiAgICAgICAgICAgICAgY29uc3QgY2VudGVyUG9pbnQgPSB7CiAgICAgICAgICAgICAgICBsYXQ6IG1pbkxhdCArIChNYXRoLm1heCguLi5sYXRzKSAtIG1pbkxhdCkgLyAyLAogICAgICAgICAgICAgICAgbG9uOiBtaW5Mb24gKyAoTWF0aC5tYXgoLi4ubG9ucykgLSBtaW5Mb24pIC8gMiwKICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgIG91dHB1dCA9IHsKICAgICAgICAgICAgICAgIHR5cGU6ICdGZWF0dXJlJywKICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHt9LAogICAgICAgICAgICAgICAgZ2VvbWV0cnk6IGdlb20uZ2VvbWV0cnksCiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJ2Rlc2NyaXB0aW9uJywKICAgICAgICAgICAgICAgIGxhdGl0dWRlOiBjZW50ZXJQb2ludC5sYXQsCiAgICAgICAgICAgICAgICBsb25naXR1ZGU6IGNlbnRlclBvaW50LmxvbiwKICAgICAgICAgICAgICAgIG5hbWU6IGdlb20ucHJvcGVydGllcy5OVVRTX05BTUUsCiAgICAgICAgICAgICAgICB0aW1lOiBpbmRpY2F0b3IudGltZVtpXSwKICAgICAgICAgICAgICAgIHZhbHVlOiBOdW1iZXIobWVhcyksCiAgICAgICAgICAgICAgICByZWZlcmVuY2VUaW1lOiBpbmRpY2F0b3IucmVmZXJlbmNlVGltZVtpXSwKICAgICAgICAgICAgICAgIHJlZmVyZW5jZVZhbHVlOiBpbmRpY2F0b3IucmVmZXJlbmNlVmFsdWVbaV0sCiAgICAgICAgICAgICAgICBjb2xvcjogaW5kaWNhdG9yLmNvbG9yQ29kZVtpXSwKICAgICAgICAgICAgICB9OwogICAgICAgICAgICAgIGlmIChpbmRpY2F0b3JDb2RlID09PSAnRTEwYTgnKSB7CiAgICAgICAgICAgICAgICAvLyBTd2FwIHZhbHVlIHRvIGhhdmUgcmVmZXJlbmNlIHZhbHVlCiAgICAgICAgICAgICAgICBvdXRwdXQudmFsdWUgPSBOdW1iZXIoaW5kaWNhdG9yLnJlZmVyZW5jZVZhbHVlW2ldKTsKICAgICAgICAgICAgICAgIG91dHB1dC5yZWZlcmVuY2VWYWx1ZSA9IE51bWJlcihtZWFzKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIG91dHB1dDsKICAgICAgICAgIH0pOwoKICAgICAgICAgIC8vIEZpbHRlciBieSB1bmRlZmluZWQgYW5kIHRpbWUKICAgICAgICAgIGZlYXR1cmVzID0gZmVhdHVyZXMuZmlsdGVyKChkKSA9PiAoCiAgICAgICAgICAgIHR5cGVvZiBkICE9PSAndW5kZWZpbmVkJykpOwoKICAgICAgICAgIGNvbnN0IGZpbHRlcmVkRmVhdHVyZXMgPSBmZWF0dXJlcy5maWx0ZXIoKGQpID0+IHsKICAgICAgICAgICAgbGV0IGluY2x1ZGUgPSBmYWxzZTsKICAgICAgICAgICAgaWYgKGQudGltZSBpbnN0YW5jZW9mIERhdGVUaW1lKSB7CiAgICAgICAgICAgICAgaW5jbHVkZSA9IGQudGltZS50b0Zvcm1hdCgnZGQuIE1NTScpID09PSB0aGlzLmRhdGFMYXllclRpbWUKICAgICAgICAgICAgICAgICYmICFOdW1iZXIuaXNOYU4oZC52YWx1ZSk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgcmV0dXJuIGluY2x1ZGU7CiAgICAgICAgICB9KTsKCiAgICAgICAgICBsYWJlbHMgPSBmZWF0dXJlcy5tYXAoKGQpID0+IGQubmFtZSk7CiAgICAgICAgICBkYXRhc2V0cy5wdXNoKHsKICAgICAgICAgICAgb3V0bGluZSwKICAgICAgICAgICAgb3V0bGluZUJhY2tncm91bmRDb2xvcjogbnVsbCwKICAgICAgICAgICAgb3V0bGluZUJvcmRlckNvbG9yOiAnYmxhY2snLAogICAgICAgICAgICBvdXRsaW5lQm9yZGVyV2lkdGg6IDEsCiAgICAgICAgICAgIHNob3dPdXRsaW5lOiB0cnVlLAogICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGZpbHRlcmVkRmVhdHVyZXMubWFwKChkKSA9PiBkLmNvbG9yKSwKICAgICAgICAgICAgYm9yZGVyQ29sb3I6IGZpbHRlcmVkRmVhdHVyZXMubWFwKChkKSA9PiBkLmNvbG9yKSwKICAgICAgICAgICAgYm9yZGVyV2lkdGg6IDMsCiAgICAgICAgICAgIGRhdGE6IGZpbHRlcmVkRmVhdHVyZXMsCiAgICAgICAgICAgIGNsaXBNYXA6ICdpdGVtcycsCiAgICAgICAgICB9KTsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgY29uc3QgZGF0YSA9IGluZGljYXRvci50aW1lLm1hcCgoZGF0ZSwgaSkgPT4gewogICAgICAgICAgICBjb2xvcnMucHVzaCh0aGlzLmdldEluZGljYXRvckNvbG9yKGluZGljYXRvci5jb2xvckNvZGVbaV0pKTsKICAgICAgICAgICAgcmV0dXJuIHsgdDogZGF0ZSwgeTogbWVhc3VyZW1lbnRbaV0gfTsKICAgICAgICAgIH0pOwogICAgICAgICAgZGF0YXNldHMucHVzaCh7CiAgICAgICAgICAgIGRhdGEsCiAgICAgICAgICAgIGxhYmVsOiBpbmRpY2F0b3IueUF4aXMsCiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogY29sb3JzLAogICAgICAgICAgICBib3JkZXJDb2xvcjogY29sb3JzLAogICAgICAgICAgfSk7CiAgICAgICAgfQogICAgICAgIGRhdGFDb2xsZWN0aW9uID0gewogICAgICAgICAgbGFiZWxzLAogICAgICAgICAgZGF0YXNldHMsCiAgICAgICAgfTsKICAgICAgfQogICAgICByZXR1cm4gZGF0YUNvbGxlY3Rpb247CiAgICB9LAogICAgaW5kaWNhdG9yT2JqZWN0KCkgewogICAgICByZXR1cm4gdGhpcy5jdXJyZW50SW5kaWNhdG9yCiAgICAgICAgfHwgdGhpcy4kc3RvcmUuc3RhdGUuaW5kaWNhdG9ycy5jdXN0b21BcmVhSW5kaWNhdG9yCiAgICAgICAgfHwgdGhpcy4kc3RvcmUuc3RhdGUuaW5kaWNhdG9ycy5zZWxlY3RlZEluZGljYXRvcjsKICAgIH0sCiAgICBpbmREZWZpbml0aW9uKCkgewogICAgICByZXR1cm4gdGhpcy5iYXNlQ29uZmlnLmluZGljYXRvcnNEZWZpbml0aW9uW3RoaXMuaW5kaWNhdG9yT2JqZWN0LmluZGljYXRvcl07CiAgICB9LAogIH0sCiAgbWV0aG9kczogewogICAgZGF0YUxheWVyVGltZVNlbGVjdGlvbihwYXlsb2FkKSB7CiAgICAgIHRoaXMuZGF0YUxheWVyVGltZSA9IHBheWxvYWQ7CiAgICAgIGNvbnN0IG5ld0luZGV4ID0gdGhpcy5hcnJheU9mT2JqZWN0cwogICAgICAgIC5tYXAoKGkpID0+IGkudmFsdWUpCiAgICAgICAgLmluZGV4T2YodGhpcy5kYXRhTGF5ZXJUaW1lKTsKICAgICAgdGhpcy5kYXRhTGF5ZXJJbmRleCA9IG5ld0luZGV4OwogICAgfSwKICAgIGRhdGFMYXllclJlZHVjZSgpIHsKICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gdGhpcy5hcnJheU9mT2JqZWN0cwogICAgICAgIC5tYXAoKGkpID0+IGkudmFsdWUpCiAgICAgICAgLmluZGV4T2YodGhpcy5kYXRhTGF5ZXJUaW1lKTsKICAgICAgdGhpcy5kYXRhTGF5ZXJJbmRleCA9IGN1cnJlbnRJbmRleCAtIDE7CiAgICAgIHRoaXMuZGF0YUxheWVyVGltZVNlbGVjdGlvbih0aGlzLmFycmF5T2ZPYmplY3RzW2N1cnJlbnRJbmRleCAtIDFdLnZhbHVlKTsKICAgIH0sCiAgICBkYXRhTGF5ZXJJbmNyZWFzZSgpIHsKICAgICAgY29uc3QgY3VycmVudEluZGV4ID0gdGhpcy5hcnJheU9mT2JqZWN0cwogICAgICAgIC5tYXAoKGkpID0+IGkudmFsdWUpCiAgICAgICAgLmluZGV4T2YodGhpcy5kYXRhTGF5ZXJUaW1lKTsKICAgICAgdGhpcy5kYXRhTGF5ZXJJbmRleCA9IGN1cnJlbnRJbmRleCArIDE7CiAgICAgIHRoaXMuZGF0YUxheWVyVGltZVNlbGVjdGlvbih0aGlzLmFycmF5T2ZPYmplY3RzW2N1cnJlbnRJbmRleCArIDFdLnZhbHVlKTsKICAgIH0sCiAgICBmb3JtYXROdW1SZWYobnVtLCBtYXhEZWNpbWFscyA9IDMpIHsKICAgICAgcmV0dXJuIE51bWJlci5wYXJzZUZsb2F0KG51bS50b0ZpeGVkKG1heERlY2ltYWxzKSk7CiAgICB9LAogICAgcm91bmRWYWx1ZUluZCh2YWwpIHsKICAgICAgaWYgKHRoaXMuaW5kRGVmaW5pdGlvbi5tYXhEZWNpbWFscyA9PT0gLTEpIHsKICAgICAgICByZXR1cm4gdmFsOwogICAgICB9CiAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKHRoaXMuaW5kRGVmaW5pdGlvbi5tYXhEZWNpbWFscykpIHsKICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXROdW1SZWYodmFsLCB0aGlzLmluZERlZmluaXRpb24ubWF4RGVjaW1hbHMpOwogICAgICB9CiAgICAgIC8vIHVzZSBkZWZhdWx0CiAgICAgIHJldHVybiB0aGlzLmZvcm1hdE51bVJlZih2YWwsIDIpOwogICAgfSwKICAgIGdldE1pbk1heERhdGUodGltZURhdGEpIHsKICAgICAgbGV0IHRpbWVNaW4gPSBNYXRoLm1pbi5hcHBseShudWxsLCB0aW1lRGF0YS5tYXAoKGQpID0+IGQudG9NaWxsaXMoKSkpOwogICAgICBsZXQgdGltZU1heCA9IE1hdGgubWF4LmFwcGx5KG51bGwsIHRpbWVEYXRhLm1hcCgoZCkgPT4gZC50b01pbGxpcygpKSk7CiAgICAgIGNvbnN0IGJ1ZmZlciA9ICh0aW1lTWF4IC0gdGltZU1pbikgLyB0aW1lRGF0YS5sZW5ndGg7CiAgICAgIHRpbWVNaW4gLT0gYnVmZmVyOwogICAgICB0aW1lTWF4ICs9IGJ1ZmZlcjsKICAgICAgcmV0dXJuIFt0aW1lTWluLCB0aW1lTWF4XTsKICAgIH0sCiAgICBjaGFydE9wdGlvbnMoKSB7CiAgICAgIGNvbnN0IGluZGljYXRvckNvZGUgPSB0aGlzLmluZGljYXRvck9iamVjdC5pbmRpY2F0b3I7CiAgICAgIGNvbnN0IHJlZmVyZW5jZSA9IE51bWJlci5wYXJzZUZsb2F0KHRoaXMuaW5kaWNhdG9yT2JqZWN0LnJlZmVyZW5jZVZhbHVlKTsKICAgICAgbGV0IHRpbWVNaW5NYXggPSB0aGlzLmdldE1pbk1heERhdGUodGhpcy5pbmRpY2F0b3JPYmplY3QudGltZSk7CiAgICAgIGNvbnN0IGFubm90YXRpb25zID0gW107CiAgICAgIGxldCBsb3cgPSAwOwogICAgICBsZXQgaGlnaCA9IDA7CiAgICAgIGNvbnN0IGRlZmF1bHRBbm5vdGF0aW9uU2V0dGluZ3MgPSB7CiAgICAgICAgdHlwZTogJ2xpbmUnLAogICAgICAgIG1vZGU6ICdob3Jpem9udGFsJywKICAgICAgICBzY2FsZUlEOiAneS1heGlzLTAnLAogICAgICAgIGJvcmRlckNvbG9yOiAncmdiYSgwLCAwLCAyNTUsIDAuNSknLAogICAgICAgIGJvcmRlcldpZHRoOiAyLAogICAgICAgIGJvcmRlckRhc2g6IFsyLCAzXSwKICAgICAgICBzY2FsZXM6IHsKICAgICAgICAgIHhBeGVzOiBbewogICAgICAgICAgICB0eXBlOiAndGltZScsCiAgICAgICAgICAgIHRpbWU6IHsKICAgICAgICAgICAgICB1bml0OiAnbW9udGgnLAogICAgICAgICAgICB9LAogICAgICAgICAgfV0sCiAgICAgICAgfSwKICAgICAgICBsYWJlbDogewogICAgICAgICAgZW5hYmxlZDogdHJ1ZSwKICAgICAgICAgIGZvbnRTdHlsZTogJ25vcm1hbCcsCiAgICAgICAgICBwYWRkaW5nWDogMiwKICAgICAgICAgIHBhZGRpbmdZOiAyLAogICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjcpJywKICAgICAgICAgIGZvbnRDb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC44KScsCiAgICAgICAgfSwKICAgICAgfTsKICAgICAgaWYgKCFOdW1iZXIuaXNOYU4ocmVmZXJlbmNlKQogICAgICAgICYmICFbJ0UxMGExJywgJ0UxMGEyJywgJ0UxMGE1JywgJ0UxMGE2JywgJ0UxMGE3JywgJ0UxMGE5JywgJ040YycsICdFOCcsICdFMTNlJywgJ0UxM2YnLCAnRTEzZycsICdFMTNoJywgJ0UxM2knLCAnRTEzbCcsICdFMTNtJywgJ0UxMmMnLCAnRTEyZCddCiAgICAgICAgICAuaW5jbHVkZXMoaW5kaWNhdG9yQ29kZSkpIHsKICAgICAgICBhbm5vdGF0aW9ucy5wdXNoKHsKICAgICAgICAgIC4uLmRlZmF1bHRBbm5vdGF0aW9uU2V0dGluZ3MsCiAgICAgICAgICBsYWJlbDogewogICAgICAgICAgICAuLi5kZWZhdWx0QW5ub3RhdGlvblNldHRpbmdzLmxhYmVsLAogICAgICAgICAgICBjb250ZW50OiBgcmVmZXJlbmNlOiAke3RoaXMuZm9ybWF0TnVtUmVmKHJlZmVyZW5jZSl9YCwKICAgICAgICAgIH0sCiAgICAgICAgICB2YWx1ZTogcmVmZXJlbmNlLAogICAgICAgIH0pOwogICAgICB9CiAgICAgIGlmIChbJ0U0J10uaW5jbHVkZXMoaW5kaWNhdG9yQ29kZSkpIHsKICAgICAgICBsb3cgPSAwLjIgKiByZWZlcmVuY2U7CiAgICAgICAgYW5ub3RhdGlvbnMucHVzaCh7CiAgICAgICAgICAuLi5kZWZhdWx0QW5ub3RhdGlvblNldHRpbmdzLAogICAgICAgICAgYm9yZGVyQ29sb3I6ICdyZ2JhKDUwLCAyNTIsIDAsIDAuNSknLAogICAgICAgICAgdmFsdWU6IGxvdywKICAgICAgICAgIGxhYmVsOiB7CiAgICAgICAgICAgIC4uLmRlZmF1bHRBbm5vdGF0aW9uU2V0dGluZ3MubGFiZWwsCiAgICAgICAgICAgIGNvbnRlbnQ6IGBvbi9vZmY6ICR7dGhpcy5mb3JtYXROdW1SZWYobG93KX1gLAogICAgICAgICAgfSwKICAgICAgICB9KTsKICAgICAgfSBlbHNlIGlmIChbJ0UxMScsICdFMWEnLCAnRTEnLCAnRTInLCAnRTJfUzInLCAnRTFhX1MyJywgJ0UxX1MyJ10uaW5jbHVkZXMoaW5kaWNhdG9yQ29kZSkpIHsKICAgICAgICBpZiAoaW5kaWNhdG9yQ29kZSA9PT0gJ0UxMScpIHsKICAgICAgICAgIGxvdyA9IDAuMyAqIHJlZmVyZW5jZTsKICAgICAgICAgIGhpZ2ggPSAwLjcgKiByZWZlcmVuY2U7CiAgICAgICAgfSBlbHNlIGlmIChbJ0UxYScsICdFMScsICdFMicsICdFMl9TMicsICdFMWFfUzInLCAnRTFfUzInXS5pbmNsdWRlcyhpbmRpY2F0b3JDb2RlKSkgewogICAgICAgICAgbG93ID0gMC43ICogcmVmZXJlbmNlOwogICAgICAgICAgaGlnaCA9IDEuMyAqIHJlZmVyZW5jZTsKICAgICAgICB9CiAgICAgICAgYW5ub3RhdGlvbnMucHVzaCh7CiAgICAgICAgICAuLi5kZWZhdWx0QW5ub3RhdGlvblNldHRpbmdzLAogICAgICAgICAgdmFsdWU6IGxvdywKICAgICAgICAgIGxhYmVsOiB7CiAgICAgICAgICAgIC4uLmRlZmF1bHRBbm5vdGF0aW9uU2V0dGluZ3MubGFiZWwsCiAgICAgICAgICAgIGNvbnRlbnQ6IGBsb3c6ICR7dGhpcy5mb3JtYXROdW1SZWYobG93KX1gLAogICAgICAgICAgfSwKICAgICAgICB9KTsKICAgICAgICBhbm5vdGF0aW9ucy5wdXNoKHsKICAgICAgICAgIC4uLmRlZmF1bHRBbm5vdGF0aW9uU2V0dGluZ3MsCiAgICAgICAgICB2YWx1ZTogaGlnaCwKICAgICAgICAgIGxhYmVsOiB7CiAgICAgICAgICAgIC4uLmRlZmF1bHRBbm5vdGF0aW9uU2V0dGluZ3MubGFiZWwsCiAgICAgICAgICAgIGNvbnRlbnQ6IGBoaWdoOiAke3RoaXMuZm9ybWF0TnVtUmVmKGhpZ2gpfWAsCiAgICAgICAgICB9LAogICAgICAgIH0pOwogICAgICB9CgogICAgICAvLyBJbnRyb2R1Y2UgYmFja2dyb3VuZCBhcmVhIGFubm90YXRpb25zIGZvciBsb2NrZG93biB0aW1lcywgZG9lcyBub3QKICAgICAgLy8gd29yayBmb3IgYWxsIGNoYXJ0IHR5cGVzLCBzbyB3ZSBtYWtlIHN1cmUgaXQgaXMgbm90IGFueSBvZiB0aG9zZSBjaGFydHMKICAgICAgaWYgKCFbJ0UxMGEzJywgJ0UxMGE4JywgJ04yJywgJ0UxMmMnLCAnRTEyZCcsICdHU0EnXS5pbmNsdWRlcyhpbmRpY2F0b3JDb2RlKSkgewogICAgICAgIC8vIEZpbmQgY291bnRyeSBiYXNlZCBvbiBhbHBoYS0zIGNvZGUKICAgICAgICBjb25zdCBjdXJyQ291bnRyeSA9IGNvdW50cmllcy5mZWF0dXJlcy5maW5kKAogICAgICAgICAgKGNudHIpID0+IGNudHIucHJvcGVydGllcy5hbHBoYTIgPT09IHRoaXMuaW5kaWNhdG9yT2JqZWN0LmNvdW50cnksCiAgICAgICAgKTsKICAgICAgICBpZiAodHlwZW9mIGN1cnJDb3VudHJ5ICE9PSAndW5kZWZpbmVkJwogICAgICAgICAgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGxvY2tkb3duVGltZXMsIGN1cnJDb3VudHJ5LmlkKSkgewogICAgICAgICAgY29uc3QgbGNrVHMgPSBsb2NrZG93blRpbWVzW2N1cnJDb3VudHJ5LmlkXVsnQzdfUmVzdHJpY3Rpb25zIG9uIGludGVybmFsIG1vdmVtZW50J107CiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxja1RzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgICAgIGxldCBhcmVhQ29sb3IgPSAncmdiYSgwLCAwLCAwLCAwLjApJzsKICAgICAgICAgICAgaWYgKGxja1RzW2ldLnZhbHVlID09PSAxKSB7CiAgICAgICAgICAgICAgYXJlYUNvbG9yID0gJ3JnYmEoMjA0LCAxNDMsIDE0MywgMC4yNCknOwogICAgICAgICAgICB9IGVsc2UgaWYgKGxja1RzW2ldLnZhbHVlID09PSAyKSB7CiAgICAgICAgICAgICAgYXJlYUNvbG9yID0gJ3JnYmEoMjA3LCAxMDksIDEwOSwgMC41NCknOwogICAgICAgICAgICB9CiAgICAgICAgICAgIC8vIFdlIGFsc28gaGF2ZSBzcGVjaWFsIGRhdGUgaGFuZGxpbmcgZm9yIHNvbWUgY2hhcnQgdHlwZXMgYXMgd2UKICAgICAgICAgICAgLy8gc2ltdWxhdGUgeWVhciBhZ25vc3RpYyByZW5kZXJpbmcsIHNvIHdlIGNvbnZlcnQgYWxsIGRhdGVzIHRvCiAgICAgICAgICAgIC8vIG9uZSB5ZWFyCiAgICAgICAgICAgIGxldCBzdGFydCA9IERhdGVUaW1lLmZyb21JU08obGNrVHNbaV0uc3RhcnQpOwogICAgICAgICAgICBsZXQgZW5kID0gRGF0ZVRpbWUuZnJvbUlTTyhsY2tUc1tpXS5lbmQpOwogICAgICAgICAgICBpZiAoWydFMTBhMicsICdFMTBhNicsICdFMTBhNycsICdFMTBjJywgJ0U4JywgJ0UxM2UnLCAnRTEzZicsICdFMTNnJywgJ0UxM2gnLCAnRTEzaScsICdFMTNsJywgJ0UxM20nXS5pbmNsdWRlcyhpbmRpY2F0b3JDb2RlKSkgewogICAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnQuc2V0KHsgeWVhcjogMjAwMCB9KTsKICAgICAgICAgICAgICBlbmQgPSBlbmQuc2V0KHsgeWVhcjogMjAwMCB9KTsKICAgICAgICAgICAgfQogICAgICAgICAgICBpZiAobGNrVHNbaV0udmFsdWUgIT09IDApIHsKICAgICAgICAgICAgICBhbm5vdGF0aW9ucy5wdXNoKHsKICAgICAgICAgICAgICAgIGRyYXdUaW1lOiAnYmVmb3JlRGF0YXNldHNEcmF3JywKICAgICAgICAgICAgICAgIHR5cGU6ICdib3gnLAogICAgICAgICAgICAgICAgeFNjYWxlSUQ6ICd4LWF4aXMtMCcsCiAgICAgICAgICAgICAgICB4TWluOiBzdGFydC50b0lTT0RhdGUoKSwKICAgICAgICAgICAgICAgIHhNYXg6IGVuZC50b0lTT0RhdGUoKSwKICAgICAgICAgICAgICAgIGJvcmRlckNvbG9yOiBhcmVhQ29sb3IsCiAgICAgICAgICAgICAgICBib3JkZXJXaWR0aDogMCwKICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogYXJlYUNvbG9yLAogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgogICAgICBsZXQgeEF4ZXMgPSB7fTsKICAgICAgaWYgKCFbJ0UxMGExJywgJ0UxMGEyJywgJ0UxMGEzJywgJ0UxMGE1JywgJ0UxMGE2JywgJ0UxMGE3JywgJ0UxMGE4JywgJ0UxMGMnLCAnRTEyYycsICdFMTJkJywgJ04yJ10uaW5jbHVkZXMoaW5kaWNhdG9yQ29kZSkpIHsKICAgICAgICB4QXhlcyA9IFt7CiAgICAgICAgICB0eXBlOiAndGltZScsCiAgICAgICAgICB0aW1lOiB7CiAgICAgICAgICAgIHVuaXQ6ICd3ZWVrJywKICAgICAgICAgIH0sCiAgICAgICAgICB0aWNrczogewogICAgICAgICAgICBtaW46IHRpbWVNaW5NYXhbMF0sCiAgICAgICAgICAgIG1heDogdGltZU1pbk1heFsxXSwKICAgICAgICAgIH0sCiAgICAgICAgICBiYXJUaGlja25lc3M6ICdmbGV4JywKICAgICAgICB9XTsKICAgICAgICBpZiAoIVsnTjMnLCAnTjNiJ10uaW5jbHVkZXMoaW5kaWNhdG9yQ29kZSkpIHsKICAgICAgICAgIHhBeGVzWzBdLmRpc3RyaWJ1dGlvbiA9ICdzZXJpZXMnOwogICAgICAgIH0KICAgICAgfQoKICAgICAgaWYgKFsnRTEwYTInLCAnRTEwYTYnLCAnRTEwYTcnLCAnRTEwYycsICdFOCcsICdFMTNlJywgJ0UxM2YnLCAnRTEzZycsICdFMTNoJywgJ0UxM2knLCAnRTEzbCcsICdFMTNtJ10uaW5jbHVkZXMoaW5kaWNhdG9yQ29kZSkpIHsKICAgICAgICAvKiBSZWNhbGN1bGF0ZSB0byBnZXQgbWluIG1heCBtb250aHMgaW4gZGF0YSBjb252ZXJ0ZWQgdG8gb25lIHllYXIgKi8KICAgICAgICB0aW1lTWluTWF4ID0gdGhpcy5nZXRNaW5NYXhEYXRlKAogICAgICAgICAgdGhpcy5pbmRpY2F0b3JPYmplY3QudGltZS5tYXAoKGRhdGUpID0+ICgKICAgICAgICAgICAgZGF0ZS5zZXQoeyB5ZWFyOiAyMDAwIH0pCiAgICAgICAgICApKSwKICAgICAgICApOwogICAgICAgIC8qIENoZWNrIGFsc28gZm9yIHJlZmVyZW5jZSB0aW1lICovCiAgICAgICAgY29uc3QgcmVmVGltZU1pbk1heCA9IHRoaXMuZ2V0TWluTWF4RGF0ZSgKICAgICAgICAgIHRoaXMuaW5kaWNhdG9yT2JqZWN0LnJlZmVyZW5jZVRpbWUubWFwKChkYXRlKSA9PiAoCiAgICAgICAgICAgIGRhdGUuc2V0KHsgeWVhcjogMjAwMCB9KQogICAgICAgICAgKSksCiAgICAgICAgKTsKICAgICAgICB4QXhlcyA9IFt7CiAgICAgICAgICB0eXBlOiAndGltZScsCiAgICAgICAgICB0aW1lOiB7CiAgICAgICAgICAgIHVuaXQ6ICdtb250aCcsCiAgICAgICAgICAgIGRpc3BsYXlGb3JtYXRzOiB7CiAgICAgICAgICAgICAgbW9udGg6ICdNTU0nLAogICAgICAgICAgICB9LAogICAgICAgICAgICB0b29sdGlwRm9ybWF0OiAnZGQuIE1NTScsCiAgICAgICAgICB9LAogICAgICAgICAgdGlja3M6IHsKICAgICAgICAgICAgbWluOiAodGltZU1pbk1heFswXSA8IHJlZlRpbWVNaW5NYXhbMF0pID8gdGltZU1pbk1heFswXSA6IHJlZlRpbWVNaW5NYXhbMF0sCiAgICAgICAgICAgIG1heDogKHRpbWVNaW5NYXhbMV0gPiByZWZUaW1lTWluTWF4WzFdKSA/IHRpbWVNaW5NYXhbMV0gOiByZWZUaW1lTWluTWF4WzFdLAogICAgICAgICAgfSwKICAgICAgICB9XTsKICAgICAgfQoKICAgICAgaWYgKFsnTjInXS5pbmNsdWRlcyhpbmRpY2F0b3JDb2RlKSkgewogICAgICAgIHRpbWVNaW5NYXggPSB0aGlzLmdldE1pbk1heERhdGUoCiAgICAgICAgICB0aGlzLmluZGljYXRvck9iamVjdC50aW1lLm1hcCgoZGF0ZSkgPT4gKAogICAgICAgICAgICBkYXRlLnNldCh7IHllYXI6IDIwMDAgfSkKICAgICAgICAgICkpLAogICAgICAgICk7CiAgICAgICAgeEF4ZXMgPSBbewogICAgICAgICAgdHlwZTogJ3RpbWUnLAogICAgICAgICAgdGltZTogewogICAgICAgICAgICB1bml0OiAnbW9udGgnLAogICAgICAgICAgICBkaXNwbGF5Rm9ybWF0czogewogICAgICAgICAgICAgIG1vbnRoOiAnTU1NJywKICAgICAgICAgICAgfSwKICAgICAgICAgICAgdG9vbHRpcEZvcm1hdDogJ2RkLiBNTU0nLAogICAgICAgICAgfSwKICAgICAgICAgIGRpc3RyaWJ1dGlvbjogJ3NlcmllcycsCiAgICAgICAgICB0aWNrczogewogICAgICAgICAgICBtaW46IHRpbWVNaW5NYXhbMF0sCiAgICAgICAgICAgIG1heDogdGltZU1pbk1heFsxXSwKICAgICAgICAgIH0sCiAgICAgICAgfV07CiAgICAgIH0KCiAgICAgIGlmIChbJ0UxMmMnLCAnRTEyZCddLmluY2x1ZGVzKGluZGljYXRvckNvZGUpKSB7CiAgICAgICAgeEF4ZXMgPSBbewogICAgICAgICAgdHlwZTogJ3RpbWUnLAogICAgICAgICAgdGltZTogewogICAgICAgICAgICB1bml0OiAneWVhcicsCiAgICAgICAgICAgIGRpc3BsYXlGb3JtYXRzOiB7CiAgICAgICAgICAgICAgeWVhcjogJ3l5eXknLAogICAgICAgICAgICB9LAogICAgICAgICAgICB0b29sdGlwRm9ybWF0OiAneXl5eS1NTS1kZCAtIHl5eXktMDYtMzAnLAogICAgICAgICAgfSwKICAgICAgICAgIGRpc3RyaWJ1dGlvbjogJ3NlcmllcycsCiAgICAgICAgICB0aWNrczogewogICAgICAgICAgICBtaW46IHRpbWVNaW5NYXhbMF0sCiAgICAgICAgICAgIG1heDogdGltZU1pbk1heFsxXSwKICAgICAgICAgIH0sCiAgICAgICAgfV07CiAgICAgIH0KCiAgICAgIGlmIChbJ0UxM2QnLCAnRTEzbicsICdDMScsICdDMicsICdDMyddLmluY2x1ZGVzKGluZGljYXRvckNvZGUpKSB7CiAgICAgICAgeEF4ZXMgPSBbewogICAgICAgICAgdHlwZTogJ3RpbWUnLAogICAgICAgICAgdGltZTogewogICAgICAgICAgICB1bml0OiAnbW9udGgnLAogICAgICAgICAgICBkaXNwbGF5Rm9ybWF0czogewogICAgICAgICAgICAgIG1vbnRoOiAnTU1NIHl5JywKICAgICAgICAgICAgfSwKICAgICAgICAgICAgdG9vbHRpcEZvcm1hdDogJ01NTSB5eXl5JywKICAgICAgICAgIH0sCiAgICAgICAgICBkaXN0cmlidXRpb246ICdzZXJpZXMnLAogICAgICAgICAgdGlja3M6IHsKICAgICAgICAgICAgbWluOiB0aW1lTWluTWF4WzBdLAogICAgICAgICAgICBtYXg6IHRpbWVNaW5NYXhbMV0sCiAgICAgICAgICB9LAogICAgICAgIH1dOwogICAgICB9CgoKICAgICAgbGV0IHBsdWdpbnMgPSB7CiAgICAgICAgZGF0YWxhYmVsczogewogICAgICAgICAgZGlzcGxheTogZmFsc2UsCiAgICAgICAgfSwKICAgICAgfTsKCiAgICAgIGNvbnN0IHlBeGVzID0gW3sKICAgICAgICBzY2FsZUxhYmVsOiB7CiAgICAgICAgICBkaXNwbGF5OiB0cnVlLAogICAgICAgICAgbGFiZWxTdHJpbmc6IHRoaXMuaW5kaWNhdG9yT2JqZWN0LnlBeGlzLAogICAgICAgICAgcGFkZGluZzogMiwKICAgICAgICB9LAogICAgICAgIHRpY2tzOiB7CiAgICAgICAgICBsaW5lSGVpZ2h0OiAxLAogICAgICAgICAgc3VnZ2VzdGVkTWluOiBNYXRoLm1pbigKICAgICAgICAgICAgLi4udGhpcy5pbmRpY2F0b3JPYmplY3QubWVhc3VyZW1lbnQKICAgICAgICAgICAgICAuZmlsdGVyKChkKSA9PiAhTnVtYmVyLmlzTmFOKGQpKSwKICAgICAgICAgICkgLSAxLAogICAgICAgICAgc3VnZ2VzdGVkTWF4OiBNYXRoLm1heCgKICAgICAgICAgICAgLi4udGhpcy5pbmRpY2F0b3JPYmplY3QubWVhc3VyZW1lbnQKICAgICAgICAgICAgICAuZmlsdGVyKChkKSA9PiAhTnVtYmVyLmlzTmFOKGQpKSwKICAgICAgICAgICkgKyAxLAogICAgICAgIH0sCiAgICAgIH1dOwoKICAgICAgLy8gVGhpcyBpbmRpY2F0b3IgaGFzIGFuIGFycmF5IG9mIHZhbHVlcyBzbyB3ZSBuZWVkIHRvIGNhbGN1bGF0ZSBtaW4vbWF4CiAgICAgIC8vIGRpZmZlcmVudAogICAgICBpZiAoWydFMTBhOSddLmluY2x1ZGVzKGluZGljYXRvckNvZGUpKSB7CiAgICAgICAgY29uc3QgbWVhc0ZsYXQgPSB0aGlzLmluZGljYXRvck9iamVjdC5tZWFzdXJlbWVudC5mbGF0KCk7CiAgICAgICAgeUF4ZXNbMF0udGlja3Muc3VnZ2VzdGVkTWluID0gTWF0aC5taW4oLi4ubWVhc0ZsYXQpOwogICAgICAgIHlBeGVzWzBdLnRpY2tzLnN1Z2dlc3RlZE1heCA9IE1hdGgubWF4KC4uLm1lYXNGbGF0KTsKICAgICAgfQoKICAgICAgY29uc3QgbGVnZW5kID0gewogICAgICAgIGxhYmVsczogewogICAgICAgICAgZ2VuZXJhdGVMYWJlbHM6IChjaGFydCkgPT4gewogICAgICAgICAgICBjb25zdCB7IGRhdGFzZXRzIH0gPSBjaGFydC5kYXRhOwogICAgICAgICAgICBjb25zdCB7IGxhYmVscyB9ID0gY2hhcnQubGVnZW5kLm9wdGlvbnM7CiAgICAgICAgICAgIGNvbnN0IHsgdXNlUG9pbnRTdHlsZSB9ID0gbGFiZWxzOwogICAgICAgICAgICBjb25zdCBvdmVycmlkZVN0eWxlID0gbGFiZWxzLnBvaW50U3R5bGU7CiAgICAgICAgICAgIGxldCBsYWJlbFNldCA9IGNoYXJ0Ll9nZXRTb3J0ZWREYXRhc2V0TWV0YXMoKTsKICAgICAgICAgICAgbGFiZWxTZXQgPSBsYWJlbFNldC5maWx0ZXIoKG1ldGEpID0+IHsKICAgICAgICAgICAgICBsZXQgaW5jbHVkZUxhYmVsID0gZmFsc2U7CiAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRhc2V0c1ttZXRhLmluZGV4XSwgJ2xhYmVsJykpIHsKICAgICAgICAgICAgICAgIGluY2x1ZGVMYWJlbCA9ICFkYXRhc2V0c1ttZXRhLmluZGV4XS5sYWJlbC5zdGFydHNXaXRoKCdoaWRlXycpOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICByZXR1cm4gaW5jbHVkZUxhYmVsOwogICAgICAgICAgICB9KTsKICAgICAgICAgICAgY29uc3QgbGFiZWxPYmplY3RzID0gbGFiZWxTZXQubWFwKChtZXRhKSA9PiB7CiAgICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSBtZXRhLmNvbnRyb2xsZXIuZ2V0U3R5bGUodXNlUG9pbnRTdHlsZSA/IDAgOiB1bmRlZmluZWQpOwogICAgICAgICAgICAgIGNvbnN0IGJvcmRlcldpZHRoID0gMjsKICAgICAgICAgICAgICBsZXQgaGlkZGVuID0gZmFsc2U7CiAgICAgICAgICAgICAgaWYgKG1ldGEuaGlkZGVuID09PSB0cnVlKSB7CiAgICAgICAgICAgICAgICBoaWRkZW4gPSB0cnVlOwogICAgICAgICAgICAgIH0KICAgICAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICAgICAgdGV4dDogZGF0YXNldHNbbWV0YS5pbmRleF0ubGFiZWwsCiAgICAgICAgICAgICAgICBmaWxsU3R5bGU6IHN0eWxlLmJhY2tncm91bmRDb2xvciwKICAgICAgICAgICAgICAgIGhpZGRlbiwKICAgICAgICAgICAgICAgIGxpbmVDYXA6IHN0eWxlLmJvcmRlckNhcFN0eWxlLAogICAgICAgICAgICAgICAgbGluZURhc2g6IHN0eWxlLmJvcmRlckRhc2gsCiAgICAgICAgICAgICAgICBsaW5lRGFzaE9mZnNldDogc3R5bGUuYm9yZGVyRGFzaE9mZnNldCwKICAgICAgICAgICAgICAgIGxpbmVKb2luOiBzdHlsZS5ib3JkZXJKb2luU3R5bGUsCiAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IGJvcmRlcldpZHRoLAogICAgICAgICAgICAgICAgc3Ryb2tlU3R5bGU6IHN0eWxlLmJvcmRlckNvbG9yLAogICAgICAgICAgICAgICAgcG9pbnRTdHlsZTogb3ZlcnJpZGVTdHlsZSB8fCBzdHlsZS5wb2ludFN0eWxlLAogICAgICAgICAgICAgICAgcm90YXRpb246IHN0eWxlLnJvdGF0aW9uLAogICAgICAgICAgICAgICAgLy8gQmVsb3cgaXMgZXh0cmEgZGF0YSB1c2VkIGZvciB0b2dnbGluZyB0aGUgZGF0YXNldHMKICAgICAgICAgICAgICAgIGRhdGFzZXRJbmRleDogbWV0YS5pbmRleCwKICAgICAgICAgICAgICB9OwogICAgICAgICAgICB9LCB0aGlzKTsKICAgICAgICAgICAgLy8gTm93IHdlIGFkZCBvdXIgZGVmYXVsdCAyIGxvY2tkb3duIGxhYmVscyBidXQgd2UgZXhjbHVkZSBpbmRpY2F0b3JzCiAgICAgICAgICAgIC8vIHdoZXJlIGl0IGlzIG5vdCBhcHBsaWNhYmxlCiAgICAgICAgICAgIGlmICghWydFMTBhMScsICdFMTBhNScsICdFMTBhOCcsICdOMicsICdONGMnLCAnRTEyYycsICdFMTJkJywgJ0dTQScsICdOMSddCiAgICAgICAgICAgICAgLmluY2x1ZGVzKHRoaXMuaW5kaWNhdG9yT2JqZWN0LmluZGljYXRvcikpIHsKICAgICAgICAgICAgICBsYWJlbE9iamVjdHMucHVzaCh7CiAgICAgICAgICAgICAgICB0ZXh0OiAnTG93IFJlc3RyaWN0aW9ucycsCiAgICAgICAgICAgICAgICBmaWxsU3R5bGU6ICdyZ2JhKDIwNCwgMTQzLCAxNDMsIDAuMjQpJywKICAgICAgICAgICAgICAgIGhpZGRlbjogZmFsc2UsCiAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IDAsCiAgICAgICAgICAgICAgICBkYXRhc2V0SW5kZXg6IC0xLAogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICAgIGxhYmVsT2JqZWN0cy5wdXNoKHsKICAgICAgICAgICAgICAgIHRleHQ6ICdIaWdoIFJlc3RyaWN0aW9ucycsCiAgICAgICAgICAgICAgICBmaWxsU3R5bGU6ICdyZ2JhKDIwNywgMTA5LCAxMDksIDAuNTQpJywKICAgICAgICAgICAgICAgIGhpZGRlbjogZmFsc2UsCiAgICAgICAgICAgICAgICBsaW5lV2lkdGg6IDAsCiAgICAgICAgICAgICAgICBkYXRhc2V0SW5kZXg6IC0xLAogICAgICAgICAgICAgIH0pOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiBsYWJlbE9iamVjdHM7CiAgICAgICAgICB9LAogICAgICAgIH0sCiAgICAgIH07CgogICAgICBpZiAoWydONGMnXS5pbmNsdWRlcyhpbmRpY2F0b3JDb2RlKSkgewogICAgICAgIHhBeGVzID0gW3sKICAgICAgICAgIHN0YWNrZWQ6IHRydWUsCiAgICAgICAgfV07CiAgICAgICAgeUF4ZXNbMF0uc3RhY2tlZCA9IHRydWU7CiAgICAgICAgeUF4ZXNbMF0udGlja3MuYmVnaW5BdFplcm8gPSB0cnVlOwogICAgICAgIHlBeGVzWzBdLnRpY2tzLnN1Z2dlc3RlZE1pbiA9IE1hdGgubWluKAogICAgICAgICAgLi4udGhpcy5pbmRpY2F0b3JPYmplY3QubWVhc3VyZW1lbnQKICAgICAgICAgICAgLmZpbHRlcigoZCkgPT4gIU51bWJlci5pc05hTihkKSksCiAgICAgICAgKTsKICAgICAgICB5QXhlc1swXS50aWNrcy5zdWdnZXN0ZWRNYXggPSBNYXRoLm1heCgKICAgICAgICAgIC4uLnRoaXMuaW5kaWNhdG9yT2JqZWN0Lm1lYXN1cmVtZW50CiAgICAgICAgICAgIC5maWx0ZXIoKGQpID0+ICFOdW1iZXIuaXNOYU4oZCkpLAogICAgICAgICk7CiAgICAgIH0KCiAgICAgIGlmIChbJ0UxMmInXS5pbmNsdWRlcyhpbmRpY2F0b3JDb2RlKSkgewogICAgICAgIC8vIHVwZGF0ZSB1c2VkIHlheGlzIGNoYXJ0IG1heCB0byBiZSBtYXggdmFsdWUKICAgICAgICB5QXhlc1swXS50aWNrcy5zdWdnZXN0ZWRNYXggPSBNYXRoLm1heCgKICAgICAgICAgIC4uLnRoaXMuaW5kaWNhdG9yT2JqZWN0Lm1lYXN1cmVtZW50CiAgICAgICAgICAgIC5maWx0ZXIoKGQpID0+ICFOdW1iZXIuaXNOYU4oZCkpLAogICAgICAgICk7CiAgICAgIH0KCiAgICAgIGlmIChbJ0UxMmInLCAnRTFhJywgJ0UxJywgJ0UyJywgJ0UyX1MyJywgJ0UxYV9TMicsICdFMV9TMicsICdFMTNkJ10uaW5jbHVkZXMoaW5kaWNhdG9yQ29kZSkpIHsKICAgICAgLy8gdXBkYXRlIHVzZWQgeWF4aXMgY2hhcnQgbWluIHRvIGJlIG1pbiB2YWx1ZQogICAgICAgIHlBeGVzWzBdLnRpY2tzLnN1Z2dlc3RlZE1pbiA9IE1hdGgubWluKAogICAgICAgICAgLi4udGhpcy5pbmRpY2F0b3JPYmplY3QubWVhc3VyZW1lbnQKICAgICAgICAgICAgLmZpbHRlcigoZCkgPT4gIU51bWJlci5pc05hTihkKSksCiAgICAgICAgKTsKICAgICAgfQogICAgICBpZiAoWydDVicsICdPVyddLmluY2x1ZGVzKGluZGljYXRvckNvZGUpKSB7CiAgICAgICAgeUF4ZXNbMF0udGlja3MuYmVnaW5BdFplcm8gPSB0cnVlOwogICAgICAgIHlBeGVzWzBdLnRpY2tzID0gewogICAgICAgICAgbGluZUhlaWdodDogMSwKICAgICAgICAgIHN1Z2dlc3RlZE1pbjogTWF0aC5taW4oCiAgICAgICAgICAgIC4uLnRoaXMuaW5kaWNhdG9yT2JqZWN0Lm1lYXN1cmVtZW50CiAgICAgICAgICAgICAgLmZpbHRlcigoZCkgPT4gIU51bWJlci5pc05hTihkKSksCiAgICAgICAgICApLAogICAgICAgICAgc3VnZ2VzdGVkTWF4OiBNYXRoLm1heCgKICAgICAgICAgICAgLi4udGhpcy5pbmRpY2F0b3JPYmplY3QubWVhc3VyZW1lbnQKICAgICAgICAgICAgICAuZmlsdGVyKChkKSA9PiAhTnVtYmVyLmlzTmFOKGQpKSwKICAgICAgICAgICksCiAgICAgICAgfTsKICAgICAgfQoKICAgICAgaWYgKFsnRTEwYTEnLCAnRTEwYTUnXS5pbmNsdWRlcyhpbmRpY2F0b3JDb2RlKSkgewogICAgICAgIHlBeGVzWzBdLnRpY2tzLmJlZ2luQXRaZXJvID0gdHJ1ZTsKICAgICAgICBwbHVnaW5zID0gewogICAgICAgICAgZGF0YWxhYmVsczogewogICAgICAgICAgICBsYWJlbHM6IHsKICAgICAgICAgICAgICB2YWx1ZTogewogICAgICAgICAgICAgICAgYW5jaG9yOiAnZW5kJywKICAgICAgICAgICAgICAgIGFsaWduOiAnZW5kJywKICAgICAgICAgICAgICAgIG9mZnNldDogMTAsCiAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6ICh2YWx1ZSwgY29udGV4dCkgPT4gewogICAgICAgICAgICAgICAgICBsZXQgbGFiZWxSZXMgPSAnJzsKICAgICAgICAgICAgICAgICAgY29uc3QgcGVyY2VudGFnZSA9IGNvbnRleHQuY2hhcnQuZGF0YS5kYXRhc2V0c1tjb250ZXh0LmRhdGFzZXRJbmRleF0KICAgICAgICAgICAgICAgICAgICAuaW5kTGFiZWxzW2NvbnRleHQuZGF0YUluZGV4XTsKICAgICAgICAgICAgICAgICAgaWYgKCFbJycsICcvJ10uaW5jbHVkZXMocGVyY2VudGFnZSkpIHsKICAgICAgICAgICAgICAgICAgICBjb25zdCBwZXJjVmFsID0gTnVtYmVyKChwZXJjZW50YWdlICogMTAwKS50b1ByZWNpc2lvbig0KSk7CiAgICAgICAgICAgICAgICAgICAgaWYgKHBlcmNWYWwgPiAwKSB7CiAgICAgICAgICAgICAgICAgICAgICBsYWJlbFJlcyA9IGArJHtwZXJjVmFsfSVgOwogICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgICBsYWJlbFJlcyA9IGAke3BlcmNWYWx9JWA7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHJldHVybiBsYWJlbFJlczsKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICBjb2xvcjogKGNvbnRleHQpID0+IHsKICAgICAgICAgICAgICAgICAgbGV0IGNvbG9yID0gJ3JlZCc7CiAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LmNoYXJ0LmRhdGEuZGF0YXNldHNbY29udGV4dC5kYXRhc2V0SW5kZXhdCiAgICAgICAgICAgICAgICAgICAgLmluZExhYmVsc1tjb250ZXh0LmRhdGFJbmRleF0gPiAwKSB7CiAgICAgICAgICAgICAgICAgICAgY29sb3IgPSAnZ3JlZW4nOwogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgIHJldHVybiBjb2xvcjsKICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICB0aXRsZTogewogICAgICAgICAgICAgICAgY29sb3I6ICdibGFjaycsCiAgICAgICAgICAgICAgICBhbmNob3I6ICdlbmQnLAogICAgICAgICAgICAgICAgYWxpZ246ICdlbmQnLAogICAgICAgICAgICAgICAgb2Zmc2V0OiAtNiwKICAgICAgICAgICAgICAgIGZvcm1hdHRlcjogKHZhbHVlKSA9PiB2YWx1ZS50b0ZpeGVkKDEpLAogICAgICAgICAgICAgIH0sCiAgICAgICAgICAgIH0sCiAgICAgICAgICB9LAogICAgICAgIH07CiAgICAgIH0KICAgICAgaWYgKFsnRTgnXS5pbmNsdWRlcyhpbmRpY2F0b3JDb2RlKSkgewogICAgICAgIHlBeGVzWzBdLnRpY2tzLnN1Z2dlc3RlZE1pbiA9IE1hdGgubWluKAogICAgICAgICAgLi4udGhpcy5pbmRpY2F0b3JPYmplY3QubWVhc3VyZW1lbnQKICAgICAgICAgICAgLmZpbHRlcigoZCkgPT4gIU51bWJlci5pc05hTihkKSksCiAgICAgICAgKTsKICAgICAgICB5QXhlc1swXS50aWNrcy5zdWdnZXN0ZWRNYXggPSBNYXRoLm1heCgKICAgICAgICAgIC4uLnRoaXMuaW5kaWNhdG9yT2JqZWN0Lm1lYXN1cmVtZW50CiAgICAgICAgICAgIC5maWx0ZXIoKGQpID0+ICFOdW1iZXIuaXNOYU4oZCkpLAogICAgICAgICk7CiAgICAgIH0KICAgICAgaWYgKFsnRTknXS5pbmNsdWRlcyhpbmRpY2F0b3JDb2RlKSkgewogICAgICAgIHlBeGVzWzBdLnRpY2tzLnN1Z2dlc3RlZE1pbiA9IDA7CiAgICAgICAgeUF4ZXNbMF0udGlja3Muc3VnZ2VzdGVkTWF4ID0gTWF0aC5tYXgoCiAgICAgICAgICAuLi50aGlzLmluZGljYXRvck9iamVjdC5tZWFzdXJlbWVudAogICAgICAgICAgICAuZmlsdGVyKChkKSA9PiAhTnVtYmVyLmlzTmFOKGQpKSwKICAgICAgICApOwogICAgICB9CiAgICAgIGlmIChbJ0UxMGE2JywgJ0UxMGE3J10uaW5jbHVkZXMoaW5kaWNhdG9yQ29kZSkpIHsKICAgICAgICB5QXhlc1swXS50aWNrcy5iZWdpbkF0WmVybyA9IHRydWU7CiAgICAgICAgcGx1Z2lucyA9IHsKICAgICAgICAgIGRhdGFsYWJlbHM6IHsKICAgICAgICAgICAgbGFiZWxzOiB7CiAgICAgICAgICAgICAgdGl0bGU6IHsKICAgICAgICAgICAgICAgIGNvbG9yOiAoY29udGV4dCkgPT4gY29udGV4dC5kYXRhc2V0LmJhY2tncm91bmRDb2xvciwKICAgICAgICAgICAgICAgIGZvbnQ6IHsKICAgICAgICAgICAgICAgICAgc2l6ZTogMTAsCiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgYW5jaG9yOiAnZW5kJywKICAgICAgICAgICAgICAgIGFsaWduOiAnZW5kJywKICAgICAgICAgICAgICAgIG9mZnNldDogKGNvbnRleHQpID0+IHsKICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQuY2hhcnQuZGF0YS5kYXRhc2V0cy5sZW5ndGggPT09IDIpIHsKICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5kYXRhc2V0SW5kZXggPT09IDApIHsKICAgICAgICAgICAgICAgICAgICAgIGlmICghTnVtYmVyLmlzTmFOKGNvbnRleHQuY2hhcnQuZGF0YS5kYXRhc2V0c1sxXS5kYXRhW2NvbnRleHQuZGF0YUluZGV4XS55KQogICAgICAgICAgICAgICAgICAgICAgICAmJiBjb250ZXh0LmNoYXJ0LmRhdGEuZGF0YXNldHNbMF0uZGF0YVtjb250ZXh0LmRhdGFJbmRleF0ueQogICAgICAgICAgICAgICAgICAgICAgICA+IGNvbnRleHQuY2hhcnQuZGF0YS5kYXRhc2V0c1sxXS5kYXRhW2NvbnRleHQuZGF0YUluZGV4XS55KSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwOwogICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0yODsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4oY29udGV4dC5jaGFydC5kYXRhLmRhdGFzZXRzWzBdLmRhdGFbY29udGV4dC5kYXRhSW5kZXhdLnkpCiAgICAgICAgICAgICAgICAgICAgICAmJiBjb250ZXh0LmNoYXJ0LmRhdGEuZGF0YXNldHNbMF0uZGF0YVtjb250ZXh0LmRhdGFJbmRleF0ueQogICAgICAgICAgICAgICAgICAgICAgPiBjb250ZXh0LmNoYXJ0LmRhdGEuZGF0YXNldHNbMV0uZGF0YVtjb250ZXh0LmRhdGFJbmRleF0ueSkgewogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0yODsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgZm9ybWF0dGVyOiAodmFsdWUpID0+IGAke3ZhbHVlLnkudG9GaXhlZCgxKX0lYCwKICAgICAgICAgICAgICB9LAogICAgICAgICAgICB9LAogICAgICAgICAgfSwKICAgICAgICB9OwogICAgICB9CgogICAgICBpZiAoWydOMicsICdFMTJjJywgJ0UxMmQnXS5pbmNsdWRlcyhpbmRpY2F0b3JDb2RlKSkgewogICAgICAgIHlBeGVzWzBdLnRpY2tzLmJlZ2luQXRaZXJvID0gdHJ1ZTsKICAgICAgfQoKICAgICAgaWYgKFsnRTEwYTMnLCAnRTEwYTgnXS5pbmNsdWRlcyhpbmRpY2F0b3JDb2RlKSkgewogICAgICAgIHlBeGVzWzBdLnRpY2tzID0gewogICAgICAgICAgc3VnZ2VzdGVkTWluOiBOdW1iZXIuTmFOLAogICAgICAgICAgc3VnZ2VzdGVkTWF4OiBOdW1iZXIuTmFOLAogICAgICAgICAgcGFkZGluZzogLTIwLAogICAgICAgIH07CiAgICAgIH0KICAgICAgaWYgKFsnRTEwYycsICdFMTBhMicsICdFMTBhNicsICdFMTBhNyddLmluY2x1ZGVzKGluZGljYXRvckNvZGUpKSB7CiAgICAgICAgeUF4ZXNbMF0udGlja3Muc3VnZ2VzdGVkTWluICs9IDE7CiAgICAgICAgeUF4ZXNbMF0udGlja3Muc3VnZ2VzdGVkTWF4IC09IDE7CiAgICAgIH0KCiAgICAgIGlmIChbJ04zJ10uaW5jbHVkZXMoaW5kaWNhdG9yQ29kZSkpIHsKICAgICAgICB5QXhlc1swXS50eXBlID0gJ215TG9nU2NhbGUnOwogICAgICAgIGlmICh0aGlzLmluZGljYXRvck9iamVjdC5hb2lJRCA9PT0gJ0VTMTknKSB7CiAgICAgICAgICB5QXhlc1swXS5taW4gPSAwLjAyOwogICAgICAgICAgeUF4ZXNbMF0ubWF4ID0gMTsKICAgICAgICB9CiAgICAgICAgeUF4ZXNbMF0udGlja3MgPSB7CiAgICAgICAgICBjYWxsYmFjazogKC4uLmFyZ3MpID0+IHsKICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBDaGFydC5UaWNrcy5mb3JtYXR0ZXJzLmxvZ2FyaXRobWljLmNhbGwodGhpcywgLi4uYXJncyk7CiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGgpIHsKICAgICAgICAgICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKS50b0xvY2FsZVN0cmluZygpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIHJldHVybiB2YWx1ZTsKICAgICAgICAgIH0sCiAgICAgICAgfTsKICAgICAgICBsZWdlbmQubGFiZWxzLnVzZVBvaW50U3R5bGUgPSB0cnVlOwogICAgICAgIGxlZ2VuZC5sYWJlbHMuYm94V2lkdGggPSA1OwogICAgICAgIGxlZ2VuZC5vbkNsaWNrID0gZnVuY3Rpb24gb25DbGljayhlLCBsZWdlbmRJdGVtKSB7CiAgICAgICAgICBpZiAobGVnZW5kSXRlbS50ZXh0ID09PSAnU3RhbmRhcmQgZGV2aWF0aW9uIChTVEQpJykgewogICAgICAgICAgICBjb25zdCBtYXN0ZXJJbmRleCA9IGxlZ2VuZEl0ZW0uZGF0YXNldEluZGV4OwogICAgICAgICAgICBjb25zdCBzbGF2ZUluZGV4ID0gMzsKICAgICAgICAgICAgY29uc3QgY2kgPSB0aGlzLmNoYXJ0OwogICAgICAgICAgICBjb25zdCBtYXN0ZXJNZXRhID0gY2kuZ2V0RGF0YXNldE1ldGEobWFzdGVySW5kZXgpOwogICAgICAgICAgICBjb25zdCBtZXRhID0gY2kuZ2V0RGF0YXNldE1ldGEoc2xhdmVJbmRleCk7CiAgICAgICAgICAgIGlmIChtYXN0ZXJNZXRhLmhpZGRlbiA9PT0gbnVsbCkgewogICAgICAgICAgICAgIG1hc3Rlck1ldGEuaGlkZGVuID0gdHJ1ZTsKICAgICAgICAgICAgICBtZXRhLmhpZGRlbiA9IHRydWU7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgbWFzdGVyTWV0YS5oaWRkZW4gPSAhbWFzdGVyTWV0YS5oaWRkZW47CiAgICAgICAgICAgICAgbWV0YS5oaWRkZW4gPSAhbWV0YS5oaWRkZW47CiAgICAgICAgICAgIH0KICAgICAgICAgICAgY2kudXBkYXRlKCk7CiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBDaGFydC5kZWZhdWx0cy5nbG9iYWwubGVnZW5kLm9uQ2xpY2suY2FsbCh0aGlzLCBlLCBsZWdlbmRJdGVtKTsKICAgICAgICAgIH0KICAgICAgICB9OwogICAgICB9CgogICAgICBjb25zdCBkZWZhdWx0U2V0dGluZ3MgPSB7CiAgICAgICAgcmVzcG9uc2l2ZTogdHJ1ZSwKICAgICAgICBtYWludGFpbkFzcGVjdFJhdGlvOiBmYWxzZSwKICAgICAgICBwbHVnaW5zLAogICAgICAgIGxlZ2VuZCwKICAgICAgICBzY2FsZXM6IHsKICAgICAgICAgIHhBeGVzLAogICAgICAgICAgeUF4ZXMsCiAgICAgICAgfSwKICAgICAgICBwYW46IHsKICAgICAgICAgIGVuYWJsZWQ6IHRydWUsCiAgICAgICAgICBtb2RlOiAneCcsCiAgICAgICAgfSwKICAgICAgICB6b29tOiB7CiAgICAgICAgICBlbmFibGVkOiB0cnVlLAogICAgICAgICAgbW9kZTogJ3gnLAogICAgICAgIH0sCiAgICAgICAgdG9vbHRpcHM6IHsKICAgICAgICAgIGNhbGxiYWNrczogewogICAgICAgICAgICBsYWJlbDogZnVuY3Rpb24gKGNvbnRleHQsIGRhdGEpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZQogICAgICAgICAgICAgIGxldCBsYWJlbCA9IGRhdGEuZGF0YXNldHNbY29udGV4dC5kYXRhc2V0SW5kZXhdLmxhYmVsIHx8ICcnOwogICAgICAgICAgICAgIGlmIChsYWJlbCkgewogICAgICAgICAgICAgICAgbGFiZWwgKz0gJzogJzsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgbGFiZWwgKz0gdGhpcy5yb3VuZFZhbHVlSW5kKE51bWJlcihjb250ZXh0LnZhbHVlKSk7CiAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsOwogICAgICAgICAgICB9LmJpbmQodGhpcyksCiAgICAgICAgICB9LAogICAgICAgIH0sCiAgICAgIH07CgogICAgICBpZiAoWydOMyddLmluY2x1ZGVzKGluZGljYXRvckNvZGUpKSB7CiAgICAgICAgZGVmYXVsdFNldHRpbmdzLnRvb2x0aXBzID0gewogICAgICAgICAgY2FsbGJhY2tzOiB7CiAgICAgICAgICAgIGxhYmVsOiAoY29udGV4dCkgPT4gewogICAgICAgICAgICAgIGNvbnN0IHsgZGF0YXNldHMgfSA9IHRoaXMuZGF0YWNvbGxlY3Rpb247CiAgICAgICAgICAgICAgY29uc3QgdmFsID0gZGF0YXNldHNbY29udGV4dC5kYXRhc2V0SW5kZXhdLmRhdGFbY29udGV4dC5pbmRleF07CiAgICAgICAgICAgICAgcmV0dXJuIGBWYWx1ZSAoTG9nMTApOiAke01hdGgubG9nMTAodmFsKS50b1ByZWNpc2lvbig0KX1gOwogICAgICAgICAgICB9LAogICAgICAgICAgfSwKICAgICAgICB9OwogICAgICB9CgogICAgICBpZiAoWydFMTBhMyddLmluY2x1ZGVzKGluZGljYXRvckNvZGUpKSB7CiAgICAgICAgZGVmYXVsdFNldHRpbmdzLmdlbyA9IHsKICAgICAgICAgIHJhZGl1c1NjYWxlOiB7CiAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsCiAgICAgICAgICAgIHNpemU6IFsxLCAyMF0sCiAgICAgICAgICB9LAogICAgICAgIH07CgogICAgICAgIGRlZmF1bHRTZXR0aW5ncy5zY2FsZSA9IHsKICAgICAgICAgIHByb2plY3Rpb246ICdtZXJjYXRvcicsCiAgICAgICAgfTsKCiAgICAgICAgZGVmYXVsdFNldHRpbmdzLnBhbi5tb2RlID0gJ3h5JzsKICAgICAgICBkZWZhdWx0U2V0dGluZ3Muem9vbS5tb2RlID0gJ3h5JzsKICAgICAgICBkZWZhdWx0U2V0dGluZ3MubGVnZW5kLmRpc3BsYXkgPSBmYWxzZTsKCiAgICAgICAgZGVmYXVsdFNldHRpbmdzLnRvb2x0aXBzID0gewogICAgICAgICAgY2FsbGJhY2tzOiB7CiAgICAgICAgICAgIGxhYmVsOiAoY29udGV4dCkgPT4gewogICAgICAgICAgICAgIGNvbnN0IHsgZGF0YXNldHMgfSA9IHRoaXMuZGF0YWNvbGxlY3Rpb247CiAgICAgICAgICAgICAgY29uc3Qgb2JqID0gZGF0YXNldHNbY29udGV4dC5kYXRhc2V0SW5kZXhdLmRhdGFbY29udGV4dC5pbmRleF07CiAgICAgICAgICAgICAgcmV0dXJuIG9iai5uYW1lOwogICAgICAgICAgICB9LAogICAgICAgICAgICBmb290ZXI6IChjb250ZXh0KSA9PiB7CiAgICAgICAgICAgICAgY29uc3QgeyBkYXRhc2V0cyB9ID0gdGhpcy5kYXRhY29sbGVjdGlvbjsKICAgICAgICAgICAgICBjb25zdCBvYmogPSBkYXRhc2V0c1tjb250ZXh0WzBdLmRhdGFzZXRJbmRleF0uZGF0YVtjb250ZXh0WzBdLmluZGV4XTsKICAgICAgICAgICAgICBjb25zdCByZWZUID0gb2JqLnJlZmVyZW5jZVRpbWU7CiAgICAgICAgICAgICAgY29uc3QgcmVmViA9IE51bWJlcihvYmoucmVmZXJlbmNlVmFsdWUpOwogICAgICAgICAgICAgIGNvbnN0IGxhYmVsT3V0cHV0ID0gWwogICAgICAgICAgICAgICAgYCR7b2JqLnRpbWUudG9JU09EYXRlKCl9OiAgJHtvYmoudmFsdWUudG9QcmVjaXNpb24oNCl9YCwKICAgICAgICAgICAgICAgIGAke3JlZlQudG9JU09EYXRlKCl9OiAgJHtyZWZWLnRvUHJlY2lzaW9uKDQpfWAsCiAgICAgICAgICAgICAgXTsKICAgICAgICAgICAgICBpZiAocmVmViAhPT0gMCkgewogICAgICAgICAgICAgICAgbGFiZWxPdXRwdXQucHVzaCgKICAgICAgICAgICAgICAgICAgYCR7KCgob2JqLnZhbHVlIC0gcmVmVikgLyByZWZWKSAqIDEwMCkudG9QcmVjaXNpb24oMil9ICVgLAogICAgICAgICAgICAgICAgKTsKICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsT3V0cHV0OwogICAgICAgICAgICB9LAogICAgICAgICAgfSwKICAgICAgICB9OwogICAgICB9CgogICAgICBpZiAoWydFMTBhOCddLmluY2x1ZGVzKGluZGljYXRvckNvZGUpKSB7CiAgICAgICAgZGVmYXVsdFNldHRpbmdzLmdlbyA9IHsKICAgICAgICAgIHJhZGl1c1NjYWxlOiB7CiAgICAgICAgICAgIGRpc3BsYXk6IHRydWUsCiAgICAgICAgICAgIHJhbmdlOiBbNSwgMjVdLAogICAgICAgICAgICB0aWNrczogewogICAgICAgICAgICAgIG1heDogMjAwMDAwMCwKICAgICAgICAgICAgfSwKICAgICAgICAgIH0sCiAgICAgICAgfTsKCiAgICAgICAgZGVmYXVsdFNldHRpbmdzLnNjYWxlID0gewogICAgICAgICAgcHJvamVjdGlvbjogJ21lcmNhdG9yJywKICAgICAgICAgIG1heDogMjAsCiAgICAgICAgfTsKCiAgICAgICAgZGVmYXVsdFNldHRpbmdzLnBhbi5tb2RlID0gJ3h5JzsKICAgICAgICBkZWZhdWx0U2V0dGluZ3Muem9vbS5tb2RlID0gJ3h5JzsKICAgICAgICBkZWZhdWx0U2V0dGluZ3MubGVnZW5kLmRpc3BsYXkgPSBmYWxzZTsKCiAgICAgICAgZGVmYXVsdFNldHRpbmdzLnRvb2x0aXBzID0gewogICAgICAgICAgY2FsbGJhY2tzOiB7CiAgICAgICAgICAgIGxhYmVsOiAoY29udGV4dCkgPT4gewogICAgICAgICAgICAgIGNvbnN0IHsgZGF0YXNldHMgfSA9IHRoaXMuZGF0YWNvbGxlY3Rpb247CiAgICAgICAgICAgICAgY29uc3Qgb2JqID0gZGF0YXNldHNbY29udGV4dC5kYXRhc2V0SW5kZXhdLmRhdGFbY29udGV4dC5pbmRleF07CiAgICAgICAgICAgICAgcmV0dXJuIG9iai5uYW1lOwogICAgICAgICAgICB9LAogICAgICAgICAgICBmb290ZXI6IChjb250ZXh0KSA9PiB7CiAgICAgICAgICAgICAgY29uc3QgeyBkYXRhc2V0cyB9ID0gdGhpcy5kYXRhY29sbGVjdGlvbjsKICAgICAgICAgICAgICBjb25zdCBvYmogPSBkYXRhc2V0c1tjb250ZXh0WzBdLmRhdGFzZXRJbmRleF0uZGF0YVtjb250ZXh0WzBdLmluZGV4XTsKICAgICAgICAgICAgICBjb25zdCByZWZWID0gTnVtYmVyKG9iai5yZWZlcmVuY2VWYWx1ZSk7CiAgICAgICAgICAgICAgY29uc3QgbGFiZWxPdXRwdXQgPSBbCiAgICAgICAgICAgICAgICBgJHtvYmoudGltZS50b0lTT0RhdGUoKX06YCwKICAgICAgICAgICAgICAgIGAkeyhyZWZWKS50b1ByZWNpc2lvbig0KX0gJSBoYXJ2ZXN0ZWRgLAogICAgICAgICAgICAgICAgYCR7KDEwMCAtIHJlZlYpLnRvUHJlY2lzaW9uKDQpfSAlIG5vdCBoYXJ2ZXN0ZWRgLAogICAgICAgICAgICAgICAgYE1heC4gYXJlYTogJHtvYmoudmFsdWV9IGhhYCwKICAgICAgICAgICAgICBdOwogICAgICAgICAgICAgIHJldHVybiBsYWJlbE91dHB1dDsKICAgICAgICAgICAgfSwKICAgICAgICAgIH0sCiAgICAgICAgfTsKICAgICAgfQoKICAgICAgcmV0dXJuIHsKICAgICAgICAuLi5kZWZhdWx0U2V0dGluZ3MsCiAgICAgICAgYW5ub3RhdGlvbjogewogICAgICAgICAgYW5ub3RhdGlvbnMsCiAgICAgICAgfSwKICAgICAgfTsKICAgIH0sCiAgfSwKfTsK"},{"version":3,"sources":["IndicatorData.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"IndicatorData.vue","sourceRoot":"src/components","sourcesContent":["<template>\n  <div style=\"width: 100%; height: 100%;\"\n    v-if=\"!['E10a2', 'E10a3', 'E10a6', 'E10a7', 'E10a8', 'E10a9',\n      'E10c', 'N1', 'N3', 'N3b', 'E8',\n      'E13e', 'E13f', 'E13g', 'E13h', 'E13i', 'E13l', 'E13m',\n      'N1a', 'N1b', 'N1c', 'N1d', 'E12b', 'GG', 'GSA', 'CV', 'OW']\n      .includes(indicatorObject.indicator)\">\n      <bar-chart v-if='datacollection'\n        id=\"chart\"\n        class=\"fill-height\"\n        :width=\"null\"\n        :height=\"null\"\n        :chart-data='datacollection'\n        :options='chartOptions()'></bar-chart>\n  </div>\n  <div style=\"width: 100%; height: 100%;\"\n    v-else-if=\"['E10a3', 'E10a8'].includes(indicatorObject.indicator)\">\n      <map-chart\n        id=\"chart\"\n        class=\"fill-height\"\n        :width=\"null\"\n        :height=\"null\"\n        :chart-data='datacollection'\n        :options='chartOptions()'>\n      </map-chart>\n      <img v-if=\"indicatorObject.indicator=='E10a3'\"\n        :src=\"require('@/assets/E10a3_label.jpg')\" alt=\"color legend\"\n        style=\"position: absolute; width: 200px; z-index: 0;\n        top: 0px; right: 0px;\"/>\n      <img v-else\n        :src=\"require('@/assets/E10a8_label.jpg')\" alt=\"color legend\"\n        style=\"position: absolute; width: 150px; z-index: 0;\n        top: 0px; right: 0px;\"/>\n      <v-row\n        class=\"justify-center align-center timeSelection mr-6 ml-0\"\n        style=\"position: absolute; bottom: 0px; z-index: 1000;\n          width: auto; max-width: 100%;left:-45px;\"\n      >\n        <v-col cols=\"6\">\n          <v-select\n            outlined dense autofocus hide-details\n            :prepend-inner-icon=\"(arrayOfObjects && dataLayerTime) && (arrayOfObjects\n              .map((i) => i.value)\n              .indexOf(dataLayerTime) > 0\n                ? 'mdi-arrow-left-drop-circle'\n                : 'mdi-asterisk')\"\n            :append-icon=\"(arrayOfObjects && dataLayerTime) && (arrayOfObjects\n              .map((i) => i.value)\n              .indexOf(dataLayerTime) < arrayOfObjects.length - 1\n                ? 'mdi-arrow-right-drop-circle'\n                : 'mdi-asterisk')\"\n            menu-props=\"auto\"\n            :items=\"arrayOfObjects\"\n            item-value=\"value\"\n            item-text=\"name\"\n            v-model=\"dataLayerTime\"\n            @change=\"dataLayerTimeSelection\"\n            @click:prepend-inner=\"dataLayerReduce\"\n            @click:append=\"dataLayerIncrease\">\n          </v-select>\n        </v-col>\n      </v-row>\n  </div>\n  <div style=\"width: 100%; height: 100%;\" v-else>\n    <line-chart v-if='datacollection'\n      id=\"chart\"\n      class=\"fill-height\"\n      :width=\"null\"\n      :height=\"null\"\n      :chart-data='datacollection'\n      :options='chartOptions()'></line-chart>\n  </div>\n</template>\n\n<script>\nimport { DateTime } from 'luxon';\nimport {\n  mapState,\n} from 'vuex';\nimport BarChart from '@/components/BarChart.vue';\nimport LineChart from '@/components/LineChart.vue';\nimport MapChart from '@/components/MapChart.vue';\nimport NUTS from '@/assets/NUTS_RG_03M_2016_4326_ESL2-DEL3.json';\nimport lockdownTimes from '@/assets/lockdown_data.json';\nimport countries from '@/assets/countries.json';\n\nexport default {\n  props: [\n    'currentIndicator',\n  ],\n  components: {\n    BarChart,\n    LineChart,\n    MapChart,\n  },\n  data() {\n    return {\n      dataLayerTime: null,\n      dataLayerIndex: 0,\n    };\n  },\n  mounted() {\n    const d = this.indicatorObject.time[this.indicatorObject.time.length - 1];\n    this.dataLayerTime = d.toFormat('dd. MMM');\n  },\n  computed: {\n    ...mapState('config', ['appConfig', 'baseConfig']),\n    arrayOfObjects() {\n      const indicator = { ...this.indicatorObject };\n      const indicatorCode = indicator.indicator;\n      const selectionOptions = [];\n      if (['E10a3', 'E10a8'].includes(indicatorCode)) {\n        // Find all unique day/month available\n        const timeset = new Set(\n          indicator.time.map((d) => d.toFormat('dd. MMM')),\n        );\n        timeset.forEach((t) => {\n          selectionOptions.push({\n            value: t,\n            name: t,\n          });\n        });\n      }\n      return selectionOptions;\n    },\n    datacollection() {\n      const indicator = { ...this.indicatorObject };\n      const indicatorCode = indicator.indicator;\n      let dataCollection;\n      const refColors = [\n        '#22aa99', '#a37', '#47a', '#a67', '#283', '#bbb',\n        '#6ce', '#994499', '#aaaa11', '#6633cc', '#e67300',\n      ];\n      if (indicator) {\n        let labels = [];\n        const { measurement } = indicator;\n        const colors = [];\n        const datasets = [];\n        if (['E10a1', 'E10a5'].includes(indicatorCode)) {\n          const referenceValue = indicator.referenceValue.map(Number);\n          for (let i = 0; i < indicator.time.length; i += 1) {\n            if (!Number.isNaN(indicator.time[i].toMillis())) {\n              const d = indicator.time[i];\n              const formattedDate = d.toFormat('dd. MMM');\n              labels.push(formattedDate);\n            } else {\n              labels.push(i);\n            }\n          }\n          const labelref = '2019';\n          const labelmeas = '2020';\n          datasets.push({\n            indLabels: Array(indicator.indicatorValue.length).join('.').split('.'),\n            label: labelref,\n            data: referenceValue,\n            fill: false,\n            backgroundColor: 'grey',\n          });\n          datasets.push({\n            indLabels: indicator.indicatorValue,\n            label: labelmeas,\n            data: measurement,\n            fill: false,\n            backgroundColor: 'black',\n          });\n        } else if (['E10a9'].includes(indicatorCode)) {\n          const categories = [\n            'National Workers',\n            'Foreign Workers',\n            'Unknown',\n          ];\n          categories.forEach((key, idx) => {\n            const data = indicator.measurement.map((row, rowIdx) => ({\n              t: indicator.time[rowIdx],\n              y: row[idx],\n            }));\n            datasets.push({\n              label: key,\n              data,\n              fill: false,\n              borderColor: refColors[idx],\n              backgroundColor: refColors[idx],\n              cubicInterpolationMode: 'monotone',\n              borderWidth: 1,\n              pointRadius: 2,\n            });\n          });\n        } else if (['GG'].includes(indicatorCode)) {\n          const vals = indicator.Values;\n          const datasetsObj = {\n            grocery: [],\n            parks: [],\n            residential: [],\n            retail_recreation: [],\n            transit_stations: [],\n          };\n          for (let entry = 0; entry < vals.length; entry += 1) {\n            const t = DateTime.fromISO(vals[entry].date);\n            datasetsObj.grocery.push({ t, y: vals[entry].grocery });\n            datasetsObj.parks.push({ t, y: vals[entry].parks });\n            datasetsObj.residential.push({ t, y: vals[entry].residential });\n            datasetsObj.retail_recreation.push({ t, y: vals[entry].retail_recreation });\n            datasetsObj.transit_stations.push({ t, y: vals[entry].transit_stations });\n          }\n          Object.keys(datasetsObj).forEach((key, idx) => {\n            datasets.push({\n              label: key,\n              data: datasetsObj[key],\n              fill: false,\n              borderColor: refColors[idx],\n              backgroundColor: refColors[idx],\n              borderWidth: 1,\n              pointRadius: 2,\n              cubicInterpolationMode: 'monotone',\n            });\n          });\n        } else if (['GSA'].includes(indicatorCode)) {\n          const vals = Object.keys(indicator.values);\n          const datasetsObj = {};\n          for (let entry = 0; entry < vals.length; entry += 1) {\n            datasetsObj[vals[entry]] = [];\n            const currVals = indicator.values[vals[entry]].values;\n            for (let i = 0; i < currVals.length; i += 1) {\n              datasetsObj[vals[entry]].push({\n                t: DateTime.fromISO(currVals[i].timestamp),\n                y: Number(currVals[i].waiting_time),\n              });\n            }\n            // It seems some timstamps are mixed in order so let us sort by date\n            // to get nice line connections through the timeline\n            datasetsObj[vals[entry]].sort((a, b) => a.t.toMillis() - b.t.toMillis());\n          }\n          Object.keys(indicator.values).forEach((key, idx) => {\n            datasets.push({\n              label: key,\n              data: datasetsObj[key],\n              fill: false,\n              borderColor: refColors[idx],\n              backgroundColor: refColors[idx],\n              borderWidth: 1,\n              pointRadius: 2,\n              cubicInterpolationMode: 'monotone',\n            });\n          });\n        } else if (['CV'].includes(indicatorCode)) {\n          const vals = indicator.Values;\n          const datasetsObj = {\n            confirmed: [],\n          };\n          for (let entry = 0; entry < vals.length; entry += 1) {\n            const t = DateTime.fromISO(vals[entry].date);\n            datasetsObj.confirmed.push({ t, y: Number(vals[entry].confirmed) });\n          }\n          Object.keys(datasetsObj).forEach((key, idx) => {\n            datasets.push({\n              label: key,\n              data: datasetsObj[key],\n              fill: false,\n              borderColor: refColors[idx],\n              backgroundColor: refColors[idx],\n              borderWidth: 1,\n              pointRadius: 2,\n              cubicInterpolationMode: 'monotone',\n            });\n          });\n        } else if (['OW'].includes(indicatorCode)) {\n          const vals = indicator.Values;\n          const pI = [\n            'total_vaccinations', 'people_fully_vaccinated',\n            'daily_vaccinations',\n          ];\n          const datasetsObj = {};\n          for (let idx = 0; idx < pI.length; idx += 1) {\n            datasetsObj[pI[idx]] = [];\n          }\n          for (let entry = 0; entry < vals.length; entry += 1) {\n            const t = DateTime.fromISO(vals[entry].date);\n            for (let idx = 0; idx < pI.length; idx += 1) {\n              datasetsObj[pI[idx]].push({ t, y: vals[entry][pI[idx]] });\n            }\n          }\n          Object.keys(datasetsObj).forEach((key, idx) => {\n            datasets.push({\n              label: key,\n              data: datasetsObj[key],\n              fill: false,\n              borderColor: refColors[idx],\n              backgroundColor: refColors[idx],\n              borderWidth: 1,\n              pointRadius: 2,\n              cubicInterpolationMode: 'monotone',\n            });\n          });\n        } else if (['N3b'].includes(indicatorCode)) {\n          const sensors = Array.from(new Set(indicator.eoSensor)).sort();\n          for (let pp = 0; pp < sensors.length; pp += 1) {\n            const pKey = sensors[pp];\n            const data = indicator.time.map((date, i) => {\n              let output = null;\n              if (indicator.eoSensor[i] === pKey) {\n                output = { t: date, y: measurement[i] };\n              }\n              return output;\n            }).filter((d) => d !== null);\n            let colorUsed = refColors[pp];\n            if (this.indDefinition.sensorColorMap && this.indDefinition.sensorColorMap[pKey]) {\n              colorUsed = this.indDefinition.sensorColorMap[pKey];\n            }\n            datasets.push({\n              label: pKey,\n              data,\n              fill: false,\n              borderColor: colorUsed,\n              backgroundColor: colorUsed,\n              cubicInterpolationMode: 'monotone',\n            });\n          }\n        } else if (['N4c'].includes(indicatorCode)) {\n          const measData = indicator.measurement.map(Number);\n          measData.shift();\n          const refData = indicator.referenceValue.map(Number);\n          refData.shift();\n\n          labels = [\n            indicator.referenceTime[0].toISODate(),\n            indicator.time[0].toISODate(),\n            indicator.time[5].toISODate(),\n          ];\n\n          datasets.push({\n            label: 'metallic waste area',\n            data: [refData[0], measData[0], measData[5]],\n            backgroundColor: refColors[0],\n          });\n          datasets.push({\n            label: 'mixed waste area',\n            data: [refData[1], measData[1], measData[6]],\n            backgroundColor: refColors[1],\n          });\n          datasets.push({\n            label: 'plastic waste area',\n            data: [refData[2], measData[2], measData[7]],\n            backgroundColor: refColors[2],\n          });\n          datasets.push({\n            label: 'soil waste area',\n            data: [refData[3], measData[3], measData[8]],\n            backgroundColor: refColors[3],\n          });\n        } else if (['E10a2', 'E10a6', 'E10a7', 'E8', 'E13e', 'E13f', 'E13g', 'E13h', 'E13i', 'E13l', 'E13m'].includes(indicatorCode)) {\n          const uniqueRefs = [];\n          const uniqueMeas = [];\n          const referenceValue = indicator.referenceValue.map(Number);\n          indicator.time.forEach((date, i) => {\n            const meas = { t: date.set({ year: 2000 }), y: measurement[i] };\n            if (typeof uniqueRefs.find((item) => item.t.equals(meas.t)) === 'undefined') {\n              uniqueMeas.push(meas);\n            }\n          });\n          indicator.referenceTime.forEach((date, i) => {\n            if (!['', '/'].includes(indicator.referenceValue[i])) {\n              const ref = { t: date.set({ year: 2000 }), y: referenceValue[i] };\n              if (typeof uniqueRefs.find((item) => item.t.equals(ref.t)) === 'undefined') {\n                uniqueRefs.push(ref);\n              }\n            }\n          });\n          datasets.push({\n            label: '2020',\n            data: uniqueMeas,\n            fill: false,\n            borderColor: refColors[1],\n            backgroundColor: refColors[1],\n            borderWidth: 2,\n          });\n          if (uniqueRefs.length > 0) {\n            datasets.push({\n              label: '2019',\n              data: uniqueRefs,\n              fill: false,\n              borderColor: refColors[0],\n              backgroundColor: refColors[0],\n              borderWidth: 2,\n            });\n          }\n        } else if (['E13n', 'C1', 'C2', 'C3'].includes(indicatorCode)) {\n          // Group by indicator value\n          const types = {};\n          indicator.indicatorValue.forEach((ind, idx) => {\n            if (Object.keys(types).includes(ind)) {\n              types[ind].push({\n                t: DateTime.fromISO(indicator.time[idx]),\n                y: Number(indicator.measurement[idx]),\n              });\n            } else {\n              types[ind] = [{\n                t: DateTime.fromISO(indicator.time[idx]),\n                y: Number(indicator.measurement[idx]),\n              }];\n            }\n          });\n          Object.keys(types).forEach((key, i) => {\n            datasets.push({\n              label: key,\n              fill: false,\n              data: types[key],\n              backgroundColor: refColors[i],\n              borderColor: refColors[i],\n              borderWidth: 2,\n            });\n          });\n        } else if (['N2', 'E10c'].includes(indicatorCode)) {\n          /* Group data by year in month slices */\n          const data = indicator.time.map((date, i) => {\n            colors.push(this.getIndicatorColor(indicator.colorCode[i]));\n            return { t: date, y: measurement[i] };\n          });\n          const dataGroups = {};\n          const colorGroups = {};\n          for (let i = 0; i < data.length; i += 1) {\n            const currYear = data[i].t.year;\n            if (Object.prototype.hasOwnProperty.call(dataGroups, currYear)) {\n              dataGroups[currYear].push({\n                t: data[i].t.set({ year: 2000 }),\n                y: [data[i].y],\n              });\n              colorGroups[currYear].push(colors[i]);\n            } else {\n              dataGroups[currYear] = [{\n                t: data[i].t.set({ year: 2000 }),\n                y: [data[i].y],\n              }];\n              colorGroups[currYear] = [colors[i]];\n            }\n          }\n          const uniqueYears = Object.keys(dataGroups);\n          uniqueYears.sort();\n          const yLength = uniqueYears.length - 1;\n          uniqueYears.forEach((key, i) => {\n            datasets.push({\n              // fill with empty values\n              indLabels: Array(dataGroups[key].length).join('.').split('.'),\n              label: key,\n              fill: false,\n              data: dataGroups[key],\n              backgroundColor: refColors[yLength - i],\n              borderColor: refColors[yLength - i],\n              borderWidth: 2,\n            });\n          });\n        } else if (['N1'].includes(indicatorCode)) {\n          const stdDevMin = [];\n          const stdDevMax = [];\n          const min = [];\n          const max = [];\n          const median = [];\n          const data = [];\n          indicator.referenceValue.forEach((item, i) => {\n            const t = indicator.time[i];\n            data.push({ y: measurement[i], t });\n            if (!Number.isNaN(item) && !['NaN', '/'].includes(item)) {\n              const obj = JSON.parse(item);\n              // [median,std,max,min,percentage valid pixels]\n              median.push({ y: obj[0], t });\n              if (obj[1] !== null) {\n                stdDevMin.push({ y: measurement[i] - obj[1], t });\n                stdDevMax.push({ y: measurement[i] + obj[1], t });\n              }\n              max.push({ y: obj[2], t });\n              min.push({ y: obj[3], t });\n            } else {\n              median.push({ y: Number.NaN, t });\n              stdDevMin.push({ y: Number.NaN, t });\n              stdDevMax.push({ y: Number.NaN, t });\n              max.push({ y: Number.NaN, t });\n              min.push({ y: Number.NaN, t });\n            }\n          });\n          datasets.push({\n            label: indicator.yAxis,\n            data,\n            fill: false,\n            backgroundColor: refColors[0],\n            borderColor: refColors[0],\n            spanGaps: false,\n            borderWidth: 2,\n          });\n          // Check for empty array, if it is the case do not include data\n          if (typeof (median.find((a) => a.y !== null)) !== 'undefined') {\n            datasets.push({\n              label: 'Median',\n              data: median,\n              fill: false,\n              pointRadius: 0,\n              borderColor: 'black',\n              borderWidth: 1,\n              pointStyle: 'line',\n              spanGaps: false,\n            });\n          }\n          // Check for empty array, if it is the case do not include data\n          if (typeof (min.find((a) => a.y !== null)) !== 'undefined') {\n            datasets.push({\n              label: 'Min',\n              data: min,\n              fill: false,\n              pointRadius: 0,\n              backgroundColor: refColors[4],\n              borderColor: refColors[4],\n              borderWidth: 1,\n              pointStyle: 'line',\n              spanGaps: false,\n            });\n          }\n          // Check for empty array, if it is the case do not include data\n          if (typeof (max.find((a) => a.y !== null)) !== 'undefined') {\n            datasets.push({\n              label: 'Max',\n              data: max,\n              fill: false,\n              pointRadius: 0,\n              backgroundColor: refColors[1],\n              borderColor: refColors[1],\n              borderWidth: 1,\n              pointStyle: 'line',\n              spanGaps: false,\n            });\n          }\n          // Check for empty array, if it is the case do not include data\n          if (typeof (stdDevMax.find((a) => a.y !== null)) !== 'undefined') {\n            datasets.push({\n              label: 'Standard deviation (STD)',\n              data: stdDevMax,\n              fill: '+1',\n              pointRadius: 0,\n              spanGaps: false,\n              backgroundColor: 'rgba(0,0,0,0.1)',\n              borderColor: 'rgba(0,0,0,0.0)',\n              pointStyle: 'rect',\n            });\n          }\n          // Check for empty array, if it is the case do not include data\n          if (typeof (stdDevMin.find((a) => a.y !== null)) !== 'undefined') {\n            datasets.push({\n              label: 'hide_',\n              data: stdDevMin,\n              fill: '-1',\n              pointRadius: 0,\n              spanGaps: false,\n              backgroundColor: 'rgba(0,0,0,0.0)',\n              borderColor: 'rgba(0,0,0,0.0)',\n              pointStyle: 'rect',\n            });\n          }\n        } else if (['N3'].includes(indicatorCode)) {\n          let referenceValue = [];\n          const stdDev = [];\n          indicator.referenceValue.forEach((item) => {\n            if (!Number.isNaN(item) && !['NaN', '[NaN NaN]', '/'].includes(item)) {\n              const obj = JSON.parse(item.replace(/,/g, '.').replace(' ', ','));\n              if (obj[0] !== -999 && obj[1] !== -999) {\n                referenceValue.push(obj[0]);\n                stdDev.push(obj[1]);\n              } else {\n                referenceValue.push(Number.NaN);\n                stdDev.push(Number.NaN);\n              }\n            } else {\n              referenceValue.push(Number.NaN);\n              stdDev.push(Number.NaN);\n            }\n          });\n\n          const stdDevMax = stdDev.map((dev, i) => (\n            Number.isNaN(referenceValue[i])\n              ? Number.NaN\n              : (10 ** (referenceValue[i] + dev))\n          ));\n          const stdDevMin = stdDev.map((dev, i) => (\n            Number.isNaN(referenceValue[i])\n              ? Number.NaN\n              : (10 ** (referenceValue[i] - dev))\n          ));\n\n          referenceValue = referenceValue.map((val) => (\n            Number.isNaN(val) ? Number.NaN : (10 ** val)\n          ));\n\n          for (let i = 0; i < indicator.time.length; i += 1) {\n            if (!Number.isNaN(indicator.time[i].toMillis())) {\n              labels.push(indicator.time[i].toISODate());\n            } else {\n              labels.push(i);\n            }\n            let colorCode = '';\n            if (Object.prototype.hasOwnProperty.call(indicator, 'colorCode')) {\n              colorCode = indicator.colorCode[i];\n            }\n            colors.push(this.getIndicatorColor(colorCode));\n          }\n\n          datasets.push({\n            label: 'Weekly climatology of chlorophyll conc. (CHL_clim) 2017-2019',\n            data: referenceValue,\n            fill: false,\n            pointRadius: 0,\n            borderColor: 'black',\n            pointStyle: 'line',\n            spanGaps: false,\n          });\n          datasets.push({\n            label: 'Standard deviation (STD)',\n            data: stdDevMax,\n            fill: '+1',\n            pointRadius: 0,\n            spanGaps: false,\n            backgroundColor: 'rgba(0,0,0,0.1)',\n            borderColor: 'rgba(0,0,0,0.0)',\n            pointStyle: 'rect',\n          });\n          datasets.push({\n            label: 'hide_',\n            data: stdDevMin,\n            fill: '-1',\n            pointRadius: 0,\n            spanGaps: false,\n            backgroundColor: 'rgba(0,0,0,0.0)',\n            borderColor: 'rgba(0,0,0,0.0)',\n            pointStyle: 'rect',\n          });\n\n          // Find unique indicator values\n          const indicatorValues = {};\n          indicator.indicatorValue.map((val, i) => {\n            let key = val.toLowerCase();\n            key = key.charAt(0).toUpperCase() + key.slice(1);\n            if (!['', '/'].includes(key) && typeof indicatorValues[key] === 'undefined') {\n              indicatorValues[key] = this.getIndicatorColor(\n                indicator.colorCode[i],\n              );\n            }\n            return null;\n          });\n\n          Object.entries(indicatorValues).forEach(([key, value]) => {\n            const currMeas = measurement.map((row, i) => {\n              let val = row;\n              if (indicator.indicatorValue[i] !== key.toUpperCase()) {\n                val = NaN;\n              }\n              return val;\n            });\n            datasets.push({\n              label: key,\n              data: currMeas.map((val) => (\n                Number.isNaN(val) ? Number.NaN : (10 ** val)\n              )),\n              backgroundColor: value,\n              borderColor: value,\n              fill: false,\n              showLine: false,\n              spanGaps: false,\n            });\n          });\n        } else if (['N1a', 'N1b', 'N1c', 'N1d', 'E12b'].includes(indicatorCode)) {\n          const maxRef = [];\n          const minRef = [];\n          const mean7dRef = [];\n          const mean7d2020 = [];\n          indicator.referenceValue.forEach((item, i) => {\n            const t = indicator.time[i];\n            if (!['', '/'].includes(item)) {\n              const obj = item.replace(/[[\\] ]/g, '').split(',')\n                .map((str) => (str === '' ? Number.NaN : Number(str)));\n              maxRef.push({ y: obj[0], t });\n              minRef.push({ y: obj[1], t });\n              mean7dRef.push({ y: obj[2], t });\n              mean7d2020.push({ y: obj[3], t });\n            } else {\n              maxRef.push({ y: Number.NaN, t });\n              minRef.push({ y: Number.NaN, t });\n              mean7dRef.push({ y: Number.NaN, t });\n              mean7d2020.push({ y: Number.NaN, t });\n            }\n          });\n\n          datasets.push({\n            label: 'Value',\n            data: measurement.map((meas, i) => ({ y: meas, t: indicator.time[i] })),\n            backgroundColor: 'rgba(255,255,255,0.0)',\n            borderColor: 'red',\n            spanGaps: false,\n            pointRadius: 0,\n            borderWidth: 1.5,\n          });\n          datasets.push({\n            label: '7-day mean',\n            data: mean7d2020,\n            backgroundColor: 'rgba(255,255,255,0.0)',\n            pointRadius: 0,\n            borderColor: 'red',\n            spanGaps: false,\n            borderDash: [6, 3],\n            borderWidth: 2,\n          });\n          datasets.push({\n            label: '2017-2019 7d mean',\n            data: mean7dRef,\n            backgroundColor: 'rgba(255,255,255,0.0)',\n            pointRadius: 0,\n            borderColor: 'grey',\n            spanGaps: false,\n            borderDash: [6, 3],\n            borderWidth: 2,\n          });\n          datasets.push({\n            label: '2017-2019 range',\n            data: maxRef,\n            fill: 4,\n            pointRadius: 0,\n            spanGaps: false,\n            backgroundColor: 'rgba(0,0,0,0.2)',\n            borderColor: 'rgba(0,0,0,0.0)',\n            pointStyle: 'rect',\n          });\n          datasets.push({\n            label: 'hide_',\n            data: minRef,\n            fill: 3,\n            pointRadius: 0,\n            spanGaps: false,\n            backgroundColor: 'rgba(0,0,0,0.0)',\n            borderColor: 'rgba(0,0,0,0.0)',\n            pointStyle: 'rect',\n          });\n\n          // Find unique indicator values\n          const indicatorValues = {};\n          indicator.indicatorValue.map((val, i) => {\n            let key = val.toLowerCase();\n            key = key.charAt(0).toUpperCase() + key.slice(1);\n            if (!['', '/'].includes(key) && typeof indicatorValues[key] === 'undefined') {\n              indicatorValues[key] = this.getIndicatorColor(\n                indicator.colorCode[i],\n              );\n            }\n            return null;\n          });\n\n          Object.entries(indicatorValues).forEach(([key, value]) => {\n            datasets.push({\n              label: key,\n              data: [],\n              backgroundColor: value,\n              borderColor: value,\n            });\n          });\n        } else if (['E10a3', 'E10a8'].includes(indicatorCode)) {\n          const nutsFeatures = NUTS.features;\n          const outline = [];\n          const currIDs = [];\n          let features = measurement.map((meas, i) => {\n            // Find correct NUTS ID Shape\n            const geom = nutsFeatures.find((f) => (\n              f.properties.NUTS_ID === indicator.siteName[i]));\n            let output;\n            if (geom) {\n              if (currIDs.indexOf(indicator.siteName[i]) === -1) {\n                currIDs.push(indicator.siteName[i]);\n                outline.push({\n                  type: 'Feature',\n                  properties: {},\n                  geometry: geom.geometry,\n                });\n              }\n              const { coordinates } = geom.geometry;\n              const lons = (geom.geometry.type === 'Polygon') ? coordinates.flat(1).map((tuple) => tuple[0]) : coordinates.flat(2).map((tuple) => tuple[0]);\n              const lats = (geom.geometry.type === 'Polygon') ? coordinates.flat(1).map((tuple) => tuple[1]) : coordinates.flat(2).map((tuple) => tuple[1]);\n              const minLat = Math.min(...lats);\n              const minLon = Math.min(...lons);\n              const centerPoint = {\n                lat: minLat + (Math.max(...lats) - minLat) / 2,\n                lon: minLon + (Math.max(...lons) - minLon) / 2,\n              };\n              output = {\n                type: 'Feature',\n                properties: {},\n                geometry: geom.geometry,\n                description: 'description',\n                latitude: centerPoint.lat,\n                longitude: centerPoint.lon,\n                name: geom.properties.NUTS_NAME,\n                time: indicator.time[i],\n                value: Number(meas),\n                referenceTime: indicator.referenceTime[i],\n                referenceValue: indicator.referenceValue[i],\n                color: indicator.colorCode[i],\n              };\n              if (indicatorCode === 'E10a8') {\n                // Swap value to have reference value\n                output.value = Number(indicator.referenceValue[i]);\n                output.referenceValue = Number(meas);\n              }\n            }\n            return output;\n          });\n\n          // Filter by undefined and time\n          features = features.filter((d) => (\n            typeof d !== 'undefined'));\n\n          const filteredFeatures = features.filter((d) => {\n            let include = false;\n            if (d.time instanceof DateTime) {\n              include = d.time.toFormat('dd. MMM') === this.dataLayerTime\n                && !Number.isNaN(d.value);\n            }\n            return include;\n          });\n\n          labels = features.map((d) => d.name);\n          datasets.push({\n            outline,\n            outlineBackgroundColor: null,\n            outlineBorderColor: 'black',\n            outlineBorderWidth: 1,\n            showOutline: true,\n            backgroundColor: filteredFeatures.map((d) => d.color),\n            borderColor: filteredFeatures.map((d) => d.color),\n            borderWidth: 3,\n            data: filteredFeatures,\n            clipMap: 'items',\n          });\n        } else {\n          const data = indicator.time.map((date, i) => {\n            colors.push(this.getIndicatorColor(indicator.colorCode[i]));\n            return { t: date, y: measurement[i] };\n          });\n          datasets.push({\n            data,\n            label: indicator.yAxis,\n            backgroundColor: colors,\n            borderColor: colors,\n          });\n        }\n        dataCollection = {\n          labels,\n          datasets,\n        };\n      }\n      return dataCollection;\n    },\n    indicatorObject() {\n      return this.currentIndicator\n        || this.$store.state.indicators.customAreaIndicator\n        || this.$store.state.indicators.selectedIndicator;\n    },\n    indDefinition() {\n      return this.baseConfig.indicatorsDefinition[this.indicatorObject.indicator];\n    },\n  },\n  methods: {\n    dataLayerTimeSelection(payload) {\n      this.dataLayerTime = payload;\n      const newIndex = this.arrayOfObjects\n        .map((i) => i.value)\n        .indexOf(this.dataLayerTime);\n      this.dataLayerIndex = newIndex;\n    },\n    dataLayerReduce() {\n      const currentIndex = this.arrayOfObjects\n        .map((i) => i.value)\n        .indexOf(this.dataLayerTime);\n      this.dataLayerIndex = currentIndex - 1;\n      this.dataLayerTimeSelection(this.arrayOfObjects[currentIndex - 1].value);\n    },\n    dataLayerIncrease() {\n      const currentIndex = this.arrayOfObjects\n        .map((i) => i.value)\n        .indexOf(this.dataLayerTime);\n      this.dataLayerIndex = currentIndex + 1;\n      this.dataLayerTimeSelection(this.arrayOfObjects[currentIndex + 1].value);\n    },\n    formatNumRef(num, maxDecimals = 3) {\n      return Number.parseFloat(num.toFixed(maxDecimals));\n    },\n    roundValueInd(val) {\n      if (this.indDefinition.maxDecimals === -1) {\n        return val;\n      }\n      if (Number.isInteger(this.indDefinition.maxDecimals)) {\n        return this.formatNumRef(val, this.indDefinition.maxDecimals);\n      }\n      // use default\n      return this.formatNumRef(val, 2);\n    },\n    getMinMaxDate(timeData) {\n      let timeMin = Math.min.apply(null, timeData.map((d) => d.toMillis()));\n      let timeMax = Math.max.apply(null, timeData.map((d) => d.toMillis()));\n      const buffer = (timeMax - timeMin) / timeData.length;\n      timeMin -= buffer;\n      timeMax += buffer;\n      return [timeMin, timeMax];\n    },\n    chartOptions() {\n      const indicatorCode = this.indicatorObject.indicator;\n      const reference = Number.parseFloat(this.indicatorObject.referenceValue);\n      let timeMinMax = this.getMinMaxDate(this.indicatorObject.time);\n      const annotations = [];\n      let low = 0;\n      let high = 0;\n      const defaultAnnotationSettings = {\n        type: 'line',\n        mode: 'horizontal',\n        scaleID: 'y-axis-0',\n        borderColor: 'rgba(0, 0, 255, 0.5)',\n        borderWidth: 2,\n        borderDash: [2, 3],\n        scales: {\n          xAxes: [{\n            type: 'time',\n            time: {\n              unit: 'month',\n            },\n          }],\n        },\n        label: {\n          enabled: true,\n          fontStyle: 'normal',\n          paddingX: 2,\n          paddingY: 2,\n          backgroundColor: 'rgba(255, 255, 255, 0.7)',\n          fontColor: 'rgba(0, 0, 0, 0.8)',\n        },\n      };\n      if (!Number.isNaN(reference)\n        && !['E10a1', 'E10a2', 'E10a5', 'E10a6', 'E10a7', 'E10a9', 'N4c', 'E8', 'E13e', 'E13f', 'E13g', 'E13h', 'E13i', 'E13l', 'E13m', 'E12c', 'E12d']\n          .includes(indicatorCode)) {\n        annotations.push({\n          ...defaultAnnotationSettings,\n          label: {\n            ...defaultAnnotationSettings.label,\n            content: `reference: ${this.formatNumRef(reference)}`,\n          },\n          value: reference,\n        });\n      }\n      if (['E4'].includes(indicatorCode)) {\n        low = 0.2 * reference;\n        annotations.push({\n          ...defaultAnnotationSettings,\n          borderColor: 'rgba(50, 252, 0, 0.5)',\n          value: low,\n          label: {\n            ...defaultAnnotationSettings.label,\n            content: `on/off: ${this.formatNumRef(low)}`,\n          },\n        });\n      } else if (['E11', 'E1a', 'E1', 'E2', 'E2_S2', 'E1a_S2', 'E1_S2'].includes(indicatorCode)) {\n        if (indicatorCode === 'E11') {\n          low = 0.3 * reference;\n          high = 0.7 * reference;\n        } else if (['E1a', 'E1', 'E2', 'E2_S2', 'E1a_S2', 'E1_S2'].includes(indicatorCode)) {\n          low = 0.7 * reference;\n          high = 1.3 * reference;\n        }\n        annotations.push({\n          ...defaultAnnotationSettings,\n          value: low,\n          label: {\n            ...defaultAnnotationSettings.label,\n            content: `low: ${this.formatNumRef(low)}`,\n          },\n        });\n        annotations.push({\n          ...defaultAnnotationSettings,\n          value: high,\n          label: {\n            ...defaultAnnotationSettings.label,\n            content: `high: ${this.formatNumRef(high)}`,\n          },\n        });\n      }\n\n      // Introduce background area annotations for lockdown times, does not\n      // work for all chart types, so we make sure it is not any of those charts\n      if (!['E10a3', 'E10a8', 'N2', 'E12c', 'E12d', 'GSA'].includes(indicatorCode)) {\n        // Find country based on alpha-3 code\n        const currCountry = countries.features.find(\n          (cntr) => cntr.properties.alpha2 === this.indicatorObject.country,\n        );\n        if (typeof currCountry !== 'undefined'\n          && Object.prototype.hasOwnProperty.call(lockdownTimes, currCountry.id)) {\n          const lckTs = lockdownTimes[currCountry.id]['C7_Restrictions on internal movement'];\n          for (let i = 0; i < lckTs.length; i++) {\n            let areaColor = 'rgba(0, 0, 0, 0.0)';\n            if (lckTs[i].value === 1) {\n              areaColor = 'rgba(204, 143, 143, 0.24)';\n            } else if (lckTs[i].value === 2) {\n              areaColor = 'rgba(207, 109, 109, 0.54)';\n            }\n            // We also have special date handling for some chart types as we\n            // simulate year agnostic rendering, so we convert all dates to\n            // one year\n            let start = DateTime.fromISO(lckTs[i].start);\n            let end = DateTime.fromISO(lckTs[i].end);\n            if (['E10a2', 'E10a6', 'E10a7', 'E10c', 'E8', 'E13e', 'E13f', 'E13g', 'E13h', 'E13i', 'E13l', 'E13m'].includes(indicatorCode)) {\n              start = start.set({ year: 2000 });\n              end = end.set({ year: 2000 });\n            }\n            if (lckTs[i].value !== 0) {\n              annotations.push({\n                drawTime: 'beforeDatasetsDraw',\n                type: 'box',\n                xScaleID: 'x-axis-0',\n                xMin: start.toISODate(),\n                xMax: end.toISODate(),\n                borderColor: areaColor,\n                borderWidth: 0,\n                backgroundColor: areaColor,\n              });\n            }\n          }\n        }\n      }\n\n      let xAxes = {};\n      if (!['E10a1', 'E10a2', 'E10a3', 'E10a5', 'E10a6', 'E10a7', 'E10a8', 'E10c', 'E12c', 'E12d', 'N2'].includes(indicatorCode)) {\n        xAxes = [{\n          type: 'time',\n          time: {\n            unit: 'week',\n          },\n          ticks: {\n            min: timeMinMax[0],\n            max: timeMinMax[1],\n          },\n          barThickness: 'flex',\n        }];\n        if (!['N3', 'N3b'].includes(indicatorCode)) {\n          xAxes[0].distribution = 'series';\n        }\n      }\n\n      if (['E10a2', 'E10a6', 'E10a7', 'E10c', 'E8', 'E13e', 'E13f', 'E13g', 'E13h', 'E13i', 'E13l', 'E13m'].includes(indicatorCode)) {\n        /* Recalculate to get min max months in data converted to one year */\n        timeMinMax = this.getMinMaxDate(\n          this.indicatorObject.time.map((date) => (\n            date.set({ year: 2000 })\n          )),\n        );\n        /* Check also for reference time */\n        const refTimeMinMax = this.getMinMaxDate(\n          this.indicatorObject.referenceTime.map((date) => (\n            date.set({ year: 2000 })\n          )),\n        );\n        xAxes = [{\n          type: 'time',\n          time: {\n            unit: 'month',\n            displayFormats: {\n              month: 'MMM',\n            },\n            tooltipFormat: 'dd. MMM',\n          },\n          ticks: {\n            min: (timeMinMax[0] < refTimeMinMax[0]) ? timeMinMax[0] : refTimeMinMax[0],\n            max: (timeMinMax[1] > refTimeMinMax[1]) ? timeMinMax[1] : refTimeMinMax[1],\n          },\n        }];\n      }\n\n      if (['N2'].includes(indicatorCode)) {\n        timeMinMax = this.getMinMaxDate(\n          this.indicatorObject.time.map((date) => (\n            date.set({ year: 2000 })\n          )),\n        );\n        xAxes = [{\n          type: 'time',\n          time: {\n            unit: 'month',\n            displayFormats: {\n              month: 'MMM',\n            },\n            tooltipFormat: 'dd. MMM',\n          },\n          distribution: 'series',\n          ticks: {\n            min: timeMinMax[0],\n            max: timeMinMax[1],\n          },\n        }];\n      }\n\n      if (['E12c', 'E12d'].includes(indicatorCode)) {\n        xAxes = [{\n          type: 'time',\n          time: {\n            unit: 'year',\n            displayFormats: {\n              year: 'yyyy',\n            },\n            tooltipFormat: 'yyyy-MM-dd - yyyy-06-30',\n          },\n          distribution: 'series',\n          ticks: {\n            min: timeMinMax[0],\n            max: timeMinMax[1],\n          },\n        }];\n      }\n\n      if (['E13d', 'E13n', 'C1', 'C2', 'C3'].includes(indicatorCode)) {\n        xAxes = [{\n          type: 'time',\n          time: {\n            unit: 'month',\n            displayFormats: {\n              month: 'MMM yy',\n            },\n            tooltipFormat: 'MMM yyyy',\n          },\n          distribution: 'series',\n          ticks: {\n            min: timeMinMax[0],\n            max: timeMinMax[1],\n          },\n        }];\n      }\n\n\n      let plugins = {\n        datalabels: {\n          display: false,\n        },\n      };\n\n      const yAxes = [{\n        scaleLabel: {\n          display: true,\n          labelString: this.indicatorObject.yAxis,\n          padding: 2,\n        },\n        ticks: {\n          lineHeight: 1,\n          suggestedMin: Math.min(\n            ...this.indicatorObject.measurement\n              .filter((d) => !Number.isNaN(d)),\n          ) - 1,\n          suggestedMax: Math.max(\n            ...this.indicatorObject.measurement\n              .filter((d) => !Number.isNaN(d)),\n          ) + 1,\n        },\n      }];\n\n      // This indicator has an array of values so we need to calculate min/max\n      // different\n      if (['E10a9'].includes(indicatorCode)) {\n        const measFlat = this.indicatorObject.measurement.flat();\n        yAxes[0].ticks.suggestedMin = Math.min(...measFlat);\n        yAxes[0].ticks.suggestedMax = Math.max(...measFlat);\n      }\n\n      const legend = {\n        labels: {\n          generateLabels: (chart) => {\n            const { datasets } = chart.data;\n            const { labels } = chart.legend.options;\n            const { usePointStyle } = labels;\n            const overrideStyle = labels.pointStyle;\n            let labelSet = chart._getSortedDatasetMetas();\n            labelSet = labelSet.filter((meta) => {\n              let includeLabel = false;\n              if (Object.prototype.hasOwnProperty.call(datasets[meta.index], 'label')) {\n                includeLabel = !datasets[meta.index].label.startsWith('hide_');\n              }\n              return includeLabel;\n            });\n            const labelObjects = labelSet.map((meta) => {\n              const style = meta.controller.getStyle(usePointStyle ? 0 : undefined);\n              const borderWidth = 2;\n              let hidden = false;\n              if (meta.hidden === true) {\n                hidden = true;\n              }\n              return {\n                text: datasets[meta.index].label,\n                fillStyle: style.backgroundColor,\n                hidden,\n                lineCap: style.borderCapStyle,\n                lineDash: style.borderDash,\n                lineDashOffset: style.borderDashOffset,\n                lineJoin: style.borderJoinStyle,\n                lineWidth: borderWidth,\n                strokeStyle: style.borderColor,\n                pointStyle: overrideStyle || style.pointStyle,\n                rotation: style.rotation,\n                // Below is extra data used for toggling the datasets\n                datasetIndex: meta.index,\n              };\n            }, this);\n            // Now we add our default 2 lockdown labels but we exclude indicators\n            // where it is not applicable\n            if (!['E10a1', 'E10a5', 'E10a8', 'N2', 'N4c', 'E12c', 'E12d', 'GSA', 'N1']\n              .includes(this.indicatorObject.indicator)) {\n              labelObjects.push({\n                text: 'Low Restrictions',\n                fillStyle: 'rgba(204, 143, 143, 0.24)',\n                hidden: false,\n                lineWidth: 0,\n                datasetIndex: -1,\n              });\n              labelObjects.push({\n                text: 'High Restrictions',\n                fillStyle: 'rgba(207, 109, 109, 0.54)',\n                hidden: false,\n                lineWidth: 0,\n                datasetIndex: -1,\n              });\n            }\n            return labelObjects;\n          },\n        },\n      };\n\n      if (['N4c'].includes(indicatorCode)) {\n        xAxes = [{\n          stacked: true,\n        }];\n        yAxes[0].stacked = true;\n        yAxes[0].ticks.beginAtZero = true;\n        yAxes[0].ticks.suggestedMin = Math.min(\n          ...this.indicatorObject.measurement\n            .filter((d) => !Number.isNaN(d)),\n        );\n        yAxes[0].ticks.suggestedMax = Math.max(\n          ...this.indicatorObject.measurement\n            .filter((d) => !Number.isNaN(d)),\n        );\n      }\n\n      if (['E12b'].includes(indicatorCode)) {\n        // update used yaxis chart max to be max value\n        yAxes[0].ticks.suggestedMax = Math.max(\n          ...this.indicatorObject.measurement\n            .filter((d) => !Number.isNaN(d)),\n        );\n      }\n\n      if (['E12b', 'E1a', 'E1', 'E2', 'E2_S2', 'E1a_S2', 'E1_S2', 'E13d'].includes(indicatorCode)) {\n      // update used yaxis chart min to be min value\n        yAxes[0].ticks.suggestedMin = Math.min(\n          ...this.indicatorObject.measurement\n            .filter((d) => !Number.isNaN(d)),\n        );\n      }\n      if (['CV', 'OW'].includes(indicatorCode)) {\n        yAxes[0].ticks.beginAtZero = true;\n        yAxes[0].ticks = {\n          lineHeight: 1,\n          suggestedMin: Math.min(\n            ...this.indicatorObject.measurement\n              .filter((d) => !Number.isNaN(d)),\n          ),\n          suggestedMax: Math.max(\n            ...this.indicatorObject.measurement\n              .filter((d) => !Number.isNaN(d)),\n          ),\n        };\n      }\n\n      if (['E10a1', 'E10a5'].includes(indicatorCode)) {\n        yAxes[0].ticks.beginAtZero = true;\n        plugins = {\n          datalabels: {\n            labels: {\n              value: {\n                anchor: 'end',\n                align: 'end',\n                offset: 10,\n                formatter: (value, context) => {\n                  let labelRes = '';\n                  const percentage = context.chart.data.datasets[context.datasetIndex]\n                    .indLabels[context.dataIndex];\n                  if (!['', '/'].includes(percentage)) {\n                    const percVal = Number((percentage * 100).toPrecision(4));\n                    if (percVal > 0) {\n                      labelRes = `+${percVal}%`;\n                    } else {\n                      labelRes = `${percVal}%`;\n                    }\n                  }\n                  return labelRes;\n                },\n                color: (context) => {\n                  let color = 'red';\n                  if (context.chart.data.datasets[context.datasetIndex]\n                    .indLabels[context.dataIndex] > 0) {\n                    color = 'green';\n                  }\n                  return color;\n                },\n              },\n              title: {\n                color: 'black',\n                anchor: 'end',\n                align: 'end',\n                offset: -6,\n                formatter: (value) => value.toFixed(1),\n              },\n            },\n          },\n        };\n      }\n      if (['E8'].includes(indicatorCode)) {\n        yAxes[0].ticks.suggestedMin = Math.min(\n          ...this.indicatorObject.measurement\n            .filter((d) => !Number.isNaN(d)),\n        );\n        yAxes[0].ticks.suggestedMax = Math.max(\n          ...this.indicatorObject.measurement\n            .filter((d) => !Number.isNaN(d)),\n        );\n      }\n      if (['E9'].includes(indicatorCode)) {\n        yAxes[0].ticks.suggestedMin = 0;\n        yAxes[0].ticks.suggestedMax = Math.max(\n          ...this.indicatorObject.measurement\n            .filter((d) => !Number.isNaN(d)),\n        );\n      }\n      if (['E10a6', 'E10a7'].includes(indicatorCode)) {\n        yAxes[0].ticks.beginAtZero = true;\n        plugins = {\n          datalabels: {\n            labels: {\n              title: {\n                color: (context) => context.dataset.backgroundColor,\n                font: {\n                  size: 10,\n                },\n                anchor: 'end',\n                align: 'end',\n                offset: (context) => {\n                  if (context.chart.data.datasets.length === 2) {\n                    if (context.datasetIndex === 0) {\n                      if (!Number.isNaN(context.chart.data.datasets[1].data[context.dataIndex].y)\n                        && context.chart.data.datasets[0].data[context.dataIndex].y\n                        > context.chart.data.datasets[1].data[context.dataIndex].y) {\n                        return 0;\n                      }\n                      return -28;\n                    }\n                    if (!Number.isNaN(context.chart.data.datasets[0].data[context.dataIndex].y)\n                      && context.chart.data.datasets[0].data[context.dataIndex].y\n                      > context.chart.data.datasets[1].data[context.dataIndex].y) {\n                      return -28;\n                    }\n                    return 0;\n                  }\n                  return 0;\n                },\n                formatter: (value) => `${value.y.toFixed(1)}%`,\n              },\n            },\n          },\n        };\n      }\n\n      if (['N2', 'E12c', 'E12d'].includes(indicatorCode)) {\n        yAxes[0].ticks.beginAtZero = true;\n      }\n\n      if (['E10a3', 'E10a8'].includes(indicatorCode)) {\n        yAxes[0].ticks = {\n          suggestedMin: Number.NaN,\n          suggestedMax: Number.NaN,\n          padding: -20,\n        };\n      }\n      if (['E10c', 'E10a2', 'E10a6', 'E10a7'].includes(indicatorCode)) {\n        yAxes[0].ticks.suggestedMin += 1;\n        yAxes[0].ticks.suggestedMax -= 1;\n      }\n\n      if (['N3'].includes(indicatorCode)) {\n        yAxes[0].type = 'myLogScale';\n        if (this.indicatorObject.aoiID === 'ES19') {\n          yAxes[0].min = 0.02;\n          yAxes[0].max = 1;\n        }\n        yAxes[0].ticks = {\n          callback: (...args) => {\n            const value = Chart.Ticks.formatters.logarithmic.call(this, ...args);\n            if (value.length) {\n              return Number(value).toLocaleString();\n            }\n            return value;\n          },\n        };\n        legend.labels.usePointStyle = true;\n        legend.labels.boxWidth = 5;\n        legend.onClick = function onClick(e, legendItem) {\n          if (legendItem.text === 'Standard deviation (STD)') {\n            const masterIndex = legendItem.datasetIndex;\n            const slaveIndex = 3;\n            const ci = this.chart;\n            const masterMeta = ci.getDatasetMeta(masterIndex);\n            const meta = ci.getDatasetMeta(slaveIndex);\n            if (masterMeta.hidden === null) {\n              masterMeta.hidden = true;\n              meta.hidden = true;\n            } else {\n              masterMeta.hidden = !masterMeta.hidden;\n              meta.hidden = !meta.hidden;\n            }\n            ci.update();\n          } else {\n            Chart.defaults.global.legend.onClick.call(this, e, legendItem);\n          }\n        };\n      }\n\n      const defaultSettings = {\n        responsive: true,\n        maintainAspectRatio: false,\n        plugins,\n        legend,\n        scales: {\n          xAxes,\n          yAxes,\n        },\n        pan: {\n          enabled: true,\n          mode: 'x',\n        },\n        zoom: {\n          enabled: true,\n          mode: 'x',\n        },\n        tooltips: {\n          callbacks: {\n            label: function (context, data) { // eslint-disable-line\n              let label = data.datasets[context.datasetIndex].label || '';\n              if (label) {\n                label += ': ';\n              }\n              label += this.roundValueInd(Number(context.value));\n              return label;\n            }.bind(this),\n          },\n        },\n      };\n\n      if (['N3'].includes(indicatorCode)) {\n        defaultSettings.tooltips = {\n          callbacks: {\n            label: (context) => {\n              const { datasets } = this.datacollection;\n              const val = datasets[context.datasetIndex].data[context.index];\n              return `Value (Log10): ${Math.log10(val).toPrecision(4)}`;\n            },\n          },\n        };\n      }\n\n      if (['E10a3'].includes(indicatorCode)) {\n        defaultSettings.geo = {\n          radiusScale: {\n            display: true,\n            size: [1, 20],\n          },\n        };\n\n        defaultSettings.scale = {\n          projection: 'mercator',\n        };\n\n        defaultSettings.pan.mode = 'xy';\n        defaultSettings.zoom.mode = 'xy';\n        defaultSettings.legend.display = false;\n\n        defaultSettings.tooltips = {\n          callbacks: {\n            label: (context) => {\n              const { datasets } = this.datacollection;\n              const obj = datasets[context.datasetIndex].data[context.index];\n              return obj.name;\n            },\n            footer: (context) => {\n              const { datasets } = this.datacollection;\n              const obj = datasets[context[0].datasetIndex].data[context[0].index];\n              const refT = obj.referenceTime;\n              const refV = Number(obj.referenceValue);\n              const labelOutput = [\n                `${obj.time.toISODate()}:  ${obj.value.toPrecision(4)}`,\n                `${refT.toISODate()}:  ${refV.toPrecision(4)}`,\n              ];\n              if (refV !== 0) {\n                labelOutput.push(\n                  `${(((obj.value - refV) / refV) * 100).toPrecision(2)} %`,\n                );\n              }\n              return labelOutput;\n            },\n          },\n        };\n      }\n\n      if (['E10a8'].includes(indicatorCode)) {\n        defaultSettings.geo = {\n          radiusScale: {\n            display: true,\n            range: [5, 25],\n            ticks: {\n              max: 2000000,\n            },\n          },\n        };\n\n        defaultSettings.scale = {\n          projection: 'mercator',\n          max: 20,\n        };\n\n        defaultSettings.pan.mode = 'xy';\n        defaultSettings.zoom.mode = 'xy';\n        defaultSettings.legend.display = false;\n\n        defaultSettings.tooltips = {\n          callbacks: {\n            label: (context) => {\n              const { datasets } = this.datacollection;\n              const obj = datasets[context.datasetIndex].data[context.index];\n              return obj.name;\n            },\n            footer: (context) => {\n              const { datasets } = this.datacollection;\n              const obj = datasets[context[0].datasetIndex].data[context[0].index];\n              const refV = Number(obj.referenceValue);\n              const labelOutput = [\n                `${obj.time.toISODate()}:`,\n                `${(refV).toPrecision(4)} % harvested`,\n                `${(100 - refV).toPrecision(4)} % not harvested`,\n                `Max. area: ${obj.value} ha`,\n              ];\n              return labelOutput;\n            },\n          },\n        };\n      }\n\n      return {\n        ...defaultSettings,\n        annotation: {\n          annotations,\n        },\n      };\n    },\n  },\n};\n</script>\n\n<style lang=\"scss\" scoped>\n.md-body {\n  font-size: small;\n}\n::v-deep .mdi-asterisk {\n  visibility: hidden;\n}\n</style>\n"]}]}