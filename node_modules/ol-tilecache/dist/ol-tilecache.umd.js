/*!
OpenLayers tile url function to load tile seeded with TileCache url scheme

@package ol-tilecache
@author Vladimir Vershinin <ghettovoice@gmail.com>
@version 7.0.0
@licence MIT
@copyright (c) 2016-2020, Vladimir Vershinin <ghettovoice@gmail.com>
*/
(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('ol/tilegrid')) :
	typeof define === 'function' && define.amd ? define('ol-tilecache', ['exports', 'ol/tilegrid'], factory) :
	(global = global || self, factory(global.TileCacheUrlFn = {}, global.ol.tilegrid));
}(this, (function (exports, tilegrid) { 'use strict';

	function createCommonjsModule(fn, basedir, module) {
		return module = {
		  path: basedir,
		  exports: {},
		  require: function (path, base) {
	      return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
	    }
		}, fn(module, module.exports), module.exports;
	}

	function commonjsRequire () {
		throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
	}

	var _typeof_1 = createCommonjsModule(function (module) {
	function _typeof(obj) {
	  "@babel/helpers - typeof";

	  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
	    module.exports = _typeof = function _typeof(obj) {
	      return typeof obj;
	    };
	  } else {
	    module.exports = _typeof = function _typeof(obj) {
	      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
	    };
	  }

	  return _typeof(obj);
	}

	module.exports = _typeof;
	});

	/**
	 * This file is part of ol-tilecache package.
	 * @module ol-tilecache
	 * @license MIT
	 * @author Vladimir Vershinin
	 */

	/**
	 * Left zero pad.
	 *
	 * @param {string | number} num
	 * @param {number} places
	 * @returns {string}
	 */
	function zeroPad(num, places) {
	  var zero = places - num.toString().length + 1;
	  return (new Array(parseInt(zero > 0 && zero, 10)).join("0") + num).toString().slice(-places);
	}
	/**
	 * The % operator in JavaScript returns the remainder of a / b, but differs from
	 * some other languages in that the result will have the same sign as the
	 * dividend. For example, -1 % 8 == -1, whereas in some other languages
	 * (such as Python) the result would be 7. This function emulates the more
	 * correct modulo behavior, which is useful for certain applications such as
	 * calculating an offset index in a circular list.
	 *
	 * @param {number} a The dividend.
	 * @param {number} b The divisor.
	 * @return {number} a % b where the result is between 0 and b (either 0 <= x < b
	 *     or b < x <= 0, depending on the sign of b).
	 * @link https://closure-library.googlecode.com/git-history/docs/local_closure_goog_math_math.js.source.html#line73
	 */

	function modulo(a, b) {
	  var m = a % b;
	  return m * b < 0 ? m + b : m;
	}

	/**
	 * This file is part of ol-tilecache package.
	 * @module ol-tilecache
	 * @license MIT
	 * @author Vladimir Vershinin
	 */
	var zRegEx = /{z}/g;
	var zPadRegEx = /{0z}/g;
	var xRegEx = /{x\d?}/g;
	var yRegEx = /{y\d?}/g;
	var dashYRegEx = /{-y\d?}/g;
	/**
	 * Basic create factory.
	 *
	 * @param {string} url Url template
	 * @param {TileGrid} [tileGrid] Tile grid.
	 * @returns {function(tileCoord: TileCoord)}
	 * @static
	 * @public
	 */

	function createTileUrlFunction(url) {
	  var tileGrid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : tilegrid.createXYZ();
	  return createTileUrlFunctionFromTemplates(expandUrl(url), tileGrid);
	}
	/**
	 * Creates tile URL function from single template.
	 *
	 * @param {string} template Source url
	 * @param {TileGrid} [tileGrid] Tile grid.
	 * @returns {function(tileCoord: TileCoord)}
	 * @private
	 */

	function createTileUrlFunctionFromTemplate(template) {
	  var tileGrid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : tilegrid.createXYZ();
	  return (
	    /**
	     * @param {TileCoord} tileCoord Tile Coordinate.
	     * @return {string | undefined} Tile URL.
	     */
	    function (tileCoord) {
	      if (tileCoord != null) {
	        return template.replace(zRegEx, zoomReplacer(tileCoord[0])).replace(zPadRegEx, zoomReplacer(tileCoord[0], true)).replace(xRegEx, coordReplacer(tileCoord[1])).replace(yRegEx, coordReplacer(tileCoord[2])).replace(dashYRegEx, function (part) {
	          var z = tileCoord[0];
	          var range = tileGrid.getFullTileRange(z);
	          if (!range) throw new Error('The {-y} placeholder requires a tile grid with extent.');
	          var y = range.getHeight() - tileCoord[2] - 1;
	          return coordReplacer(y)(part);
	        });
	      }
	    }
	  );
	}
	/**
	 * Creates tile URL function from multiple templates.
	 *
	 * @param {string[]} templates Url templates
	 * @param {TileGrid} [tileGrid] Tile grid.
	 * @returns {function(tileCoord: TileCoord)}
	 * @private
	 */

	function createTileUrlFunctionFromTemplates(templates) {
	  var tileGrid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : tilegrid.createXYZ();
	  return createTileUrlFunctionFromTileUrlFunctions(templates.map(function (tileUrlFunction) {
	    return createTileUrlFunctionFromTemplate(tileUrlFunction, tileGrid);
	  }));
	}
	/**
	 * @param zoom
	 * @param pad
	 * @returns {function}
	 * @private
	 */

	function zoomReplacer(zoom, pad) {
	  return function () {
	    return pad ? zeroPad(zoom, 2) : zoom.toString();
	  };
	}
	/**
	 * @param coord
	 * @returns {function}
	 * @private
	 */


	function coordReplacer(coord) {
	  return function (part) {
	    var match = part.match(/\d/);

	    if (match) {
	      return zeroPad(coord, 9).slice((match[0] - 1) * 3, match[0] * 3);
	    }

	    return coord.toString();
	  };
	}
	/**
	 * @param {string} url
	 * @returns {Array.<string>}
	 * @private
	 */


	function expandUrl(url) {
	  var urls = [];
	  var match = /{(\d)-(\d)}/.exec(url) || /{([a-z])-([a-z])}/.exec(url);

	  if (match) {
	    var startCharCode = match[1].charCodeAt(0);
	    var stopCharCode = match[2].charCodeAt(0);

	    for (var charCode = startCharCode; charCode <= stopCharCode; ++charCode) {
	      urls.push(url.replace(match[0], String.fromCharCode(charCode)));
	    }
	  } else {
	    urls.push(url);
	  }

	  return urls;
	}
	/**
	 * @param {Array.<function(tileCoord: TileCoord)>} tileUrlFunctions
	 * @returns {function(tileCoord: TileCoord)}
	 * @private
	 */


	function createTileUrlFunctionFromTileUrlFunctions(tileUrlFunctions) {
	  if (tileUrlFunctions.length === 1) {
	    return tileUrlFunctions[0];
	  }

	  return (
	    /**
	     * @param {TileCoord} tileCoord Tile Coordinate.
	     * @param {number} pixelRatio Pixel ratio.
	     * @param {Projection} projection Projection.
	     * @return {string | undefined} Tile URL.
	     */
	    function (tileCoord, pixelRatio, projection) {
	      if (tileCoord != null) {
	        var h = (tileCoord[1] << tileCoord[0]) + tileCoord[2];
	        var index = modulo(h, tileUrlFunctions.length);
	        return tileUrlFunctions[index](tileCoord, pixelRatio, projection);
	      }
	    }
	  );
	}

	if (typeof window !== 'undefined' && _typeof_1(window.ol) === 'object') {
	  window.ol.tileCacheUrlFn = {
	    createTileUrlFunction: createTileUrlFunction,
	    createTileUrlFunctionFromTemplate: createTileUrlFunctionFromTemplate,
	    createTileUrlFunctionFromTemplates: createTileUrlFunctionFromTemplates
	  };
	}

	exports.createTileUrlFunction = createTileUrlFunction;
	exports.createTileUrlFunctionFromTemplate = createTileUrlFunctionFromTemplate;
	exports.createTileUrlFunctionFromTemplates = createTileUrlFunctionFromTemplates;

	Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ol-tilecache.umd.js.map
